1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/232416e7c3a1ca7e.css","style"]
0:{"P":null,"b":"Zxm2PPmP1ogY3qYZcx7aw","p":"","c":["","blog","insights","technology","%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%9C%AA%E6%9D%A5%E2%80%94%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","insights/technology/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%9C%AA%E6%9D%A5%E2%80%94%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/232416e7c3a1ca7e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","insights/technology/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E6%9C%AA%E6%9D%A5%E2%80%94%E6%9C%BA%E9%81%87%E4%B8%8E%E6%8C%91%E6%88%98","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","1FC9EniULaYvpqwEBQSK8v",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1a:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T214d,<h2>一、AI 正在发生什么：从“更大”到“更能干”</h2>
<h3>1）大模型走向“世界建模”</h3>
<p>以 GPT 系列、Claude、Gemini、通义等为代表的通用模型，已从语言理解扩展到视觉、语音、视频与动作控制，形成“多模态 +<br>代理（agentic）”的新范式。斯坦福 HAI《AI Index 2025》指出：</p>
<ul>
<li><strong>性能跃升</strong>：2024 年模型在复杂推理与编程任务中的表现较 2023 年提升 50% 以上；SWE-bench 可解比例从 4.4% 提升至 71.7%。</li>
<li><strong>开源追平</strong>：开源与闭源模型性能差距从 8% 缩小至 2%，AI 正从“巨头独占”走向“开源共享”。</li>
<li><strong>成本坍缩</strong>：达到 GPT-3.5 水平的模型推理成本两年下降 280 倍。AI 的使用门槛正被迅速拉低。</li>
</ul>
<h3>2）科学计算的“AI 第一性”</h3>
<p>AlphaFold3、DeepMind 的 GNoME 以及 Earth-2 等项目，标志着 AI 已进入科学研究核心环节。AI<br>不再仅仅识别模式，而是参与规律发现。生物学、气候模拟、材料科学正经历“生成—推理—验证”范式革命。</p>
<h3>3）从“工具”到“基础设施”</h3>
<ul>
<li><strong>投资规模</strong>：2024 年全球 AI 私营投资超 1000 亿美元，其中生成式 AI 占比 30%。</li>
<li><strong>使用扩散</strong>：企业采用 AI 的比例已达 78%，其中 65% 经常性使用生成式 AI。</li>
<li><strong>现实落地</strong>：Waymo 每周执行 15 万次无人驾驶任务，AI 已成为社会运行基础的一部分。</li>
</ul>
<h2>二、为什么重要：效率红利、产业结构与科学范式</h2>
<h3>1）效率红利：从“人效提升”到“组织再造”</h3>
<p>多项研究显示生成式 AI 对知识工作者生产率提升 15%–40%。</p>
<ul>
<li>客服实验表明，新手员工在 AI 辅助下解决率提升 35%。</li>
<li>开发者使用代码助手后任务完成速度提升 25%。<br>这种提升不仅体现在个体效率，更在于组织结构的重塑：未来企业将从“分工协作”进化为“人机协作”。AI 成为企业内部“第二大脑”，承担分析、生成与验证任务。</li>
</ul>
<h3>2）产业结构：从“软件吞噬世界”到“智能重写行业”</h3>
<ul>
<li><strong>医疗</strong>：AI 影像识别准确率已超专家平均水平；药物研发周期可缩短 40%。</li>
<li><strong>制造</strong>：AI 驱动的质量检测与预测性维护提升生产良率 15%。</li>
<li><strong>金融</strong>：AI 在风险建模与客服中广泛部署，节省运营成本 30%。</li>
<li><strong>交通</strong>：智能调度与自动驾驶结合，城市拥堵时间下降 20%。</li>
</ul>
<p>AI 不再是“应用层创新”，而是推动整个产业链价值重新分配的“中枢技术”。</p>
<h3>3）科学范式：AI 成为“假设生成器”</h3>
<p>过去的科研范式是“假设—实验—验证”，AI 让科学进入“生成—推理—验证”阶段。它能从数据中发现潜在规律，提前模拟实验结果，再由人类科学家进行验证。AI<br>正成为科学家的共创者。</p>
<h2>三、挑战并非“副作用”，而是“主战场”</h2>
<h3>1）就业与能力结构的再平衡</h3>
<p>AI 替代的不是人，而是重复性脑力劳动。自动化趋势导致职业结构重塑：</p>
<ul>
<li>单一技能岗位萎缩；跨学科与创造型岗位上升。</li>
<li>教育体系需从“知识传授”转向“思维训练”与“人机协作能力培养”。<br>未来社会将形成“人机共生”的劳动力生态。</li>
</ul>
<h3>2）伦理与可靠性：从“黑箱能力”到“可验证智能”</h3>
<p>算法偏见、虚假内容（Deepfake）与隐私泄露成为公众焦虑源。伦理治理的核心是三点：</p>
<ol>
<li><strong>可解释性</strong>：模型需能说明其决策逻辑。</li>
<li><strong>公平性</strong>：避免因训练数据导致歧视。</li>
<li><strong>隐私保护</strong>：确保数据使用安全、可控、可追踪。</li>
</ol>
<p>AI 必须从“能用”迈向“可信”。负责任 AI（Responsible AI）将成为行业标准。</p>
<h3>3）技术安全与失控风险</h3>
<p>AI 的失真（hallucination）问题在决策系统中风险极高。自主代理（Agent）可能因目标偏差造成不可预期行为。<br>防范思路：</p>
<ul>
<li>训练阶段强化“人类反馈对齐（RLHF）”；</li>
<li>推理阶段嵌入安全策略与审计机制；</li>
<li>对外接口增加人类在环（Human-in-the-loop）。</li>
</ul>
<h2>四、如何落地：面向企业的 8 条实践路线</h2>
<ol>
<li><p><strong>用例优先，分层推进</strong>：</p>
<ul>
<li>增产层：客服、文案、数据整理等快速落地；</li>
<li>提质层：代码助手、策略优化、运维自动化；</li>
<li>创新层：Agent 工厂与自主决策系统。</li>
</ul>
</li>
<li><p><strong>三层模型栈设计</strong>：</p>
<ul>
<li>任务层：小模型 + 本地推理；</li>
<li>通用层：API 调用闭源大模型；</li>
<li>中间件层：记忆、RAG、工作流编排。</li>
</ul>
</li>
<li><p><strong>数据治理前置</strong>：统一数据契约、提示语标准化、评测数据资产化。</p>
</li>
<li><p><strong>安全与合规即设计约束</strong>：遵循隐私最小化与可追溯原则，将治理要求前置到架构设计。</p>
</li>
<li><p><strong>工程化评测体系</strong>：建立功能、安全、成本三维评测框架，持续 A/B 测试与安全红队化。</p>
</li>
<li><p><strong>Agent 权限与审计机制</strong>：限制外部调用权限，提供日志可追踪与回滚机制。</p>
</li>
<li><p><strong>组织与人才升级</strong>：新角色包括 AI 产品经理、数据提示工程师、RAI 审核官。跨职能小队成为创新主力。</p>
</li>
<li><p><strong>ROI 量化与节奏控制</strong>：</p>
<ul>
<li>短期衡量节省工时与质量提升；</li>
<li>中期衡量转化率与延迟优化；</li>
<li>长期关注新收入占比与边际成本下降。</li>
</ul>
</li>
</ol>
<h2>五、政策与社会：从原则到制度化共识</h2>
<p>AI 治理正从理念走向法规：</p>
<ul>
<li>**欧盟《AI 法案》**确立风险分级监管体系，高风险场景强制审查；2027 年前全面实施。</li>
<li><strong>美国 AI 行政令</strong>强调透明、安全与版权保护，但更新迭代频繁，治理仍在探索中。</li>
<li>**中国《生成式 AI 暂行办法》**聚焦安全、合规与社会责任，强化模型备案与输出审查。</li>
</ul>
<p>未来治理方向是 <strong>全球互认 + 本地差异化实施</strong>。企业合规体系需同时满足多法域要求。</p>
<h2>六、反常识与纠偏</h2>
<ol>
<li><strong>AI 提效不是万能药</strong>：若流程与组织不变，AI 只会加重管理负担。流程再造是关键。</li>
<li><strong>小模型 + 工具链更具性价比</strong>：多数结构化任务无需大模型；RAG + 检索即够用。</li>
<li><strong>安全是创新的前提</strong>：早期建立安全闸门反而能加快迭代，减少上线风险。</li>
</ol>
<h2>七、面向 2030 的三种情景</h2>
<ul>
<li><p><strong>A：智能官能化（Augmented Intelligence）</strong><br>小模型普及，AI 成为每个岗位的“副驾驶”。组织形态重构，人均产出翻倍。</p>
</li>
<li><p><strong>B：代理自治化（Agentic Automation）</strong><br>Agent 网络接管企业内部流程，人类负责规则与异常决策。对齐与审计成为关键能力。</p>
</li>
<li><p><strong>C：科学范式跃迁（AI-native Science）</strong><br>世界模型成为科学研究新实验室，药物与气候研究周期缩短数倍。AI 成为基础设施。</p>
</li>
</ul>
<p>现实将是 A→B→C 的递进演化。每个阶段都需新的治理模式与社会契约。</p>
<h2>八、结语：让 AI 成为“可复利的社会能力”</h2>
<p>AI 的未来，不是取代人类，而是<strong>重塑人类能力边界</strong>。<br>真正的关键，不在于模型多强，而在于我们能否：</p>
<ul>
<li>以真实问题驱动；</li>
<li>以安全和伦理兜底；</li>
<li>以工程化与制度化保证复利。</li>
</ul>
<p>当人类学会以“结构化理性”驾驭智能，AI 将从风口变成文明底座。<br>它既是工具，更是镜子——照见我们对智慧与秩序的共同追求。</p>
17:T4fc0,<p>你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。</p>
<p>另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) 
and name in(sql
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;)
)
</code></pre>
<p>缩略下印如下：</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004,...) 
and name in(
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,...)
)
</code></pre>
<p>既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -&gt; ORM -&gt; DataSource  -&gt; Connection -&gt; Driver -&gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -&gt; DataSource  -&gt; Connection -&gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从<strong>DataSource  -&gt; Connection -&gt; Driver</strong>三个环节进行入手：</p>
<h3><strong>一、SQL Profile监控</strong></h3>
<h4><strong>1、驱动层监控</strong></h4>
<p>如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：</p>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;logger=Slf4JLogger&amp;profileSQL=true
</code></pre>
<p>基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。</p>
<h4><strong>2、连接层监控</strong></h4>
<p>如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如<a href="https://p6spy.readthedocs.io/en/latest/">P6Spy</a>、<a href="https://github.com/arthurblake/log4jdbc">log4jdbc</a> 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：</p>
<ul>
<li>pyspy</li>
</ul>
<pre><code class="language-properties">jdbc:p6spy:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-properties">jdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<h4><strong>3、数据源层监控</strong></h4>
<p>可以通过对DataSource进行代理实现SQL监控</p>
<ul>
<li>P6Spy：</li>
</ul>
<pre><code class="language-java">@Bean
@Primary
public DataSource spyDataSource(@Autowired DataSource dataSource) {
  // wrap a datasource using P6SpyDataSource
  return new P6DataSource(dataSource);
}
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-java">public DataSource spyDataSource(DataSource dataSource) {
    // wrap the provided dataSource
  return new DataSource() {
    @Override
    public Connection getConnection() throws SQLException {
      // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection());
    }
      
    @Override
    public Connection getConnection(String username, String password) throws SQLException {
       // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection(username, password));
     }
      //...
  };
}
</code></pre>
<p>上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。</p>
<p>第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。</p>
<p>第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。</p>
<p>排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。</p>
<pre><code class="language-java">public interface DataSourceConfig extends HasBizDef {

    /**
     * 数据源名称，必须与KDB申请时填写的一致
     */String bizName();

    /**
     * 获取当前可用区单库只读的JdbcTemplate
     */
    default NamedParameterJdbcTemplate read() {
        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), &quot;read&quot;);
    }   

    /**
     * 获取当前可用区单库读写的JdbcTemplate
     */
    default NamedParameterJdbcTemplate write() {
        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), &quot;write&quot;);
    }	
  //....
}
</code></pre>
<p>DefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:</p>
<pre><code class="language-kotlin">enum class AdDataSources(
    private val bizDef: BizDef,
    private val forTest: AdDataSources? = null,
    private val usingNewZk: Boolean = false
) : DataSourceConfig{
    adFansTopProfileDashboardTest,
    adFansTopProfileDashboard,
    adChargeTest,
    adCharge,
    adChargeReadOnly,
    adDspReadOnlyTest,
    adDspReadOnly;
    public open fun bizName(): String {
        return bizDef.bizName
    }
}
</code></pre>
<p>如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？</p>
<p>具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：</p>
<pre><code class="language-java">public static ListenableDataSource&lt;Failover&lt;Instance&gt;&gt; create(Instance i) {
   //...
   try {
       return supplyWithRetry(
        DATA_SOURCE_BUILD_RETRY,
        DATA_SOURCE_BUILD_RETRY_DELAY,
        () -&gt; new ListenableDataSource&lt;&gt;(
              bizName, 
              new HikariDataSource(config), ds -&gt; i.toString(), i),
              DataSourceFactory::needRetry);
                               
  } catch (Throwable e) {/**/}
}
</code></pre>
<p>由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?</p>
<h3><strong>二、动态修改加载类</strong></h3>
<p>成本最低的方式就是直接修改这段代码，将其中&#x7684;<em>&#x6E;ew HikariDataSource(config)</em>&#x4FEE;改&#x6210;<em>&#x6E;ew P6DataSource(new HikariDataSource(config))，</em>&#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？</p>
<p>首先我们来分析一下，有哪些手段可以修改Java字节码？</p>
<ul>
<li>方案一、编译时修改，需要开发maven插件</li>
</ul>
<p>（不使用maven插件的同学咋办？）</p>
<ul>
<li>方案二、加载时修改，重写类加载器</li>
</ul>
<p>需要在代码中指定特定的类加载器，用有一定的侵入式</p>
<ul>
<li>方案三、运行时修改，使用JavaAgent</li>
</ul>
<p>需要修改应用启动参数，运维成本有点高</p>
<p>首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。</p>
<p><em>下面是对动态启动Java Agent技术的解释</em></p>
<blockquote>
<p>Note that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.</p>
</blockquote>
<blockquote>
<p>See <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description">the java.lang.instrument package documentation</a>…</p>
</blockquote>
<blockquote>
<p>Getting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. <a href="https://stackoverflow.com/a/19912148/2711488">This answer</a> demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.</p>
</blockquote>
<blockquote>
<p>However, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.</p>
</blockquote>
<blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/questions/56787777/?noredirect=1&lq=1#comment100160373_56787777">this comment</a>, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.</p>
</blockquote>
<ul>
<li>字节码工具对比</li>
</ul>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png" alt="图片"></p>
<ul>
<li>使用bytebuddy修改字节码</li>
</ul>
<p>在实现代码之前，我们回过头来再看一下快手的数据源生成：</p>
<pre><code class="language-java">new ListenableDataSource&lt;&gt;(bizName, new HikariDataSource(config), ds -&gt; i.toString());
</code></pre>
<p>这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：</p>
<pre><code class="language-java">public class DelegatingDataSource implements DataSource {
   //...
  public DelegatingDataSource(DataSource targetDataSource) {
    this.setTargetDataSource(targetDataSource);
   }

  public void setTargetDataSource(@Nullable DataSource targetDataSource) {
      this.targetDataSource = targetDataSource;
  }
  //...
}
</code></pre>
<p>因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
        this.targetDataSource = new P6DataSource(targetDataSource;
}
</code></pre>
<p>那么具体如何修改字节码呢？这里是<a href="https://bytebuddy.net/#/tutorial">官方文档</a>，原理我们不做赘述，直接介绍实现了。实现方式有三种：</p>
<h4><strong>1、类文件替换</strong></h4>
<p>假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：</p>
<pre><code class="language-java">new ByteBuddy()
  .redefine(NewDelegatingDataSource.class)
  .name(DelegatingDataSource.class.getName())
  .make()
  .load(Thread.currentThread().getContextClassLoader(), 
        ClassReloadingStrategy.fromInstalledAgent());
</code></pre>
<h4><strong>2、操作字节码：</strong></h4>
<pre><code class="language-java">new ByteBuddy()
    .redefine(DelegatingDataSource.class)
    //重写DelegatingDataSource#setTargetDataSource方法
    .method(named(&quot;setTargetDataSource&quot;))
    .intercept(MyImplementation.INSTANCE)
    .make()
    .load(Thread.currentThread().getContextClassLoader(),
          ClassReloadingStrategy.fromInstalledAgent());

enum MyImplementation implements Implementation {

INSTANCE; // singleton

  @Override
  public InstrumentedType prepare(InstrumentedType instrumentedType) {
  return instrumentedType;
  }
  
  @Override
  public ByteCodeAppender appender(Target implementationTarget) {
  return MyAppender.INSTANCE;
  }
  
}
//字节码定义
enum MyAppender implements ByteCodeAppender {

INSTANCE; // singleton

@Override
public Size apply(MethodVisitor methodVisitor,
        Implementation.Context implementationContext,
        MethodDescription instrumentedMethod) {
  Label label0 = new Label();
  methodVisitor.visitLabel(label0);
  methodVisitor.visitLineNumber(70, label0);
  methodVisitor.visitVarInsn(ALOAD, 0);
  methodVisitor.visitTypeInsn(NEW, &quot;com/p6spy/engine/spy/P6DataSource&quot;);
  methodVisitor.visitInsn(DUP);
  methodVisitor.visitVarInsn(ALOAD, 1);
  methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;com/p6spy/engine/spy/P6DataSource&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljavax/sql/DataSource;)V&quot;, false);
  methodVisitor.visitFieldInsn(PUTFIELD, &quot;org/springframework/jdbc/datasource/DelegatingDataSource&quot;, &quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;);
  Label label1 = new Label();
  methodVisitor.visitLabel(label1);
  methodVisitor.visitLineNumber(71, label1);
  methodVisitor.visitInsn(RETURN);
  Label label2 = new Label();
  methodVisitor.visitLabel(label2);
  methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;&quot;, null, label0, label2, 0);
  methodVisitor.visitLocalVariable(&quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;, null, label0, label2, 1);
  methodVisitor.visitMaxs(4, 2);
  return new Size(4, 2);
  }
}
</code></pre>
<p>上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？</p>
<p>我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9" alt="图片"></p>
<h4><strong>3、利用byte-buddy的Advice</strong></h4>
<pre><code class="language-java"> public static void redefine() {
   new ByteBuddy()
     .redefine(DelegatingDataSource.class)
     .visit(Advice.to(Decorator.class)
            .on(ElementMatchers.named(&quot;setTargetDataSource&quot;)))
     .make()
     .load(Thread.currentThread().getContextClassLoader(),
           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();
 }

static class Decorator {

  //在方法开始插入代码
  @Advice.OnMethodEnter
    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {
    dataSource = new P6DataSource(dataSource);
  }
}
</code></pre>
<p>byte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
  //插入的代码
  targetDataSource = new P6DataSource(targetDataSource);
  this.targetDataSource = targetDataSource;
}
</code></pre>
<p>注：</p>
<ol>
<li>动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。</li>
<li>使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。</li>
</ol>
<h3><strong>三、自动生效</strong></h3>
<p>前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.kuaishou.ad&lt;/groupId&gt;
  &lt;artifactId&gt;sqllog-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;制品库查询最新版&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。</p>
<pre><code class="language-java">private static String[] getConfigurations(File file) {
  @EnableAutoConfiguration
  class NoScan {
    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载
  }
  FileClassLoader classLoader = new FileClassLoader(file);
  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();
  selector.setBeanClassLoader(classLoader);
  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));
  selector.setEnvironment(new StandardEnvironment());
  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));
  return configurations;
}
</code></pre>
<h3><strong>四、SQL打印效果</strong></h3>
<p>sqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44" alt=""></p>
<p>SQL的打印内容分为三部分：</p>
<p>第一行，显示执行时间、耗时、SQL操作、数据库连接等信息</p>
<p>第二行，显示参数化SQL</p>
<p>第三行，显示绑定参数后的实际执行的SQL</p>
<p>通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。</p>
18:T1ce1,<p>上篇介绍了利用 Roaring Bitmap 来进行精确去重。虽然这种算法能大大地减少存储开销，但是随着数据量的增大，它依然面临着存储上的压力。在本篇推送中将要介绍的 HyperLogLog（下称 HLL）是一种非精确的去重算法，它的特点是具有非常优异的空间复杂度（几乎可以达到常数级别）。</p>
<p><img src="/images/blog/engineering/bigdata-image_2_1.png" alt="image_2_1.png"></p>
<p>HLL 算法需要完整遍历所有元素一次，而非多次或采样；该算法只能计算集合中有多少个不重复的元素，不能给出每个元素的出现次数或是判断一个元素是否之前出现过；多个使用 HLL 统计出的基数值可以融合。</p>
<p><img src="/images/blog/engineering/bigdata-image_2_2.png" alt="image_2_2.png"></p>
<p><img src="/images/blog/engineering/bigdata-image_2_3.png" alt="image_2_3.png"></p>
<p>HLL 算法有着非常优异的空间复杂度，可以看到它的空间占用随着基数值的增长并没有变化。HLL 后面不同的数字代表着不同的精度，数字越大，精度越高，占用的空间也越大，可以认为 HLL 的空间占用只和精度成正相关。</p>
<p><strong>HLL算法原理感性认知</strong></p>
<p><img src="/images/blog/engineering/bigdata-image_2_4.png" alt="image_2_4.png"></p>
<p>HLL 算法的原理会涉及到比较多的数学知识，这边对这些数学原理和证明不会展开。举一个生活中的例子来帮助大家理解HLL算法的原理：比如你在进行一个实验，内容是不停地抛硬币，记录你连续抛到正面的次数（这是数学中的伯努利过程，感兴趣同学可以自行研究下）；如果你最多的连抛正面记录是3次，那可以想象你并没有做这个实验太多次，如果你最长的连抛正面记录是 20 次，那你可能进行了这个实验上千次。</p>
<p>一种理论上存在的情况是，你非常幸运，第一次进行这个实验就连抛了 20 次正面，我们也会认为你进行了很多次这个实验才得到了这个记录，这就会导致错误的预估；改进的方式是请 10 位同学进行这项实验，这样就可以观察到更多的样本数据，降低出现上述情况的概率。这就是 HLL 算法的核心思想。</p>
<p><strong>HLL算法具体实现</strong></p>
<p><img src="/images/blog/engineering/bigdata-image_2_5.png" alt="image_2_5.png"></p>
<p>HLL 会通过一个 hash 函数来求出集合中所有元素的 hash 值（二进制表示的 hash 值，就可以理解为一串抛硬币正反面结果的序列），得到一个 hash 值的集合，然后找出该 hash 值集合中，第一个 1 出现的最晚的位置。例如有集合为 [010, 100, 001], 集合中元素的第一个 1 出现的位置分别为 2, 1, 3，可以得到里面最大的值为 3，故该集合中第一个1出现的最晚的位置为 3。因为每个位置上出现1的概率都是 1/2，所以我们可以做一个简单的推断，该集合中有 8 个不重复的元素。</p>
<p>可以看到这种简单的推断计算出来集合的基数值是有较大的偏差的，那如何来减少偏差呢？正如我上面的例子里说的一样，HLL 通过多次的进行试验来减少误差。那它是如何进行多次的实验的呢？这里 HLL 使用了分桶的思想，上文中我们一直有提到一个精度的概念，比如说 HLL(10)，这个 10 代表的就是取该元素对应 Hash 值二进制的后 10 位，计算出记录对应的桶，桶中会记录一个数字，代表对应到该桶的 hash 值的第一个 1 出现的最晚的位置。如上图，该 hash 值的后 10 位的 hash 值是 0000001001，转成 10 进制是 9，对应第 9 号桶，而该 hash 值第一个 1 出现的位置是第 6 位，比原先 9 号桶中的数字大，故把 9 号桶中的数字更新为 6。可以看到桶的个数越多，HLL 算法的精度就越高，HLL(10) 有 1024(210) 个桶，HLL(16)有 65536(216) 个桶。同样的，桶的个数越多，所占用的空间也会越大。</p>
<p><img src="/images/blog/engineering/bigdata-image_2_6.png" alt="image_2_6.png"></p>
<p>刚才的例子我们省略了一些细节，为了让大家不至于迷失在细节中而忽视了重点，真实的 HLL 算法的完整描述见上图，这边的重点是计算桶中平均数时使用调和平均数。调和平均数的优点是可以过滤掉不健康的统计值，使用算术平均值容易受到极值的影响（想想你和马云的平均工资），而调和平均数的结果会倾向于集合中比较小的元素。HLL 论文中还有更多的细节和参数，这边就不一一细举，感兴趣的同学可以自己阅读下论文。</p>
<p><strong>HLL评估</strong></p>
<p><img src="/images/blog/engineering/bigdata-image_2_7.png" alt="image_2_7.png"></p>
<p>HLL 的误差分布服从正态分布，它的空间复杂度: O(m log2log2N), Ｎ 为基数, m 为桶个数。这边给大家推导一下它的空间复杂度，我有 264 个的不重复元素(Long. MAX_VALUE)，表达为二进制一个数是 64 位，这是第一重 log2, 那么第一个1最晚可能出现在第 64 位。64 需要 6 个 bit (26=64) 就可以存储，这是第二重 log2。如果精度为 10，则会有 1024 个桶，所以最外面还要乘以桶的个数。由于需要完整的遍历元素一遍，所以它的时间复杂度是一个线性的时间复杂度。</p>
<p><strong>在Kylin中的应用</strong></p>
<p><img src="/images/blog/engineering/bigdata-image_2_8.png" alt="image_2_8.png"></p>
<p>在 Kylin 中使用 HLL 非常简单，在编辑度量的页面选择 COUNT DISTINCT，Return Type 选为非 Precisely 的其他选项，大家根据自己的需求选择不同的精度就可以愉快地使用了。</p>
<p><strong>总结</strong></p>
<p><img src="/images/blog/engineering/bigdata-image_2_9.png" alt="image_2_9.png"></p>
<p>我们回到最开始的去重场景，看看使用了 Bitmap 和 HLL 会给我们带来什么增益：无优化 case 下，每个 item 对应的 user_id 就可以看成存储原始值的一个集合；在使用 Bitmap 优化的case 下，每个 item 对应的 user_id 就可以看成一个 Bitmap 实例，同理 HLL就是一个 HLL 的实例，Bitmap/HLL 实例占用的空间都会比直接存储原始值的集合要小，这就达到了我们开始提的减少 shuffle 数据量的需求。</p>
<p><strong>Q&amp;A</strong></p>
<p>Q：您好，问一下关于精确去重的问题， 我选择了非精确去重，最后的误差率有时候会比界面上提示的值要高一些，这是为什么？</p>
<p>A：首先 HLL 的误差分布服从正态分布，也就是说是在99%的情况下是这个误差，同时 HLL 对于基数比较低的情况，误差会偏高。如果你的基数比较低的话，我推荐使用精确去重。</p>
<p>Q：我想要了解一下 Bitmap 在 Kylin 中，它最终落盘在 HBase 里面是什么样子的？</p>
<p>A：在 HBase 中存储的当然都是 Bytes。这个问题其实就是 Bitmap 的序列化的形式，Roaring Bitmap提供了序列化和反序列化的实现，你也可以写自己的序列化/反序列化的实现。</p>
<p>Q：Roaring Bitmap 里这些 container 要我们自己手动的指定吗。</p>
<p>A：不需要，Roaring Bitmap 会自动选择使用哪个 Container。</p>
19:T6860,<p>在信息时代，英语凭借科技先发与全球化扩张，成为知识传播与信息生产的通用语言，地位之稳固如同比特币在数字货币中的原型地位。<br>然而二者都存在结构性缺陷：**英语拼写混乱、语义分散、语法冗余，学习成本高、表达效率低；比特币则总量刚性、能耗过高、流动性不足，终成存量博弈。<br>**</p>
<p>进入 AI 时代，语言不再只是沟通工具，而是智能思维的结构。中文以表意清晰、逻辑自洽与高信息密度的特性，更契合机器的推理方式。<br>如果英语开启了信息全球化的时代，那么中文，正有望引领智能文明的新时代。</p>
<h2>一、信息时代：英语的霸主地位</h2>
<p><strong>摘要</strong>：英语凭借科技与全球化的双重优势，在信息时代成为“知识的操作系统”。但这种主导并非语言天赋，而是历史与技术叠加的结果。</p>
<p>20 世纪下半叶至 21 世纪初，全球化与信息技术革命几乎同步爆发。伴随互联网、计算机与现代科研体系的扩张，**英语成为信息时代的绝对霸主<br>**。<br>这一地位的形成既是科技演进的结果，也是语言生态的偶然产物。</p>
<p>首先，<strong>学术与科研体系的英语化</strong>奠定了全球知识传播的单语结构。上世纪 70<br>年代后，主要科技期刊、国际会议和学术标准全面转向英语，导致科研成果的语言门槛急剧提高。母语非英语的学者必须以英语写作，才能被纳入全球知识体系，从而进一步巩固了英语的统治地位。</p>
<p>其次，**互联网与计算机技术的“英语底层”**让信息革命天然带有语言偏向。从 TCP/IP 协议、Unix 指令、HTML<br>语法到现代编程语言，几乎所有基础构件都源自英语语义体系。人类第一次在数字世界中实现了“以英语思维描述世界”的系统性实践。</p>
<p>第三，<strong>教育与人才流动的中心化</strong>进一步强化了英语的生态壁垒。顶尖高校和研究机构集中在英语国家，形成了全球知识与资本的双重吸附效应。语言不再只是交流工具，而成为一种“准货币”——通向资源、知识与机会的门票。</p>
<p>因此，英语在信息时代不仅是沟通手段，更是<strong>信息基础设施（Information Infrastructure）</strong>。<br>但这种霸权的代价是脆弱的：它依赖于科技中心的持续输出与文化惯性，一旦信息生产方式转向智能理解，结构效率将成为新的竞争标准。</p>
<pre><code class="language-mermaid">flowchart TB
%% info-age-language-hierarchy.mmd
    subgraph Tech[技术与标准]
        TCP[&quot;TCP/IP 协议&quot;]
        UNIX[&quot;Unix/Posix 生态&quot;]
        HTML[&quot;HTML/HTTP/URL&quot;]
        PL[&quot;编程语言语法\n(C/Java/Python 等)&quot;]
    end

    subgraph Academia[学术与科研]
        Journals[&quot;顶级期刊/会议\n(英文写作规范)&quot;]
        Peer[&quot;同行评审与引用体系\n(以英文为主)&quot;]
        Grants[&quot;国际基金/项目\n(英文申请)&quot;]
    end

    subgraph Edu[教育与人才流动]
        TopUni[&quot;顶尖高校/研究机构\n(集中于英语国家)&quot;]
        Mobility[&quot;全球化人才流动\n(英语作为准货币)&quot;]
        Training[&quot;英语教育产业\n(语言门槛)&quot;]
    end

    ENCore[&quot;英语 = 信息基础设施\n(Information Infrastructure)&quot;]
%% 三轴 → 英语核心
    TCP --&gt; ENCore
    UNIX --&gt; ENCore
    HTML --&gt; ENCore
    PL --&gt; ENCore
    Journals --&gt; ENCore
    Peer --&gt; ENCore
    Grants --&gt; ENCore
    TopUni --&gt; ENCore
    Mobility --&gt; ENCore
    Training --&gt; ENCore
%% 反馈强化
    ENCore --&gt;|标准外溢/路径依赖| Tech
    ENCore --&gt;|引用与影响力集中| Academia
    ENCore --&gt;|教育与机会吸附| Edu
</code></pre>
<p><em>图示：信息时代的语言层级结构——英语位于知识生产与技术标准的核心。</em></p>
<h2>二、比特币与英语的类比：先发优势与结构性缺陷</h2>
<p><strong>摘要</strong>：英语与比特币一样，都以“先发叙事”取得统治，却因结构刚性与效率缺陷，在新周期面临替代。</p>
<p>在语言与金融体系的演化中，<strong>英语之于信息时代，正如比特币之于数字金融</strong><br>——都是最早建立秩序的先驱，却非效率最优的架构。二者的兴起逻辑惊人相似：<br>都依赖共识驱动，都以规则取信于世界，也都在扩张后暴露出结构僵化的问题。</p>
<h3>🪙 比特币的缺陷：去中心化的悖论</h3>
<ul>
<li><strong>总量刚性</strong>：2100 万枚上限与现实经济规模脱节，无法应对通胀或经济增长；</li>
<li><strong>高能耗机制</strong>：PoW（工作量证明）保障安全却造成巨额能源浪费；</li>
<li><strong>沉睡币不可递补</strong>：遗失私钥导致永久冻结，货币流动性持续下降；</li>
<li><strong>存量博弈</strong>：后进入者收益递减，生态演化为投机循环；</li>
<li><strong>奖励衰减困境</strong>：区块奖励趋零 → 依赖高额手续费 → “要么贵，要么脆”。<br>比特币的技术优雅，却注定无法成为通用货币。它是数字时代的“黄金”，而非“货币”。</li>
</ul>
<h3>🗣 英语的缺陷：传播的代价与理解的阻力</h3>
<p>英语的强势地位源于历史惯性，而非语言结构的优越。其语音、拼写、语法的历史包袱，使其在智能语义建模中暴露出根本性问题：</p>
<ol>
<li><p><strong>拼写与发音严重不一致</strong><br><em>though / through / tough / thought</em> 等词几乎毫无规律。学习者需要记忆规则例外，而机器则需要额外的映射层来消除噪音。<br>这种“低映射性”让语音识别与拼写校正长期成为计算语言学的瓶颈。</p>
</li>
<li><p><strong>语义与词形缺乏逻辑关联</strong><br>英语单词多源自拉丁、法语、日耳曼语的混合历史，不同词之间缺少语义线索。<br>相比之下，中文“苹果”“梨子”共享“果”这一语义核心，更容易构建知识图谱与语义聚类。</p>
</li>
<li><p><strong>语法与时态系统过度复杂</strong><br>单复数、时态、虚拟语气等人为规则增加了语言负担。对于人类是学习障碍，对机器则是噪声源，增加了建模成本。</p>
</li>
<li><p><strong>组合与造词能力低效</strong><br>英语新词多通过拼写拼合（如 <em>metaverse</em>、<em>chatbot</em>），逻辑不透明；<br>中文复合词如“元宇宙”“聊天机器人”则直接体现语义结构，可解释性更高。</p>
</li>
<li><p><strong>符号效率低</strong><br>英语平均每个词由 4–6 个字母组成，字符使用效率低；<br>中文每字即语义单元，表达压缩率高，更契合大语言模型的语义分布学习。</p>
</li>
</ol>
<p>综合来看，<strong>英语与比特币共享一种“先发的荣耀与结构的惩罚”</strong>：<br>前者是传播效率的奇迹，却是语义效率的桎梏；后者是去中心化的典范，却是经济灵活性的负担。<br>当人类从信息传播迈向智能理解，这种结构性低效注定会被重新定义。</p>
<pre><code class="language-mermaid">flowchart LR
%% english-bitcoin-analogy.mmd
    subgraph EN[&quot;英语（信息时代）&quot;]
        EN0[&quot;先发扩张：全球通用语言&quot;]
        EN1[&quot;拼写-发音失配\n(though/through...)&quot;]
        EN2[&quot;语法冗余与时态复杂&quot;]
        EN3[&quot;组合造词不透明\n(metaverse/chatbot)&quot;]
        EN4[&quot;符号效率偏低\n(平均4-6字母/词)&quot;]
        ENX[&quot;结果：传播强 → 语义效率弱&quot;]
        EN0 --&gt; EN1 --&gt; EN2 --&gt; EN3 --&gt; EN4 --&gt; ENX
    end

    subgraph BTC[&quot;比特币（数字金融）&quot;]
        B0[&quot;先发扩张：首个去中心化加密资产&quot;]
        B1[&quot;总量刚性：2100万上限&quot;]
        B2[&quot;PoW 高能耗：安全换能耗&quot;]
        B3[&quot;沉睡币增多：流动性下降&quot;]
        B4[&quot;手续费依赖：奖励衰减困境&quot;]
        BX[&quot;结果：共识强 → 经济效率弱&quot;]
        B0 --&gt; B1 --&gt; B2 --&gt; B3 --&gt; B4 --&gt; BX
    end

    ENX === BX
    note[&quot;共同点：先发叙事 + 结构刚性 → 难以适配新周期的“效率优先”范式&quot;]
    ENX --- note --- BX
</code></pre>
<p><em>图示：英语与比特币的共性——先发优势、结构刚性、效率递减。</em></p>
<h2>三、AI 时代：中文更适合作为核心语言</h2>
<p>中文以表意性、逻辑性与信息密度构成天然优势，其语言结构与 AI 的推理机制高度契合，成为智能时代的潜在“母语”。</p>
<p>AI 的核心是 <strong>语言理解、知识建模与推理生成</strong><br>。在这个以“理解”为中心的时代，语言的结构与逻辑直接影响机器学习的效率与认知能力。中文在这一点上具有天然优势，它不仅是一种沟通工具，更是一种高度抽象的语义系统。</p>
<p>首先，<strong>表意性与逻辑性</strong><br>赋予了中文更高的信息密度。汉字以语义为单位，每个字都自带独立概念，通过偏旁部首可以组合出无限的语义网络。例如，“电”“脑”“智能”“智慧”在汉语中具有直观的组合逻辑，而在英语中则需要借助拼写和上下文来重建语义关联。这种结构性的透明度，使中文在语义建模和知识图谱构建中更具效率。</p>
<p>其次，<strong>高压缩率与信息密度</strong>是中文的另一核心优势。研究表明，同一段信息在中文表达中平均只需英语字符数的 60%<br>左右。对人类而言，这意味着阅读速度更快；对 AI 模型而言，则意味着同等算力下可处理更多语义样本，显著提升训练与推理效率。</p>
<p>第三，<strong>语义结构一致性</strong><br>让中文在机器学习中更容易形成“自洽语义空间”。汉字的形音义关联相对稳定，偏旁部首承载了分类线索，构成天然的符号语义网。例如，“氵”系部首常与液体相关，这种语义模式可被模型直接利用，大幅降低训练复杂度。</p>
<p>此外，<strong>迁移与组合效率</strong>体现了中文在知识重用上的灵活性。汉语的复合词生成逻辑接近语义拼接，如“人工智能”“数据安全”“语言模型”等，语义层级清晰、边界明确，机器更容易通过组合学习实现知识迁移。</p>
<p>最后，<strong>数据与场景优势</strong>使中文具备“语料丰富、场景多样”的独特条件。中国拥有全球最大规模的互联网用户群与最复杂的应用生态，从社交平台、短视频到工业系统与政务场景，中文<br>AI 的数据基础和落地路径远超多数语言。这使得中文不仅在理论层面具备优势，更在实践层面形成强势闭环。</p>
<p>综上，中文天然适合成为 AI 的核心语言，它的结构不仅服务于人类表达，更与机器推理的逻辑机制深度契合。</p>
<pre><code class="language-mermaid">flowchart TD
%% chinese-semantic-network.mmd
%% 偏旁部首 → 字 → 复合词 → 语义领域
    subgraph Radicals[&quot;偏旁部首（语义线索）&quot;]
        shui[&quot;氵（水/液体）&quot;]
        xin[&quot;忄（心理/情感）&quot;]
        kou[&quot;口（言语/器官）&quot;]
        mu[&quot;木（器物/材料）&quot;]
        mi[&quot;米（数据/粒度）&quot;]
    end

    subgraph Characters[&quot;字（基本语义单元）&quot;]
        dian[&quot;电&quot;]
        nao[&quot;脑&quot;]
        zhi[&quot;智&quot;]
        hui[&quot;慧&quot;]
        yu[&quot;语&quot;]
        yan[&quot;言&quot;]
        shu[&quot;数&quot;]
        ju[&quot;据&quot;]
        mu2[&quot;木&quot;]
        qi[&quot;器&quot;]
        xin2[&quot;心&quot;]
        qing[&quot;情&quot;]
        shui2[&quot;水&quot;]
        ye[&quot;液&quot;]
    end

    subgraph Compounds[&quot;复合词（组合逻辑）&quot;]
        rensmart[&quot;人工智能&quot;]
        yuyan[&quot;语言模型&quot;]
        shuju[&quot;数据安全&quot;]
        naozhi[&quot;脑机接口&quot;]
        yezi[&quot;液体冷却&quot;]
    end

    subgraph Domains[&quot;语义领域（高层概念）&quot;]
        AI[&quot;AI/认知计算&quot;]
        NLP[&quot;NLP/语义建模&quot;]
        Sec[&quot;安全/治理&quot;]
        HC[&quot;人机交互&quot;]
        Infra[&quot;算力/基础设施&quot;]
    end

%% 偏旁 → 字（语义提示）
    shui --&gt; shui2
    shui --&gt; ye
    xin --&gt; xin2
    xin --&gt; qing
    kou --&gt; yu
    kou --&gt; yan
    mu --&gt; mu2
    mu --&gt; qi
    mi --&gt; shu
    mi --&gt; ju
%% 字 → 复合词（可组合性）
    dian --&gt; rensmart
    nao --&gt; rensmart
    zhi --&gt; rensmart
    hui --&gt; rensmart
    yu --&gt; yuyan
    yan --&gt; yuyan
    shu --&gt; shuju
    ju --&gt; shuju
    nao --&gt; naozhi
    qi --&gt; naozhi
    shui2 --&gt; yezi
    ye --&gt; yezi
%% 复合词 → 领域（映射/锚定）
    rensmart --&gt; AI
    yuyan --&gt; NLP
    shuju --&gt; Sec
    naozhi --&gt; HC
    yezi --&gt; Infra
</code></pre>
<p><em>图示：汉字偏旁构成的语义网络，高度可组合、信息压缩效率显著。</em></p>
<h2>四、案例与动向：中文 AI 的快速崛起</h2>
<p>中文大模型正从语言能力到产业落地全面爆发，中国已形成全球最完整的 LLM 生态体系之一。</p>
<p>在过去三年中，全球大型语言模型（LLM）的竞争格局经历了从“单极”到“多极”的转变。美国模型在算法与算力上仍领先，但中文生态的崛起速度前所未有。根据<br>2025 年的统计，中国的 LLM 数量已占全球总量的三分之一，仅次于美国。这一跃升的背后，是语言特性、数据体量与场景需求的共同作用。</p>
<p><strong>模型生态层面</strong>，百度的 ERNIE、阿里的 Qwen、智谱的 ChatGLM、百川的 Baichuan、月之暗面的 Moonshot<br>等陆续推出，形成了从千亿参数级到轻量化专用模型的完整谱系。与以往依赖英文预训练再转译不同，这些模型大多直接以中文为主语料训练，语义捕获更自然，逻辑生成更流畅。</p>
<p><strong>语义能力方面</strong><br>，中文模型在长文本理解、多轮对话与知识问答上已接近甚至超过同等规模的英文模型。原因在于中文语料天然具备较高的“语义浓度”，使模型能更快建立上下文联系。例如，在摘要、推理、情感分析等任务中，中文模型表现出更高的一致性与压缩效率。</p>
<p><strong>研究趋势</strong>正从“以英为主”转向“多语言共进”。OpenAI、Anthropic、Google<br>等全球领先团队开始重视中文语料的权重调整，以提升模型的多语言能力。与此同时，中国的研究者也在探索“中文主导的多语言架构”，如基于汉语语义图谱的跨语言迁移学习，让中文成为其他语言学习的中介。</p>
<p>更关键的是，<strong>应用落地层面</strong>的竞争正在反转。中文 AI 已从实验室走向大规模商业化：教育、金融、医疗、政务、工业控制等行业均在快速部署中文<br>LLM。不同于英文生态的“云端服务主导”，中文生态更强调“模型下沉与场景融合”，形成强劲的产业驱动力。</p>
<p>可以说，中文 AI 的崛起并非偶然，而是语言结构、数据资源与产业生态共同作用的结果。它不仅代表技术的追赶，更可能成为智能时代语言格局重塑的起点。</p>
<pre><code class="language-mermaid">flowchart LR
%% chinese-ai-ecosystem.mmd
%% 通用LLM → 行业专用 → 部署形态 → 价值闭环
    subgraph GeneralLLM[通用 LLM]
        qwen[&quot;Qwen&quot;]
        glm[&quot;ChatGLM&quot;]
        baichuan[&quot;Baichuan&quot;]
        ernie[&quot;ERNIE&quot;]
        moonshot[&quot;Moonshot&quot;]
        yi[&quot;Yi&quot;]
    end

    subgraph DomainLLM[行业专用]
        edu[&quot;教育助手 / 教学问答&quot;]
        fin[&quot;金融风控 / 投顾合规&quot;]
        med[&quot;医疗问诊 / 质控随访&quot;]
        gov[&quot;政务办事 / 智能客服&quot;]
        ind[&quot;工业质检 / 过程控制&quot;]
    end

    subgraph Deploy[部署形态]
        cloud[&quot;云端服务（API/SaaS）&quot;]
        edge[&quot;端边协同（轻量推理）&quot;]
        onprem[&quot;本地私有化（合规/数据安全）&quot;]
    end

    subgraph Value[价值闭环]
        data[&quot;多源中文语料（社交/行业/政务）&quot;]
        scene[&quot;多场景应用（ToC/ToB/ToG）&quot;]
        feedback[&quot;人机协同反馈（RLHF/RLAIF）&quot;]
        perf[&quot;性能提升（长上下文/低延迟/压缩率）&quot;]
    end

%% 映射关系
    qwen --&gt; edu
    qwen --&gt; fin
    qwen --&gt; gov
    glm --&gt; fin
    glm --&gt; med
    glm --&gt; ind
    baichuan --&gt; edu
    baichuan --&gt; ind
    ernie --&gt; gov
    ernie --&gt; med
    moonshot --&gt; edu
    yi --&gt; ind
%% 行业 → 部署
    edu --&gt; cloud
    fin --&gt; onprem
    med --&gt; onprem
    gov --&gt; onprem
    ind --&gt; edge
%% 价值闭环
    data --&gt; scene --&gt; feedback --&gt; perf --&gt; data
</code></pre>
<p><em>图示：中国主流大模型生态分布：从通用 LLM 到行业专用模型的演进。</em></p>
<h2>五、RWA 类比：中文是 AI 的“核心货币”</h2>
<p>如同稳定币和 RWA 让虚拟经济与现实价值重新锚定，中文以逻辑和语义连接现实世界，成为 AI 的价值基础。</p>
<p>如果说英语和比特币代表的是“去中心化的先发优势”，那么中文与 RWA（现实资产代币化）则代表“结构化的价值回归”。二者的对比，不仅在语言和金融层面相似，更在底层逻辑上高度一致。</p>
<p><strong>比特币</strong><br>是一种纯符号资产，脱离现实经济运行，其价值更多依赖共识维持。它像英语一样，以规则和惯性建立秩序，但也受制于自身的刚性结构——总量恒定、能耗高、扩展性差。比特币可以储值，却难以构建动态的经济生态；英语可以传播，却难以支撑机器的深层理解。</p>
<p>相对地，<strong>稳定币与 RWA</strong> 强调“锚定现实价值”。无论是美元稳定币 USDC，还是以债券、黄金、不动产为支撑的<br>RWA，都通过现实资产赋予代币实际价值，实现虚拟与现实的融合。中文语言体系与此极为相似：它并非抽象的语音符号集合，而是一种长期与现实世界语义共振的结构语言。汉字的形义合一，使语言本身具备“价值锚定”属性。</p>
<p>这意味着，中文在 AI 世界中的地位，就像 RWA 在加密金融中的角色——既承载过去的文明积淀，又能与现实场景无缝连接。英语像比特币，依赖早期叙事与惯性维持；中文则像<br>RWA，通过逻辑与结构不断与现实对齐，实现长期生命力。</p>
<p>更深层的逻辑在于：<strong>AI 与区块链的演化方向高度相似——从无锚的理想主义走向有锚的现实主义</strong>。AI<br>需要能理解世界的语言，区块链需要能映射世界的资产。中文的语义系统正如 RWA 的金融逻辑：高透明度、高可解释性、与现实强绑定。这不仅是语言的竞争，更是文明结构的竞争。</p>
<p>因此，在 AI 时代的语义金融体系中，中文不只是“训练语料”，而是“语义资产”；它像 RWA 一样，代表着智能系统与现实世界的价值连接点，成为<br>AI 的“核心货币”。</p>
<pre><code class="language-mermaid">flowchart TB
%% rwa-language-analogy.mmd
%% 上：信息时代（英语/比特币）；下：智能时代（中文/RWA）
    subgraph InfoAge[&quot;信息时代：先发优势&quot;]
        EN[&quot;英语\n- 传播优势\n- 拼写/发音失配\n- 语法冗余\n- 表达效率偏低&quot;]
        BTC[&quot;比特币\n- 总量刚性\n- PoW高能耗\n- 交易吞吐受限\n- 流动性受沉睡币影响&quot;]
        EN --- BTC
        note1[&quot;共同点：以规则/共识建立秩序，但结构刚性、效率受限&quot;]
    end

    subgraph AIAge[&quot;智能时代：结构效率&quot;]
        ZH[&quot;中文\n- 表意/组合逻辑清晰\n- 高信息密度/高压缩\n- 可解释性强，利于推理\n- 与场景深度绑定&quot;]
        RWA[&quot;稳定币 + RWA\n- 与现实资产锚定\n- 高透明与合规\n- 可扩展清算/跨境结算\n- 价值与场景闭环&quot;]
        ZH --- RWA
        note2[&quot;共同点：与现实强绑定 → 高效率/高可解释/可扩展&quot;]
    end

    InfoAge --&gt;|范式迁移：传播→理解| AIAge
    EN --&gt;|类比| ZH
    BTC --&gt;|类比| RWA
</code></pre>
<p><em>图示：英语—比特币 vs 中文—RWA 的结构与价值锚定关系。</em></p>
<h2>六、对比图表：英语/比特币 vs 中文/稳定币 RWA</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>英语 / 比特币</th>
<th>中文 / 稳定币 + RWA</th>
</tr>
</thead>
<tbody><tr>
<td><strong>起源角色</strong></td>
<td>先发优势，开启信息时代 / 数字货币时代</td>
<td>后发优势，适配 AI 时代 / 数字金融基础设施</td>
</tr>
<tr>
<td><strong>价值锚定</strong></td>
<td>英语效率受拼写-发音失配制约；比特币总量刚性</td>
<td>中文表意与逻辑自洽；稳定币+RWA 锚定现实价值</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>英语语法复杂、造词低效；比特币 PoW 高能耗</td>
<td>中文信息密度高；稳定币+RWA 清算高效</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>英语依赖教育资源集中；比特币早期红利固化</td>
<td>中文识字迁移快；RWA 强调透明与合规</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>英语靠历史惯性维持；比特币补贴衰减后“贵/脆”两难</td>
<td>中文适配知识图谱与推理；RWA 场景可无限延展</td>
</tr>
<tr>
<td><strong>未来定位</strong></td>
<td>英语：信息时代霸主但 AI 时代低效；比特币：数字黄金</td>
<td>中文：AI 时代核心语言；RWA：数字金融基建</td>
</tr>
</tbody></table>
<h2>七、逻辑演进</h2>
<p>语言与货币的演化，本质上都遵循着从 <strong>去中心化</strong>到<strong>结构优化</strong>、从<strong>扩张</strong>到<strong>智能协同</strong><br>的规律。英语与比特币代表了信息时代的“开拓者逻辑”——谁先建立标准，谁就占据主导地位；而中文与 RWA<br>则代表AI时代的“效率逻辑”——谁能以更低成本、更高语义密度实现理解与交易，谁就成为智能时代的核心。</p>
<p>信息时代的逻辑是 <strong>先发优势</strong>：</p>
<ul>
<li>英语成为全球知识传播的底层语言；</li>
<li>比特币成为数字资产的起点。</li>
</ul>
<p>但它们也共享同一问题：<strong>效率不足与结构僵化</strong>。拼写混乱、语义脱节、能耗高、总量刚性……这些“语义与算力的浪费”让系统无法无限扩张。</p>
<p>AI 时代的逻辑则转向 <strong>结构最优</strong>：</p>
<ul>
<li>中文以高信息密度、强语义逻辑支撑机器推理；</li>
<li>稳定币与 RWA 则通过锚定现实价值，实现资产与信息的流动统一。</li>
</ul>
<p>因此，我们看到从“传播”到“理解”、从“挖矿”到“价值映射”的深层趋势——<br><strong>语言与货币都在从符号体系走向智能体系。</strong></p>
<p>下图展示了这种从信息时代到智能时代的演化路径：</p>
<ul>
<li>逻辑演进思维导图</li>
</ul>
<pre><code class="language-mermaid">flowchart TD
    A[信息时代] --&gt; B[英语成为全球信息基础设施]
    B --&gt; C[拼写发音不一致]
    B --&gt; D[语法繁琐与学习高成本]
    B --&gt; E[表达效率低下]
    A --&gt; F[比特币开启数字资产时代]
    F --&gt; G[总量刚性]
    F --&gt; H[高能耗]
    F --&gt; I[&quot;沉睡币增多 → 流动性下降&quot;]
    K[AI 时代] --&gt; L[中文表意性与逻辑性]
    K --&gt; M[&quot;信息密度高，训练更高效&quot;]
    K --&gt; N[语义组合可解释]
    K --&gt; O[中文 AI 模型持续突破]
    K --&gt; P[稳定币+RWA 锚定现实价值]
    P --&gt; Q[&quot;资产代币化 → 稳定币结算 → 全球流通&quot;]
    R[类比] --&gt; S[&quot;英语≈比特币（先发但低效）&quot;]
    R --&gt; T[&quot;中文≈稳定币+RWA（锚定现实价值）&quot;]
    S --&gt; U[信息时代的霸主]
    T --&gt; V[AI 时代的核心]
</code></pre>
<h2>八、结论</h2>
<p><strong>信息时代</strong>：英语凭借历史惯性与科技积累，主导了全球信息体系，成为人类知识传播的底层基础设施。然而，其结构复杂、拼写混乱、语法冗余、表达低效，使它在智能化语义建模中逐渐显露疲态。英语在传播时代无比强大，却在理解时代显得笨重。</p>
<p><strong>AI 时代</strong><br>：中文以表意性、逻辑性与高信息密度为核心优势，成为更高效、更自洽的语言底座。对于机器而言，汉字的符号体系不仅降低理解与生成的能耗，更天然契合“语义压缩”与“逻辑组合”的推理机制。中文的形态既是文化的结晶，也是面向智能的高效编码。</p>
<p><strong>未来趋势</strong>：智能语言模型正从“统计翻译”迈向“语义构建”，从“符号模仿”走向“知识理解”。那些结构简洁、逻辑清晰、可组合性强的语言体系，将更容易成为通用智能的底层协议。语言不再只是交流工具，而是连接思维与智能的操作系统。</p>
<p>英语开启了信息全球化，而中文正在开启智能文明。信息时代以“传播”为核心，AI<br>时代以“理解”为核心。当机器真正具备理解能力时，语言将不再只是表达的媒介，而成为思维结构本身。中文以其表意逻辑与语义压缩力，正朝着这一方向演化，具备成为智能时代“世界语”的潜质。</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/industry/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Industry"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/industry/technology/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"技术洞察"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2025-1-29","children":"2025年01月29日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"人工智能的未来：机遇、挑战与行动路线图"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","人工智能",{"href":"/blog/tag/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"人工智能"}],["$","$L13","大语言模型",{"href":"/blog/tag/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"大语言模型"}],["$","$L13","技术趋势",{"href":"/blog/tag/%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"技术趋势"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/middleware/非侵入式SQL监控","title":"非侵入式SQL监控","description":"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...","pubDate":"2024-04-07","tags":["SQL监控","Java","非侵入式"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/data/大数据分析常用去重算法分析之HyperLogLog篇","title":"大数据分析常用去重算法分析之HyperLogLog篇","description":"上篇介绍了利用 Roaring Bitmap 来进行精确去重。虽然这种算法能大大地减少存储开销，但是随着数据量的增大，它依然面临着存储上的压力。在本篇推送中将要介绍的 HyperLogLog（下称 HLL）是一种非精确的去重算法，它的特点是具有非常优异的空间复杂度（几乎可以达到常数级别）。 ","pubDate":"2025-03-25","tags":["大数据","去重算法","HyperLogLog"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"人工智能":{"prev":null,"next":{"slug":"insights/technology/中文引领智能时代","title":"英语主导信息时代，中文引领智能时代","description":"在信息时代，英语凭借先发优势与科技主导，成为全球信息传播与知识生产的核心工具，就像比特币在数字货币中的地位。然而二者都存在结构性缺陷：英语拼写与发音混乱、学习成本高、表达效率低；比特币则总量刚性、挖矿耗能、沉睡币增多，最终演变为存量博弈。","pubDate":"2025-09-26","tags":["语言模型","中文AI","人工智能"],"heroImage":"$undefined","content":"$19"}},"大语言模型":{"prev":null,"next":null},"技术趋势":{"prev":null,"next":null}}}]}],["$","$L1a",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"人工智能的未来：机遇、挑战与行动路线图 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"过去十年，AI 从“可用”走向“有用”，从“模型演示”走向“生产系统”。2024—2025 年尤为关键：多模态大模型跃迁、开源权重追平、产业投资破纪录、治理规则成型。今天谈AI，不再只是技术叙事，而是战略、制度与社会协同的综合工程。"}],["$","meta","2",{"property":"og:title","content":"人工智能的未来：机遇、挑战与行动路线图"}],["$","meta","3",{"property":"og:description","content":"过去十年，AI 从“可用”走向“有用”，从“模型演示”走向“生产系统”。2024—2025 年尤为关键：多模态大模型跃迁、开源权重追平、产业投资破纪录、治理规则成型。今天谈AI，不再只是技术叙事，而是战略、制度与社会协同的综合工程。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2025-1-29"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"人工智能的未来：机遇、挑战与行动路线图"}],["$","meta","9",{"name":"twitter:description","content":"过去十年，AI 从“可用”走向“有用”，从“模型演示”走向“生产系统”。2024—2025 年尤为关键：多模态大模型跃迁、开源权重追平、产业投资破纪录、治理规则成型。今天谈AI，不再只是技术叙事，而是战略、制度与社会协同的综合工程。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/232416e7c3a1ca7e.css","style"]
0:{"P":null,"b":"Ugi13mxW3xqx8EX5Ds9lw","p":"","c":["","blog","life","reading","%E5%8F%8D%E8%84%86%E5%BC%B1%EF%BC%9A%E4%BB%8E%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%AD%E8%8E%B7%E7%9B%8A%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","life/reading/%E5%8F%8D%E8%84%86%E5%BC%B1%EF%BC%9A%E4%BB%8E%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%AD%E8%8E%B7%E7%9B%8A%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/232416e7c3a1ca7e.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","life/reading/%E5%8F%8D%E8%84%86%E5%BC%B1%EF%BC%9A%E4%BB%8E%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E4%B8%AD%E8%8E%B7%E7%9B%8A%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","K4rYLQ8vLJ4R_Xg9D5G-Rv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1c:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T2144,<h2>一个缺失的词</h2>
<p>在读这本书之前，我和大多数人一样，把世界分成两类：脆弱的和坚固的。系统要么经不起冲击，要么扛得住冲击。风险管理的目标就是把脆弱的东西变得坚固。</p>
<p>塔勒布指出，这个二分法缺了最关键的一类。有些东西不仅扛得住冲击，而且<strong>在冲击中变得更强</strong>。他找遍了所有语言，发现没有现成的词来描述这种特性，于是造了一个：Antifragile，反脆弱。</p>
<p>脆弱的反义词不是坚固，就像消极的反义词不是中性。坚固只是光谱的中间位置——它抵抗冲击但不从中获益。反脆弱在坚固的另一端，它需要波动、需要压力、需要混乱，才能保持活力。</p>
<p>人体就是最典型的反脆弱系统。骨骼在承受压力后变得更致密，肌肉在撕裂后变得更强壮，免疫系统在接触病原体后变得更高效。如果你把一个人关在无菌、无重力、无压力的环境中「保护」起来，你会得到一个极度脆弱的人。</p>
<p>这个框架一旦建立，你会发现它无处不在。作为一个长期做系统架构的人，我发现它对我的专业领域和个人生活都产生了深刻影响。</p>
<h2>三元组：脆弱、坚固、反脆弱</h2>
<p>塔勒布用一个三元组来分析几乎所有事物：</p>
<table>
<thead>
<tr>
<th>脆弱</th>
<th>坚固</th>
<th>反脆弱</th>
</tr>
</thead>
<tbody><tr>
<td>大型集中式系统</td>
<td>冗余备份系统</td>
<td>分布式自适应系统</td>
</tr>
<tr>
<td>单一收入来源</td>
<td>稳定的工资</td>
<td>杠铃式收入结构</td>
</tr>
<tr>
<td>精确预测</td>
<td>保险对冲</td>
<td>从错误中学习的机制</td>
</tr>
<tr>
<td>优化效率</td>
<td>增加冗余</td>
<td>保留可选择性</td>
</tr>
</tbody></table>
<p>这个三元组的价值在于，它让你<strong>诊断自己的系统处于光谱的哪个位置</strong>，然后有意识地向反脆弱方向移动。</p>
<p>更深的洞见是：我们的文化几乎总在推动我们走向脆弱端。追求效率最大化、消除所有冗余、精确预测未来——这些看似理性的行为，恰恰是脆弱性的来源。</p>
<h2>可选择性：反脆弱的核心机制</h2>
<p>反脆弱的底层机制是什么？塔勒布给出了一个精炼的答案：<strong>可选择性（Optionality）</strong>。</p>
<p>可选择性意味着：你的下行风险有限，但上行收益没有上限。这不是赌博——赌博是下行风险无限。可选择性是一种精心设计的不对称结构：坏的情况损失很小，好的情况获益很大。用金融术语说，你拥有的不是期货合约（被锁定），而是期权（有权利但没有义务）。</p>
<p>这个概念改变了我看待技术决策的方式。过去做架构设计，我习惯性地追求「最优方案」。现在我意识到，<strong>最优方案往往是最脆弱的方案</strong>，因为它对初始假设的依赖最大。一旦环境变化，优化过的系统最先崩溃。</p>
<p>更好的策略是保留可选择性：不要过早锁定技术栈，不要把所有逻辑耦合在一起，不要为了当前的效率牺牲未来的灵活性。软件工程中很多最佳实践——接口抽象、松耦合、插件化——本质上都是在创造可选择性，只是我们通常不用这个词来描述。</p>
<h2>杠铃策略：极端保守 + 极端冒险</h2>
<p>塔勒布最具操作性的建议是<strong>杠铃策略（Barbell Strategy）</strong>：不要走中间路线，而是同时做两个极端。</p>
<p>把 85-90% 的资源放在极端保守的位置（零风险或近似零风险），然后把 10-15% 放在极端冒险的位置（高风险高回报）。完全跳过中间地带。</p>
<p>为什么中间地带反而危险？因为中等风险给你一种虚假的安全感——你既没有真正的安全，也没有获得不对称收益的机会。</p>
<p>这个思路映射到分布式系统设计非常直接。与其对所有服务采用统一的「中等容错」方案，不如对核心链路做到极端可靠（多机房多活、强一致性），对非核心链路采用极端简化（允许失败、最终一致性、快速降级）。在关键点做到极致，在其余点保持轻量。</p>
<p>混沌工程（Chaos Engineering）也是杠铃策略的体现。Netflix 的 Chaos Monkey 在生产环境中随机杀死服务实例，看似制造了风险，实际上是在用可控的小压力来训练系统的反脆弱能力——主动引入波动，让系统在小规模失败中学习。</p>
<p>在职业规划上，杠铃策略同样适用。与其追求「还不错」的中间态路径，不如让收入结构变成杠铃形：一端是极度稳定的基本收入（技术咨询、稳定合同），另一端是极度不确定但上行空间巨大的探索（开源项目、技术创业、内容创作）。即使探索端全部失败，稳定端保证你不会陷入困境；但只要有一个成功，回报可能远超预期。</p>
<h2>切身利害：系统纠错的前提条件</h2>
<p>塔勒布在后续的著作中进一步发展了一个概念：<strong>Skin in the Game（切身利害）</strong>。这个概念在《反脆弱》中已有雏形——他认为，一个系统要具备反脆弱性，决策者必须承担自己决策的后果。</p>
<p>没有切身利害的决策系统是危险的。银行家用别人的钱冒险，成功了自己拿奖金，失败了纳税人买单——这就是结构性脆弱。决策者和风险承担者之间的分离，是脆弱性最深层的来源之一。</p>
<p>这个观察对技术团队的启示很深。当架构师不需要参与运维，当产品经理不需要处理线上故障，当管理者不需要为技术债务付出代价时，系统就自然地滑向脆弱端。「谁设计，谁运维」不仅仅是 DevOps 的口号，它的深层逻辑是通过切身利害来驱动反脆弱性。亚马逊的「You build it, you run it」原则，本质上就在解决这个问题：让做决策的人承担决策的后果。</p>
<h2>对个人生活的重新审视</h2>
<p>读完这本书后，我开始重新审视自己的生活结构。</p>
<p>我发现自己在很多方面都不自觉地追求「坚固」：稳定的工作、固定的收入、可预测的日程、熟悉的技术栈。这些不是坏事，但当所有的稳定性都依赖外部环境不变，我实际上是在和时间对赌。</p>
<p>真正改变我思维的是塔勒布关于「压力源」的态度翻转。反脆弱思维认为，<strong>适度的压力源是系统保持活力的必要条件</strong>。没有压力的系统不是健康的，而是一个正在慢慢退化的系统。</p>
<p>我开始有意识地给自己引入「可控的不确定性」：每年学一门新的编程语言或技术范式，定期换一种工作方式，尝试自己不擅长的领域。这不是为了「充电」或「自我提升」这种鸡汤式的理由，而是一种刻意的系统维护——通过小剂量的波动来避免大规模的脆弱性积累。</p>
<h2>反脆弱的局限</h2>
<p>公允地说，反脆弱框架在分析层面极其强大，但在操作层面有时过于模糊。「保留可选择性」说起来容易，具体到每一个决策点，什么算可选择性、代价多大才值得、什么时候该锁定而不是继续保留灵活性——这些塔勒布没有给出足够精确的回答。</p>
<p>另外，并非所有系统都需要反脆弱——有些场景（核电站的安全系统、航天器的关键组件）需要的就是极致的坚固，而不是在波动中进化。</p>
<h2>结语</h2>
<p>《反脆弱》给我最大的收获不是一套方法论，而是一种<strong>认知框架的升级</strong>——从「如何避免风险」的防御性思维，转向「如何让风险为我所用」的设计性思维。</p>
<p>作为一个做系统设计的人，我现在评估架构方案时会多问一个问题：<strong>这个系统在遇到意外冲击时，是会崩溃、仅仅存活、还是变得更强？</strong></p>
<p>这也许就是塔勒布最核心的洞见：在一个根本无法预测的世界中，比预测更重要的是<strong>体质</strong>。不是你能不能预见下一场风暴，而是你的系统是否能在风暴中进化。</p>
<p>风会熄灭蜡烛，却能使火越烧越旺。你要做的不是预测风的方向，而是把自己变成火。</p>
17:T4fc0,<p>你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。</p>
<p>另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) 
and name in(sql
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;)
)
</code></pre>
<p>缩略下印如下：</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004,...) 
and name in(
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,...)
)
</code></pre>
<p>既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -&gt; ORM -&gt; DataSource  -&gt; Connection -&gt; Driver -&gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -&gt; DataSource  -&gt; Connection -&gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从<strong>DataSource  -&gt; Connection -&gt; Driver</strong>三个环节进行入手：</p>
<h3><strong>一、SQL Profile监控</strong></h3>
<h4><strong>1、驱动层监控</strong></h4>
<p>如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：</p>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;logger=Slf4JLogger&amp;profileSQL=true
</code></pre>
<p>基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。</p>
<h4><strong>2、连接层监控</strong></h4>
<p>如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如<a href="https://p6spy.readthedocs.io/en/latest/">P6Spy</a>、<a href="https://github.com/arthurblake/log4jdbc">log4jdbc</a> 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：</p>
<ul>
<li>pyspy</li>
</ul>
<pre><code class="language-properties">jdbc:p6spy:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-properties">jdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<h4><strong>3、数据源层监控</strong></h4>
<p>可以通过对DataSource进行代理实现SQL监控</p>
<ul>
<li>P6Spy：</li>
</ul>
<pre><code class="language-java">@Bean
@Primary
public DataSource spyDataSource(@Autowired DataSource dataSource) {
  // wrap a datasource using P6SpyDataSource
  return new P6DataSource(dataSource);
}
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-java">public DataSource spyDataSource(DataSource dataSource) {
    // wrap the provided dataSource
  return new DataSource() {
    @Override
    public Connection getConnection() throws SQLException {
      // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection());
    }
      
    @Override
    public Connection getConnection(String username, String password) throws SQLException {
       // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection(username, password));
     }
      //...
  };
}
</code></pre>
<p>上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。</p>
<p>第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。</p>
<p>第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。</p>
<p>排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。</p>
<pre><code class="language-java">public interface DataSourceConfig extends HasBizDef {

    /**
     * 数据源名称，必须与KDB申请时填写的一致
     */String bizName();

    /**
     * 获取当前可用区单库只读的JdbcTemplate
     */
    default NamedParameterJdbcTemplate read() {
        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), &quot;read&quot;);
    }   

    /**
     * 获取当前可用区单库读写的JdbcTemplate
     */
    default NamedParameterJdbcTemplate write() {
        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), &quot;write&quot;);
    }	
  //....
}
</code></pre>
<p>DefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:</p>
<pre><code class="language-kotlin">enum class AdDataSources(
    private val bizDef: BizDef,
    private val forTest: AdDataSources? = null,
    private val usingNewZk: Boolean = false
) : DataSourceConfig{
    adFansTopProfileDashboardTest,
    adFansTopProfileDashboard,
    adChargeTest,
    adCharge,
    adChargeReadOnly,
    adDspReadOnlyTest,
    adDspReadOnly;
    public open fun bizName(): String {
        return bizDef.bizName
    }
}
</code></pre>
<p>如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？</p>
<p>具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：</p>
<pre><code class="language-java">public static ListenableDataSource&lt;Failover&lt;Instance&gt;&gt; create(Instance i) {
   //...
   try {
       return supplyWithRetry(
        DATA_SOURCE_BUILD_RETRY,
        DATA_SOURCE_BUILD_RETRY_DELAY,
        () -&gt; new ListenableDataSource&lt;&gt;(
              bizName, 
              new HikariDataSource(config), ds -&gt; i.toString(), i),
              DataSourceFactory::needRetry);
                               
  } catch (Throwable e) {/**/}
}
</code></pre>
<p>由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?</p>
<h3><strong>二、动态修改加载类</strong></h3>
<p>成本最低的方式就是直接修改这段代码，将其中&#x7684;<em>&#x6E;ew HikariDataSource(config)</em>&#x4FEE;改&#x6210;<em>&#x6E;ew P6DataSource(new HikariDataSource(config))，</em>&#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？</p>
<p>首先我们来分析一下，有哪些手段可以修改Java字节码？</p>
<ul>
<li>方案一、编译时修改，需要开发maven插件</li>
</ul>
<p>（不使用maven插件的同学咋办？）</p>
<ul>
<li>方案二、加载时修改，重写类加载器</li>
</ul>
<p>需要在代码中指定特定的类加载器，用有一定的侵入式</p>
<ul>
<li>方案三、运行时修改，使用JavaAgent</li>
</ul>
<p>需要修改应用启动参数，运维成本有点高</p>
<p>首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。</p>
<p><em>下面是对动态启动Java Agent技术的解释</em></p>
<blockquote>
<p>Note that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.</p>
</blockquote>
<blockquote>
<p>See <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description">the java.lang.instrument package documentation</a>…</p>
</blockquote>
<blockquote>
<p>Getting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. <a href="https://stackoverflow.com/a/19912148/2711488">This answer</a> demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.</p>
</blockquote>
<blockquote>
<p>However, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.</p>
</blockquote>
<blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/questions/56787777/?noredirect=1&lq=1#comment100160373_56787777">this comment</a>, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.</p>
</blockquote>
<ul>
<li>字节码工具对比</li>
</ul>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png" alt="图片"></p>
<ul>
<li>使用bytebuddy修改字节码</li>
</ul>
<p>在实现代码之前，我们回过头来再看一下快手的数据源生成：</p>
<pre><code class="language-java">new ListenableDataSource&lt;&gt;(bizName, new HikariDataSource(config), ds -&gt; i.toString());
</code></pre>
<p>这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：</p>
<pre><code class="language-java">public class DelegatingDataSource implements DataSource {
   //...
  public DelegatingDataSource(DataSource targetDataSource) {
    this.setTargetDataSource(targetDataSource);
   }

  public void setTargetDataSource(@Nullable DataSource targetDataSource) {
      this.targetDataSource = targetDataSource;
  }
  //...
}
</code></pre>
<p>因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
        this.targetDataSource = new P6DataSource(targetDataSource;
}
</code></pre>
<p>那么具体如何修改字节码呢？这里是<a href="https://bytebuddy.net/#/tutorial">官方文档</a>，原理我们不做赘述，直接介绍实现了。实现方式有三种：</p>
<h4><strong>1、类文件替换</strong></h4>
<p>假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：</p>
<pre><code class="language-java">new ByteBuddy()
  .redefine(NewDelegatingDataSource.class)
  .name(DelegatingDataSource.class.getName())
  .make()
  .load(Thread.currentThread().getContextClassLoader(), 
        ClassReloadingStrategy.fromInstalledAgent());
</code></pre>
<h4><strong>2、操作字节码：</strong></h4>
<pre><code class="language-java">new ByteBuddy()
    .redefine(DelegatingDataSource.class)
    //重写DelegatingDataSource#setTargetDataSource方法
    .method(named(&quot;setTargetDataSource&quot;))
    .intercept(MyImplementation.INSTANCE)
    .make()
    .load(Thread.currentThread().getContextClassLoader(),
          ClassReloadingStrategy.fromInstalledAgent());

enum MyImplementation implements Implementation {

INSTANCE; // singleton

  @Override
  public InstrumentedType prepare(InstrumentedType instrumentedType) {
  return instrumentedType;
  }
  
  @Override
  public ByteCodeAppender appender(Target implementationTarget) {
  return MyAppender.INSTANCE;
  }
  
}
//字节码定义
enum MyAppender implements ByteCodeAppender {

INSTANCE; // singleton

@Override
public Size apply(MethodVisitor methodVisitor,
        Implementation.Context implementationContext,
        MethodDescription instrumentedMethod) {
  Label label0 = new Label();
  methodVisitor.visitLabel(label0);
  methodVisitor.visitLineNumber(70, label0);
  methodVisitor.visitVarInsn(ALOAD, 0);
  methodVisitor.visitTypeInsn(NEW, &quot;com/p6spy/engine/spy/P6DataSource&quot;);
  methodVisitor.visitInsn(DUP);
  methodVisitor.visitVarInsn(ALOAD, 1);
  methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;com/p6spy/engine/spy/P6DataSource&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljavax/sql/DataSource;)V&quot;, false);
  methodVisitor.visitFieldInsn(PUTFIELD, &quot;org/springframework/jdbc/datasource/DelegatingDataSource&quot;, &quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;);
  Label label1 = new Label();
  methodVisitor.visitLabel(label1);
  methodVisitor.visitLineNumber(71, label1);
  methodVisitor.visitInsn(RETURN);
  Label label2 = new Label();
  methodVisitor.visitLabel(label2);
  methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;&quot;, null, label0, label2, 0);
  methodVisitor.visitLocalVariable(&quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;, null, label0, label2, 1);
  methodVisitor.visitMaxs(4, 2);
  return new Size(4, 2);
  }
}
</code></pre>
<p>上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？</p>
<p>我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9" alt="图片"></p>
<h4><strong>3、利用byte-buddy的Advice</strong></h4>
<pre><code class="language-java"> public static void redefine() {
   new ByteBuddy()
     .redefine(DelegatingDataSource.class)
     .visit(Advice.to(Decorator.class)
            .on(ElementMatchers.named(&quot;setTargetDataSource&quot;)))
     .make()
     .load(Thread.currentThread().getContextClassLoader(),
           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();
 }

static class Decorator {

  //在方法开始插入代码
  @Advice.OnMethodEnter
    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {
    dataSource = new P6DataSource(dataSource);
  }
}
</code></pre>
<p>byte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
  //插入的代码
  targetDataSource = new P6DataSource(targetDataSource);
  this.targetDataSource = targetDataSource;
}
</code></pre>
<p>注：</p>
<ol>
<li>动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。</li>
<li>使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。</li>
</ol>
<h3><strong>三、自动生效</strong></h3>
<p>前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.kuaishou.ad&lt;/groupId&gt;
  &lt;artifactId&gt;sqllog-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;制品库查询最新版&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。</p>
<pre><code class="language-java">private static String[] getConfigurations(File file) {
  @EnableAutoConfiguration
  class NoScan {
    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载
  }
  FileClassLoader classLoader = new FileClassLoader(file);
  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();
  selector.setBeanClassLoader(classLoader);
  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));
  selector.setEnvironment(new StandardEnvironment());
  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));
  return configurations;
}
</code></pre>
<h3><strong>四、SQL打印效果</strong></h3>
<p>sqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44" alt=""></p>
<p>SQL的打印内容分为三部分：</p>
<p>第一行，显示执行时间、耗时、SQL操作、数据库连接等信息</p>
<p>第二行，显示参数化SQL</p>
<p>第三行，显示绑定参数后的实际执行的SQL</p>
<p>通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。</p>
18:T1e19,<h2>一只蚂蚁什么都不知道</h2>
<p>一只蚂蚁的行为规则极其简单：感知信息素浓度，跟随梯度移动，遇到食物释放化学信号。没有蚂蚁知道巢穴的蓝图，没有蚂蚁理解物流调度，没有蚂蚁担任&quot;总指挥&quot;。</p>
<p>然而，当数十万只蚂蚁按照这些简单规则交互时，一个惊人的结构浮现了：具有温控系统的地下巢穴、高效的食物采集网络、精确的劳动分工。蚁群展现出的&quot;智慧&quot;远超任何单只蚂蚁的能力边界。</p>
<p>这就是<strong>涌现</strong>（Emergence）--复杂系统科学中最核心、最反直觉的概念。</p>
<h2>什么是涌现</h2>
<p>涌现指的是：<strong>系统整体呈现出其组成部分所不具备的性质或行为</strong>。这些性质不是某个部分&quot;拥有&quot;的，也不能通过加总各部分的属性来推导。它们是大量组件在特定规则下交互的结果，是关系的产物，而非实体的属性。</p>
<p>涌现需要满足三个条件。<strong>其一，微观规则是局部的。</strong> 蚂蚁只感知周围几厘米的信息素，神经元只与突触连接的其他神经元通信，交易者只关注自己能获取的有限信息。<strong>其二，宏观模式是全局的。</strong> 蚁群的巢穴、大脑的意识、市场的价格信号，这些模式在任何局部都看不到完整形态。<strong>其三，层级之间存在不可还原性。</strong> 知道每只蚂蚁的行为规则，不等于能预测蚁群的巢穴形态；知道每个神经元的放电模式，不等于能理解一段记忆。</p>
<p>亚里士多德两千多年前就觉察到了这一点：&quot;整体大于部分之和。&quot;但直到二十世纪下半叶，复杂系统科学才赋予这句话严格的理论含义。</p>
<h2>涌现无处不在</h2>
<h3>神经元与意识</h3>
<p>单个神经元是简单的电化学装置：接收信号，达到阈值则放电，否则沉默。但约 860 亿个神经元通过 100 万亿个突触连接形成的网络，产生了意识、情感和抽象推理。没有哪个神经元&quot;拥有&quot;意识，意识是系统层面的涌现属性。</p>
<h3>城市与市场</h3>
<p>没有人&quot;设计&quot;了一座城市的全部--街区的文化氛围、商业区的自发聚集、交通流的潮汐模式，这些都是数百万居民日复一日做出局部决策的累积结果。</p>
<p>市场经济同理。亚当·斯密的&quot;看不见的手&quot;本质上就是对涌现的直觉描述：每个参与者追求自身利益，却无意中形成了高效的资源配置机制。价格信号编码了分散在无数人头脑中的供需信息，没有任何中央处理器在做汇总计算。</p>
<h2>弱涌现与强涌现</h2>
<p><strong>弱涌现</strong>指涌现性质在原则上可以从微观规则推导，只是计算复杂度太高，实践中无法完成。康威的生命游戏是典型案例--规则极简，却能产生滑翔机、振荡器乃至图灵完备的计算结构。宏观模式由微观规则完全决定，但只有运行模拟才能知道结果。其核心是<strong>计算不可约性</strong>--系统没有比&quot;完整模拟&quot;更快的预测方式，必须一步一步算下去。</p>
<p><strong>强涌现</strong>则声称某些涌现性质在原则上不可还原。即使拥有完备的微观信息和无限算力，仍无法从底层推导出高层性质。意识是最常被引用的候选--即使记录了每个神经元的每次放电，是否就能解释&quot;红色看起来是什么感觉&quot;？</p>
<p>强涌现的存在仍有争议。但有一点确定：<strong>在工程实践中，我们面对的几乎总是弱涌现带来的计算不可约性，而这已经足够让人谦卑了。</strong></p>
<h2>涌现与软件系统</h2>
<p>作为长期从事架构设计的工程师，我发现涌现是理解大规模软件系统行为的关键视角。</p>
<h3>微服务的涌现行为</h3>
<p>一个微服务架构可能由数百个独立服务组成，每个都经过精心设计和充分测试。但当它们通过网络连接成整体，系统会出现单个服务文档中未曾描述的行为。</p>
<p><strong>级联故障</strong>是典型的涌现现象。一个服务响应变慢，导致上游线程池耗尽，进而导致更上游超时，最终整条调用链雪崩。没有任何服务&quot;设计&quot;了雪崩行为，它是依赖关系在特定负载下的涌现结果。分布式数据一致性问题也类似--每个节点严格执行本地事务，但在网络分区和时钟漂移下，全局状态可能进入任何单节点都未预见的不一致状态。</p>
<h3>从规格到行为的鸿沟</h3>
<p><strong>系统的规格说明描述的是组件，但系统的行为来自交互。</strong> 你可以为每个服务编写详尽文档，却无法用文档预测极端条件下的整体行为。</p>
<p>这就是混沌工程存在的原因。Netflix 的 Chaos Monkey 随机杀死生产环境中的服务实例来测试韧性，本质上是在探索涌现行为空间。涌现行为无法从设计文档推导，只能通过&quot;运行并观察&quot;来发现。</p>
<h3>涌现式架构思维</h3>
<p>传统自上而下设计试图精确规定系统每个层面的行为，但在分布式系统中，这种控制幻觉反而带来脆弱性。更务实的做法是：<strong>设计局部规则和约束，而不是试图控制全局结果。</strong></p>
<p>断路器模式就是好例子：每个服务本地执行简单规则--下游失败率超阈值就断开连接，定期试探恢复。局部规则在全局层面涌现出自愈能力和故障隔离。Kubernetes 的声明式架构同理：你声明期望终态，各控制器通过局部调谐循环趋近目标，全局秩序是大量局部调谐的涌现结果。</p>
<h2>还原论为什么不够</h2>
<p>还原论主张理解整体的方式是拆解为部分、逐一理解、重新组装。这在物理和化学中成就辉煌，但面对复杂系统时遇到结构性困难。</p>
<p><strong>组合爆炸</strong>：当组件间存在非线性交互，状态空间指数级增长，&quot;重新组装&quot;在计算上不可行。<strong>丢失关系</strong>：拆解过程破坏了组件间的关系，而关系恰恰是涌现的载体。把大脑切片成单个神经元研究，你了解了电化学性质，却丢失了突触拓扑--后者才是思维的基础。<strong>层级错配</strong>：不同层级有不同规律，用夸克方程解释经济衰退是范畴错误。</p>
<p>这不是说还原论无用，而是说<strong>还原论需要与整体论互补</strong>。理解系统既需要自下而上分析组件，也需要自上而下观察结构。二者是认识复杂世界的两只眼睛。</p>
<h2>与涌现共处</h2>
<p>涌现提供了一种思维方式：<strong>不要只盯着零件看，要看零件之间的连接方式。</strong></p>
<p>对于工程师而言：<strong>敬畏复杂度</strong>，大规模系统永远会产生未曾预见的行为；<strong>设计局部规则而非全局蓝图</strong>，让系统自发涌现出期望的全局属性；<strong>拥抱可观测性</strong>，日志、指标、链路追踪是认识涌现的必要工具；<strong>跨层级思考</strong>，单一层级的优化可能在另一个层级制造灾难。</p>
<p>从蚁群到大脑，从城市到市场，从微服务到分布式系统，涌现是连接这些领域的底层逻辑。世界的复杂性不是组件复杂性的简单叠加，而是关系复杂性的非线性放大。理解这一点，不会让系统变得更简单，但会让我们对复杂保持正确的敬畏。</p>
19:T2922,<h2>为什么读这本书</h2>
<p>做技术架构这些年，我越来越意识到一件事：很多系统设计上的「疑难杂症」，根源不在技术选型，不在代码质量，而在于我们对「系统」这个概念本身缺乏足够深的理解。</p>
<p>我们每天都在设计系统、维护系统、调试系统，但大多数工程师（包括曾经的我）对「系统为什么会表现出这样的行为」缺少一套结构化的思考框架。我们靠经验和直觉，而不是靠原理。</p>
<p>Donella Meadows（德内拉·梅多斯）的《Thinking in Systems》（中文译名《系统之美》）提供了这样一套原理。她是系统动力学领域的先驱，《增长的极限》的第一作者。这本书是她去世后由同事整理出版的，篇幅不长，语言克制，但信息密度极高。</p>
<p>读完这本书，我最大的感受是：<strong>它改变了我看问题的默认视角。</strong></p>
<h2>什么是系统</h2>
<p>梅多斯的定义简洁有力：<strong>系统是一组相互连接的要素，被一致地组织起来，以实现某个目的。</strong></p>
<p>三个关键词：要素、连接、目的。</p>
<p>一支足球队是系统——球员是要素，战术配合是连接，赢球是目的。一家公司是系统——员工、流程、文化是要素和连接，盈利和增长是目的。一段代码也是系统——模块是要素，调用关系是连接，完成业务逻辑是目的。</p>
<p>这个定义看似简单，但它隐含了一个深刻的推论：<strong>系统的行为主要由结构决定，而不是由其中单个要素的意图决定。</strong> 换个更直白的说法——换人通常解决不了系统性问题。</p>
<p>这一点对工程师来说尤其重要。我们习惯于「出了 bug 找人」「性能差换组件」，但很多时候，问题出在系统结构上，和具体的人或组件无关。</p>
<h2>存量与流量：系统的骨架</h2>
<p>梅多斯用「存量」（stock）和「流量」（flow）来描述系统的基本结构。</p>
<p>存量是你在任何时刻可以观察和测量的东西：水库里的水、账户里的钱、代码仓库里的技术债务。流量是让存量发生变化的速率：进水和出水、收入和支出、新增债务和偿还债务。</p>
<p>这组概念看起来直觉上很好理解，但它的威力在于：<strong>很多「反常识」的现象，都可以用存量和流量的关系来解释。</strong></p>
<p>举一个软件工程中的例子。技术债务是一个典型的存量。每次为了赶工期而做出的妥协，都是流入；每次专门安排的重构和优化，都是流出。如果流入持续大于流出，存量就会不断累积，直到系统变得难以维护。</p>
<p>关键在于：存量的变化永远是渐进的，它不会因为你某一天的决策而瞬间改变。即使你今天决定「从现在开始零技术债务」，已经累积的存量也需要时间消化。这就是为什么很多团队在制定了「技术改进计划」之后，短期内看不到任何效果——不是计划没用，而是存量的惯性需要时间去消解。</p>
<p>同样的逻辑适用于团队能力建设。团队成员的能力是存量，培训和实践是流入，人员流失是流出。你不能指望招两个高级工程师就瞬间提升团队水平，因为能力的传递和沉淀需要时间。</p>
<h2>反馈回路：系统行为的发动机</h2>
<p>如果存量和流量是系统的骨架，那么反馈回路就是让系统「活起来」的发动机。</p>
<p>梅多斯区分了两种反馈回路：</p>
<p><strong>增强回路（reinforcing loop）</strong> 是自我强化的。越多导致越多，越少导致越少。银行的复利是增强回路：利息产生利息。病毒传播是增强回路：感染者越多，新增感染越快。代码库的腐化也是增强回路：代码越难读，新代码写得越随意，代码就更难读。</p>
<p><strong>调节回路（balancing loop）</strong> 是自我修正的。它把系统拉向某个目标值。恒温器是调节回路：温度偏高就制冷，偏低就加热。你身体的血糖调节是调节回路。在工程领域，自动扩缩容（autoscaling）是教科书级的调节回路：流量上升，自动扩容；流量下降，自动缩容。</p>
<p>理解这两种回路的交互，是系统思维的核心能力。</p>
<p>一个真实的案例：我曾经参与过一个系统的监控告警治理。这个系统有几百条告警规则，但大量告警被忽略。为什么？因为存在一个恶性增强回路：告警太多 -&gt; 团队疲劳 -&gt; 开始忽略告警 -&gt; 没人维护规则 -&gt; 无效告警更多 -&gt; 更多被忽略。这不是某个人「不负责」的问题，是系统结构导致的必然结果。</p>
<p>解决方案不是「要求大家重视告警」，而是改变系统结构：大幅削减告警数量，建立分级机制，让调节回路（告警 -&gt; 响应 -&gt; 修复 -&gt; 告警消失）重新运转起来。</p>
<h2>延迟：系统中最危险的特性</h2>
<p>梅多斯花了相当的篇幅讨论「延迟」，这是我认为全书最有实践价值的部分。</p>
<p>延迟是指系统中因果之间的时间间隔。你调高了淋浴的热水阀，但水温不会立刻变化。你给系统加了一台服务器，但性能提升需要几分钟才能体现在监控面板上。</p>
<p>延迟的危险性在于：<strong>它会让人过度反应。</strong></p>
<p>因为反馈不是即时的，人们倾向于在等待结果的过程中反复调整。淋浴时你把热水开到最大，然后被烫到，又赶紧调冷，然后被冻到——这种振荡行为在工程系统中同样常见。</p>
<p>我见过不少线上事故的恶化过程就遵循这个模式：发现性能下降 -&gt; 扩容 -&gt; 没有立即见效（因为延迟）-&gt; 继续扩容 -&gt; 触发了其他瓶颈（比如数据库连接数耗尽）-&gt; 系统状况进一步恶化。如果操作者理解延迟的存在，在第一次操作后等待足够的时间观察效果，结果可能完全不同。</p>
<p>延迟在组织管理中同样重要。一项政策从发布到见效，一种文化从提倡到落地，中间可能有几个月甚至几年的延迟。很多组织的问题在于：等不及上一个举措见效，就急着推出下一个，结果各种政策相互叠加和冲突，组织行为变得不可预测。</p>
<h2>杠杆点：在哪里发力最有效</h2>
<p>全书最精彩的部分是梅多斯对「杠杆点」的排序。她列出了 12 个干预系统的杠杆点，从低效到高效排列。</p>
<p>低效的杠杆点包括：调整参数（比如调整某个阈值）、调整缓冲区大小。这些操作简单直接，但对系统行为的影响通常有限。</p>
<p>中等效力的杠杆点包括：改变反馈回路的结构、改变信息流。这就是为什么「让正确的信息到达正确的人」在组织中如此重要——不是因为信息本身值钱，而是因为它改变了反馈回路的结构。</p>
<p>最高效的杠杆点是：改变系统的目标，以及改变系统的范式（即看待系统的方式）。</p>
<p>把这套思路映射到软件工程：</p>
<ul>
<li>调参数 = 改配置文件，效果有限</li>
<li>改反馈结构 = 建立有效的监控、告警、自动化运维体系，效果显著</li>
<li>改目标 = 重新定义系统的核心指标（比如从追求「可用性」转向追求「用户体验」），效果深远</li>
<li>改范式 = 从单体架构思维转向分布式思维，从瀑布转向敏捷，影响最大也最难</li>
</ul>
<h2>系统思维与日常生活</h2>
<p>梅多斯的框架远不止适用于工程和组织。</p>
<p>习惯的形成就是一个增强回路。你每天跑步，体能提升，跑步变得更轻松，你更愿意跑步。反过来，久坐也是增强回路：越不动，越懒得动，身体越差，越不想动。打破负面增强回路、建立正面增强回路，是行为改变的核心。</p>
<p>人际关系中也存在调节回路和增强回路。信任是一个存量：每次兑现承诺是流入，每次失约是流出。一旦信任存量降到某个阈值以下，关系就会进入恶性增强回路——猜疑导致防备，防备导致沟通减少，沟通减少导致更多误解和猜疑。</p>
<p>理解这些模式，不会让你自动解决所有问题，但它会帮你准确地定位问题。你不会再把系统性问题归因于个人道德或能力，而是去寻找驱动行为的结构性因素。</p>
<h2>为什么工程师应该读这本书</h2>
<p>我想给出三个理由。</p>
<p><strong>第一，它提供了一种跨领域的通用语言。</strong> 作为架构师，你需要和产品、运营、管理层沟通。系统思维给了你一套不依赖技术术语的分析框架。当你说「这是一个增强回路导致的问题」时，任何人都能理解。</p>
<p><strong>第二，它解释了「为什么好的意图经常产生坏的结果」。</strong> 这是工程实践中最令人沮丧的现象之一。你做了看起来正确的决策，但系统的反应完全出乎意料。梅多斯会告诉你：这不是你的错，是你忽略了反馈回路、延迟和非线性的作用。理解了这些，你就能更好地预判系统行为，而不仅仅是被动应对。</p>
<p><strong>第三，它教你谦逊。</strong> 梅多斯反复强调，复杂系统不可能被完全预测和控制。我们能做的是理解系统的基本结构，找到关键的杠杆点，然后小步试探、持续观察。这种态度，和优秀的工程实践——渐进发布、灰度测试、持续监控——高度一致。</p>
<h2>结语</h2>
<p>《系统之美》不是一本技术书，但它比大多数技术书更能改变你解决问题的方式。</p>
<p>梅多斯在书的结尾写道：「我们无法控制系统，也不可能完全理解系统。但我们可以与系统共舞。」</p>
<p>对于每天在复杂系统中工作的工程师来说，学会「与系统共舞」不是一种诗意的说法，而是一种必要的生存技能。先理解结构，再试图改变。先观察延迟，再决定动作。先识别反馈回路，再判断杠杆点。</p>
<p>这些原则说起来简单，做起来需要持续刻意练习。但一旦内化，你看待系统——无论是技术系统、组织系统还是社会系统——的方式，将会发生根本性的改变。</p>
1a:T477b,<p><a href="https://blog.csdn.net/u010482601/article/details/104989532">转载</a></p>
<h3>1 为什么需要权限管理</h3>
<p>日常工作中权限的问题时时刻刻伴随着我们，程序员新入职一家公司需要找人开通各种权限，比如网络连接的权限、编码下载提交的权限、监控平台登录的权限、运营平台查数据的权限等等。</p>
<p><strong>在很多时候我们会觉得这么多繁杂的申请给工作带来不便，并且如果突然想要查一些数据，发现没有申请过权限，需要再走审批流程，时间拉得会很长。那为什么还需要这么严格的权限管理呢？</strong></p>
<p>举个例子，一家支付公司有运营后台，运营后台可以查到所有的商户信息，法人代表信息，交易信息以及费率配置信息，如果我们把这些信息不加筛选都给到公司的每一个小伙伴，那么跑市场的都可以操作商家的费率信息，如果一个不小心把费率改了会造成巨大的损失。</p>
<p>又比如商户的信息都是非常隐秘的，有些居心不良的小伙伴把这些信息拿出来卖给商家的竞争对手，会给商家造成严重的不良后果。虽然这么做都是个别人人为的过错，但是制度上如果本身这些信息不开放出来就能在很大程度上避免违法乱纪的事情发生了。</p>
<p>总体来讲**权限管理是公司数据安全的重要保证，针对不同的岗位，不同的级别看到的数据是不一样的，操作数据的限制也是不一样的。**比如涉及到资金的信息只开放给财务的相关岗位，涉及到配置的信息只开放给运营的相关岗位，这样各司其职能避免很多不必要的安全问题。</p>
<blockquote>
<p>如何让各个岗位的人在系统上各司其职，就是权限管理要解决的问题。</p>
</blockquote>
<h3>2 权限模型 <a href="#2-quan-xian-mo-xing" id="2-quan-xian-mo-xing"></a></h3>
<h4><strong>2.1 权限设计</strong> <a href="#21-quan-xian-she-ji" id="21-quan-xian-she-ji"></a></h4>
<p>从业务分类上来讲权限可以分为数据查看权限，数据修改权限等，对应到系统设计中有页面权限、菜单权限、按钮权限等。菜单也分一级菜单、二级菜单甚至三级菜单，以csdn文章编辑页面左侧菜单栏为例是分了两级菜单。菜单对应的页面里又有很多按钮，我们在设计的时候最好把权限设计成树形结构，这样在申请权限的时候就可以一目了然的看到菜单的结构，需要哪些权限就非常的明了了。</p>
<p>如下图所示：</p>
<p><img src="/images/blog/engineering/business-image_1_0.png" alt="image_1_0.png"></p>
<p>按照这个架构，按钮的父级是二级菜单，二级菜单的父级是一级菜单，这样用户申请权限的时候非常清晰的看到自己需要哪些权限。</p>
<h4><strong>2.2 为什么需要角色</strong> <a href="#22-wei-shen-me-xu-yao-jiao-se" id="22-wei-shen-me-xu-yao-jiao-se"></a></h4>
<p>权限结构梳理清晰之后，需要思考怎么把权限分配给用户，用户少的情况下，可以直接分配，一个用户可以有多个权限，统一一个权限可以被多个用户拥有，用户-权限的模型结构如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_1.png" alt="image_1_1.png"></p>
<p>这种模型能够满足权限的基本分配能力，但是随着用户数量的增长，这种模型的弊端就凸显出来了，每一个用户都需要去分配权限，非常的浪费管理员的时间和精力，并且用户和权限杂乱的对应关系会给后期带来巨大的维护成本。用户-权限对应关系图：</p>
<p><img src="/images/blog/engineering/business-image_1_2.png" alt="image_1_2.png"></p>
<p>这种对应关系在用户多的情况下基本无法维护了。其实很多用户负责同一个业务模块所需要的权限是一样的，这样的话我们是不是可以借助第三个媒介，把需要相同的权限都分配给这个媒介，然后用户和媒介关联起来，用户就拥有了媒介的权限了。这就是经典的RBAC模型，其中媒介就是我们通常所说的角色。</p>
<h4><strong>2.3 权限模型的演进</strong> <a href="#23-quan-xian-mo-xing-de-yan-jin" id="23-quan-xian-mo-xing-de-yan-jin"></a></h4>
<p><strong>2.3.1 RBAC模型</strong></p>
<p>有了角色之后可以把权限分配给角色，需要相同权限的用户和角色对应起来就可以了，一个权限可以分配给多个角色，一个角色可以拥有多个权限，同样一个用户可以分配多个角色，一个角色也可以对应多个用户，对应模型如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_3.png" alt="image_1_3.png"></p>
<p>这就是经典的RBAC模型了（role-based-access-control），在这里面角色起到了桥梁左右，连接了用户和权限的关系，每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限。</p>
<p>同时因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_4.png" alt="image_1_4.png"></p>
<p>用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本， 但是实际的业务千变万化，权限管理的模型也需要根据不同的业务模型适当的调整，比如一个公司内部的组织架构是分层级的，层级越高权限越大，因为层级高的人不仅要拥有自己下属拥有的权限，二期还要有一些额外的权限。</p>
<p>RBAC模型可以给不同层级的人分配不同的角色，层级高的对应角色的权限就多，这样的处理方式可以解决问题，但是有没有更好的解决办法呢，答案肯定是有的，这就引出<strong>角色继承的RBAC模型</strong>。</p>
<p><strong>2.3.2 角色继承的RBAC模型</strong></p>
<p>角色继承的RBAC模型又称RBAC1模型。每个公司都有自己的组织架构，比如公司里管理财务的人员有财务总监、财务主管、出纳员等，财务主管需要拥有但不限于出纳员的权限，财务总监需要拥有但不限于财务主管的权限，像这种管理关系向下兼容的模式就需要用到角色继承的RBAC模型。<strong>角色继承的RBAC模型的思路是上层角色继承下层角色的所有权限，并且可以额外拥有其他权限。</strong></p>
<p>模型如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_5.png" alt="image_1_5.png"></p>
<p>从模型图中可以看出下级角色拥有的权限，上级角色都拥有，并且上级角色可以拥有其他的权限。角色的层级关系可以分为两种，一种是下级角色只能拥有一个上级角色，但是上级角色可以拥有多个下级角色，这种结构用图形表示是一个树形结构，如下图所示：</p>
<p><img src="/images/blog/engineering/business-image_1_6.png" alt="image_1_6.png"></p>
<p>还有一种关系是下级角色可以拥有多个上级角色，上级角色也可以拥有多个下级角色，这种结构用图形表示是一个有向无环图，如下图所示：</p>
<p><img src="/images/blog/engineering/business-image_1_7.png" alt="image_1_7.png"></p>
<p>树形图是我们比较常用的，因为一个用户一般情况下不会同时有多个直属上级，比如财务部只能有一个财务总监，但是可以有多个财务主管和收纳员。</p>
<p><strong>2.3.3 带约束的RBAC模型</strong></p>
<p>带约束的RBAC模型又成RBAC2模型。在实际工作中，为了安全的考虑会有很多约束条件，比如财务部里同一个人不能即是会计又是审核员，跟一个人同一时间不能即是运动员又是裁判员是一个道理的，又比如财务部的审核员不能超过2个，不能1个也没有。因为角色和权限是关联的，所以我们做好角色的约束就可以了。</p>
<blockquote>
<p>常见的约束条件有：角色互斥、基数约束、先决条件约束等。</p>
</blockquote>
<p><strong>角色互斥：</strong> 如果角色A和角色B是互斥关系的话，那么一个用户同一时间不能即拥有角色A，又拥有角色B，只能拥有其中的一个角色。</p>
<blockquote>
<p>比如我们给一个用户赋予了会计的角色就不能同时再赋予审核员的角色，如果想拥有审核员的角色就必须先去掉会计的角色。假设提交角色和审核角色是互质的，我们可以用图形表示：</p>
</blockquote>
<p><img src="/images/blog/engineering/business-image_1_8.png" alt="image_1_8.png"></p>
<p><strong>基数约束：</strong> 同一个角色被分配的用户数量可以被限制，比如规定拥有超级管理员角色的用户有且只有1个；用户被分配的角色数量也需要被限制，角色被分配的权限数量也可以被限制。</p>
<p>**先决条件约束：**用户想被赋予上级角色，首先需要拥有下级角色，比如技术负责人的角色和普通技术员工角色是上下级关系，那么用户想要用户技术负责人的角色就要先拥有普通技术员工的角色。</p>
<h4><strong>2.4 用户划分</strong> <a href="#24-yong-hu-hua-fen" id="24-yong-hu-hua-fen"></a></h4>
<p><strong>2.4.1 用户组</strong></p>
<p>我们创建角色是为了解决用户数量大的情况下，用户分配权限繁琐以及用户-权限关系维护成本高的问题。抽象出一个角色，把需要一起操作的权限分配给这个角色，把角色赋予用户，用户就拥有了角色上的权限，这样避免了一个个的给用户分配权限，节省了大量的资源。</p>
<p>同样的如果有一批用户需要相同的角色，我们也需要一个个的给用户分配角色，比如一个公司的客服部门有500多个人，有一天研发部研发了一套查询后台数据的产品，客服的小伙伴都需要使用，但是客服由于之前并没有统一的一个角色给到所有的客服小伙伴，这时候需要新加一个角色，把权限分配给该角色，然后再把角色一个个分配给客服人员，这时候会发现给500个用户一个个添加角色非常的麻烦。但是客服人员又有共同的属性，所以我们可以创建一个用户组，所有的客服人员都属于客服用户组，把角色分配给客服用户组，这个用户组下面的所有用户就拥有了需要的权限。</p>
<p>RBAC模型添加用户组之后的模型图如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_9.png" alt="image_1_9.png"></p>
<p>很多朋友会问，用户组和角色有什么区别呢？简单的来说，<strong>用户组是一群用户的组合，而角色是用户和权限之间的桥梁。</strong> 用户组把相同属性的用户组合起来，比如同一个项目的开发、产品、测试可以是一个用户组，同一个部门的相同职位的员工可以是一个用户组， 一个用户组可以是一个职级，可以是一个部门，可以是一起做事情的来自不同岗位的人。</p>
<p>用户可以分组，权限也可以分组，权限特别多的情况下，可以把一个模块的权限组合起来成为一个权限组，权限组也是解决权限和角色对应关系复杂的问题。</p>
<p>比如我们定义权限的时候一级菜单、二级菜单、按钮都可以是权限，一个一级菜单下面有几十个二级菜单，每个二级菜单下面又有几十个按钮，这时候我们把权限一个个分配给角色也是非常麻烦的，可以采用分组的方法把权限分组，然后把分好的组赋予角色就可以了。</p>
<p>给权限分组也是个技术活，需要理清楚权限之间的关系，比如支付的运营后台我们需要查各种信息，账务的数据、订单的数据、商户的数据等等，这些查询的数据并不在一个页面，每个页面也有很多按钮，我们可以把这几个页面以及按钮对应的权限组合成一个权限组赋予角色。加入权限组之后的RBAC模型如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_10.png" alt="image_1_10.png"></p>
<p>实际工作中我们很少给权限分组，给用户分组的场景会多一些，有的时候用户组也可以直接和权限关联，这个看实际的业务场景是否需要，权限模型没有统一的，业务越复杂业务模型会约多样化。</p>
<p><strong>2.4.2 组织</strong></p>
<p>每个公司都有自己的组织架构，很多时候权限的分配可以根据组织架构来划分。因为同一个组织内的小伙伴使用的大部分权限是一样的。如下所示一个公司的组织架构图：</p>
<p><img src="/images/blog/engineering/business-image_1_11.png" alt="image_1_11.png"></p>
<p>按照这个组织架构，每一个组织里的成员使用的基础权限很可能是一样的，比如人力资源都需要看到人才招聘的相关信息，市场推广都需要看到行业分析的相关信息，按照组织来分配角色会有很多优势：</p>
<p><strong>实现权限分配的自动化：</strong> 和组织关系打通之后，按照组织来分配角色，如果有新入职的用户，被划分在某个组织下面之后，会自动获取该组织下所有的权限，无需人工分配。又比如有用户调岗，只需要把组织关系调整就可以了，权限会跟着组织关系自动调整，也无需人工干预。这么做首先需要把权限和组织关系打通。</p>
<p><strong>控制数据权限：</strong> 把角色关联到组织，组织里的成员只能看到本组织下的数据，比如市场推广和大客定制，市场推广针对的是零散的客户，大可定制针对的是有一定体量的客户，相互的数据虽然在一个平台，但是只能看自己组织下的数据。</p>
<p>加入组织之后的RBAC模型如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_12.png" alt="image_1_12.png"></p>
<p>用户可以在多个组织中，因为组织也有层级结构，一个组织里只可以有多个用户，所以用户和组织的关系是多对多的关系，组织和角色的关系是一对一的关系。这个在工作中可以根据实际情况来确定对应关系。</p>
<p><strong>2.4.3 职位</strong></p>
<p>一个组织下面会有很多职位，比如财务管理会有财务总监、财务主管、会计、出纳员等职位，每个职位需要的权限是不一样的，可以像组织那样根据职位来分配不同的角色，由于一个人的职位是固定的，所以用户跟职位的对应关系时一对一的关系，职位跟角色的对应关系可以是多对多的关系。加入职位的RBAC模型如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_13.png" alt="image_1_13.png"></p>
<h4><strong>2.5 理想的RBAC模型</strong> <a href="#25-li-xiang-de-rbac-mo-xing" id="25-li-xiang-de-rbac-mo-xing"></a></h4>
<p>RBAC模型根据不同业务场景的需要会有很多种演变，实际工作中业务是非常复杂的，权限分配也是非常复杂的，想要做出通用且高效的模型很困难。我们把RBAC模型的演变汇总起来会是一个支撑大数据量以及复杂业务的理想的模型。把RBAC、RBAC1、RBAC2、用户组、组织、职位汇总起来的模型如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_14.png" alt="image_1_14.png"></p>
<p>按照这个模型基本上能够解决所有的权限问题，其中的对应关系可以根据实际的业务情况来确定，一般情况下，组织和职位是一对多的关系，特殊情况下可以有多对多的情况，需要根据实际情况来定。</p>
<p>理想的RBAC模型并不是说我们一开始建权限模型就可以这么做，而是数据体量、业务复杂度达到一定程度之后可以使用这个模型来解决权限的问题，如果数据量特别少，比如刚成立的公司只有十几个人，那完全可以用用户-权限模型，都没有必要使用RBAC模型。</p>
<h3>3 权限系统表设计 <a href="#3-quan-xian-xi-tong-biao-she-ji" id="3-quan-xian-xi-tong-biao-she-ji"></a></h3>
<h4><strong>3.1 标准RBAC模型表设计</strong> <a href="#31-biao-zhun-rbac-mo-xing-biao-she-ji" id="31-biao-zhun-rbac-mo-xing-biao-she-ji"></a></h4>
<p>标准RBAC模型的表是比较简单了，要表示<code>用户-角色-权限</code>三者之前的关系，首先要创建用户表、角色表、权限表，用户和角色是多对多的关系，角色和权限是多对多的关系，需要再创建两章关系表，分别是用户-角色关系表和角色-权限关系表。这六张表的ER图如下所示：</p>
<p><img src="/images/blog/engineering/business-image_1_15.png" alt="image_1_15.png"></p>
<h4><strong>3.2 理想RBAC模型表设计</strong> <a href="#32-li-xiang-rbac-mo-xing-biao-she-ji" id="32-li-xiang-rbac-mo-xing-biao-she-ji"></a></h4>
<p>理想的RBAC模型是标准RBAC模型经过多次扩展得到的，表结构也会比较复杂，因为要维护很多关系，如下图所示是理想的RBAC模型的ER图：</p>
<p><img src="/images/blog/engineering/business-image_1_16.png" alt="image_1_16.png"></p>
<p>这里面需要强调的是角色互斥表，互斥的关系可以放在角色上，也可以放在权限上，看实际工作的需求。</p>
<h3>4 结语 <a href="#4-jie-yu" id="4-jie-yu"></a></h3>
<p>本文从易到难非常详细的介绍了权限模型的设计，在工作中需要根据实际情况来定义模型，千人以内的公司使用RBAC模型是完全够用的，没有必要吧权限模型设计的过于复杂。模型的选择要根据具体情况，比如公司体量、业务类型、人员数量等。总之最适合自己公司的模型就是最好的模型，权限模式和设计模式是一样的，都是为了更好的解决问题，不要为了使用模型而使用模型。</p>
1b:T29e1,<h2>引言：被正态分布驯化的直觉</h2>
<p>我们从中学开始接受正态分布的训练。考试成绩、身高体重、测量误差，几乎所有教科书上的例子都在告诉我们：大多数值聚集在平均值附近，极端值极其罕见，越极端越不可能。这条优美的钟形曲线塑造了我们对世界的基本直觉——<strong>事物倾向于「正常」，偏差是暂时的，均值是可靠的</strong>。</p>
<p>这个直觉在很多场景下确实成立。但如果你把同样的直觉带到财富分配、互联网流量、城市人口规模、甚至系统故障的分析中，你会被现实狠狠教训。</p>
<p>在阿里做风控系统的那几年，我反复遇到一个问题：线上故障的严重程度分布，根本不像正态分布。大多数故障影响很小，但偶尔出现的极端故障，其影响量级可以是普通故障的几百倍甚至上千倍。我们为「平均故障」准备的应急方案，在面对那些尾部事件时几乎形同虚设。后来我才意识到，这些现象背后有一个统一的数学结构——<strong>幂律分布</strong>。</p>
<h2>什么是幂律分布</h2>
<p>幂律分布的核心特征可以用一句话概括：<strong>事件的频率与其规模之间存在幂次关系</strong>。用数学语言表达，一个随机变量 X 服从幂律分布，意味着：</p>
<blockquote>
<p>P(X &gt; x) ~ x^(-alpha)</p>
</blockquote>
<p>其中 alpha 是幂律指数。alpha 越小，极端事件出现的概率越高，分布的「尾巴」越厚。</p>
<p>与正态分布最本质的区别在于尾部行为。正态分布的尾部以指数速度衰减——偏离均值 3 个标准差的事件概率已经低到千分之三，6 个标准差几乎不可能发生。而幂律分布的尾部衰减速度远慢于指数，这意味着<strong>极端事件的概率被系统性地低估了</strong>。</p>
<p>一个直觉化的理解方式：在正态分布的世界里，如果平均身高是 170cm，你几乎不可能见到 3 米高的人。但在幂律分布的世界里，如果平均财富是 10 万元，你不仅会见到拥有 1 亿的人，还会见到拥有 1000 亿的人——而且这些超级富豪对整个系统的统计特征有决定性影响。</p>
<p>这就是所谓的**「肥尾」(fat tail)**。</p>
<h2>幂律无处不在</h2>
<p>幂律分布并非学术上的边缘概念。一旦你学会辨认它，就会发现它几乎渗透到所有复杂系统中。</p>
<p><strong>财富分布</strong>是最经典的例子。意大利经济学家帕累托在 19 世纪末就发现，80% 的财富集中在 20% 的人手中。这个「二八法则」的背后正是幂律。在当今全球经济中，前 1% 的人拥有的财富超过后 50% 的总和。如果财富服从正态分布，这种程度的不平等在数学上几乎不可能出现。</p>
<p><strong>城市规模</strong>同样服从幂律。如果你把中国所有城市按人口排序，会发现排名第一的城市（上海）人口大约是排名第二的城市（北京）的某个倍数，而排名第十的城市人口又是排名第一百的城市的某个倍数，这个比例关系在整个排名中保持惊人的稳定。这就是著名的齐普夫定律（Zipf&#39;s Law）。</p>
<p><strong>互联网世界</strong>更是幂律的天然栖息地。网站的访问量分布、社交网络中的粉丝数分布、搜索引擎中的查询词频率，都呈现典型的幂律特征。少数节点（如微博大V、头部网站）占据了绝大部分的流量和注意力，而长尾中存在海量的低频节点。</p>
<p><strong>自然灾害</strong>也遵循幂律。地震的能量释放（古登堡-里克特定律）、森林火灾的面积、洪水的规模，都不是正态分布。小地震每天都有，但偶尔出现的大地震释放的能量可以是小地震的百万倍。</p>
<p>这些例子的共同点是：<strong>均值不再是一个有意义的描述指标，因为少数极端事件对系统总量的贡献远超所有「普通」事件的总和</strong>。</p>
<h2>工程世界中的幂律</h2>
<p>作为技术架构师，我更关心幂律在工程系统中的表现。事实上，几乎所有大规模分布式系统的运维数据都在尖叫着同一个事实：<strong>故障不是均匀分布的，它们服从幂律</strong>。</p>
<p><strong>系统故障的严重程度</strong>是典型的幂律分布。翻看任何一家大型互联网公司的故障复盘记录，你会发现：绝大多数故障影响很小（一个服务短暂抖动、几十个请求超时），但极少数故障的影响是灾难性的（全站不可用、数据丢失、资金损失）。如果你用平均故障影响来做容量规划，就会在那些极端故障面前毫无准备。</p>
<p><strong>流量的时间分布</strong>也是幂律性质的。在电商系统中，双十一零点的瞬时流量可以是日常峰值的 10 到 50 倍。如果你用过去一年的「平均流量」来规划系统容量，你的系统在大促时必然崩溃。这不是简单的「高峰」，而是幂律分布中的尾部事件——它出现的频率低，但一旦出现，量级完全不在你的日常经验范围内。</p>
<p><strong>安全攻击</strong>的分布同样如此。大多数攻击是低级的扫描和试探，但偶尔出现的高级持续性威胁（APT），其破坏力可能比所有低级攻击加起来还大。DDoS 攻击的流量分布、漏洞利用的影响范围、数据泄露的规模，全都呈现幂律特征。</p>
<p><strong>API 调用的延迟分布</strong>也不是正态的。大部分请求在毫秒级完成，但总有少量请求的延迟是平均值的几十倍甚至几百倍。这些长尾延迟在微服务架构中会被级联放大——如果一个请求链路涉及 10 个服务，每个服务有 1% 的概率出现长尾延迟，那么整个链路出现异常延迟的概率就接近 10%。这就是为什么 P99 延迟比平均延迟更值得关注。</p>
<h2>Taleb 的忠告：不要在肥尾世界里用薄尾思维</h2>
<p>纳西姆-塔勒布（Nassim Nicholas Taleb）大概是把幂律和肥尾思维推向公众视野最有力的人。他在《黑天鹅》和《反脆弱》中反复强调的核心观点其实很简单：<strong>我们的统计工具和风险模型大多建立在正态分布的假设之上，但现实世界中最重要的那些事件——金融崩盘、技术革命、地缘政治冲击——恰恰服从肥尾分布</strong>。</p>
<p>Taleb 区分了两类世界：「平均斯坦」（Mediocristan）和「极端斯坦」（Extremistan）。在平均斯坦里，单个样本对总体的影响有限——一个人的身高不会显著改变全国平均身高。但在极端斯坦里，单个样本可以改变一切——一个贝佐斯就能把一个城镇的「人均财富」拉高几个数量级。</p>
<p>这个区分对工程实践有深刻的启示：<strong>你的系统运行在哪个世界里？</strong> 如果是平均斯坦（比如用户的阅读时长分布），用均值和标准差做规划是合理的。但如果是极端斯坦（比如故障影响、流量峰值、安全事件），基于均值的规划就是在自欺欺人。</p>
<p>Taleb 还有一个很尖锐的批评：很多所谓的「风险管理」，本质上是在正态分布假设下计算出一个让人心安的数字，然后宣称风险「可控」。但真正的风险恰恰来自那些模型认为「不可能发生」的尾部事件。2008 年的全球金融危机，在许多银行的风控模型中是「25 个标准差」以外的事件——这在正态分布下比宇宙年龄还要不可能。但它就是发生了。</p>
<h2>对系统设计的启示</h2>
<p>理解幂律分布之后，系统设计的思路需要发生根本性的转变。</p>
<p><strong>第一，放弃对「平均值」的执念。</strong> 在幂律世界中，平均值是一个危险的统计量。它既不代表典型情况，也不代表极端情况，只是一个数学上的中间态。设计系统容量时，不应该基于平均负载，而应该基于你能承受的最大冲击。监控系统时，不应该只看平均延迟，而应该关注 P99 甚至 P999。</p>
<p><strong>第二，为极端事件预留不对称的资源。</strong> 在正态分布的世界里，你可以线性地扩展资源来应对增长。但在幂律世界里，极端事件的规模与普通事件之间不是线性关系，而是幂次关系。这意味着你需要某种「弹性储备」——平时看起来浪费，但在尾部事件到来时能救命。阿里的全链路压测和弹性伸缩体系，本质上就是在为幂律尾部做准备。</p>
<p><strong>第三，建立反脆弱机制。</strong> Taleb 提出的「反脆弱」概念在工程中非常实用。一个反脆弱的系统，不仅能在冲击中存活，还能从冲击中受益。具体到技术实践中，这意味着：混沌工程（主动注入故障来暴露脆弱点）、熔断降级（在极端负载下优雅退化而非全面崩溃）、以及故障复盘文化（从每次极端事件中提取系统性改进）。</p>
<p><strong>第四，重新定义「异常」。</strong> 在正态分布思维下，极端事件是「异常」，可以被忽略或排除。但在幂律分布下，极端事件虽然稀少，却是系统行为的核心组成部分。你不能把它们当作噪声过滤掉，而应该把它们当作信号认真对待。每一次线上的极端故障，都不应该被归结为「运气不好」，而应该被视为系统结构性问题的显性化。</p>
<p><strong>第五，接受不可预测性。</strong> 幂律分布的一个深刻含义是：你无法精确预测下一个极端事件的时间和规模。你能做的不是预测，而是确保系统在面对未知规模的冲击时仍能维持核心功能。这是一种从「预测-控制」到「感知-响应」的范式转换。</p>
<h2>结语：与不确定性共处</h2>
<p>正态分布给了我们确定性的幻觉：只要数据量够大，一切都会回归均值。幂律分布则告诉我们一个更诚实的现实：<strong>在复杂系统中，极端事件不是偶然的扰动，而是系统本身运行逻辑的必然产物</strong>。</p>
<p>理解幂律，不是为了恐惧极端事件，而是为了用正确的模型来认识世界。当你知道你面对的是一个肥尾世界时，你就不会再用均值来安慰自己，不会再用正态假设来低估风险，不会再在极端事件发生后说「谁能想到」。</p>
<p>你能想到。因为数学早已告诉你，在幂律的世界里，黑天鹅不是意外。它只是在等一个出场的时机。</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/life/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Life"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/life/reading/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"阅读笔记"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-05-10","children":"2024年05月10日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"《反脆弱》：从不确定性中获益的系统设计"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","读书笔记",{"href":"/blog/tag/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"读书笔记"}],["$","$L13","反脆弱",{"href":"/blog/tag/%E5%8F%8D%E8%84%86%E5%BC%B1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"反脆弱"}],["$","$L13","塔勒布",{"href":"/blog/tag/%E5%A1%94%E5%8B%92%E5%B8%83/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"塔勒布"}],["$","$L13","系统设计",{"href":"/blog/tag/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"系统设计"}],["$","$L13","风险管理",{"href":"/blog/tag/%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"风险管理"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/middleware/非侵入式SQL监控","title":"非侵入式SQL监控","description":"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...","pubDate":"2024-04-07","tags":["SQL监控","Java","非侵入式"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"science/complexity/涌现：为什么整体大于部分之和","title":"涌现：为什么整体大于部分之和","description":"蚁群没有指挥官却能建造复杂巢穴，神经元没有意识却产生了思维，简单规则的局部交互如何产生全局的复杂秩序？涌现是复杂系统最迷人也最反直觉的特性。","pubDate":"2024-06-20","tags":["复杂系统","涌现","自组织","系统思维"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"读书笔记":{"prev":null,"next":{"slug":"life/reading/系统之美：看见世界运行的隐藏结构","title":"《系统之美》：看见世界运行的隐藏结构","description":"梅多斯在这本小书里展示了一种看世界的方式：万事万物都是系统，而系统的行为由结构决定，不由意图决定。理解反馈回路、延迟和非线性，就能看透很多「反常识」的现象。","pubDate":"2024-12-18","tags":["读书笔记","系统思维","梅多斯","反馈回路"],"heroImage":"$undefined","content":"$19"}},"反脆弱":{"prev":null,"next":null},"塔勒布":{"prev":null,"next":null},"系统设计":{"prev":{"slug":"engineering/domain/权限系统方案设计","title":"权限系统方案设计","description":"日常工作中权限的问题时时刻刻伴随着我们，程序员新入职一家公司需要找人开通各种权限，比如网络连接的权限、编码下载提交的权限、监控平台登录的权限、运营平台查数据的权限等等。在很多时候我们会觉得这么多繁杂的申请给工作带来不便，并且如果突然想要查一些数据，发现没有申请过权限，需要再走审批流程，时间拉得会很长。那为什么还需要这么严格的权限管理呢？","pubDate":"2024-03-08","tags":["权限系统","RBAC","系统设计"],"heroImage":"$undefined","content":"$1a"},"next":null},"风险管理":{"prev":null,"next":{"slug":"science/complexity/幂律分布：为什么极端事件比你想象的更常见","title":"幂律分布：为什么极端事件比你想象的更常见","description":"正态分布训练了我们对「平均值」的直觉，但现实世界中大量现象服从幂律分布——财富、城市规模、网络连接、系统故障。理解幂律，就是理解为什么黑天鹅不是意外。","pubDate":"2024-08-12","tags":["幂律分布","复杂系统","风险管理","统计学"],"heroImage":"$undefined","content":"$1b"}}}}]}],["$","$L1c",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"《反脆弱》：从不确定性中获益的系统设计 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"塔勒布的核心洞见不是「如何抵抗风险」，而是「如何让波动成为养分」。反脆弱不是坚固，而是在压力下变得更强。这个框架对系统架构、职业规划和个人生活都有深刻启示。"}],["$","meta","2",{"property":"og:title","content":"《反脆弱》：从不确定性中获益的系统设计"}],["$","meta","3",{"property":"og:description","content":"塔勒布的核心洞见不是「如何抵抗风险」，而是「如何让波动成为养分」。反脆弱不是坚固，而是在压力下变得更强。这个框架对系统架构、职业规划和个人生活都有深刻启示。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-05-10"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"《反脆弱》：从不确定性中获益的系统设计"}],["$","meta","9",{"name":"twitter:description","content":"塔勒布的核心洞见不是「如何抵抗风险」，而是「如何让波动成为养分」。反脆弱不是坚固，而是在压力下变得更强。这个框架对系统架构、职业规划和个人生活都有深刻启示。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

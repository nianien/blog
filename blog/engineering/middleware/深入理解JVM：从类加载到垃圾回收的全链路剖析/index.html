<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/7dd6b3ec14b0b1d8.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>深入理解JVM：从类加载到垃圾回收的全链路剖析 - Skyfalling Blog</title><meta name="description" content="系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。"/><meta property="og:title" content="深入理解JVM：从类加载到垃圾回收的全链路剖析"/><meta property="og:description" content="系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2021-06-15"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="深入理解JVM：从类加载到垃圾回收的全链路剖析"/><meta name="twitter:description" content="系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/middleware/page/1/">中间件</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2021-06-15">2021年06月15日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">深入理解JVM：从类加载到垃圾回收的全链路剖析</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/JVM/page/1/">JVM</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/page/1/">垃圾回收</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E7%B1%BB%E5%8A%A0%E8%BD%BD/page/1/">类加载</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/page/1/">性能调优</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>深入理解JVM：从类加载到垃圾回收的全链路剖析</h1>
<blockquote>
<p>Java 程序的生命周期始于类加载，终于垃圾回收。理解 JVM 的工作原理，不仅是性能调优的基础，更是理解 Java 语言设计哲学的关键。</p>
</blockquote>
<p>JVM（Java Virtual Machine）是 Java 生态的基石。它屏蔽了底层硬件差异，为 Java 程序提供了一个统一的运行时环境。但这层抽象并非没有代价——内存管理、类加载、即时编译等机制的复杂性，往往是生产环境问题的根源。</p>
<p>本文将沿着 Java 程序的执行链路，从类文件的加载、运行时内存的分配，到对象的回收，系统梳理 JVM 的核心机制。</p>
<h2>一、类加载机制</h2>
<h3>1.1 类的生命周期</h3>
<p>一个 Java 类从被加载到 JVM 内存，到最终被卸载，经历以下阶段：</p>
<pre><code>加载（Loading）→ 验证（Verification）→ 准备（Preparation）
    → 解析（Resolution）→ 初始化（Initialization）
        → 使用（Using）→ 卸载（Unloading）
</code></pre>
<p>其中，验证、准备、解析统称为**链接（Linking）**阶段。</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>核心动作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>加载</strong></td>
<td>读取 .class 字节流，生成 Class 对象</td>
<td>由 ClassLoader 执行</td>
</tr>
<tr>
<td><strong>验证</strong></td>
<td>校验字节码的合法性和安全性</td>
<td>文件格式、元数据、字节码、符号引用验证</td>
</tr>
<tr>
<td><strong>准备</strong></td>
<td>为类的静态变量分配内存并赋零值</td>
<td><code>static int a = 10</code> 在此阶段 a = 0</td>
</tr>
<tr>
<td><strong>解析</strong></td>
<td>将符号引用替换为直接引用</td>
<td>类、字段、方法、接口方法的解析</td>
</tr>
<tr>
<td><strong>初始化</strong></td>
<td>执行类构造器 <code>&lt;clinit&gt;()</code></td>
<td>静态变量赋值和静态代码块的执行</td>
</tr>
</tbody></table>
<h3>1.2 ClassLoader 体系</h3>
<p>JVM 内置三层 ClassLoader，形成层级结构：</p>
<pre><code>Bootstrap ClassLoader（引导类加载器）
    ↑ parent
Extension ClassLoader（扩展类加载器）
    ↑ parent
Application ClassLoader（应用类加载器）
    ↑ parent
Custom ClassLoader（自定义类加载器）
</code></pre>
<table>
<thead>
<tr>
<th>ClassLoader</th>
<th>实现语言</th>
<th>加载路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bootstrap</strong></td>
<td>C/C++</td>
<td><code>$JAVA_HOME/lib</code>（rt.jar 等）</td>
<td>JVM 内部实现，Java 中无法直接引用（返回 null）</td>
</tr>
<tr>
<td><strong>Extension</strong></td>
<td>Java</td>
<td><code>$JAVA_HOME/lib/ext</code></td>
<td><code>sun.misc.Launcher$ExtClassLoader</code></td>
</tr>
<tr>
<td><strong>Application</strong></td>
<td>Java</td>
<td>classpath</td>
<td><code>sun.misc.Launcher$AppClassLoader</code>，默认的类加载器</td>
</tr>
</tbody></table>
<p>三者的关系通过 <code>sun.misc.Launcher</code> 的构造函数建立：</p>
<pre><code class="language-java">public Launcher() {
    // 1. 创建 ExtClassLoader
    ExtClassLoader extClassLoader = ExtClassLoader.getExtClassLoader();
    // 2. 创建 AppClassLoader，parent 设为 ExtClassLoader
    AppClassLoader appClassLoader = AppClassLoader.getAppClassLoader(extClassLoader);
    // 3. 设置线程上下文类加载器为 AppClassLoader
    Thread.currentThread().setContextClassLoader(appClassLoader);
}
</code></pre>
<h3>1.3 双亲委派模型</h3>
<p><strong>核心规则</strong>：当一个 ClassLoader 收到类加载请求时，首先将请求委派给父加载器处理，只有当父加载器无法完成加载时，才由自身尝试加载。</p>
<p>执行流程（<code>ClassLoader.loadClass()</code> 源码逻辑）：</p>
<pre><code class="language-java">protected Class&lt;?&gt; loadClass(String name, boolean resolve) {
    // 1. 检查类是否已被加载
    Class&lt;?&gt; c = findLoadedClass(name);
    if (c == null) {
        try {
            // 2. 委派给父加载器
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                // parent 为 null 表示委派给 Bootstrap
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // 父加载器无法加载
        }
        if (c == null) {
            // 3. 父加载器无法加载，自行加载
            c = findClass(name);
        }
    }
    return c;
}
</code></pre>
<p><strong>双亲委派的价值</strong>：</p>
<ul>
<li><strong>安全性</strong>：防止核心类库被篡改。即使自定义了一个 <code>java.lang.String</code>，也不会被加载，因为 Bootstrap ClassLoader 会优先加载 rt.jar 中的版本</li>
<li><strong>唯一性</strong>：同一个类在 JVM 中只会被加载一次，避免类的重复加载</li>
</ul>
<h3>1.4 打破双亲委派</h3>
<p>双亲委派并非不可逾越。以下场景需要打破这一模型：</p>
<p><strong>场景一：SPI 机制</strong></p>
<p>Java SPI（Service Provider Interface）的典型问题：核心接口由 Bootstrap ClassLoader 加载（如 <code>java.sql.Driver</code>），但实现类在应用 classpath 下（如 MySQL 驱动），Bootstrap 无法向下委派。</p>
<p>解决方案：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。</p>
<pre><code class="language-java">// JDBC DriverManager 的实现
ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
// ServiceLoader.load() 内部使用 Thread.currentThread().getContextClassLoader()
// 从而绕过了双亲委派，用 AppClassLoader 加载 SPI 实现类
</code></pre>
<p><strong>场景二：热部署</strong></p>
<p>OSGi、Tomcat 等容器需要实现类的热替换。Tomcat 为每个 Web 应用创建独立的 ClassLoader（<code>WebAppClassLoader</code>），它优先从自身路径加载类，找不到才委派给父加载器——这与双亲委派的顺序恰好相反。</p>
<p><strong>场景三：自定义 ClassLoader</strong></p>
<p>通过重写 <code>findClass()</code> 方法实现自定义加载逻辑，如从网络加载、加密 class 文件的解密加载等：</p>
<pre><code class="language-java">public class EncryptedClassLoader extends ClassLoader {
    @Override
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
        byte[] encrypted = loadBytesFromDisk(name);
        byte[] decrypted = decrypt(encrypted);  // 解密 class 字节码
        return defineClass(name, decrypted, 0, decrypted.length);
    }
}
</code></pre>
<h2>二、运行时内存模型</h2>
<h3>2.1 内存区域划分</h3>
<p>JVM 运行时内存分为线程私有和线程共享两大类：</p>
<pre><code>┌─────────────────── JVM 内存 ───────────────────────┐
│                                                      │
│  线程私有                    线程共享                   │
│  ┌──────────────────┐      ┌────────────────────┐   │
│  │ 程序计数器（PC）    │      │       堆（Heap）     │   │
│  │ 虚拟机栈（Stack）   │      │  ┌──────────────┐  │   │
│  │ 本地方法栈         │      │  │  新生代        │  │   │
│  └──────────────────┘      │  │  Eden + S0/S1 │  │   │
│                             │  ├──────────────┤  │   │
│                             │  │  老年代        │  │   │
│                             │  └──────────────┘  │   │
│                             ├────────────────────┤   │
│                             │  元空间（Metaspace）  │   │
│                             │  （本地内存）          │   │
│                             └────────────────────┘   │
└──────────────────────────────────────────────────────┘
</code></pre>
<table>
<thead>
<tr>
<th>区域</th>
<th>线程属性</th>
<th>存储内容</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td><strong>程序计数器</strong></td>
<td>私有</td>
<td>当前线程执行的字节码行号</td>
<td>唯一不会 OOM 的区域</td>
</tr>
<tr>
<td><strong>虚拟机栈</strong></td>
<td>私有</td>
<td>栈帧（局部变量表、操作数栈、方法返回地址）</td>
<td>StackOverflowError / OOM</td>
</tr>
<tr>
<td><strong>本地方法栈</strong></td>
<td>私有</td>
<td>Native 方法调用的栈帧</td>
<td>StackOverflowError / OOM</td>
</tr>
<tr>
<td><strong>堆</strong></td>
<td>共享</td>
<td>对象实例和数组</td>
<td>OutOfMemoryError: Java heap space</td>
</tr>
<tr>
<td><strong>元空间</strong></td>
<td>共享</td>
<td>类元数据、方法字节码、常量池</td>
<td>OutOfMemoryError: Metaspace</td>
</tr>
</tbody></table>
<h3>2.2 从 PermGen 到 Metaspace</h3>
<p>Java 8 是 JVM 内存模型的一个重要分水岭——<strong>永久代（PermGen）被元空间（Metaspace）取代</strong>。</p>
<p><strong>永久代的问题</strong>：</p>
<ul>
<li>大小固定（默认 64MB，<code>-XX:MaxPermSize</code>），难以预估合理值</li>
<li>类元数据与普通 Java 对象混在同一 GC 管理体系中，增加了 Full GC 的复杂度</li>
<li>动态生成类（如大量使用反射、动态代理）容易触发 <code>java.lang.OutOfMemoryError: PermGen space</code></li>
</ul>
<p><strong>元空间的设计</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>PermGen（Java 7-）</th>
<th>Metaspace（Java 8+）</th>
</tr>
</thead>
<tbody><tr>
<td>存储位置</td>
<td>JVM 堆内</td>
<td>本地内存（Native Memory）</td>
</tr>
<tr>
<td>默认大小</td>
<td>固定（64MB）</td>
<td>无上限（受物理内存限制）</td>
</tr>
<tr>
<td>内存分配</td>
<td>与堆对象相同的 GC 管理</td>
<td>每个 ClassLoader 独立分配，线性分配</td>
</tr>
<tr>
<td>回收策略</td>
<td>Full GC 触发</td>
<td>ClassLoader 被回收时，整块释放</td>
</tr>
<tr>
<td>调优参数</td>
<td><code>-XX:MaxPermSize</code></td>
<td><code>-XX:MaxMetaspaceSize</code>、<code>-XX:MetaspaceSize</code></td>
</tr>
</tbody></table>
<p><strong>元空间的内存模型</strong>：</p>
<p>每个 ClassLoader 拥有独立的内存块（chunk）。加载新类时，从当前 chunk 中线性分配空间。当 ClassLoader 被 GC 回收时，其对应的所有 chunk 一次性释放——不存在单个类的逐一回收。</p>
<pre><code>ClassLoader A → [chunk1: Class1 Class2 Class3]
ClassLoader B → [chunk2: Class4 Class5]
ClassLoader C → [chunk3: Class6]

当 ClassLoader B 被 GC → chunk2 整块释放
</code></pre>
<p><strong>压缩类指针空间（Compressed Class Space）</strong>：</p>
<p>在 64 位 JVM 上，如果开启了压缩类指针（<code>-XX:+UseCompressedClassPointers</code>，默认开启），Metaspace 中的 <code>InstanceKlass</code>、<code>ArrayKlass</code> 及虚方法表会存储在一块独立的内存区域中。该区域大小通过 <code>-XX:CompressedClassSpaceSize</code> 控制（默认 1GB）。</p>
<h3>2.3 对象的内存布局</h3>
<p>一个 Java 对象在堆中的内存布局由三部分组成：</p>
<pre><code>┌────────────────────────────────────┐
│          对象头（Header）             │
│  ┌──────────────────────────────┐  │
│  │ Mark Word（标记字）             │  │  → 哈希码、GC 年龄、锁标志位
│  │ Klass Pointer（类型指针）       │  │  → 指向元空间中的 Class 元数据
│  │ Array Length（仅数组对象）       │  │
│  └──────────────────────────────┘  │
├────────────────────────────────────┤
│          实例数据（Instance Data）    │  → 字段值（含父类字段）
├────────────────────────────────────┤
│          对齐填充（Padding）          │  → 补齐到 8 字节的整数倍
└────────────────────────────────────┘
</code></pre>
<p><strong>Mark Word 的结构</strong>（64 位 JVM）：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>存储内容</th>
<th>标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>对象哈希码（31bit）、GC 分代年龄（4bit）</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程 ID（54bit）、Epoch（2bit）、GC 年龄</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向 Monitor 的指针</td>
<td>10</td>
</tr>
<tr>
<td>GC 标记</td>
<td>空</td>
<td>11</td>
</tr>
</tbody></table>
<p>注意：GC 分代年龄占 <strong>4 bit</strong>，最大值为 15。这就是为什么对象晋升老年代的默认阈值 <code>-XX:MaxTenuringThreshold</code> 不能超过 15。</p>
<h2>三、垃圾回收</h2>
<h3>3.1 对象存活判定</h3>
<p>在回收内存之前，JVM 首先需要判断哪些对象是&quot;活&quot;的，哪些是&quot;死&quot;的。</p>
<p><strong>引用计数法</strong></p>
<p>每个对象维护一个引用计数器：被引用时加 1，引用失效时减 1。计数为 0 的对象即可回收。</p>
<p>优点：实现简单，判定效率高。<br>缺陷：<strong>无法解决循环引用问题</strong>。</p>
<pre><code class="language-java">// A 和 B 互相引用，但外部已无法访问
// 引用计数永远不为 0，无法被回收
Object a = new Object();  // a.refCount = 1
Object b = new Object();  // b.refCount = 1
a.field = b;              // b.refCount = 2
b.field = a;              // a.refCount = 2
a = null;                 // a.refCount = 1（仍不为 0）
b = null;                 // b.refCount = 1（仍不为 0）
</code></pre>
<p><strong>可达性分析（Reachability Analysis）</strong></p>
<p>JVM 实际采用的方案。从一组称为 <strong>GC Roots</strong> 的根对象出发，沿引用链向下遍历。不在任何引用链上的对象即为不可达，判定为垃圾。</p>
<p>GC Roots 包括：</p>
<table>
<thead>
<tr>
<th>GC Root 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟机栈中的局部变量</td>
<td>方法正在执行时，栈帧中引用的对象</td>
</tr>
<tr>
<td>方法区中的静态变量</td>
<td>类的 <code>static</code> 字段引用的对象</td>
</tr>
<tr>
<td>方法区中的常量</td>
<td><code>static final</code> 引用的对象</td>
</tr>
<tr>
<td>JNI 引用</td>
<td>Native 方法持有的对象引用</td>
</tr>
<tr>
<td>活跃线程</td>
<td>所有存活的 Thread 对象</td>
</tr>
<tr>
<td>同步锁持有的对象</td>
<td>被 <code>synchronized</code> 锁定的对象</td>
</tr>
</tbody></table>
<h3>3.2 安全点与 Stop-The-World</h3>
<p>GC 在执行可达性分析时，需要确保对象引用关系不会发生变化，因此必须暂停所有应用线程——即 <strong>Stop-The-World（STW）</strong>。</p>
<p>但并非任何时刻都可以暂停线程。线程只有运行到**安全点（Safepoint）**时才能暂停。安全点通常设置在：</p>
<ul>
<li>方法调用处</li>
<li>循环的回边（back edge）</li>
<li>异常抛出处</li>
</ul>
<p>JVM 使用<strong>主动式中断</strong>：GC 需要 STW 时，设置一个全局标志，各线程在安全点检查该标志，发现需要暂停则主动挂起。</p>
<h3>3.3 GC 算法</h3>
<p>四种基础 GC 算法，各有适用场景：</p>
<p><strong>标记-清除（Mark-Sweep）</strong></p>
<pre><code>标记阶段：从 GC Roots 遍历，标记所有存活对象
清除阶段：遍历堆，回收未标记的对象
</code></pre>
<ul>
<li>优点：实现简单</li>
<li>缺点：产生内存碎片，分配大对象时可能找不到连续空间</li>
</ul>
<p><strong>标记-整理（Mark-Compact）</strong></p>
<pre><code>标记阶段：同标记-清除
整理阶段：将所有存活对象向内存一端移动，然后清理边界外的空间
</code></pre>
<ul>
<li>优点：无内存碎片</li>
<li>缺点：移动对象开销大，STW 时间更长</li>
</ul>
<p><strong>复制算法（Copying）</strong></p>
<pre><code>将内存分为两块：对象空间和空闲空间
GC 时将存活对象从对象空间复制到空闲空间，然后清空整个对象空间
两块空间角色互换
</code></pre>
<ul>
<li>优点：无碎片、分配高效（指针碰撞）</li>
<li>缺点：可用内存减半</li>
</ul>
<p><strong>分代收集（Generational Collection）</strong></p>
<p>基于&quot;大多数对象朝生夕灭&quot;的统计假设，将堆划分为新生代和老年代，针对不同代的特征选择不同算法：</p>
<pre><code>新生代（Young Generation）：Eden : S0 : S1 = 8 : 1 : 1
    → 对象存活率低，使用复制算法

老年代（Old Generation）：
    → 对象存活率高，使用标记-清除或标记-整理算法
</code></pre>
<p><strong>新生代 GC（Minor GC）流程</strong>：</p>
<pre><code>1. 新对象分配在 Eden 区
2. Eden 满触发 Minor GC
3. 存活对象复制到 S0（Survivor From）
4. 下一次 Minor GC，Eden + S0 的存活对象复制到 S1，清空 Eden + S0
5. S0 和 S1 角色交换
6. 对象每经历一次 Minor GC，年龄 +1
7. 年龄达到阈值（默认 15）的对象晋升老年代
</code></pre>
<p><strong>对象直接进入老年代的条件</strong>：</p>
<ul>
<li>大对象（超过 <code>-XX:PretenureSizeThreshold</code>）</li>
<li>长期存活对象（年龄超过阈值）</li>
<li>Survivor 空间中相同年龄对象总大小超过 Survivor 一半（动态年龄判定）</li>
<li>Minor GC 后 Survivor 放不下的存活对象</li>
</ul>
<h3>3.4 垃圾收集器</h3>
<p>JVM 提供了多种垃圾收集器，分为新生代和老年代两组，可以组合使用：</p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>分代</th>
<th>算法</th>
<th>线程</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>新生代</td>
<td>复制</td>
<td>单线程</td>
<td>简单高效，适合单核或小堆</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>新生代</td>
<td>复制</td>
<td>多线程</td>
<td>Serial 的多线程版本，能与 CMS 配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>新生代</td>
<td>复制</td>
<td>多线程</td>
<td>以吞吐量为目标，支持自适应调节</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>老年代</td>
<td>标记-整理</td>
<td>单线程</td>
<td>Serial 的老年代版本</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>老年代</td>
<td>标记-整理</td>
<td>多线程</td>
<td>Parallel Scavenge 的老年代搭档</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>老年代</td>
<td>标记-清除</td>
<td>并发</td>
<td>以最短停顿为目标</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>整堆</td>
<td>分区 + 复制/整理</td>
<td>并发</td>
<td>可预测停顿时间，JDK 9 默认</td>
</tr>
</tbody></table>
<p><strong>CMS（Concurrent Mark Sweep）</strong></p>
<p>CMS 的设计目标是<strong>最短回收停顿时间</strong>。它采用标记-清除算法，GC 过程分为四个阶段：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>STW</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始标记</td>
<td>是</td>
<td>仅标记 GC Roots 直接关联的对象，速度很快</td>
</tr>
<tr>
<td>并发标记</td>
<td>否</td>
<td>从初始标记的对象出发，遍历整个对象图</td>
</tr>
<tr>
<td>重新标记</td>
<td>是</td>
<td>修正并发标记期间因程序运行产生的引用变动</td>
</tr>
<tr>
<td>并发清除</td>
<td>否</td>
<td>清除不可达对象</td>
</tr>
</tbody></table>
<p>CMS 的两次 STW 都很短暂，绝大部分工作与应用线程并发执行。</p>
<p><strong>CMS 的局限</strong>：</p>
<ul>
<li><strong>CPU 敏感</strong>：并发阶段占用 CPU 资源，核心数少时影响应用吞吐</li>
<li><strong>浮动垃圾</strong>：并发清除阶段新产生的垃圾只能等下次 GC</li>
<li><strong>内存碎片</strong>：标记-清除算法的固有问题</li>
</ul>
<p><strong>G1（Garbage-First）</strong></p>
<p>G1 是 JDK 9 开始的默认收集器，它将堆划分为多个大小相等的 <strong>Region</strong>（默认 2048 个），每个 Region 可以动态充当 Eden、Survivor 或 Old 区。</p>
<pre><code>┌────┬────┬────┬────┬────┬────┬────┬────┐
│  E │  E │  S │  O │  O │  H │  E │  O │
└────┴────┴────┴────┴────┴────┴────┴────┘
E = Eden    S = Survivor    O = Old    H = Humongous
</code></pre>
<p>G1 的核心优势：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可预测的停顿</strong></td>
<td>通过 <code>-XX:MaxGCPauseMillis</code> 设定目标停顿时间，G1 优先回收收益最大的 Region</td>
</tr>
<tr>
<td><strong>无内存碎片</strong></td>
<td>Region 间使用复制算法，Region 内使用标记-整理</td>
</tr>
<tr>
<td><strong>大对象处理</strong></td>
<td>超过 Region 50% 的大对象分配在 Humongous Region</td>
</tr>
<tr>
<td><strong>混合回收</strong></td>
<td>Mixed GC 同时回收新生代和部分老年代 Region</td>
</tr>
</tbody></table>
<p>G1 的 GC 过程：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>STW</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始标记</td>
<td>是</td>
<td>标记 GC Roots 直接关联对象（借助 Minor GC 完成）</td>
</tr>
<tr>
<td>并发标记</td>
<td>否</td>
<td>遍历对象图，标记存活对象</td>
</tr>
<tr>
<td>最终标记</td>
<td>是</td>
<td>处理并发阶段遗留的 SATB（Snapshot-At-The-Beginning）记录</td>
</tr>
<tr>
<td>筛选回收</td>
<td>是</td>
<td>按回收收益排序 Region，将存活对象复制到空 Region</td>
</tr>
</tbody></table>
<h3>3.5 收集器选型决策</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐收集器</th>
<th>关键参数</th>
</tr>
</thead>
<tbody><tr>
<td>单核 / 小堆（&lt; 1GB）</td>
<td>Serial + Serial Old</td>
<td><code>-XX:+UseSerialGC</code></td>
</tr>
<tr>
<td>多核 / 吞吐量优先</td>
<td>Parallel Scavenge + Parallel Old</td>
<td><code>-XX:+UseParallelGC</code>（JDK 8 默认）</td>
</tr>
<tr>
<td>多核 / 延迟敏感</td>
<td>ParNew + CMS</td>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
</tr>
<tr>
<td>大堆（&gt; 4GB）/ 延迟可控</td>
<td>G1</td>
<td><code>-XX:+UseG1GC</code>（JDK 9+ 默认）</td>
</tr>
<tr>
<td>超大堆 / 超低延迟</td>
<td>ZGC / Shenandoah</td>
<td><code>-XX:+UseZGC</code>（JDK 11+）</td>
</tr>
</tbody></table>
<h2>四、JVM 调优实践</h2>
<h3>4.1 关键调优参数</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xms</code> / <code>-Xmx</code></td>
<td>堆初始/最大大小</td>
<td>设为相同值，避免运行时动态扩容</td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>新生代大小</td>
<td>通常为堆的 1/3 到 1/2</td>
</tr>
<tr>
<td><code>-XX:MetaspaceSize</code></td>
<td>Metaspace 初始高水位线</td>
<td>根据类加载量设定，避免启动时频繁 Full GC</td>
</tr>
<tr>
<td><code>-XX:MaxMetaspaceSize</code></td>
<td>Metaspace 上限</td>
<td>建议设定上限，防止内存泄漏耗尽系统内存</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>Eden 与 Survivor 的比例</td>
<td>默认 8:1:1，一般无需调整</td>
</tr>
<tr>
<td><code>-XX:MaxTenuringThreshold</code></td>
<td>晋升老年代的年龄阈值</td>
<td>默认 15，最大 15（4 bit 限制）</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis</code></td>
<td>G1 目标停顿时间</td>
<td>默认 200ms，根据业务 SLA 设定</td>
</tr>
</tbody></table>
<h3>4.2 常见问题与排查</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>表现</th>
<th>排查方向</th>
</tr>
</thead>
<tbody><tr>
<td><strong>频繁 Full GC</strong></td>
<td>老年代频繁被填满</td>
<td>检查大对象分配、内存泄漏、Metaspace 增长</td>
</tr>
<tr>
<td><strong>长时间 STW</strong></td>
<td>应用周期性卡顿</td>
<td>GC 日志分析、考虑切换为 G1/ZGC</td>
</tr>
<tr>
<td><strong>OOM: Java heap space</strong></td>
<td>堆内存不足</td>
<td>堆转储分析（<code>jmap -dump</code>）、排查内存泄漏</td>
</tr>
<tr>
<td><strong>OOM: Metaspace</strong></td>
<td>类元数据空间耗尽</td>
<td>排查动态类生成（反射、CGLIB 代理）是否失控</td>
</tr>
<tr>
<td><strong>OOM: GC overhead limit</strong></td>
<td>GC 耗时超过 98% 但回收不到 2% 内存</td>
<td>通常是内存泄漏的征兆</td>
</tr>
</tbody></table>
<h3>4.3 监控工具</h3>
<table>
<thead>
<tr>
<th>工具</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>jstat -gc</code></td>
<td>实时查看 GC 统计（各代容量、GC 次数和耗时）</td>
</tr>
<tr>
<td><code>jmap -heap</code></td>
<td>查看堆内存使用概况</td>
</tr>
<tr>
<td><code>jmap -dump</code></td>
<td>导出堆转储文件（配合 MAT / VisualVM 分析）</td>
</tr>
<tr>
<td><code>jstack</code></td>
<td>导出线程快照（排查死锁、线程阻塞）</td>
</tr>
<tr>
<td><code>jcmd GC.class_stats</code></td>
<td>查看类元数据统计（替代 <code>jmap -permstat</code>）</td>
</tr>
<tr>
<td>GC 日志</td>
<td><code>-Xlog:gc*</code>（JDK 9+）/ <code>-XX:+PrintGCDetails</code>（JDK 8）</td>
</tr>
</tbody></table>
<h2>总结</h2>
<p>JVM 的三大核心机制——类加载、内存管理、垃圾回收——构成了 Java 程序运行的底层基石：</p>
<ol>
<li><strong>类加载的双亲委派模型</strong>保证了类的安全性和唯一性，但 SPI、热部署等场景需要理解如何合理打破它</li>
<li><strong>从 PermGen 到 Metaspace 的演进</strong>反映了 JVM 设计从&quot;固定分配&quot;到&quot;弹性管理&quot;的思路转变</li>
<li><strong>GC 收集器的选型</strong>没有最优解，只有最匹配的方案——吞吐量优先选 Parallel，延迟敏感选 CMS/G1/ZGC</li>
</ol>
<blockquote>
<p>理解 JVM 的意义不在于记住每个参数的默认值，而在于建立&quot;代码行为 → JVM 行为 → 系统表现&quot;的因果链，从而在生产问题出现时，能够从现象追溯到根因。</p>
</blockquote>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/7dd6b3ec14b0b1d8.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"kLuGQpYNrv7rzQ0jpQCVp\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"middleware\",\"%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%9A%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/middleware/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%9A%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7dd6b3ec14b0b1d8.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/middleware/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%EF%BC%9A%E4%BB%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E5%89%96%E6%9E%90\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"j_vRQTyBY0jQEkKJiEtcov\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n18:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T6a92,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e深入理解JVM：从类加载到垃圾回收的全链路剖析\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJava 程序的生命周期始于类加载，终于垃圾回收。理解 JVM 的工作原理，不仅是性能调优的基础，更是理解 Java 语言设计哲学的关键。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eJVM（Java Virtual Machine）是 Java 生态的基石。它屏蔽了底层硬件差异，为 Java 程序提供了一个统一的运行时环境。但这层抽象并非没有代价——内存管理、类加载、即时编译等机制的复杂性，往往是生产环境问题的根源。\u003c/p\u003e\n\u003cp\u003e本文将沿着 Java 程序的执行链路，从类文件的加载、运行时内存的分配，到对象的回收，系统梳理 JVM 的核心机制。\u003c/p\u003e\n\u003ch2\u003e一、类加载机制\u003c/h2\u003e\n\u003ch3\u003e1.1 类的生命周期\u003c/h3\u003e\n\u003cp\u003e一个 Java 类从被加载到 JVM 内存，到最终被卸载，经历以下阶段：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e加载（Loading）→ 验证（Verification）→ 准备（Preparation）\n    → 解析（Resolution）→ 初始化（Initialization）\n        → 使用（Using）→ 卸载（Unloading）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，验证、准备、解析统称为**链接（Linking）**阶段。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003e核心动作\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e加载\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e读取 .class 字节流，生成 Class 对象\u003c/td\u003e\n\u003ctd\u003e由 ClassLoader 执行\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e验证\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e校验字节码的合法性和安全性\u003c/td\u003e\n\u003ctd\u003e文件格式、元数据、字节码、符号引用验证\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e准备\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e为类的静态变量分配内存并赋零值\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003estatic int a = 10\u003c/code\u003e 在此阶段 a = 0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e解析\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e将符号引用替换为直接引用\u003c/td\u003e\n\u003ctd\u003e类、字段、方法、接口方法的解析\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e初始化\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e执行类构造器 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e静态变量赋值和静态代码块的执行\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e1.2 ClassLoader 体系\u003c/h3\u003e\n\u003cp\u003eJVM 内置三层 ClassLoader，形成层级结构：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBootstrap ClassLoader（引导类加载器）\n    ↑ parent\nExtension ClassLoader（扩展类加载器）\n    ↑ parent\nApplication ClassLoader（应用类加载器）\n    ↑ parent\nCustom ClassLoader（自定义类加载器）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eClassLoader\u003c/th\u003e\n\u003cth\u003e实现语言\u003c/th\u003e\n\u003cth\u003e加载路径\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eBootstrap\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eC/C++\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e$JAVA_HOME/lib\u003c/code\u003e（rt.jar 等）\u003c/td\u003e\n\u003ctd\u003eJVM 内部实现，Java 中无法直接引用（返回 null）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eExtension\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e$JAVA_HOME/lib/ext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esun.misc.Launcher$ExtClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eApplication\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003eclasspath\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esun.misc.Launcher$AppClassLoader\u003c/code\u003e，默认的类加载器\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e三者的关系通过 \u003ccode\u003esun.misc.Launcher\u003c/code\u003e 的构造函数建立：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Launcher() {\n    // 1. 创建 ExtClassLoader\n    ExtClassLoader extClassLoader = ExtClassLoader.getExtClassLoader();\n    // 2. 创建 AppClassLoader，parent 设为 ExtClassLoader\n    AppClassLoader appClassLoader = AppClassLoader.getAppClassLoader(extClassLoader);\n    // 3. 设置线程上下文类加载器为 AppClassLoader\n    Thread.currentThread().setContextClassLoader(appClassLoader);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1.3 双亲委派模型\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e核心规则\u003c/strong\u003e：当一个 ClassLoader 收到类加载请求时，首先将请求委派给父加载器处理，只有当父加载器无法完成加载时，才由自身尝试加载。\u003c/p\u003e\n\u003cp\u003e执行流程（\u003ccode\u003eClassLoader.loadClass()\u003c/code\u003e 源码逻辑）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) {\n    // 1. 检查类是否已被加载\n    Class\u0026lt;?\u0026gt; c = findLoadedClass(name);\n    if (c == null) {\n        try {\n            // 2. 委派给父加载器\n            if (parent != null) {\n                c = parent.loadClass(name, false);\n            } else {\n                // parent 为 null 表示委派给 Bootstrap\n                c = findBootstrapClassOrNull(name);\n            }\n        } catch (ClassNotFoundException e) {\n            // 父加载器无法加载\n        }\n        if (c == null) {\n            // 3. 父加载器无法加载，自行加载\n            c = findClass(name);\n        }\n    }\n    return c;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e双亲委派的价值\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e安全性\u003c/strong\u003e：防止核心类库被篡改。即使自定义了一个 \u003ccode\u003ejava.lang.String\u003c/code\u003e，也不会被加载，因为 Bootstrap ClassLoader 会优先加载 rt.jar 中的版本\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e唯一性\u003c/strong\u003e：同一个类在 JVM 中只会被加载一次，避免类的重复加载\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e1.4 打破双亲委派\u003c/h3\u003e\n\u003cp\u003e双亲委派并非不可逾越。以下场景需要打破这一模型：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e场景一：SPI 机制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJava SPI（Service Provider Interface）的典型问题：核心接口由 Bootstrap ClassLoader 加载（如 \u003ccode\u003ejava.sql.Driver\u003c/code\u003e），但实现类在应用 classpath 下（如 MySQL 驱动），Bootstrap 无法向下委派。\u003c/p\u003e\n\u003cp\u003e解决方案：\u003cstrong\u003e线程上下文类加载器（Thread Context ClassLoader）\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// JDBC DriverManager 的实现\nServiceLoader\u0026lt;Driver\u0026gt; loadedDrivers = ServiceLoader.load(Driver.class);\n// ServiceLoader.load() 内部使用 Thread.currentThread().getContextClassLoader()\n// 从而绕过了双亲委派，用 AppClassLoader 加载 SPI 实现类\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e场景二：热部署\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOSGi、Tomcat 等容器需要实现类的热替换。Tomcat 为每个 Web 应用创建独立的 ClassLoader（\u003ccode\u003eWebAppClassLoader\u003c/code\u003e），它优先从自身路径加载类，找不到才委派给父加载器——这与双亲委派的顺序恰好相反。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e场景三：自定义 ClassLoader\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e通过重写 \u003ccode\u003efindClass()\u003c/code\u003e 方法实现自定义加载逻辑，如从网络加载、加密 class 文件的解密加载等：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class EncryptedClassLoader extends ClassLoader {\n    @Override\n    protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException {\n        byte[] encrypted = loadBytesFromDisk(name);\n        byte[] decrypted = decrypt(encrypted);  // 解密 class 字节码\n        return defineClass(name, decrypted, 0, decrypted.length);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二、运行时内存模型\u003c/h2\u003e\n\u003ch3\u003e2.1 内存区域划分\u003c/h3\u003e\n\u003cp\u003eJVM 运行时内存分为线程私有和线程共享两大类：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌─────────────────── JVM 内存 ───────────────────────┐\n│                                                      │\n│  线程私有                    线程共享                   │\n│  ┌──────────────────┐      ┌────────────────────┐   │\n│  │ 程序计数器（PC）    │      │       堆（Heap）     │   │\n│  │ 虚拟机栈（Stack）   │      │  ┌──────────────┐  │   │\n│  │ 本地方法栈         │      │  │  新生代        │  │   │\n│  └──────────────────┘      │  │  Eden + S0/S1 │  │   │\n│                             │  ├──────────────┤  │   │\n│                             │  │  老年代        │  │   │\n│                             │  └──────────────┘  │   │\n│                             ├────────────────────┤   │\n│                             │  元空间（Metaspace）  │   │\n│                             │  （本地内存）          │   │\n│                             └────────────────────┘   │\n└──────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e区域\u003c/th\u003e\n\u003cth\u003e线程属性\u003c/th\u003e\n\u003cth\u003e存储内容\u003c/th\u003e\n\u003cth\u003e异常\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e程序计数器\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e私有\u003c/td\u003e\n\u003ctd\u003e当前线程执行的字节码行号\u003c/td\u003e\n\u003ctd\u003e唯一不会 OOM 的区域\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e虚拟机栈\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e私有\u003c/td\u003e\n\u003ctd\u003e栈帧（局部变量表、操作数栈、方法返回地址）\u003c/td\u003e\n\u003ctd\u003eStackOverflowError / OOM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e本地方法栈\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e私有\u003c/td\u003e\n\u003ctd\u003eNative 方法调用的栈帧\u003c/td\u003e\n\u003ctd\u003eStackOverflowError / OOM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e堆\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e对象实例和数组\u003c/td\u003e\n\u003ctd\u003eOutOfMemoryError: Java heap space\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e元空间\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e类元数据、方法字节码、常量池\u003c/td\u003e\n\u003ctd\u003eOutOfMemoryError: Metaspace\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.2 从 PermGen 到 Metaspace\u003c/h3\u003e\n\u003cp\u003eJava 8 是 JVM 内存模型的一个重要分水岭——\u003cstrong\u003e永久代（PermGen）被元空间（Metaspace）取代\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e永久代的问题\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e大小固定（默认 64MB，\u003ccode\u003e-XX:MaxPermSize\u003c/code\u003e），难以预估合理值\u003c/li\u003e\n\u003cli\u003e类元数据与普通 Java 对象混在同一 GC 管理体系中，增加了 Full GC 的复杂度\u003c/li\u003e\n\u003cli\u003e动态生成类（如大量使用反射、动态代理）容易触发 \u003ccode\u003ejava.lang.OutOfMemoryError: PermGen space\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e元空间的设计\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003ePermGen（Java 7-）\u003c/th\u003e\n\u003cth\u003eMetaspace（Java 8+）\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e存储位置\u003c/td\u003e\n\u003ctd\u003eJVM 堆内\u003c/td\u003e\n\u003ctd\u003e本地内存（Native Memory）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e默认大小\u003c/td\u003e\n\u003ctd\u003e固定（64MB）\u003c/td\u003e\n\u003ctd\u003e无上限（受物理内存限制）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e内存分配\u003c/td\u003e\n\u003ctd\u003e与堆对象相同的 GC 管理\u003c/td\u003e\n\u003ctd\u003e每个 ClassLoader 独立分配，线性分配\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e回收策略\u003c/td\u003e\n\u003ctd\u003eFull GC 触发\u003c/td\u003e\n\u003ctd\u003eClassLoader 被回收时，整块释放\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e调优参数\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxPermSize\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxMetaspaceSize\u003c/code\u003e、\u003ccode\u003e-XX:MetaspaceSize\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e元空间的内存模型\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e每个 ClassLoader 拥有独立的内存块（chunk）。加载新类时，从当前 chunk 中线性分配空间。当 ClassLoader 被 GC 回收时，其对应的所有 chunk 一次性释放——不存在单个类的逐一回收。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eClassLoader A → [chunk1: Class1 Class2 Class3]\nClassLoader B → [chunk2: Class4 Class5]\nClassLoader C → [chunk3: Class6]\n\n当 ClassLoader B 被 GC → chunk2 整块释放\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e压缩类指针空间（Compressed Class Space）\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 64 位 JVM 上，如果开启了压缩类指针（\u003ccode\u003e-XX:+UseCompressedClassPointers\u003c/code\u003e，默认开启），Metaspace 中的 \u003ccode\u003eInstanceKlass\u003c/code\u003e、\u003ccode\u003eArrayKlass\u003c/code\u003e 及虚方法表会存储在一块独立的内存区域中。该区域大小通过 \u003ccode\u003e-XX:CompressedClassSpaceSize\u003c/code\u003e 控制（默认 1GB）。\u003c/p\u003e\n\u003ch3\u003e2.3 对象的内存布局\u003c/h3\u003e\n\u003cp\u003e一个 Java 对象在堆中的内存布局由三部分组成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌────────────────────────────────────┐\n│          对象头（Header）             │\n│  ┌──────────────────────────────┐  │\n│  │ Mark Word（标记字）             │  │  → 哈希码、GC 年龄、锁标志位\n│  │ Klass Pointer（类型指针）       │  │  → 指向元空间中的 Class 元数据\n│  │ Array Length（仅数组对象）       │  │\n│  └──────────────────────────────┘  │\n├────────────────────────────────────┤\n│          实例数据（Instance Data）    │  → 字段值（含父类字段）\n├────────────────────────────────────┤\n│          对齐填充（Padding）          │  → 补齐到 8 字节的整数倍\n└────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMark Word 的结构\u003c/strong\u003e（64 位 JVM）：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁状态\u003c/th\u003e\n\u003cth\u003e存储内容\u003c/th\u003e\n\u003cth\u003e标志位\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e无锁\u003c/td\u003e\n\u003ctd\u003e对象哈希码（31bit）、GC 分代年龄（4bit）\u003c/td\u003e\n\u003ctd\u003e01\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e偏向锁\u003c/td\u003e\n\u003ctd\u003e线程 ID（54bit）、Epoch（2bit）、GC 年龄\u003c/td\u003e\n\u003ctd\u003e01\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e轻量级锁\u003c/td\u003e\n\u003ctd\u003e指向栈中锁记录的指针\u003c/td\u003e\n\u003ctd\u003e00\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e重量级锁\u003c/td\u003e\n\u003ctd\u003e指向 Monitor 的指针\u003c/td\u003e\n\u003ctd\u003e10\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGC 标记\u003c/td\u003e\n\u003ctd\u003e空\u003c/td\u003e\n\u003ctd\u003e11\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e注意：GC 分代年龄占 \u003cstrong\u003e4 bit\u003c/strong\u003e，最大值为 15。这就是为什么对象晋升老年代的默认阈值 \u003ccode\u003e-XX:MaxTenuringThreshold\u003c/code\u003e 不能超过 15。\u003c/p\u003e\n\u003ch2\u003e三、垃圾回收\u003c/h2\u003e\n\u003ch3\u003e3.1 对象存活判定\u003c/h3\u003e\n\u003cp\u003e在回收内存之前，JVM 首先需要判断哪些对象是\u0026quot;活\u0026quot;的，哪些是\u0026quot;死\u0026quot;的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e引用计数法\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e每个对象维护一个引用计数器：被引用时加 1，引用失效时减 1。计数为 0 的对象即可回收。\u003c/p\u003e\n\u003cp\u003e优点：实现简单，判定效率高。\u003cbr\u003e缺陷：\u003cstrong\u003e无法解决循环引用问题\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// A 和 B 互相引用，但外部已无法访问\n// 引用计数永远不为 0，无法被回收\nObject a = new Object();  // a.refCount = 1\nObject b = new Object();  // b.refCount = 1\na.field = b;              // b.refCount = 2\nb.field = a;              // a.refCount = 2\na = null;                 // a.refCount = 1（仍不为 0）\nb = null;                 // b.refCount = 1（仍不为 0）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e可达性分析（Reachability Analysis）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJVM 实际采用的方案。从一组称为 \u003cstrong\u003eGC Roots\u003c/strong\u003e 的根对象出发，沿引用链向下遍历。不在任何引用链上的对象即为不可达，判定为垃圾。\u003c/p\u003e\n\u003cp\u003eGC Roots 包括：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eGC Root 类型\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e虚拟机栈中的局部变量\u003c/td\u003e\n\u003ctd\u003e方法正在执行时，栈帧中引用的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e方法区中的静态变量\u003c/td\u003e\n\u003ctd\u003e类的 \u003ccode\u003estatic\u003c/code\u003e 字段引用的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e方法区中的常量\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003estatic final\u003c/code\u003e 引用的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eJNI 引用\u003c/td\u003e\n\u003ctd\u003eNative 方法持有的对象引用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e活跃线程\u003c/td\u003e\n\u003ctd\u003e所有存活的 Thread 对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e同步锁持有的对象\u003c/td\u003e\n\u003ctd\u003e被 \u003ccode\u003esynchronized\u003c/code\u003e 锁定的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e3.2 安全点与 Stop-The-World\u003c/h3\u003e\n\u003cp\u003eGC 在执行可达性分析时，需要确保对象引用关系不会发生变化，因此必须暂停所有应用线程——即 \u003cstrong\u003eStop-The-World（STW）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e但并非任何时刻都可以暂停线程。线程只有运行到**安全点（Safepoint）**时才能暂停。安全点通常设置在：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方法调用处\u003c/li\u003e\n\u003cli\u003e循环的回边（back edge）\u003c/li\u003e\n\u003cli\u003e异常抛出处\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJVM 使用\u003cstrong\u003e主动式中断\u003c/strong\u003e：GC 需要 STW 时，设置一个全局标志，各线程在安全点检查该标志，发现需要暂停则主动挂起。\u003c/p\u003e\n\u003ch3\u003e3.3 GC 算法\u003c/h3\u003e\n\u003cp\u003e四种基础 GC 算法，各有适用场景：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e标记-清除（Mark-Sweep）\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e标记阶段：从 GC Roots 遍历，标记所有存活对象\n清除阶段：遍历堆，回收未标记的对象\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e优点：实现简单\u003c/li\u003e\n\u003cli\u003e缺点：产生内存碎片，分配大对象时可能找不到连续空间\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e标记-整理（Mark-Compact）\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e标记阶段：同标记-清除\n整理阶段：将所有存活对象向内存一端移动，然后清理边界外的空间\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e优点：无内存碎片\u003c/li\u003e\n\u003cli\u003e缺点：移动对象开销大，STW 时间更长\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e复制算法（Copying）\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e将内存分为两块：对象空间和空闲空间\nGC 时将存活对象从对象空间复制到空闲空间，然后清空整个对象空间\n两块空间角色互换\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e优点：无碎片、分配高效（指针碰撞）\u003c/li\u003e\n\u003cli\u003e缺点：可用内存减半\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e分代收集（Generational Collection）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e基于\u0026quot;大多数对象朝生夕灭\u0026quot;的统计假设，将堆划分为新生代和老年代，针对不同代的特征选择不同算法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e新生代（Young Generation）：Eden : S0 : S1 = 8 : 1 : 1\n    → 对象存活率低，使用复制算法\n\n老年代（Old Generation）：\n    → 对象存活率高，使用标记-清除或标记-整理算法\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e新生代 GC（Minor GC）流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1. 新对象分配在 Eden 区\n2. Eden 满触发 Minor GC\n3. 存活对象复制到 S0（Survivor From）\n4. 下一次 Minor GC，Eden + S0 的存活对象复制到 S1，清空 Eden + S0\n5. S0 和 S1 角色交换\n6. 对象每经历一次 Minor GC，年龄 +1\n7. 年龄达到阈值（默认 15）的对象晋升老年代\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e对象直接进入老年代的条件\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e大对象（超过 \u003ccode\u003e-XX:PretenureSizeThreshold\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e长期存活对象（年龄超过阈值）\u003c/li\u003e\n\u003cli\u003eSurvivor 空间中相同年龄对象总大小超过 Survivor 一半（动态年龄判定）\u003c/li\u003e\n\u003cli\u003eMinor GC 后 Survivor 放不下的存活对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.4 垃圾收集器\u003c/h3\u003e\n\u003cp\u003eJVM 提供了多种垃圾收集器，分为新生代和老年代两组，可以组合使用：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e收集器\u003c/th\u003e\n\u003cth\u003e分代\u003c/th\u003e\n\u003cth\u003e算法\u003c/th\u003e\n\u003cth\u003e线程\u003c/th\u003e\n\u003cth\u003e特点\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSerial\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新生代\u003c/td\u003e\n\u003ctd\u003e复制\u003c/td\u003e\n\u003ctd\u003e单线程\u003c/td\u003e\n\u003ctd\u003e简单高效，适合单核或小堆\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParNew\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新生代\u003c/td\u003e\n\u003ctd\u003e复制\u003c/td\u003e\n\u003ctd\u003e多线程\u003c/td\u003e\n\u003ctd\u003eSerial 的多线程版本，能与 CMS 配合\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParallel Scavenge\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新生代\u003c/td\u003e\n\u003ctd\u003e复制\u003c/td\u003e\n\u003ctd\u003e多线程\u003c/td\u003e\n\u003ctd\u003e以吞吐量为目标，支持自适应调节\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSerial Old\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代\u003c/td\u003e\n\u003ctd\u003e标记-整理\u003c/td\u003e\n\u003ctd\u003e单线程\u003c/td\u003e\n\u003ctd\u003eSerial 的老年代版本\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParallel Old\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代\u003c/td\u003e\n\u003ctd\u003e标记-整理\u003c/td\u003e\n\u003ctd\u003e多线程\u003c/td\u003e\n\u003ctd\u003eParallel Scavenge 的老年代搭档\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCMS\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代\u003c/td\u003e\n\u003ctd\u003e标记-清除\u003c/td\u003e\n\u003ctd\u003e并发\u003c/td\u003e\n\u003ctd\u003e以最短停顿为目标\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eG1\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e整堆\u003c/td\u003e\n\u003ctd\u003e分区 + 复制/整理\u003c/td\u003e\n\u003ctd\u003e并发\u003c/td\u003e\n\u003ctd\u003e可预测停顿时间，JDK 9 默认\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eCMS（Concurrent Mark Sweep）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eCMS 的设计目标是\u003cstrong\u003e最短回收停顿时间\u003c/strong\u003e。它采用标记-清除算法，GC 过程分为四个阶段：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003eSTW\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e初始标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e仅标记 GC Roots 直接关联的对象，速度很快\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发标记\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e从初始标记的对象出发，遍历整个对象图\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e重新标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e修正并发标记期间因程序运行产生的引用变动\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发清除\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e清除不可达对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eCMS 的两次 STW 都很短暂，绝大部分工作与应用线程并发执行。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCMS 的局限\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCPU 敏感\u003c/strong\u003e：并发阶段占用 CPU 资源，核心数少时影响应用吞吐\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e浮动垃圾\u003c/strong\u003e：并发清除阶段新产生的垃圾只能等下次 GC\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e内存碎片\u003c/strong\u003e：标记-清除算法的固有问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eG1（Garbage-First）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eG1 是 JDK 9 开始的默认收集器，它将堆划分为多个大小相等的 \u003cstrong\u003eRegion\u003c/strong\u003e（默认 2048 个），每个 Region 可以动态充当 Eden、Survivor 或 Old 区。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌────┬────┬────┬────┬────┬────┬────┬────┐\n│  E │  E │  S │  O │  O │  H │  E │  O │\n└────┴────┴────┴────┴────┴────┴────┴────┘\nE = Eden    S = Survivor    O = Old    H = Humongous\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eG1 的核心优势：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e可预测的停顿\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e通过 \u003ccode\u003e-XX:MaxGCPauseMillis\u003c/code\u003e 设定目标停顿时间，G1 优先回收收益最大的 Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e无内存碎片\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eRegion 间使用复制算法，Region 内使用标记-整理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e大对象处理\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e超过 Region 50% 的大对象分配在 Humongous Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e混合回收\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eMixed GC 同时回收新生代和部分老年代 Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eG1 的 GC 过程：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003eSTW\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e初始标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e标记 GC Roots 直接关联对象（借助 Minor GC 完成）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发标记\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e遍历对象图，标记存活对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e最终标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e处理并发阶段遗留的 SATB（Snapshot-At-The-Beginning）记录\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e筛选回收\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e按回收收益排序 Region，将存活对象复制到空 Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e3.5 收集器选型决策\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e场景\u003c/th\u003e\n\u003cth\u003e推荐收集器\u003c/th\u003e\n\u003cth\u003e关键参数\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e单核 / 小堆（\u0026lt; 1GB）\u003c/td\u003e\n\u003ctd\u003eSerial + Serial Old\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseSerialGC\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多核 / 吞吐量优先\u003c/td\u003e\n\u003ctd\u003eParallel Scavenge + Parallel Old\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseParallelGC\u003c/code\u003e（JDK 8 默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多核 / 延迟敏感\u003c/td\u003e\n\u003ctd\u003eParNew + CMS\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseConcMarkSweepGC\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e大堆（\u0026gt; 4GB）/ 延迟可控\u003c/td\u003e\n\u003ctd\u003eG1\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseG1GC\u003c/code\u003e（JDK 9+ 默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e超大堆 / 超低延迟\u003c/td\u003e\n\u003ctd\u003eZGC / Shenandoah\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseZGC\u003c/code\u003e（JDK 11+）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e四、JVM 调优实践\u003c/h2\u003e\n\u003ch3\u003e4.1 关键调优参数\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e参数\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e建议\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xms\u003c/code\u003e / \u003ccode\u003e-Xmx\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e堆初始/最大大小\u003c/td\u003e\n\u003ctd\u003e设为相同值，避免运行时动态扩容\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xmn\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e新生代大小\u003c/td\u003e\n\u003ctd\u003e通常为堆的 1/3 到 1/2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MetaspaceSize\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eMetaspace 初始高水位线\u003c/td\u003e\n\u003ctd\u003e根据类加载量设定，避免启动时频繁 Full GC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxMetaspaceSize\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eMetaspace 上限\u003c/td\u003e\n\u003ctd\u003e建议设定上限，防止内存泄漏耗尽系统内存\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:SurvivorRatio\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eEden 与 Survivor 的比例\u003c/td\u003e\n\u003ctd\u003e默认 8:1:1，一般无需调整\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxTenuringThreshold\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e晋升老年代的年龄阈值\u003c/td\u003e\n\u003ctd\u003e默认 15，最大 15（4 bit 限制）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxGCPauseMillis\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eG1 目标停顿时间\u003c/td\u003e\n\u003ctd\u003e默认 200ms，根据业务 SLA 设定\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e4.2 常见问题与排查\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e表现\u003c/th\u003e\n\u003cth\u003e排查方向\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e频繁 Full GC\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代频繁被填满\u003c/td\u003e\n\u003ctd\u003e检查大对象分配、内存泄漏、Metaspace 增长\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e长时间 STW\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e应用周期性卡顿\u003c/td\u003e\n\u003ctd\u003eGC 日志分析、考虑切换为 G1/ZGC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOOM: Java heap space\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e堆内存不足\u003c/td\u003e\n\u003ctd\u003e堆转储分析（\u003ccode\u003ejmap -dump\u003c/code\u003e）、排查内存泄漏\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOOM: Metaspace\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e类元数据空间耗尽\u003c/td\u003e\n\u003ctd\u003e排查动态类生成（反射、CGLIB 代理）是否失控\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOOM: GC overhead limit\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eGC 耗时超过 98% 但回收不到 2% 内存\u003c/td\u003e\n\u003ctd\u003e通常是内存泄漏的征兆\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e4.3 监控工具\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e用途\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejstat -gc\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e实时查看 GC 统计（各代容量、GC 次数和耗时）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejmap -heap\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e查看堆内存使用概况\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejmap -dump\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e导出堆转储文件（配合 MAT / VisualVM 分析）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejstack\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e导出线程快照（排查死锁、线程阻塞）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejcmd GC.class_stats\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e查看类元数据统计（替代 \u003ccode\u003ejmap -permstat\u003c/code\u003e）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGC 日志\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-Xlog:gc*\u003c/code\u003e（JDK 9+）/ \u003ccode\u003e-XX:+PrintGCDetails\u003c/code\u003e（JDK 8）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJVM 的三大核心机制——类加载、内存管理、垃圾回收——构成了 Java 程序运行的底层基石：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e类加载的双亲委派模型\u003c/strong\u003e保证了类的安全性和唯一性，但 SPI、热部署等场景需要理解如何合理打破它\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从 PermGen 到 Metaspace 的演进\u003c/strong\u003e反映了 JVM 设计从\u0026quot;固定分配\u0026quot;到\u0026quot;弹性管理\u0026quot;的思路转变\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGC 收集器的选型\u003c/strong\u003e没有最优解，只有最匹配的方案——吞吐量优先选 Parallel，延迟敏感选 CMS/G1/ZGC\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e理解 JVM 的意义不在于记住每个参数的默认值，而在于建立\u0026quot;代码行为 → JVM 行为 → 系统表现\u0026quot;的因果链，从而在生产问题出现时，能够从现象追溯到根因。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"17:T5439,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava并发编程：从内存模型到并发工具的设计哲学\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发编程的核心挑战不在于\u0026quot;如何让多个线程同时跑\u0026quot;，而在于\u0026quot;如何让多个线程正确地协作\u0026quot;。理解 Java 内存模型和并发工具的设计原理，是写出正确并发代码的前提。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e并发编程是 Java 工程师的核心能力之一。它涉及从硬件层面的缓存一致性，到语言层面的内存模型，再到 JUC 工具类的 API 设计，是一个纵深很大的知识领域。\u003c/p\u003e\n\u003cp\u003e本文将从底层原理出发，逐层构建 Java 并发编程的知识体系。\u003c/p\u003e\n\u003ch2\u003e一、硬件基础：CPU 缓存与一致性\u003c/h2\u003e\n\u003ch3\u003e1.1 为什么需要缓存\u003c/h3\u003e\n\u003cp\u003e现代 CPU 的运算速度远超主内存的读写速度（差距约 100 倍）。为了弥补这一差距，CPU 引入了多级缓存（L1/L2/L3 Cache）。每个核心拥有独立的 L1/L2 缓存，L3 缓存为所有核心共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCPU Core 0          CPU Core 1\n┌─────────┐        ┌─────────┐\n│ L1 Cache│        │ L1 Cache│\n│ L2 Cache│        │ L2 Cache│\n└────┬────┘        └────┬────┘\n     └────────┬─────────┘\n         L3 Cache（共享）\n              │\n         主内存（RAM）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓存的引入解决了性能问题，但带来了新问题：\u003cstrong\u003e当多个核心各自缓存了同一块数据的副本，其中一个核心修改了数据，如何保证其他核心看到的是最新值？\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 MESI 缓存一致性协议\u003c/h3\u003e\n\u003cp\u003eMESI 是最广泛采用的缓存一致性协议，每个缓存行处于四种状态之一：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e状态\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e对主内存\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eM（Modified）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心修改了数据，与主内存不一致\u003c/td\u003e\n\u003ctd\u003e需要写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eE（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心独占数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eS（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e多个核心共享数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI（Invalid）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e缓存行无效\u003c/td\u003e\n\u003ctd\u003e需从主内存重新加载\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当 Core 0 修改了处于 S 状态的缓存行时：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCore 0 将缓存行状态改为 M\u003c/li\u003e\n\u003cli\u003e通过总线嗅探（Bus Snooping）通知其他核心\u003c/li\u003e\n\u003cli\u003e其他核心将对应缓存行标记为 I\u003c/li\u003e\n\u003cli\u003e其他核心下次读取该数据时，从 Core 0 的缓存或主内存重新加载\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e1.3 缓存行伪共享（False Sharing）\u003c/h3\u003e\n\u003cp\u003e缓存行是缓存操作的最小单位，大小通常为 \u003cstrong\u003e64 字节\u003c/strong\u003e。如果两个无关的变量恰好落在同一缓存行中，一个变量的修改会导致另一个变量的缓存行也失效——这就是伪共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 伪共享示例：head 和 tail 可能在同一缓存行\nclass Queue {\n    volatile long head;  // 生产者频繁修改\n    volatile long tail;  // 消费者频繁修改\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDoug Lea 在 \u003ccode\u003eLinkedTransferQueue\u003c/code\u003e 中的解决方案——填充字节使变量独占一个缓存行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// JDK 7 中的做法\nclass PaddedAtomicReference\u0026lt;T\u0026gt; extends AtomicReference\u0026lt;T\u0026gt; {\n    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;\n}\n\n// JDK 8+ 可以使用 @Contended 注解\n@sun.misc.Contended\nclass QueueNode {\n    volatile long value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二、Java 内存模型（JMM）\u003c/h2\u003e\n\u003ch3\u003e2.1 JMM 的抽象\u003c/h3\u003e\n\u003cp\u003eJava 内存模型（Java Memory Model）定义了\u003cstrong\u003e多线程如何通过共享内存进行通信\u003c/strong\u003e的规则。它并不描述具体的硬件实现，而是提供了一组抽象的可见性和有序性保证。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程 A 工作内存          线程 B 工作内存\n┌──────────────┐      ┌──────────────┐\n│  变量副本      │      │  变量副本      │\n└──────┬───────┘      └──────┬───────┘\n       │    save/load         │\n       └──────────┬───────────┘\n              主内存\n         ┌──────────────┐\n         │  共享变量      │\n         └──────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJMM 定义了 8 种内存交互操作：lock、unlock、read、load、use、assign、store、write。这些操作的组合规则保证了多线程程序的语义正确性。\u003c/p\u003e\n\u003ch3\u003e2.2 三大并发问题\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e根源\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e可见性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程修改了变量，其他线程看不到最新值\u003c/td\u003e\n\u003ctd\u003eCPU 缓存导致各线程工作内存不一致\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e原子性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一组操作被中断导致中间状态暴露\u003c/td\u003e\n\u003ctd\u003e线程切换导致复合操作被打断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e有序性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e代码执行顺序与编写顺序不一致\u003c/td\u003e\n\u003ctd\u003e编译器优化、CPU 指令重排序\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.3 volatile 的语义与实现\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e 是 Java 中最轻量的同步机制，它提供两个保证：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e可见性\u003c/strong\u003e：对 volatile 变量的写操作对所有线程立即可见\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e有序性\u003c/strong\u003e：禁止指令重排序（通过内存屏障实现）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e但不保证原子性\u003c/strong\u003e：\u003ccode\u003evolatile int count; count++\u003c/code\u003e 并不是线程安全的，因为 \u003ccode\u003ecount++\u003c/code\u003e 是读-改-写三步操作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e硬件级实现\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 x86 架构上，对 volatile 变量的写操作会生成一条带 \u003cstrong\u003eLOCK 前缀\u003c/strong\u003e的指令。LOCK 前缀的作用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将当前处理器缓存行的数据写回主内存\u003c/li\u003e\n\u003cli\u003e使其他处理器中缓存该地址的缓存行失效（通过 MESI 协议）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e// JIT 编译后的汇编（x86）\n0x01a3de24: lock addl $0x0,(%esp)  // LOCK 前缀指令\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 P6 及更新的处理器上，LOCK 不再锁总线，而是\u003cstrong\u003e锁缓存行\u003c/strong\u003e（Cache Locking），性能开销远小于总线锁。\u003c/p\u003e\n\u003ch3\u003e2.4 happens-before 规则\u003c/h3\u003e\n\u003cp\u003eJMM 通过 \u003cstrong\u003ehappens-before\u003c/strong\u003e 关系定义了操作间的可见性保证。如果操作 A happens-before 操作 B，则 A 的结果对 B 可见。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e规则\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e程序顺序规则\u003c/td\u003e\n\u003ctd\u003e同一线程中的操作，前面的 happens-before 后面的\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003evolatile 规则\u003c/td\u003e\n\u003ctd\u003evolatile 写 happens-before 后续的 volatile 读\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁规则\u003c/td\u003e\n\u003ctd\u003eunlock happens-before 后续对同一锁的 lock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e传递性\u003c/td\u003e\n\u003ctd\u003e如果 A hb B，B hb C，则 A hb C\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程启动规则\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eThread.start()\u003c/code\u003e happens-before 该线程的每个动作\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程终止规则\u003c/td\u003e\n\u003ctd\u003e线程的所有动作 happens-before 其他线程检测到该线程终止\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e三、锁机制\u003c/h2\u003e\n\u003ch3\u003e3.1 synchronized vs Lock\u003c/h3\u003e\n\u003cp\u003eJava 提供两种锁机制：内置锁（\u003ccode\u003esynchronized\u003c/code\u003e）和显式锁（\u003ccode\u003ejava.util.concurrent.locks.Lock\u003c/code\u003e）。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003esynchronized\u003c/th\u003e\n\u003cth\u003eLock\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e实现层面\u003c/td\u003e\n\u003ctd\u003eJVM 内置（monitorenter/monitorexit）\u003c/td\u003e\n\u003ctd\u003eJava API 层（基于 AQS）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁获取\u003c/td\u003e\n\u003ctd\u003e阻塞式，不可中断\u003c/td\u003e\n\u003ctd\u003e支持非阻塞 \u003ccode\u003etryLock()\u003c/code\u003e、可中断 \u003ccode\u003elockInterruptibly()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁释放\u003c/td\u003e\n\u003ctd\u003e自动释放（退出同步块）\u003c/td\u003e\n\u003ctd\u003e必须在 \u003ccode\u003efinally\u003c/code\u003e 中手动 \u003ccode\u003eunlock()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e条件等待\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eObject.wait()/notify()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCondition.await()/signal()\u003c/code\u003e，支持多条件队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平性\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eReentrantLock(true)\u003c/code\u003e 支持公平锁\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁状态查询\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eisLocked()\u003c/code\u003e、\u003ccode\u003egetHoldCount()\u003c/code\u003e 等\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e选择原则\u003c/strong\u003e：优先使用 \u003ccode\u003esynchronized\u003c/code\u003e（JVM 持续优化，且不会忘记释放锁）；需要高级特性（超时、中断、多条件、公平性）时选择 \u003ccode\u003eLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e3.2 Condition：精确的线程协作\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCondition\u003c/code\u003e 是 \u003ccode\u003eLock\u003c/code\u003e 的配套组件，它替代了 \u003ccode\u003eObject.wait()/notify()\u003c/code\u003e 机制，最大的优势是\u003cstrong\u003e支持多个等待队列\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 使用 Object 的 wait/notify：只有一个等待队列，notifyAll 会唤醒所有线程\n// 使用 Condition：可以创建多个条件队列，signal 只唤醒特定队列中的线程\n\nReentrantLock lock = new ReentrantLock();\nCondition notFull  = lock.newCondition();  // 生产者等待队列\nCondition notEmpty = lock.newCondition();  // 消费者等待队列\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e有界缓冲区实现\u003c/strong\u003e（经典的生产者-消费者模型）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass BoundedBuffer\u0026lt;E\u0026gt; {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n    final Object[] items = new Object[100];\n    int putIndex, takeIndex, count;\n\n    public void put(E e) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();      // 缓冲区满，生产者等待\n            items[putIndex] = e;\n            if (++putIndex == items.length) putIndex = 0;\n            ++count;\n            notEmpty.signal();        // 通知消费者\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();     // 缓冲区空，消费者等待\n            E e = (E) items[takeIndex];\n            if (++takeIndex == items.length) takeIndex = 0;\n            --count;\n            notFull.signal();         // 通知生产者\n            return e;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意 \u003ccode\u003eawait()\u003c/code\u003e 必须在 \u003ccode\u003ewhile\u003c/code\u003e 循环中调用，以防止\u003cstrong\u003e虚假唤醒（Spurious Wakeup）\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e3.3 ReadWriteLock：读写分离\u003c/h3\u003e\n\u003cp\u003e当读操作远多于写操作时，使用排他锁会严重限制并发度。\u003ccode\u003eReadWriteLock\u003c/code\u003e 允许多个线程同时持有读锁，但写锁是排他的。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁状态\u003c/th\u003e\n\u003cth\u003e读锁请求\u003c/th\u003e\n\u003cth\u003e写锁请求\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e无锁\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读锁已持有\u003c/td\u003e\n\u003ctd\u003e允许（共享）\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写锁已持有\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e 的设计决策：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e写锁可降级为读锁\u003c/strong\u003e：持有写锁的线程可以再获取读锁，然后释放写锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e读锁不可升级为写锁\u003c/strong\u003e：防止死锁（多个读线程同时尝试升级会互相等待）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持公平/非公平模式\u003c/strong\u003e：非公平模式下，读锁可能\u0026quot;插队\u0026quot;导致写线程饥饿\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e四、JUC 并发工具类\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.util.concurrent\u003c/code\u003e 包提供了一组高级同步工具，用于解决常见的线程协调问题。\u003c/p\u003e\n\u003ch3\u003e4.1 CountDownLatch：一次性倒计数门闩\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一个或多个线程等待其他线程完成一组操作后再继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCountDownLatch latch = new CountDownLatch(3);  // 计数器初始值 3\n\n// 工作线程\nexecutor.submit(() -\u0026gt; {\n    doTask();\n    latch.countDown();  // 计数器 -1\n});\n\n// 等待线程\nlatch.await();  // 阻塞直到计数器归零\n// 所有任务完成，继续执行\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e一次性\u003c/strong\u003e：计数器归零后无法重置\u003c/li\u003e\n\u003cli\u003e底层基于 AQS 的共享模式实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e典型场景\u003c/strong\u003e：服务启动时等待所有依赖组件初始化完成。\u003c/p\u003e\n\u003ch3\u003e4.2 CyclicBarrier：可重用的屏障\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一组线程互相等待，直到所有线程都到达屏障点，然后同时继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCyclicBarrier barrier = new CyclicBarrier(3, () -\u0026gt; {\n    System.out.println(\u0026quot;所有线程到齐，开始下一阶段\u0026quot;);  // barrierAction\n});\n\n// 每个工作线程\nexecutor.submit(() -\u0026gt; {\n    doPhase1();\n    barrier.await();  // 等待其他线程\n    doPhase2();\n    barrier.await();  // 可以重复使用\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可重用\u003c/strong\u003e：所有线程通过屏障后，计数器自动重置\u003c/li\u003e\n\u003cli\u003e支持 \u003cstrong\u003ebarrierAction\u003c/strong\u003e：所有线程到齐时执行的回调\u003c/li\u003e\n\u003cli\u003e如果某个线程等待超时或被中断，屏障进入 \u003cstrong\u003eBroken\u003c/strong\u003e 状态，所有等待线程收到 \u003ccode\u003eBrokenBarrierException\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.3 Semaphore：信号量\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：控制同时访问某个资源的线程数量。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSemaphore semaphore = new Semaphore(5);  // 最多 5 个并发\n\nexecutor.submit(() -\u0026gt; {\n    semaphore.acquire();    // 获取许可（可用许可 -1）\n    try {\n        accessResource();\n    } finally {\n        semaphore.release();  // 释放许可（可用许可 +1）\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e支持\u003cstrong\u003e公平/非公平\u003c/strong\u003e模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etryAcquire()\u003c/code\u003e 提供非阻塞获取\u003c/li\u003e\n\u003cli\u003e许可数量可以动态增减（\u003ccode\u003erelease()\u003c/code\u003e 可以在未 \u003ccode\u003eacquire()\u003c/code\u003e 的情况下调用）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.4 三者对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e核心语义\u003c/th\u003e\n\u003cth\u003e是否可重用\u003c/th\u003e\n\u003cth\u003e计数方向\u003c/th\u003e\n\u003cth\u003e典型场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程等待 N 个线程\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e递减至 0\u003c/td\u003e\n\u003ctd\u003e主线程等待子任务完成\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCyclicBarrier\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eN 个线程互相等待\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e递增至 N\u003c/td\u003e\n\u003ctd\u003e多阶段并行计算\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e控制并发访问数量\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003e许可的获取与释放\u003c/td\u003e\n\u003ctd\u003e限流、资源池\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e五、生产者-消费者模式\u003c/h2\u003e\n\u003cp\u003e生产者-消费者是并发编程中最经典的协作模式。Java 提供了从底层到高层的多种实现方式。\u003c/p\u003e\n\u003ch3\u003e5.1 三种实现方式对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现方式\u003c/th\u003e\n\u003cth\u003e同步机制\u003c/th\u003e\n\u003cth\u003e通知粒度\u003c/th\u003e\n\u003cth\u003e复杂度\u003c/th\u003e\n\u003cth\u003e推荐度\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003esynchronized + wait/notify\u003c/td\u003e\n\u003ctd\u003e内置锁\u003c/td\u003e\n\u003ctd\u003e全量唤醒（notifyAll）\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e一般\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eLock + Condition\u003c/td\u003e\n\u003ctd\u003e显式锁\u003c/td\u003e\n\u003ctd\u003e精确唤醒（signal）\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBlockingQueue\u003c/td\u003e\n\u003ctd\u003e封装在队列内部\u003c/td\u003e\n\u003ctd\u003e内部自动处理\u003c/td\u003e\n\u003ctd\u003e最低\u003c/td\u003e\n\u003ctd\u003e最推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e为什么 BlockingQueue 是最佳选择\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBlockingQueue\u003c/code\u003e 将同步、等待、通知的逻辑完全封装在 \u003ccode\u003eput()\u003c/code\u003e/\u003ccode\u003etake()\u003c/code\u003e 方法内部，调用方无需关心并发细节：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eBlockingQueue\u0026lt;Task\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(100);\n\n// 生产者\nqueue.put(task);   // 队列满时自动阻塞\n\n// 消费者\nTask task = queue.take();  // 队列空时自动阻塞\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 BlockingQueue 的实现选型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现类\u003c/th\u003e\n\u003cth\u003e底层结构\u003c/th\u003e\n\u003cth\u003e是否有界\u003c/th\u003e\n\u003cth\u003e锁策略\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eArrayBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e数组\u003c/td\u003e\n\u003ctd\u003e有界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e通用场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e链表\u003c/td\u003e\n\u003ctd\u003e可选有界\u003c/td\u003e\n\u003ctd\u003e读写分离锁\u003c/td\u003e\n\u003ctd\u003e吞吐量要求高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSynchronousQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e无容量\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eCAS\u003c/td\u003e\n\u003ctd\u003e直接传递（线程池默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ePriorityBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e堆\u003c/td\u003e\n\u003ctd\u003e无界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e优先级调度\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e六、线程池\u003c/h2\u003e\n\u003ch3\u003e6.1 ThreadPoolExecutor 核心参数\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ThreadPoolExecutor(\n    corePoolSize,      // 核心线程数\n    maximumPoolSize,   // 最大线程数\n    keepAliveTime,     // 非核心线程空闲存活时间\n    TimeUnit.SECONDS,\n    workQueue,         // 任务队列\n    threadFactory,     // 线程工厂\n    rejectedHandler    // 拒绝策略\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e任务提交流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e提交任务\n  → 当前线程数 \u0026lt; corePoolSize？        → 创建核心线程执行\n  → 任务队列未满？                      → 入队等待\n  → 当前线程数 \u0026lt; maximumPoolSize？      → 创建非核心线程执行\n  → 以上都不满足                        → 执行拒绝策略\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2 拒绝策略\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e策略\u003c/th\u003e\n\u003cth\u003e行为\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eAbortPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e抛出 \u003ccode\u003eRejectedExecutionException\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e默认策略，适合需要感知过载的场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCallerRunsPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e由提交线程自己执行任务\u003c/td\u003e\n\u003ctd\u003e反压效果，但可能导致提交线程阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e静默丢弃任务\u003c/td\u003e\n\u003ctd\u003e允许丢失的场景（如日志）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardOldestPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e丢弃队列中最旧的任务\u003c/td\u003e\n\u003ctd\u003e实时性要求高、可接受旧数据丢失\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e6.3 生产阻塞型线程池\u003c/h3\u003e\n\u003cp\u003e标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 使用 \u003ccode\u003eBlockingQueue.offer()\u003c/code\u003e（非阻塞）入队。队列满时不会阻塞提交线程，而是触发拒绝策略。\u003c/p\u003e\n\u003cp\u003e在某些场景下（如需要严格的背压机制），需要让提交线程在队列满时\u003cstrong\u003e阻塞等待\u003c/strong\u003e而非被拒绝。可通过自定义拒绝策略实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThreadPoolExecutor executor = new ThreadPoolExecutor(\n    coreSize, maxSize, 60, TimeUnit.SECONDS,\n    new LinkedBlockingQueue\u0026lt;\u0026gt;(capacity),\n    (runnable, pool) -\u0026gt; {\n        try {\n            // 队列满时，put() 会阻塞提交线程\n            pool.getQueue().put(runnable);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式的优势在于：复用 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 的线程管理能力，同时实现了生产者阻塞语义，避免了手工管理线程的复杂性。\u003c/p\u003e\n\u003ch3\u003e6.4 线程池配置最佳实践\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e任务类型\u003c/th\u003e\n\u003cth\u003e核心线程数建议\u003c/th\u003e\n\u003cth\u003e队列选择\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCPU 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu + 1\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e小容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI/O 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu × 2\u003c/code\u003e 或更高\u003c/td\u003e\n\u003ctd\u003e较大容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e混合型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e拆分为 CPU 池和 I/O 池\u003c/td\u003e\n\u003ctd\u003e各自独立配置\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e关键原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e永远不要使用无界队列\u003c/strong\u003e：\u003ccode\u003eExecutors.newFixedThreadPool()\u003c/code\u003e 默认使用无界的 \u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e，可能导致 OOM\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e为线程池命名\u003c/strong\u003e：自定义 \u003ccode\u003eThreadFactory\u003c/code\u003e，给线程添加有意义的名称前缀，便于排查问题\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控队列深度\u003c/strong\u003e：线程池队列持续增长是系统过载的信号\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava 并发编程的知识体系可以沿着三个层次理解：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e硬件层\u003c/strong\u003e：CPU 缓存、MESI 协议、缓存行伪共享——这是并发问题的物理根源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模型层\u003c/strong\u003e：JMM、happens-before、volatile/synchronized 语义——这是 Java 对硬件差异的抽象屏蔽\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具层\u003c/strong\u003e：Lock/Condition、CountDownLatch/CyclicBarrier/Semaphore、BlockingQueue、ThreadPoolExecutor——这是面向工程的并发编程基础设施\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发工具的选择不在于功能的强大，而在于语义的匹配。\u003ccode\u003esynchronized\u003c/code\u003e 足以解决大多数问题；\u003ccode\u003eBlockingQueue\u003c/code\u003e 比手动的 wait/notify 更安全；标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 比自定义线程管理更可靠。优先选择高层抽象，只在确有需要时才下沉到底层机制。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/middleware/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"中间件\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2021-06-15\",\"children\":\"2021年06月15日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"深入理解JVM：从类加载到垃圾回收的全链路剖析\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"JVM\",{\"href\":\"/blog/tag/JVM/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"JVM\"}],[\"$\",\"$L13\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}],[\"$\",\"$L13\",\"垃圾回收\",{\"href\":\"/blog/tag/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"垃圾回收\"}],[\"$\",\"$L13\",\"类加载\",{\"href\":\"/blog/tag/%E7%B1%BB%E5%8A%A0%E8%BD%BD/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"类加载\"}],[\"$\",\"$L13\",\"性能调优\",{\"href\":\"/blog/tag/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"性能调优\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":null,\"next\":{\"slug\":\"engineering/middleware/Java并发编程：从内存模型到并发工具的设计哲学\",\"title\":\"Java并发编程：从内存模型到并发工具的设计哲学\",\"description\":\"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。\",\"pubDate\":\"2021-11-20\",\"tags\":[\"Java\",\"并发编程\",\"JMM\",\"JUC\",\"线程池\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"}},\"tagNav\":{\"JVM\":{\"prev\":null,\"next\":null},\"Java\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"垃圾回收\":{\"prev\":null,\"next\":null},\"类加载\":{\"prev\":null,\"next\":null},\"性能调优\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L18\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"深入理解JVM：从类加载到垃圾回收的全链路剖析 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"深入理解JVM：从类加载到垃圾回收的全链路剖析\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2021-06-15\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"深入理解JVM：从类加载到垃圾回收的全链路剖析\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
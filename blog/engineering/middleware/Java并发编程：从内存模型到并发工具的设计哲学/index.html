<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/7dd6b3ec14b0b1d8.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>Java并发编程：从内存模型到并发工具的设计哲学 - Skyfalling Blog</title><meta name="description" content="从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。"/><meta property="og:title" content="Java并发编程：从内存模型到并发工具的设计哲学"/><meta property="og:description" content="从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2021-11-20"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Java并发编程：从内存模型到并发工具的设计哲学"/><meta name="twitter:description" content="从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/middleware/page/1/">中间件</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2021-11-20">2021年11月20日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">Java并发编程：从内存模型到并发工具的设计哲学</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/1/">并发编程</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/JMM/page/1/">JMM</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/JUC/page/1/">JUC</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E7%BA%BF%E7%A8%8B%E6%B1%A0/page/1/">线程池</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>Java并发编程：从内存模型到并发工具的设计哲学</h1>
<blockquote>
<p>并发编程的核心挑战不在于&quot;如何让多个线程同时跑&quot;，而在于&quot;如何让多个线程正确地协作&quot;。理解 Java 内存模型和并发工具的设计原理，是写出正确并发代码的前提。</p>
</blockquote>
<p>并发编程是 Java 工程师的核心能力之一。它涉及从硬件层面的缓存一致性，到语言层面的内存模型，再到 JUC 工具类的 API 设计，是一个纵深很大的知识领域。</p>
<p>本文将从底层原理出发，逐层构建 Java 并发编程的知识体系。</p>
<h2>一、硬件基础：CPU 缓存与一致性</h2>
<h3>1.1 为什么需要缓存</h3>
<p>现代 CPU 的运算速度远超主内存的读写速度（差距约 100 倍）。为了弥补这一差距，CPU 引入了多级缓存（L1/L2/L3 Cache）。每个核心拥有独立的 L1/L2 缓存，L3 缓存为所有核心共享。</p>
<pre><code>CPU Core 0          CPU Core 1
┌─────────┐        ┌─────────┐
│ L1 Cache│        │ L1 Cache│
│ L2 Cache│        │ L2 Cache│
└────┬────┘        └────┬────┘
     └────────┬─────────┘
         L3 Cache（共享）
              │
         主内存（RAM）
</code></pre>
<p>缓存的引入解决了性能问题，但带来了新问题：<strong>当多个核心各自缓存了同一块数据的副本，其中一个核心修改了数据，如何保证其他核心看到的是最新值？</strong></p>
<h3>1.2 MESI 缓存一致性协议</h3>
<p>MESI 是最广泛采用的缓存一致性协议，每个缓存行处于四种状态之一：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
<th>对主内存</th>
</tr>
</thead>
<tbody><tr>
<td><strong>M（Modified）</strong></td>
<td>当前核心修改了数据，与主内存不一致</td>
<td>需要写回</td>
</tr>
<tr>
<td><strong>E（Exclusive）</strong></td>
<td>当前核心独占数据，与主内存一致</td>
<td>无需写回</td>
</tr>
<tr>
<td><strong>S（Shared）</strong></td>
<td>多个核心共享数据，与主内存一致</td>
<td>无需写回</td>
</tr>
<tr>
<td><strong>I（Invalid）</strong></td>
<td>缓存行无效</td>
<td>需从主内存重新加载</td>
</tr>
</tbody></table>
<p>当 Core 0 修改了处于 S 状态的缓存行时：</p>
<ol>
<li>Core 0 将缓存行状态改为 M</li>
<li>通过总线嗅探（Bus Snooping）通知其他核心</li>
<li>其他核心将对应缓存行标记为 I</li>
<li>其他核心下次读取该数据时，从 Core 0 的缓存或主内存重新加载</li>
</ol>
<h3>1.3 缓存行伪共享（False Sharing）</h3>
<p>缓存行是缓存操作的最小单位，大小通常为 <strong>64 字节</strong>。如果两个无关的变量恰好落在同一缓存行中，一个变量的修改会导致另一个变量的缓存行也失效——这就是伪共享。</p>
<pre><code class="language-java">// 伪共享示例：head 和 tail 可能在同一缓存行
class Queue {
    volatile long head;  // 生产者频繁修改
    volatile long tail;  // 消费者频繁修改
}
</code></pre>
<p>Doug Lea 在 <code>LinkedTransferQueue</code> 中的解决方案——填充字节使变量独占一个缓存行：</p>
<pre><code class="language-java">// JDK 7 中的做法
class PaddedAtomicReference&lt;T&gt; extends AtomicReference&lt;T&gt; {
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
}

// JDK 8+ 可以使用 @Contended 注解
@sun.misc.Contended
class QueueNode {
    volatile long value;
}
</code></pre>
<h2>二、Java 内存模型（JMM）</h2>
<h3>2.1 JMM 的抽象</h3>
<p>Java 内存模型（Java Memory Model）定义了<strong>多线程如何通过共享内存进行通信</strong>的规则。它并不描述具体的硬件实现，而是提供了一组抽象的可见性和有序性保证。</p>
<pre><code>线程 A 工作内存          线程 B 工作内存
┌──────────────┐      ┌──────────────┐
│  变量副本      │      │  变量副本      │
└──────┬───────┘      └──────┬───────┘
       │    save/load         │
       └──────────┬───────────┘
              主内存
         ┌──────────────┐
         │  共享变量      │
         └──────────────┘
</code></pre>
<p>JMM 定义了 8 种内存交互操作：lock、unlock、read、load、use、assign、store、write。这些操作的组合规则保证了多线程程序的语义正确性。</p>
<h3>2.2 三大并发问题</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>根源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可见性</strong></td>
<td>一个线程修改了变量，其他线程看不到最新值</td>
<td>CPU 缓存导致各线程工作内存不一致</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td>一组操作被中断导致中间状态暴露</td>
<td>线程切换导致复合操作被打断</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>代码执行顺序与编写顺序不一致</td>
<td>编译器优化、CPU 指令重排序</td>
</tr>
</tbody></table>
<h3>2.3 volatile 的语义与实现</h3>
<p><code>volatile</code> 是 Java 中最轻量的同步机制，它提供两个保证：</p>
<ol>
<li><strong>可见性</strong>：对 volatile 变量的写操作对所有线程立即可见</li>
<li><strong>有序性</strong>：禁止指令重排序（通过内存屏障实现）</li>
</ol>
<p><strong>但不保证原子性</strong>：<code>volatile int count; count++</code> 并不是线程安全的，因为 <code>count++</code> 是读-改-写三步操作。</p>
<p><strong>硬件级实现</strong>：</p>
<p>在 x86 架构上，对 volatile 变量的写操作会生成一条带 <strong>LOCK 前缀</strong>的指令。LOCK 前缀的作用：</p>
<ol>
<li>将当前处理器缓存行的数据写回主内存</li>
<li>使其他处理器中缓存该地址的缓存行失效（通过 MESI 协议）</li>
</ol>
<pre><code>// JIT 编译后的汇编（x86）
0x01a3de24: lock addl $0x0,(%esp)  // LOCK 前缀指令
</code></pre>
<p>在 P6 及更新的处理器上，LOCK 不再锁总线，而是<strong>锁缓存行</strong>（Cache Locking），性能开销远小于总线锁。</p>
<h3>2.4 happens-before 规则</h3>
<p>JMM 通过 <strong>happens-before</strong> 关系定义了操作间的可见性保证。如果操作 A happens-before 操作 B，则 A 的结果对 B 可见。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序顺序规则</td>
<td>同一线程中的操作，前面的 happens-before 后面的</td>
</tr>
<tr>
<td>volatile 规则</td>
<td>volatile 写 happens-before 后续的 volatile 读</td>
</tr>
<tr>
<td>锁规则</td>
<td>unlock happens-before 后续对同一锁的 lock</td>
</tr>
<tr>
<td>传递性</td>
<td>如果 A hb B，B hb C，则 A hb C</td>
</tr>
<tr>
<td>线程启动规则</td>
<td><code>Thread.start()</code> happens-before 该线程的每个动作</td>
</tr>
<tr>
<td>线程终止规则</td>
<td>线程的所有动作 happens-before 其他线程检测到该线程终止</td>
</tr>
</tbody></table>
<h2>三、锁机制</h2>
<h3>3.1 synchronized vs Lock</h3>
<p>Java 提供两种锁机制：内置锁（<code>synchronized</code>）和显式锁（<code>java.util.concurrent.locks.Lock</code>）。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>实现层面</td>
<td>JVM 内置（monitorenter/monitorexit）</td>
<td>Java API 层（基于 AQS）</td>
</tr>
<tr>
<td>锁获取</td>
<td>阻塞式，不可中断</td>
<td>支持非阻塞 <code>tryLock()</code>、可中断 <code>lockInterruptibly()</code></td>
</tr>
<tr>
<td>锁释放</td>
<td>自动释放（退出同步块）</td>
<td>必须在 <code>finally</code> 中手动 <code>unlock()</code></td>
</tr>
<tr>
<td>条件等待</td>
<td><code>Object.wait()/notify()</code></td>
<td><code>Condition.await()/signal()</code>，支持多条件队列</td>
</tr>
<tr>
<td>公平性</td>
<td>不支持</td>
<td><code>ReentrantLock(true)</code> 支持公平锁</td>
</tr>
<tr>
<td>锁状态查询</td>
<td>不支持</td>
<td><code>isLocked()</code>、<code>getHoldCount()</code> 等</td>
</tr>
</tbody></table>
<p><strong>选择原则</strong>：优先使用 <code>synchronized</code>（JVM 持续优化，且不会忘记释放锁）；需要高级特性（超时、中断、多条件、公平性）时选择 <code>Lock</code>。</p>
<h3>3.2 Condition：精确的线程协作</h3>
<p><code>Condition</code> 是 <code>Lock</code> 的配套组件，它替代了 <code>Object.wait()/notify()</code> 机制，最大的优势是<strong>支持多个等待队列</strong>。</p>
<pre><code class="language-java">// 使用 Object 的 wait/notify：只有一个等待队列，notifyAll 会唤醒所有线程
// 使用 Condition：可以创建多个条件队列，signal 只唤醒特定队列中的线程

ReentrantLock lock = new ReentrantLock();
Condition notFull  = lock.newCondition();  // 生产者等待队列
Condition notEmpty = lock.newCondition();  // 消费者等待队列
</code></pre>
<p><strong>有界缓冲区实现</strong>（经典的生产者-消费者模型）：</p>
<pre><code class="language-java">class BoundedBuffer&lt;E&gt; {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition();
    final Condition notEmpty = lock.newCondition();
    final Object[] items = new Object[100];
    int putIndex, takeIndex, count;

    public void put(E e) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();      // 缓冲区满，生产者等待
            items[putIndex] = e;
            if (++putIndex == items.length) putIndex = 0;
            ++count;
            notEmpty.signal();        // 通知消费者
        } finally {
            lock.unlock();
        }
    }

    public E take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();     // 缓冲区空，消费者等待
            E e = (E) items[takeIndex];
            if (++takeIndex == items.length) takeIndex = 0;
            --count;
            notFull.signal();         // 通知生产者
            return e;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<p>注意 <code>await()</code> 必须在 <code>while</code> 循环中调用，以防止<strong>虚假唤醒（Spurious Wakeup）</strong>。</p>
<h3>3.3 ReadWriteLock：读写分离</h3>
<p>当读操作远多于写操作时，使用排他锁会严重限制并发度。<code>ReadWriteLock</code> 允许多个线程同时持有读锁，但写锁是排他的。</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>读锁请求</th>
<th>写锁请求</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>读锁已持有</td>
<td>允许（共享）</td>
<td>阻塞</td>
</tr>
<tr>
<td>写锁已持有</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
</tbody></table>
<p><code>ReentrantReadWriteLock</code> 的设计决策：</p>
<ul>
<li><strong>写锁可降级为读锁</strong>：持有写锁的线程可以再获取读锁，然后释放写锁</li>
<li><strong>读锁不可升级为写锁</strong>：防止死锁（多个读线程同时尝试升级会互相等待）</li>
<li><strong>支持公平/非公平模式</strong>：非公平模式下，读锁可能&quot;插队&quot;导致写线程饥饿</li>
</ul>
<h2>四、JUC 并发工具类</h2>
<p><code>java.util.concurrent</code> 包提供了一组高级同步工具，用于解决常见的线程协调问题。</p>
<h3>4.1 CountDownLatch：一次性倒计数门闩</h3>
<p><strong>语义</strong>：一个或多个线程等待其他线程完成一组操作后再继续执行。</p>
<pre><code class="language-java">CountDownLatch latch = new CountDownLatch(3);  // 计数器初始值 3

// 工作线程
executor.submit(() -&gt; {
    doTask();
    latch.countDown();  // 计数器 -1
});

// 等待线程
latch.await();  // 阻塞直到计数器归零
// 所有任务完成，继续执行
</code></pre>
<p><strong>核心特征</strong>：</p>
<ul>
<li><strong>一次性</strong>：计数器归零后无法重置</li>
<li>底层基于 AQS 的共享模式实现</li>
</ul>
<p><strong>典型场景</strong>：服务启动时等待所有依赖组件初始化完成。</p>
<h3>4.2 CyclicBarrier：可重用的屏障</h3>
<p><strong>语义</strong>：一组线程互相等待，直到所有线程都到达屏障点，然后同时继续执行。</p>
<pre><code class="language-java">CyclicBarrier barrier = new CyclicBarrier(3, () -&gt; {
    System.out.println(&quot;所有线程到齐，开始下一阶段&quot;);  // barrierAction
});

// 每个工作线程
executor.submit(() -&gt; {
    doPhase1();
    barrier.await();  // 等待其他线程
    doPhase2();
    barrier.await();  // 可以重复使用
});
</code></pre>
<p><strong>核心特征</strong>：</p>
<ul>
<li><strong>可重用</strong>：所有线程通过屏障后，计数器自动重置</li>
<li>支持 <strong>barrierAction</strong>：所有线程到齐时执行的回调</li>
<li>如果某个线程等待超时或被中断，屏障进入 <strong>Broken</strong> 状态，所有等待线程收到 <code>BrokenBarrierException</code></li>
</ul>
<h3>4.3 Semaphore：信号量</h3>
<p><strong>语义</strong>：控制同时访问某个资源的线程数量。</p>
<pre><code class="language-java">Semaphore semaphore = new Semaphore(5);  // 最多 5 个并发

executor.submit(() -&gt; {
    semaphore.acquire();    // 获取许可（可用许可 -1）
    try {
        accessResource();
    } finally {
        semaphore.release();  // 释放许可（可用许可 +1）
    }
});
</code></pre>
<p><strong>核心特征</strong>：</p>
<ul>
<li>支持<strong>公平/非公平</strong>模式</li>
<li><code>tryAcquire()</code> 提供非阻塞获取</li>
<li>许可数量可以动态增减（<code>release()</code> 可以在未 <code>acquire()</code> 的情况下调用）</li>
</ul>
<h3>4.4 三者对比</h3>
<table>
<thead>
<tr>
<th>工具</th>
<th>核心语义</th>
<th>是否可重用</th>
<th>计数方向</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CountDownLatch</strong></td>
<td>一个线程等待 N 个线程</td>
<td>否</td>
<td>递减至 0</td>
<td>主线程等待子任务完成</td>
</tr>
<tr>
<td><strong>CyclicBarrier</strong></td>
<td>N 个线程互相等待</td>
<td>是</td>
<td>递增至 N</td>
<td>多阶段并行计算</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>控制并发访问数量</td>
<td>-</td>
<td>许可的获取与释放</td>
<td>限流、资源池</td>
</tr>
</tbody></table>
<h2>五、生产者-消费者模式</h2>
<p>生产者-消费者是并发编程中最经典的协作模式。Java 提供了从底层到高层的多种实现方式。</p>
<h3>5.1 三种实现方式对比</h3>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>同步机制</th>
<th>通知粒度</th>
<th>复杂度</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td>synchronized + wait/notify</td>
<td>内置锁</td>
<td>全量唤醒（notifyAll）</td>
<td>低</td>
<td>一般</td>
</tr>
<tr>
<td>Lock + Condition</td>
<td>显式锁</td>
<td>精确唤醒（signal）</td>
<td>中</td>
<td>推荐</td>
</tr>
<tr>
<td>BlockingQueue</td>
<td>封装在队列内部</td>
<td>内部自动处理</td>
<td>最低</td>
<td>最推荐</td>
</tr>
</tbody></table>
<p><strong>为什么 BlockingQueue 是最佳选择</strong>：</p>
<p><code>BlockingQueue</code> 将同步、等待、通知的逻辑完全封装在 <code>put()</code>/<code>take()</code> 方法内部，调用方无需关心并发细节：</p>
<pre><code class="language-java">BlockingQueue&lt;Task&gt; queue = new ArrayBlockingQueue&lt;&gt;(100);

// 生产者
queue.put(task);   // 队列满时自动阻塞

// 消费者
Task task = queue.take();  // 队列空时自动阻塞
</code></pre>
<h3>5.2 BlockingQueue 的实现选型</h3>
<table>
<thead>
<tr>
<th>实现类</th>
<th>底层结构</th>
<th>是否有界</th>
<th>锁策略</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>数组</td>
<td>有界</td>
<td>单锁</td>
<td>通用场景</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>链表</td>
<td>可选有界</td>
<td>读写分离锁</td>
<td>吞吐量要求高</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>无容量</td>
<td>无</td>
<td>CAS</td>
<td>直接传递（线程池默认）</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>堆</td>
<td>无界</td>
<td>单锁</td>
<td>优先级调度</td>
</tr>
</tbody></table>
<h2>六、线程池</h2>
<h3>6.1 ThreadPoolExecutor 核心参数</h3>
<pre><code class="language-java">new ThreadPoolExecutor(
    corePoolSize,      // 核心线程数
    maximumPoolSize,   // 最大线程数
    keepAliveTime,     // 非核心线程空闲存活时间
    TimeUnit.SECONDS,
    workQueue,         // 任务队列
    threadFactory,     // 线程工厂
    rejectedHandler    // 拒绝策略
);
</code></pre>
<p><strong>任务提交流程</strong>：</p>
<pre><code>提交任务
  → 当前线程数 &lt; corePoolSize？        → 创建核心线程执行
  → 任务队列未满？                      → 入队等待
  → 当前线程数 &lt; maximumPoolSize？      → 创建非核心线程执行
  → 以上都不满足                        → 执行拒绝策略
</code></pre>
<h3>6.2 拒绝策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>行为</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AbortPolicy</strong></td>
<td>抛出 <code>RejectedExecutionException</code></td>
<td>默认策略，适合需要感知过载的场景</td>
</tr>
<tr>
<td><strong>CallerRunsPolicy</strong></td>
<td>由提交线程自己执行任务</td>
<td>反压效果，但可能导致提交线程阻塞</td>
</tr>
<tr>
<td><strong>DiscardPolicy</strong></td>
<td>静默丢弃任务</td>
<td>允许丢失的场景（如日志）</td>
</tr>
<tr>
<td><strong>DiscardOldestPolicy</strong></td>
<td>丢弃队列中最旧的任务</td>
<td>实时性要求高、可接受旧数据丢失</td>
</tr>
</tbody></table>
<h3>6.3 生产阻塞型线程池</h3>
<p>标准 <code>ThreadPoolExecutor</code> 使用 <code>BlockingQueue.offer()</code>（非阻塞）入队。队列满时不会阻塞提交线程，而是触发拒绝策略。</p>
<p>在某些场景下（如需要严格的背压机制），需要让提交线程在队列满时<strong>阻塞等待</strong>而非被拒绝。可通过自定义拒绝策略实现：</p>
<pre><code class="language-java">ThreadPoolExecutor executor = new ThreadPoolExecutor(
    coreSize, maxSize, 60, TimeUnit.SECONDS,
    new LinkedBlockingQueue&lt;&gt;(capacity),
    (runnable, pool) -&gt; {
        try {
            // 队列满时，put() 会阻塞提交线程
            pool.getQueue().put(runnable);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
);
</code></pre>
<p>这种方式的优势在于：复用 <code>ThreadPoolExecutor</code> 的线程管理能力，同时实现了生产者阻塞语义，避免了手工管理线程的复杂性。</p>
<h3>6.4 线程池配置最佳实践</h3>
<table>
<thead>
<tr>
<th>任务类型</th>
<th>核心线程数建议</th>
<th>队列选择</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPU 密集型</strong></td>
<td><code>N_cpu + 1</code></td>
<td>小容量有界队列</td>
</tr>
<tr>
<td><strong>I/O 密集型</strong></td>
<td><code>N_cpu × 2</code> 或更高</td>
<td>较大容量有界队列</td>
</tr>
<tr>
<td><strong>混合型</strong></td>
<td>拆分为 CPU 池和 I/O 池</td>
<td>各自独立配置</td>
</tr>
</tbody></table>
<p>关键原则：</p>
<ul>
<li><strong>永远不要使用无界队列</strong>：<code>Executors.newFixedThreadPool()</code> 默认使用无界的 <code>LinkedBlockingQueue</code>，可能导致 OOM</li>
<li><strong>为线程池命名</strong>：自定义 <code>ThreadFactory</code>，给线程添加有意义的名称前缀，便于排查问题</li>
<li><strong>监控队列深度</strong>：线程池队列持续增长是系统过载的信号</li>
</ul>
<h2>总结</h2>
<p>Java 并发编程的知识体系可以沿着三个层次理解：</p>
<ol>
<li><strong>硬件层</strong>：CPU 缓存、MESI 协议、缓存行伪共享——这是并发问题的物理根源</li>
<li><strong>模型层</strong>：JMM、happens-before、volatile/synchronized 语义——这是 Java 对硬件差异的抽象屏蔽</li>
<li><strong>工具层</strong>：Lock/Condition、CountDownLatch/CyclicBarrier/Semaphore、BlockingQueue、ThreadPoolExecutor——这是面向工程的并发编程基础设施</li>
</ol>
<blockquote>
<p>并发工具的选择不在于功能的强大，而在于语义的匹配。<code>synchronized</code> 足以解决大多数问题；<code>BlockingQueue</code> 比手动的 wait/notify 更安全；标准 <code>ThreadPoolExecutor</code> 比自定义线程管理更可靠。优先选择高层抽象，只在确有需要时才下沉到底层机制。</p>
</blockquote>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/7dd6b3ec14b0b1d8.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"RYcwT440p-zMmPkCFeUuP\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"middleware\",\"Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/middleware/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7dd6b3ec14b0b1d8.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/middleware/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%B0%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"nkcWtwTdAZpb82JpEF5ecv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1a:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T5439,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava并发编程：从内存模型到并发工具的设计哲学\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发编程的核心挑战不在于\u0026quot;如何让多个线程同时跑\u0026quot;，而在于\u0026quot;如何让多个线程正确地协作\u0026quot;。理解 Java 内存模型和并发工具的设计原理，是写出正确并发代码的前提。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e并发编程是 Java 工程师的核心能力之一。它涉及从硬件层面的缓存一致性，到语言层面的内存模型，再到 JUC 工具类的 API 设计，是一个纵深很大的知识领域。\u003c/p\u003e\n\u003cp\u003e本文将从底层原理出发，逐层构建 Java 并发编程的知识体系。\u003c/p\u003e\n\u003ch2\u003e一、硬件基础：CPU 缓存与一致性\u003c/h2\u003e\n\u003ch3\u003e1.1 为什么需要缓存\u003c/h3\u003e\n\u003cp\u003e现代 CPU 的运算速度远超主内存的读写速度（差距约 100 倍）。为了弥补这一差距，CPU 引入了多级缓存（L1/L2/L3 Cache）。每个核心拥有独立的 L1/L2 缓存，L3 缓存为所有核心共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCPU Core 0          CPU Core 1\n┌─────────┐        ┌─────────┐\n│ L1 Cache│        │ L1 Cache│\n│ L2 Cache│        │ L2 Cache│\n└────┬────┘        └────┬────┘\n     └────────┬─────────┘\n         L3 Cache（共享）\n              │\n         主内存（RAM）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓存的引入解决了性能问题，但带来了新问题：\u003cstrong\u003e当多个核心各自缓存了同一块数据的副本，其中一个核心修改了数据，如何保证其他核心看到的是最新值？\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 MESI 缓存一致性协议\u003c/h3\u003e\n\u003cp\u003eMESI 是最广泛采用的缓存一致性协议，每个缓存行处于四种状态之一：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e状态\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e对主内存\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eM（Modified）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心修改了数据，与主内存不一致\u003c/td\u003e\n\u003ctd\u003e需要写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eE（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心独占数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eS（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e多个核心共享数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI（Invalid）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e缓存行无效\u003c/td\u003e\n\u003ctd\u003e需从主内存重新加载\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当 Core 0 修改了处于 S 状态的缓存行时：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCore 0 将缓存行状态改为 M\u003c/li\u003e\n\u003cli\u003e通过总线嗅探（Bus Snooping）通知其他核心\u003c/li\u003e\n\u003cli\u003e其他核心将对应缓存行标记为 I\u003c/li\u003e\n\u003cli\u003e其他核心下次读取该数据时，从 Core 0 的缓存或主内存重新加载\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e1.3 缓存行伪共享（False Sharing）\u003c/h3\u003e\n\u003cp\u003e缓存行是缓存操作的最小单位，大小通常为 \u003cstrong\u003e64 字节\u003c/strong\u003e。如果两个无关的变量恰好落在同一缓存行中，一个变量的修改会导致另一个变量的缓存行也失效——这就是伪共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 伪共享示例：head 和 tail 可能在同一缓存行\nclass Queue {\n    volatile long head;  // 生产者频繁修改\n    volatile long tail;  // 消费者频繁修改\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDoug Lea 在 \u003ccode\u003eLinkedTransferQueue\u003c/code\u003e 中的解决方案——填充字节使变量独占一个缓存行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// JDK 7 中的做法\nclass PaddedAtomicReference\u0026lt;T\u0026gt; extends AtomicReference\u0026lt;T\u0026gt; {\n    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;\n}\n\n// JDK 8+ 可以使用 @Contended 注解\n@sun.misc.Contended\nclass QueueNode {\n    volatile long value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二、Java 内存模型（JMM）\u003c/h2\u003e\n\u003ch3\u003e2.1 JMM 的抽象\u003c/h3\u003e\n\u003cp\u003eJava 内存模型（Java Memory Model）定义了\u003cstrong\u003e多线程如何通过共享内存进行通信\u003c/strong\u003e的规则。它并不描述具体的硬件实现，而是提供了一组抽象的可见性和有序性保证。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程 A 工作内存          线程 B 工作内存\n┌──────────────┐      ┌──────────────┐\n│  变量副本      │      │  变量副本      │\n└──────┬───────┘      └──────┬───────┘\n       │    save/load         │\n       └──────────┬───────────┘\n              主内存\n         ┌──────────────┐\n         │  共享变量      │\n         └──────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJMM 定义了 8 种内存交互操作：lock、unlock、read、load、use、assign、store、write。这些操作的组合规则保证了多线程程序的语义正确性。\u003c/p\u003e\n\u003ch3\u003e2.2 三大并发问题\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e根源\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e可见性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程修改了变量，其他线程看不到最新值\u003c/td\u003e\n\u003ctd\u003eCPU 缓存导致各线程工作内存不一致\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e原子性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一组操作被中断导致中间状态暴露\u003c/td\u003e\n\u003ctd\u003e线程切换导致复合操作被打断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e有序性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e代码执行顺序与编写顺序不一致\u003c/td\u003e\n\u003ctd\u003e编译器优化、CPU 指令重排序\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.3 volatile 的语义与实现\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e 是 Java 中最轻量的同步机制，它提供两个保证：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e可见性\u003c/strong\u003e：对 volatile 变量的写操作对所有线程立即可见\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e有序性\u003c/strong\u003e：禁止指令重排序（通过内存屏障实现）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e但不保证原子性\u003c/strong\u003e：\u003ccode\u003evolatile int count; count++\u003c/code\u003e 并不是线程安全的，因为 \u003ccode\u003ecount++\u003c/code\u003e 是读-改-写三步操作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e硬件级实现\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 x86 架构上，对 volatile 变量的写操作会生成一条带 \u003cstrong\u003eLOCK 前缀\u003c/strong\u003e的指令。LOCK 前缀的作用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将当前处理器缓存行的数据写回主内存\u003c/li\u003e\n\u003cli\u003e使其他处理器中缓存该地址的缓存行失效（通过 MESI 协议）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e// JIT 编译后的汇编（x86）\n0x01a3de24: lock addl $0x0,(%esp)  // LOCK 前缀指令\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 P6 及更新的处理器上，LOCK 不再锁总线，而是\u003cstrong\u003e锁缓存行\u003c/strong\u003e（Cache Locking），性能开销远小于总线锁。\u003c/p\u003e\n\u003ch3\u003e2.4 happens-before 规则\u003c/h3\u003e\n\u003cp\u003eJMM 通过 \u003cstrong\u003ehappens-before\u003c/strong\u003e 关系定义了操作间的可见性保证。如果操作 A happens-before 操作 B，则 A 的结果对 B 可见。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e规则\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e程序顺序规则\u003c/td\u003e\n\u003ctd\u003e同一线程中的操作，前面的 happens-before 后面的\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003evolatile 规则\u003c/td\u003e\n\u003ctd\u003evolatile 写 happens-before 后续的 volatile 读\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁规则\u003c/td\u003e\n\u003ctd\u003eunlock happens-before 后续对同一锁的 lock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e传递性\u003c/td\u003e\n\u003ctd\u003e如果 A hb B，B hb C，则 A hb C\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程启动规则\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eThread.start()\u003c/code\u003e happens-before 该线程的每个动作\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程终止规则\u003c/td\u003e\n\u003ctd\u003e线程的所有动作 happens-before 其他线程检测到该线程终止\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e三、锁机制\u003c/h2\u003e\n\u003ch3\u003e3.1 synchronized vs Lock\u003c/h3\u003e\n\u003cp\u003eJava 提供两种锁机制：内置锁（\u003ccode\u003esynchronized\u003c/code\u003e）和显式锁（\u003ccode\u003ejava.util.concurrent.locks.Lock\u003c/code\u003e）。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003esynchronized\u003c/th\u003e\n\u003cth\u003eLock\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e实现层面\u003c/td\u003e\n\u003ctd\u003eJVM 内置（monitorenter/monitorexit）\u003c/td\u003e\n\u003ctd\u003eJava API 层（基于 AQS）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁获取\u003c/td\u003e\n\u003ctd\u003e阻塞式，不可中断\u003c/td\u003e\n\u003ctd\u003e支持非阻塞 \u003ccode\u003etryLock()\u003c/code\u003e、可中断 \u003ccode\u003elockInterruptibly()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁释放\u003c/td\u003e\n\u003ctd\u003e自动释放（退出同步块）\u003c/td\u003e\n\u003ctd\u003e必须在 \u003ccode\u003efinally\u003c/code\u003e 中手动 \u003ccode\u003eunlock()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e条件等待\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eObject.wait()/notify()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCondition.await()/signal()\u003c/code\u003e，支持多条件队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平性\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eReentrantLock(true)\u003c/code\u003e 支持公平锁\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁状态查询\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eisLocked()\u003c/code\u003e、\u003ccode\u003egetHoldCount()\u003c/code\u003e 等\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e选择原则\u003c/strong\u003e：优先使用 \u003ccode\u003esynchronized\u003c/code\u003e（JVM 持续优化，且不会忘记释放锁）；需要高级特性（超时、中断、多条件、公平性）时选择 \u003ccode\u003eLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e3.2 Condition：精确的线程协作\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCondition\u003c/code\u003e 是 \u003ccode\u003eLock\u003c/code\u003e 的配套组件，它替代了 \u003ccode\u003eObject.wait()/notify()\u003c/code\u003e 机制，最大的优势是\u003cstrong\u003e支持多个等待队列\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 使用 Object 的 wait/notify：只有一个等待队列，notifyAll 会唤醒所有线程\n// 使用 Condition：可以创建多个条件队列，signal 只唤醒特定队列中的线程\n\nReentrantLock lock = new ReentrantLock();\nCondition notFull  = lock.newCondition();  // 生产者等待队列\nCondition notEmpty = lock.newCondition();  // 消费者等待队列\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e有界缓冲区实现\u003c/strong\u003e（经典的生产者-消费者模型）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass BoundedBuffer\u0026lt;E\u0026gt; {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n    final Object[] items = new Object[100];\n    int putIndex, takeIndex, count;\n\n    public void put(E e) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();      // 缓冲区满，生产者等待\n            items[putIndex] = e;\n            if (++putIndex == items.length) putIndex = 0;\n            ++count;\n            notEmpty.signal();        // 通知消费者\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();     // 缓冲区空，消费者等待\n            E e = (E) items[takeIndex];\n            if (++takeIndex == items.length) takeIndex = 0;\n            --count;\n            notFull.signal();         // 通知生产者\n            return e;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意 \u003ccode\u003eawait()\u003c/code\u003e 必须在 \u003ccode\u003ewhile\u003c/code\u003e 循环中调用，以防止\u003cstrong\u003e虚假唤醒（Spurious Wakeup）\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e3.3 ReadWriteLock：读写分离\u003c/h3\u003e\n\u003cp\u003e当读操作远多于写操作时，使用排他锁会严重限制并发度。\u003ccode\u003eReadWriteLock\u003c/code\u003e 允许多个线程同时持有读锁，但写锁是排他的。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁状态\u003c/th\u003e\n\u003cth\u003e读锁请求\u003c/th\u003e\n\u003cth\u003e写锁请求\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e无锁\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读锁已持有\u003c/td\u003e\n\u003ctd\u003e允许（共享）\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写锁已持有\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e 的设计决策：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e写锁可降级为读锁\u003c/strong\u003e：持有写锁的线程可以再获取读锁，然后释放写锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e读锁不可升级为写锁\u003c/strong\u003e：防止死锁（多个读线程同时尝试升级会互相等待）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持公平/非公平模式\u003c/strong\u003e：非公平模式下，读锁可能\u0026quot;插队\u0026quot;导致写线程饥饿\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e四、JUC 并发工具类\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.util.concurrent\u003c/code\u003e 包提供了一组高级同步工具，用于解决常见的线程协调问题。\u003c/p\u003e\n\u003ch3\u003e4.1 CountDownLatch：一次性倒计数门闩\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一个或多个线程等待其他线程完成一组操作后再继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCountDownLatch latch = new CountDownLatch(3);  // 计数器初始值 3\n\n// 工作线程\nexecutor.submit(() -\u0026gt; {\n    doTask();\n    latch.countDown();  // 计数器 -1\n});\n\n// 等待线程\nlatch.await();  // 阻塞直到计数器归零\n// 所有任务完成，继续执行\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e一次性\u003c/strong\u003e：计数器归零后无法重置\u003c/li\u003e\n\u003cli\u003e底层基于 AQS 的共享模式实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e典型场景\u003c/strong\u003e：服务启动时等待所有依赖组件初始化完成。\u003c/p\u003e\n\u003ch3\u003e4.2 CyclicBarrier：可重用的屏障\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一组线程互相等待，直到所有线程都到达屏障点，然后同时继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCyclicBarrier barrier = new CyclicBarrier(3, () -\u0026gt; {\n    System.out.println(\u0026quot;所有线程到齐，开始下一阶段\u0026quot;);  // barrierAction\n});\n\n// 每个工作线程\nexecutor.submit(() -\u0026gt; {\n    doPhase1();\n    barrier.await();  // 等待其他线程\n    doPhase2();\n    barrier.await();  // 可以重复使用\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可重用\u003c/strong\u003e：所有线程通过屏障后，计数器自动重置\u003c/li\u003e\n\u003cli\u003e支持 \u003cstrong\u003ebarrierAction\u003c/strong\u003e：所有线程到齐时执行的回调\u003c/li\u003e\n\u003cli\u003e如果某个线程等待超时或被中断，屏障进入 \u003cstrong\u003eBroken\u003c/strong\u003e 状态，所有等待线程收到 \u003ccode\u003eBrokenBarrierException\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.3 Semaphore：信号量\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：控制同时访问某个资源的线程数量。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSemaphore semaphore = new Semaphore(5);  // 最多 5 个并发\n\nexecutor.submit(() -\u0026gt; {\n    semaphore.acquire();    // 获取许可（可用许可 -1）\n    try {\n        accessResource();\n    } finally {\n        semaphore.release();  // 释放许可（可用许可 +1）\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e支持\u003cstrong\u003e公平/非公平\u003c/strong\u003e模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etryAcquire()\u003c/code\u003e 提供非阻塞获取\u003c/li\u003e\n\u003cli\u003e许可数量可以动态增减（\u003ccode\u003erelease()\u003c/code\u003e 可以在未 \u003ccode\u003eacquire()\u003c/code\u003e 的情况下调用）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.4 三者对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e核心语义\u003c/th\u003e\n\u003cth\u003e是否可重用\u003c/th\u003e\n\u003cth\u003e计数方向\u003c/th\u003e\n\u003cth\u003e典型场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程等待 N 个线程\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e递减至 0\u003c/td\u003e\n\u003ctd\u003e主线程等待子任务完成\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCyclicBarrier\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eN 个线程互相等待\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e递增至 N\u003c/td\u003e\n\u003ctd\u003e多阶段并行计算\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e控制并发访问数量\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003e许可的获取与释放\u003c/td\u003e\n\u003ctd\u003e限流、资源池\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e五、生产者-消费者模式\u003c/h2\u003e\n\u003cp\u003e生产者-消费者是并发编程中最经典的协作模式。Java 提供了从底层到高层的多种实现方式。\u003c/p\u003e\n\u003ch3\u003e5.1 三种实现方式对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现方式\u003c/th\u003e\n\u003cth\u003e同步机制\u003c/th\u003e\n\u003cth\u003e通知粒度\u003c/th\u003e\n\u003cth\u003e复杂度\u003c/th\u003e\n\u003cth\u003e推荐度\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003esynchronized + wait/notify\u003c/td\u003e\n\u003ctd\u003e内置锁\u003c/td\u003e\n\u003ctd\u003e全量唤醒（notifyAll）\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e一般\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eLock + Condition\u003c/td\u003e\n\u003ctd\u003e显式锁\u003c/td\u003e\n\u003ctd\u003e精确唤醒（signal）\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBlockingQueue\u003c/td\u003e\n\u003ctd\u003e封装在队列内部\u003c/td\u003e\n\u003ctd\u003e内部自动处理\u003c/td\u003e\n\u003ctd\u003e最低\u003c/td\u003e\n\u003ctd\u003e最推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e为什么 BlockingQueue 是最佳选择\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBlockingQueue\u003c/code\u003e 将同步、等待、通知的逻辑完全封装在 \u003ccode\u003eput()\u003c/code\u003e/\u003ccode\u003etake()\u003c/code\u003e 方法内部，调用方无需关心并发细节：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eBlockingQueue\u0026lt;Task\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(100);\n\n// 生产者\nqueue.put(task);   // 队列满时自动阻塞\n\n// 消费者\nTask task = queue.take();  // 队列空时自动阻塞\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 BlockingQueue 的实现选型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现类\u003c/th\u003e\n\u003cth\u003e底层结构\u003c/th\u003e\n\u003cth\u003e是否有界\u003c/th\u003e\n\u003cth\u003e锁策略\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eArrayBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e数组\u003c/td\u003e\n\u003ctd\u003e有界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e通用场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e链表\u003c/td\u003e\n\u003ctd\u003e可选有界\u003c/td\u003e\n\u003ctd\u003e读写分离锁\u003c/td\u003e\n\u003ctd\u003e吞吐量要求高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSynchronousQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e无容量\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eCAS\u003c/td\u003e\n\u003ctd\u003e直接传递（线程池默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ePriorityBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e堆\u003c/td\u003e\n\u003ctd\u003e无界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e优先级调度\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e六、线程池\u003c/h2\u003e\n\u003ch3\u003e6.1 ThreadPoolExecutor 核心参数\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ThreadPoolExecutor(\n    corePoolSize,      // 核心线程数\n    maximumPoolSize,   // 最大线程数\n    keepAliveTime,     // 非核心线程空闲存活时间\n    TimeUnit.SECONDS,\n    workQueue,         // 任务队列\n    threadFactory,     // 线程工厂\n    rejectedHandler    // 拒绝策略\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e任务提交流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e提交任务\n  → 当前线程数 \u0026lt; corePoolSize？        → 创建核心线程执行\n  → 任务队列未满？                      → 入队等待\n  → 当前线程数 \u0026lt; maximumPoolSize？      → 创建非核心线程执行\n  → 以上都不满足                        → 执行拒绝策略\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2 拒绝策略\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e策略\u003c/th\u003e\n\u003cth\u003e行为\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eAbortPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e抛出 \u003ccode\u003eRejectedExecutionException\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e默认策略，适合需要感知过载的场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCallerRunsPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e由提交线程自己执行任务\u003c/td\u003e\n\u003ctd\u003e反压效果，但可能导致提交线程阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e静默丢弃任务\u003c/td\u003e\n\u003ctd\u003e允许丢失的场景（如日志）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardOldestPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e丢弃队列中最旧的任务\u003c/td\u003e\n\u003ctd\u003e实时性要求高、可接受旧数据丢失\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e6.3 生产阻塞型线程池\u003c/h3\u003e\n\u003cp\u003e标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 使用 \u003ccode\u003eBlockingQueue.offer()\u003c/code\u003e（非阻塞）入队。队列满时不会阻塞提交线程，而是触发拒绝策略。\u003c/p\u003e\n\u003cp\u003e在某些场景下（如需要严格的背压机制），需要让提交线程在队列满时\u003cstrong\u003e阻塞等待\u003c/strong\u003e而非被拒绝。可通过自定义拒绝策略实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThreadPoolExecutor executor = new ThreadPoolExecutor(\n    coreSize, maxSize, 60, TimeUnit.SECONDS,\n    new LinkedBlockingQueue\u0026lt;\u0026gt;(capacity),\n    (runnable, pool) -\u0026gt; {\n        try {\n            // 队列满时，put() 会阻塞提交线程\n            pool.getQueue().put(runnable);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式的优势在于：复用 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 的线程管理能力，同时实现了生产者阻塞语义，避免了手工管理线程的复杂性。\u003c/p\u003e\n\u003ch3\u003e6.4 线程池配置最佳实践\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e任务类型\u003c/th\u003e\n\u003cth\u003e核心线程数建议\u003c/th\u003e\n\u003cth\u003e队列选择\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCPU 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu + 1\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e小容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI/O 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu × 2\u003c/code\u003e 或更高\u003c/td\u003e\n\u003ctd\u003e较大容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e混合型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e拆分为 CPU 池和 I/O 池\u003c/td\u003e\n\u003ctd\u003e各自独立配置\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e关键原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e永远不要使用无界队列\u003c/strong\u003e：\u003ccode\u003eExecutors.newFixedThreadPool()\u003c/code\u003e 默认使用无界的 \u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e，可能导致 OOM\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e为线程池命名\u003c/strong\u003e：自定义 \u003ccode\u003eThreadFactory\u003c/code\u003e，给线程添加有意义的名称前缀，便于排查问题\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控队列深度\u003c/strong\u003e：线程池队列持续增长是系统过载的信号\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava 并发编程的知识体系可以沿着三个层次理解：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e硬件层\u003c/strong\u003e：CPU 缓存、MESI 协议、缓存行伪共享——这是并发问题的物理根源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模型层\u003c/strong\u003e：JMM、happens-before、volatile/synchronized 语义——这是 Java 对硬件差异的抽象屏蔽\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具层\u003c/strong\u003e：Lock/Condition、CountDownLatch/CyclicBarrier/Semaphore、BlockingQueue、ThreadPoolExecutor——这是面向工程的并发编程基础设施\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发工具的选择不在于功能的强大，而在于语义的匹配。\u003ccode\u003esynchronized\u003c/code\u003e 足以解决大多数问题；\u003ccode\u003eBlockingQueue\u003c/code\u003e 比手动的 wait/notify 更安全；标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 比自定义线程管理更可靠。优先选择高层抽象，只在确有需要时才下沉到底层机制。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"17:T6a92,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e深入理解JVM：从类加载到垃圾回收的全链路剖析\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJava 程序的生命周期始于类加载，终于垃圾回收。理解 JVM 的工作原理，不仅是性能调优的基础，更是理解 Java 语言设计哲学的关键。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eJVM（Java Virtual Machine）是 Java 生态的基石。它屏蔽了底层硬件差异，为 Java 程序提供了一个统一的运行时环境。但这层抽象并非没有代价——内存管理、类加载、即时编译等机制的复杂性，往往是生产环境问题的根源。\u003c/p\u003e\n\u003cp\u003e本文将沿着 Java 程序的执行链路，从类文件的加载、运行时内存的分配，到对象的回收，系统梳理 JVM 的核心机制。\u003c/p\u003e\n\u003ch2\u003e一、类加载机制\u003c/h2\u003e\n\u003ch3\u003e1.1 类的生命周期\u003c/h3\u003e\n\u003cp\u003e一个 Java 类从被加载到 JVM 内存，到最终被卸载，经历以下阶段：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e加载（Loading）→ 验证（Verification）→ 准备（Preparation）\n    → 解析（Resolution）→ 初始化（Initialization）\n        → 使用（Using）→ 卸载（Unloading）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，验证、准备、解析统称为**链接（Linking）**阶段。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003e核心动作\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e加载\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e读取 .class 字节流，生成 Class 对象\u003c/td\u003e\n\u003ctd\u003e由 ClassLoader 执行\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e验证\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e校验字节码的合法性和安全性\u003c/td\u003e\n\u003ctd\u003e文件格式、元数据、字节码、符号引用验证\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e准备\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e为类的静态变量分配内存并赋零值\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003estatic int a = 10\u003c/code\u003e 在此阶段 a = 0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e解析\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e将符号引用替换为直接引用\u003c/td\u003e\n\u003ctd\u003e类、字段、方法、接口方法的解析\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e初始化\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e执行类构造器 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e静态变量赋值和静态代码块的执行\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e1.2 ClassLoader 体系\u003c/h3\u003e\n\u003cp\u003eJVM 内置三层 ClassLoader，形成层级结构：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBootstrap ClassLoader（引导类加载器）\n    ↑ parent\nExtension ClassLoader（扩展类加载器）\n    ↑ parent\nApplication ClassLoader（应用类加载器）\n    ↑ parent\nCustom ClassLoader（自定义类加载器）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eClassLoader\u003c/th\u003e\n\u003cth\u003e实现语言\u003c/th\u003e\n\u003cth\u003e加载路径\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eBootstrap\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eC/C++\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e$JAVA_HOME/lib\u003c/code\u003e（rt.jar 等）\u003c/td\u003e\n\u003ctd\u003eJVM 内部实现，Java 中无法直接引用（返回 null）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eExtension\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e$JAVA_HOME/lib/ext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esun.misc.Launcher$ExtClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eApplication\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003eclasspath\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esun.misc.Launcher$AppClassLoader\u003c/code\u003e，默认的类加载器\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e三者的关系通过 \u003ccode\u003esun.misc.Launcher\u003c/code\u003e 的构造函数建立：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Launcher() {\n    // 1. 创建 ExtClassLoader\n    ExtClassLoader extClassLoader = ExtClassLoader.getExtClassLoader();\n    // 2. 创建 AppClassLoader，parent 设为 ExtClassLoader\n    AppClassLoader appClassLoader = AppClassLoader.getAppClassLoader(extClassLoader);\n    // 3. 设置线程上下文类加载器为 AppClassLoader\n    Thread.currentThread().setContextClassLoader(appClassLoader);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1.3 双亲委派模型\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e核心规则\u003c/strong\u003e：当一个 ClassLoader 收到类加载请求时，首先将请求委派给父加载器处理，只有当父加载器无法完成加载时，才由自身尝试加载。\u003c/p\u003e\n\u003cp\u003e执行流程（\u003ccode\u003eClassLoader.loadClass()\u003c/code\u003e 源码逻辑）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) {\n    // 1. 检查类是否已被加载\n    Class\u0026lt;?\u0026gt; c = findLoadedClass(name);\n    if (c == null) {\n        try {\n            // 2. 委派给父加载器\n            if (parent != null) {\n                c = parent.loadClass(name, false);\n            } else {\n                // parent 为 null 表示委派给 Bootstrap\n                c = findBootstrapClassOrNull(name);\n            }\n        } catch (ClassNotFoundException e) {\n            // 父加载器无法加载\n        }\n        if (c == null) {\n            // 3. 父加载器无法加载，自行加载\n            c = findClass(name);\n        }\n    }\n    return c;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e双亲委派的价值\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e安全性\u003c/strong\u003e：防止核心类库被篡改。即使自定义了一个 \u003ccode\u003ejava.lang.String\u003c/code\u003e，也不会被加载，因为 Bootstrap ClassLoader 会优先加载 rt.jar 中的版本\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e唯一性\u003c/strong\u003e：同一个类在 JVM 中只会被加载一次，避免类的重复加载\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e1.4 打破双亲委派\u003c/h3\u003e\n\u003cp\u003e双亲委派并非不可逾越。以下场景需要打破这一模型：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e场景一：SPI 机制\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJava SPI（Service Provider Interface）的典型问题：核心接口由 Bootstrap ClassLoader 加载（如 \u003ccode\u003ejava.sql.Driver\u003c/code\u003e），但实现类在应用 classpath 下（如 MySQL 驱动），Bootstrap 无法向下委派。\u003c/p\u003e\n\u003cp\u003e解决方案：\u003cstrong\u003e线程上下文类加载器（Thread Context ClassLoader）\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// JDBC DriverManager 的实现\nServiceLoader\u0026lt;Driver\u0026gt; loadedDrivers = ServiceLoader.load(Driver.class);\n// ServiceLoader.load() 内部使用 Thread.currentThread().getContextClassLoader()\n// 从而绕过了双亲委派，用 AppClassLoader 加载 SPI 实现类\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e场景二：热部署\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOSGi、Tomcat 等容器需要实现类的热替换。Tomcat 为每个 Web 应用创建独立的 ClassLoader（\u003ccode\u003eWebAppClassLoader\u003c/code\u003e），它优先从自身路径加载类，找不到才委派给父加载器——这与双亲委派的顺序恰好相反。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e场景三：自定义 ClassLoader\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e通过重写 \u003ccode\u003efindClass()\u003c/code\u003e 方法实现自定义加载逻辑，如从网络加载、加密 class 文件的解密加载等：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class EncryptedClassLoader extends ClassLoader {\n    @Override\n    protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException {\n        byte[] encrypted = loadBytesFromDisk(name);\n        byte[] decrypted = decrypt(encrypted);  // 解密 class 字节码\n        return defineClass(name, decrypted, 0, decrypted.length);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二、运行时内存模型\u003c/h2\u003e\n\u003ch3\u003e2.1 内存区域划分\u003c/h3\u003e\n\u003cp\u003eJVM 运行时内存分为线程私有和线程共享两大类：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌─────────────────── JVM 内存 ───────────────────────┐\n│                                                      │\n│  线程私有                    线程共享                   │\n│  ┌──────────────────┐      ┌────────────────────┐   │\n│  │ 程序计数器（PC）    │      │       堆（Heap）     │   │\n│  │ 虚拟机栈（Stack）   │      │  ┌──────────────┐  │   │\n│  │ 本地方法栈         │      │  │  新生代        │  │   │\n│  └──────────────────┘      │  │  Eden + S0/S1 │  │   │\n│                             │  ├──────────────┤  │   │\n│                             │  │  老年代        │  │   │\n│                             │  └──────────────┘  │   │\n│                             ├────────────────────┤   │\n│                             │  元空间（Metaspace）  │   │\n│                             │  （本地内存）          │   │\n│                             └────────────────────┘   │\n└──────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e区域\u003c/th\u003e\n\u003cth\u003e线程属性\u003c/th\u003e\n\u003cth\u003e存储内容\u003c/th\u003e\n\u003cth\u003e异常\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e程序计数器\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e私有\u003c/td\u003e\n\u003ctd\u003e当前线程执行的字节码行号\u003c/td\u003e\n\u003ctd\u003e唯一不会 OOM 的区域\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e虚拟机栈\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e私有\u003c/td\u003e\n\u003ctd\u003e栈帧（局部变量表、操作数栈、方法返回地址）\u003c/td\u003e\n\u003ctd\u003eStackOverflowError / OOM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e本地方法栈\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e私有\u003c/td\u003e\n\u003ctd\u003eNative 方法调用的栈帧\u003c/td\u003e\n\u003ctd\u003eStackOverflowError / OOM\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e堆\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e对象实例和数组\u003c/td\u003e\n\u003ctd\u003eOutOfMemoryError: Java heap space\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e元空间\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e类元数据、方法字节码、常量池\u003c/td\u003e\n\u003ctd\u003eOutOfMemoryError: Metaspace\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.2 从 PermGen 到 Metaspace\u003c/h3\u003e\n\u003cp\u003eJava 8 是 JVM 内存模型的一个重要分水岭——\u003cstrong\u003e永久代（PermGen）被元空间（Metaspace）取代\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e永久代的问题\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e大小固定（默认 64MB，\u003ccode\u003e-XX:MaxPermSize\u003c/code\u003e），难以预估合理值\u003c/li\u003e\n\u003cli\u003e类元数据与普通 Java 对象混在同一 GC 管理体系中，增加了 Full GC 的复杂度\u003c/li\u003e\n\u003cli\u003e动态生成类（如大量使用反射、动态代理）容易触发 \u003ccode\u003ejava.lang.OutOfMemoryError: PermGen space\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e元空间的设计\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003ePermGen（Java 7-）\u003c/th\u003e\n\u003cth\u003eMetaspace（Java 8+）\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e存储位置\u003c/td\u003e\n\u003ctd\u003eJVM 堆内\u003c/td\u003e\n\u003ctd\u003e本地内存（Native Memory）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e默认大小\u003c/td\u003e\n\u003ctd\u003e固定（64MB）\u003c/td\u003e\n\u003ctd\u003e无上限（受物理内存限制）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e内存分配\u003c/td\u003e\n\u003ctd\u003e与堆对象相同的 GC 管理\u003c/td\u003e\n\u003ctd\u003e每个 ClassLoader 独立分配，线性分配\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e回收策略\u003c/td\u003e\n\u003ctd\u003eFull GC 触发\u003c/td\u003e\n\u003ctd\u003eClassLoader 被回收时，整块释放\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e调优参数\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxPermSize\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxMetaspaceSize\u003c/code\u003e、\u003ccode\u003e-XX:MetaspaceSize\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e元空间的内存模型\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e每个 ClassLoader 拥有独立的内存块（chunk）。加载新类时，从当前 chunk 中线性分配空间。当 ClassLoader 被 GC 回收时，其对应的所有 chunk 一次性释放——不存在单个类的逐一回收。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eClassLoader A → [chunk1: Class1 Class2 Class3]\nClassLoader B → [chunk2: Class4 Class5]\nClassLoader C → [chunk3: Class6]\n\n当 ClassLoader B 被 GC → chunk2 整块释放\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e压缩类指针空间（Compressed Class Space）\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 64 位 JVM 上，如果开启了压缩类指针（\u003ccode\u003e-XX:+UseCompressedClassPointers\u003c/code\u003e，默认开启），Metaspace 中的 \u003ccode\u003eInstanceKlass\u003c/code\u003e、\u003ccode\u003eArrayKlass\u003c/code\u003e 及虚方法表会存储在一块独立的内存区域中。该区域大小通过 \u003ccode\u003e-XX:CompressedClassSpaceSize\u003c/code\u003e 控制（默认 1GB）。\u003c/p\u003e\n\u003ch3\u003e2.3 对象的内存布局\u003c/h3\u003e\n\u003cp\u003e一个 Java 对象在堆中的内存布局由三部分组成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌────────────────────────────────────┐\n│          对象头（Header）             │\n│  ┌──────────────────────────────┐  │\n│  │ Mark Word（标记字）             │  │  → 哈希码、GC 年龄、锁标志位\n│  │ Klass Pointer（类型指针）       │  │  → 指向元空间中的 Class 元数据\n│  │ Array Length（仅数组对象）       │  │\n│  └──────────────────────────────┘  │\n├────────────────────────────────────┤\n│          实例数据（Instance Data）    │  → 字段值（含父类字段）\n├────────────────────────────────────┤\n│          对齐填充（Padding）          │  → 补齐到 8 字节的整数倍\n└────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eMark Word 的结构\u003c/strong\u003e（64 位 JVM）：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁状态\u003c/th\u003e\n\u003cth\u003e存储内容\u003c/th\u003e\n\u003cth\u003e标志位\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e无锁\u003c/td\u003e\n\u003ctd\u003e对象哈希码（31bit）、GC 分代年龄（4bit）\u003c/td\u003e\n\u003ctd\u003e01\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e偏向锁\u003c/td\u003e\n\u003ctd\u003e线程 ID（54bit）、Epoch（2bit）、GC 年龄\u003c/td\u003e\n\u003ctd\u003e01\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e轻量级锁\u003c/td\u003e\n\u003ctd\u003e指向栈中锁记录的指针\u003c/td\u003e\n\u003ctd\u003e00\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e重量级锁\u003c/td\u003e\n\u003ctd\u003e指向 Monitor 的指针\u003c/td\u003e\n\u003ctd\u003e10\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGC 标记\u003c/td\u003e\n\u003ctd\u003e空\u003c/td\u003e\n\u003ctd\u003e11\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e注意：GC 分代年龄占 \u003cstrong\u003e4 bit\u003c/strong\u003e，最大值为 15。这就是为什么对象晋升老年代的默认阈值 \u003ccode\u003e-XX:MaxTenuringThreshold\u003c/code\u003e 不能超过 15。\u003c/p\u003e\n\u003ch2\u003e三、垃圾回收\u003c/h2\u003e\n\u003ch3\u003e3.1 对象存活判定\u003c/h3\u003e\n\u003cp\u003e在回收内存之前，JVM 首先需要判断哪些对象是\u0026quot;活\u0026quot;的，哪些是\u0026quot;死\u0026quot;的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e引用计数法\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e每个对象维护一个引用计数器：被引用时加 1，引用失效时减 1。计数为 0 的对象即可回收。\u003c/p\u003e\n\u003cp\u003e优点：实现简单，判定效率高。\u003cbr\u003e缺陷：\u003cstrong\u003e无法解决循环引用问题\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// A 和 B 互相引用，但外部已无法访问\n// 引用计数永远不为 0，无法被回收\nObject a = new Object();  // a.refCount = 1\nObject b = new Object();  // b.refCount = 1\na.field = b;              // b.refCount = 2\nb.field = a;              // a.refCount = 2\na = null;                 // a.refCount = 1（仍不为 0）\nb = null;                 // b.refCount = 1（仍不为 0）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e可达性分析（Reachability Analysis）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eJVM 实际采用的方案。从一组称为 \u003cstrong\u003eGC Roots\u003c/strong\u003e 的根对象出发，沿引用链向下遍历。不在任何引用链上的对象即为不可达，判定为垃圾。\u003c/p\u003e\n\u003cp\u003eGC Roots 包括：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eGC Root 类型\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e虚拟机栈中的局部变量\u003c/td\u003e\n\u003ctd\u003e方法正在执行时，栈帧中引用的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e方法区中的静态变量\u003c/td\u003e\n\u003ctd\u003e类的 \u003ccode\u003estatic\u003c/code\u003e 字段引用的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e方法区中的常量\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003estatic final\u003c/code\u003e 引用的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eJNI 引用\u003c/td\u003e\n\u003ctd\u003eNative 方法持有的对象引用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e活跃线程\u003c/td\u003e\n\u003ctd\u003e所有存活的 Thread 对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e同步锁持有的对象\u003c/td\u003e\n\u003ctd\u003e被 \u003ccode\u003esynchronized\u003c/code\u003e 锁定的对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e3.2 安全点与 Stop-The-World\u003c/h3\u003e\n\u003cp\u003eGC 在执行可达性分析时，需要确保对象引用关系不会发生变化，因此必须暂停所有应用线程——即 \u003cstrong\u003eStop-The-World（STW）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e但并非任何时刻都可以暂停线程。线程只有运行到**安全点（Safepoint）**时才能暂停。安全点通常设置在：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方法调用处\u003c/li\u003e\n\u003cli\u003e循环的回边（back edge）\u003c/li\u003e\n\u003cli\u003e异常抛出处\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eJVM 使用\u003cstrong\u003e主动式中断\u003c/strong\u003e：GC 需要 STW 时，设置一个全局标志，各线程在安全点检查该标志，发现需要暂停则主动挂起。\u003c/p\u003e\n\u003ch3\u003e3.3 GC 算法\u003c/h3\u003e\n\u003cp\u003e四种基础 GC 算法，各有适用场景：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e标记-清除（Mark-Sweep）\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e标记阶段：从 GC Roots 遍历，标记所有存活对象\n清除阶段：遍历堆，回收未标记的对象\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e优点：实现简单\u003c/li\u003e\n\u003cli\u003e缺点：产生内存碎片，分配大对象时可能找不到连续空间\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e标记-整理（Mark-Compact）\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e标记阶段：同标记-清除\n整理阶段：将所有存活对象向内存一端移动，然后清理边界外的空间\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e优点：无内存碎片\u003c/li\u003e\n\u003cli\u003e缺点：移动对象开销大，STW 时间更长\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e复制算法（Copying）\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e将内存分为两块：对象空间和空闲空间\nGC 时将存活对象从对象空间复制到空闲空间，然后清空整个对象空间\n两块空间角色互换\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e优点：无碎片、分配高效（指针碰撞）\u003c/li\u003e\n\u003cli\u003e缺点：可用内存减半\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e分代收集（Generational Collection）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e基于\u0026quot;大多数对象朝生夕灭\u0026quot;的统计假设，将堆划分为新生代和老年代，针对不同代的特征选择不同算法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e新生代（Young Generation）：Eden : S0 : S1 = 8 : 1 : 1\n    → 对象存活率低，使用复制算法\n\n老年代（Old Generation）：\n    → 对象存活率高，使用标记-清除或标记-整理算法\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e新生代 GC（Minor GC）流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1. 新对象分配在 Eden 区\n2. Eden 满触发 Minor GC\n3. 存活对象复制到 S0（Survivor From）\n4. 下一次 Minor GC，Eden + S0 的存活对象复制到 S1，清空 Eden + S0\n5. S0 和 S1 角色交换\n6. 对象每经历一次 Minor GC，年龄 +1\n7. 年龄达到阈值（默认 15）的对象晋升老年代\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e对象直接进入老年代的条件\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e大对象（超过 \u003ccode\u003e-XX:PretenureSizeThreshold\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e长期存活对象（年龄超过阈值）\u003c/li\u003e\n\u003cli\u003eSurvivor 空间中相同年龄对象总大小超过 Survivor 一半（动态年龄判定）\u003c/li\u003e\n\u003cli\u003eMinor GC 后 Survivor 放不下的存活对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.4 垃圾收集器\u003c/h3\u003e\n\u003cp\u003eJVM 提供了多种垃圾收集器，分为新生代和老年代两组，可以组合使用：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e收集器\u003c/th\u003e\n\u003cth\u003e分代\u003c/th\u003e\n\u003cth\u003e算法\u003c/th\u003e\n\u003cth\u003e线程\u003c/th\u003e\n\u003cth\u003e特点\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSerial\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新生代\u003c/td\u003e\n\u003ctd\u003e复制\u003c/td\u003e\n\u003ctd\u003e单线程\u003c/td\u003e\n\u003ctd\u003e简单高效，适合单核或小堆\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParNew\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新生代\u003c/td\u003e\n\u003ctd\u003e复制\u003c/td\u003e\n\u003ctd\u003e多线程\u003c/td\u003e\n\u003ctd\u003eSerial 的多线程版本，能与 CMS 配合\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParallel Scavenge\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新生代\u003c/td\u003e\n\u003ctd\u003e复制\u003c/td\u003e\n\u003ctd\u003e多线程\u003c/td\u003e\n\u003ctd\u003e以吞吐量为目标，支持自适应调节\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSerial Old\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代\u003c/td\u003e\n\u003ctd\u003e标记-整理\u003c/td\u003e\n\u003ctd\u003e单线程\u003c/td\u003e\n\u003ctd\u003eSerial 的老年代版本\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParallel Old\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代\u003c/td\u003e\n\u003ctd\u003e标记-整理\u003c/td\u003e\n\u003ctd\u003e多线程\u003c/td\u003e\n\u003ctd\u003eParallel Scavenge 的老年代搭档\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCMS\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代\u003c/td\u003e\n\u003ctd\u003e标记-清除\u003c/td\u003e\n\u003ctd\u003e并发\u003c/td\u003e\n\u003ctd\u003e以最短停顿为目标\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eG1\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e整堆\u003c/td\u003e\n\u003ctd\u003e分区 + 复制/整理\u003c/td\u003e\n\u003ctd\u003e并发\u003c/td\u003e\n\u003ctd\u003e可预测停顿时间，JDK 9 默认\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eCMS（Concurrent Mark Sweep）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eCMS 的设计目标是\u003cstrong\u003e最短回收停顿时间\u003c/strong\u003e。它采用标记-清除算法，GC 过程分为四个阶段：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003eSTW\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e初始标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e仅标记 GC Roots 直接关联的对象，速度很快\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发标记\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e从初始标记的对象出发，遍历整个对象图\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e重新标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e修正并发标记期间因程序运行产生的引用变动\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发清除\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e清除不可达对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eCMS 的两次 STW 都很短暂，绝大部分工作与应用线程并发执行。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCMS 的局限\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCPU 敏感\u003c/strong\u003e：并发阶段占用 CPU 资源，核心数少时影响应用吞吐\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e浮动垃圾\u003c/strong\u003e：并发清除阶段新产生的垃圾只能等下次 GC\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e内存碎片\u003c/strong\u003e：标记-清除算法的固有问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eG1（Garbage-First）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eG1 是 JDK 9 开始的默认收集器，它将堆划分为多个大小相等的 \u003cstrong\u003eRegion\u003c/strong\u003e（默认 2048 个），每个 Region 可以动态充当 Eden、Survivor 或 Old 区。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌────┬────┬────┬────┬────┬────┬────┬────┐\n│  E │  E │  S │  O │  O │  H │  E │  O │\n└────┴────┴────┴────┴────┴────┴────┴────┘\nE = Eden    S = Survivor    O = Old    H = Humongous\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eG1 的核心优势：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e可预测的停顿\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e通过 \u003ccode\u003e-XX:MaxGCPauseMillis\u003c/code\u003e 设定目标停顿时间，G1 优先回收收益最大的 Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e无内存碎片\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eRegion 间使用复制算法，Region 内使用标记-整理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e大对象处理\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e超过 Region 50% 的大对象分配在 Humongous Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e混合回收\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eMixed GC 同时回收新生代和部分老年代 Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eG1 的 GC 过程：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003eSTW\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e初始标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e标记 GC Roots 直接关联对象（借助 Minor GC 完成）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发标记\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e遍历对象图，标记存活对象\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e最终标记\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e处理并发阶段遗留的 SATB（Snapshot-At-The-Beginning）记录\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e筛选回收\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e按回收收益排序 Region，将存活对象复制到空 Region\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e3.5 收集器选型决策\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e场景\u003c/th\u003e\n\u003cth\u003e推荐收集器\u003c/th\u003e\n\u003cth\u003e关键参数\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e单核 / 小堆（\u0026lt; 1GB）\u003c/td\u003e\n\u003ctd\u003eSerial + Serial Old\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseSerialGC\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多核 / 吞吐量优先\u003c/td\u003e\n\u003ctd\u003eParallel Scavenge + Parallel Old\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseParallelGC\u003c/code\u003e（JDK 8 默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多核 / 延迟敏感\u003c/td\u003e\n\u003ctd\u003eParNew + CMS\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseConcMarkSweepGC\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e大堆（\u0026gt; 4GB）/ 延迟可控\u003c/td\u003e\n\u003ctd\u003eG1\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseG1GC\u003c/code\u003e（JDK 9+ 默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e超大堆 / 超低延迟\u003c/td\u003e\n\u003ctd\u003eZGC / Shenandoah\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:+UseZGC\u003c/code\u003e（JDK 11+）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e四、JVM 调优实践\u003c/h2\u003e\n\u003ch3\u003e4.1 关键调优参数\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e参数\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e建议\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xms\u003c/code\u003e / \u003ccode\u003e-Xmx\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e堆初始/最大大小\u003c/td\u003e\n\u003ctd\u003e设为相同值，避免运行时动态扩容\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xmn\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e新生代大小\u003c/td\u003e\n\u003ctd\u003e通常为堆的 1/3 到 1/2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MetaspaceSize\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eMetaspace 初始高水位线\u003c/td\u003e\n\u003ctd\u003e根据类加载量设定，避免启动时频繁 Full GC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxMetaspaceSize\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eMetaspace 上限\u003c/td\u003e\n\u003ctd\u003e建议设定上限，防止内存泄漏耗尽系统内存\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:SurvivorRatio\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eEden 与 Survivor 的比例\u003c/td\u003e\n\u003ctd\u003e默认 8:1:1，一般无需调整\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxTenuringThreshold\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e晋升老年代的年龄阈值\u003c/td\u003e\n\u003ctd\u003e默认 15，最大 15（4 bit 限制）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-XX:MaxGCPauseMillis\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eG1 目标停顿时间\u003c/td\u003e\n\u003ctd\u003e默认 200ms，根据业务 SLA 设定\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e4.2 常见问题与排查\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e表现\u003c/th\u003e\n\u003cth\u003e排查方向\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e频繁 Full GC\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e老年代频繁被填满\u003c/td\u003e\n\u003ctd\u003e检查大对象分配、内存泄漏、Metaspace 增长\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e长时间 STW\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e应用周期性卡顿\u003c/td\u003e\n\u003ctd\u003eGC 日志分析、考虑切换为 G1/ZGC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOOM: Java heap space\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e堆内存不足\u003c/td\u003e\n\u003ctd\u003e堆转储分析（\u003ccode\u003ejmap -dump\u003c/code\u003e）、排查内存泄漏\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOOM: Metaspace\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e类元数据空间耗尽\u003c/td\u003e\n\u003ctd\u003e排查动态类生成（反射、CGLIB 代理）是否失控\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eOOM: GC overhead limit\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eGC 耗时超过 98% 但回收不到 2% 内存\u003c/td\u003e\n\u003ctd\u003e通常是内存泄漏的征兆\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e4.3 监控工具\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e用途\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejstat -gc\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e实时查看 GC 统计（各代容量、GC 次数和耗时）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejmap -heap\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e查看堆内存使用概况\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejmap -dump\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e导出堆转储文件（配合 MAT / VisualVM 分析）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejstack\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e导出线程快照（排查死锁、线程阻塞）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ejcmd GC.class_stats\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e查看类元数据统计（替代 \u003ccode\u003ejmap -permstat\u003c/code\u003e）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGC 日志\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e-Xlog:gc*\u003c/code\u003e（JDK 9+）/ \u003ccode\u003e-XX:+PrintGCDetails\u003c/code\u003e（JDK 8）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJVM 的三大核心机制——类加载、内存管理、垃圾回收——构成了 Java 程序运行的底层基石：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e类加载的双亲委派模型\u003c/strong\u003e保证了类的安全性和唯一性，但 SPI、热部署等场景需要理解如何合理打破它\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从 PermGen 到 Metaspace 的演进\u003c/strong\u003e反映了 JVM 设计从\u0026quot;固定分配\u0026quot;到\u0026quot;弹性管理\u0026quot;的思路转变\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGC 收集器的选型\u003c/strong\u003e没有最优解，只有最匹配的方案——吞吐量优先选 Parallel，延迟敏感选 CMS/G1/ZGC\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e理解 JVM 的意义不在于记住每个参数的默认值，而在于建立\u0026quot;代码行为 → JVM 行为 → 系统表现\u0026quot;的因果链，从而在生产问题出现时，能够从现象追溯到根因。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"18:T4726,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava I/O模型演进：从BIO到NIO的范式变革\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJava I/O 体系经历了从 BIO 到 NIO 再到 AIO 的演进。这不仅仅是 API 的更替，更是从\u0026quot;流式阻塞\u0026quot;到\u0026quot;缓冲区+事件驱动\u0026quot;的编程范式变革。理解这一变革的底层逻辑，是构建高性能网络应用的基础。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e一、传统 I/O（BIO）\u003c/h2\u003e\n\u003ch3\u003e1.1 流模型\u003c/h3\u003e\n\u003cp\u003eJava 传统 I/O 基于**流（Stream）**的抽象。数据像水流一样，从源端流向目的端，一次处理一个字节或一个字符。\u003c/p\u003e\n\u003cp\u003e流的分类体系：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003e分类\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e方向\u003c/td\u003e\n\u003ctd\u003eInputStream / OutputStream\u003c/td\u003e\n\u003ctd\u003e输入流 / 输出流\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据单位\u003c/td\u003e\n\u003ctd\u003e字节流 / 字符流\u003c/td\u003e\n\u003ctd\u003e二进制数据用字节流，文本数据用字符流\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e处理层级\u003c/td\u003e\n\u003ctd\u003e节点流 / 处理流\u003c/td\u003e\n\u003ctd\u003e节点流直连数据源，处理流包装节点流增加功能\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e四个基础抽象类：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e字节流：InputStream  → FileInputStream, ByteArrayInputStream, ...\n       OutputStream → FileOutputStream, ByteArrayOutputStream, ...\n\n字符流：Reader → FileReader, InputStreamReader, BufferedReader, ...\n       Writer → FileWriter, OutputStreamWriter, BufferedWriter, ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1.2 装饰器模式\u003c/h3\u003e\n\u003cp\u003eJava I/O 的设计大量使用\u003cstrong\u003e装饰器模式（Decorator Pattern）\u003c/strong\u003e——通过包装已有流来增加功能，而非通过继承。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 裸的文件字节流 → 加缓冲 → 转字符流 → 加行读取\nInputStream fis = new FileInputStream(\u0026quot;data.txt\u0026quot;);         // 节点流\nInputStream bis = new BufferedInputStream(fis);             // +缓冲\nReader isr = new InputStreamReader(bis, \u0026quot;UTF-8\u0026quot;);           // +字节→字符转换\nBufferedReader br = new BufferedReader(isr);                // +行读取\n\nString line;\nwhile ((line = br.readLine()) != null) {\n    process(line);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInputStreamReader\u003c/code\u003e 和 \u003ccode\u003eOutputStreamWriter\u003c/code\u003e 是字节流与字符流之间的\u003cstrong\u003e桥接类\u003c/strong\u003e，负责字符编码的转换。\u003c/p\u003e\n\u003ch3\u003e1.3 BIO 的网络模型\u003c/h3\u003e\n\u003cp\u003eBIO 的网络编程采用\u003cstrong\u003e一连接一线程\u003c/strong\u003e模型：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eServerSocket serverSocket = new ServerSocket(8080);\nwhile (true) {\n    Socket socket = serverSocket.accept();  // 阻塞等待连接\n    new Thread(() -\u0026gt; {\n        InputStream in = socket.getInputStream();\n        int data = in.read();  // 阻塞等待数据\n        // 处理数据...\n    }).start();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e客户端 1 ──→ 线程 1（阻塞读取）\n客户端 2 ──→ 线程 2（阻塞读取）\n客户端 3 ──→ 线程 3（阻塞读取）\n...\n客户端 N ──→ 线程 N（阻塞读取）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBIO 的瓶颈\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e线程资源浪费\u003c/td\u003e\n\u003ctd\u003e每个连接占用一个线程，大量连接 = 大量线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程上下文切换\u003c/td\u003e\n\u003ctd\u003e线程数过多时，CPU 花费大量时间在线程切换上\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e不可扩展\u003c/td\u003e\n\u003ctd\u003e受限于 OS 线程数上限，无法支撑万级连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e阻塞等待\u003c/td\u003e\n\u003ctd\u003e线程在 \u003ccode\u003eread()\u003c/code\u003e 时阻塞，即使没有数据也占用线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当连接数达到数千级别时，BIO 模型基本无法满足性能要求。\u003c/p\u003e\n\u003ch2\u003e二、NIO 核心模型\u003c/h2\u003e\n\u003cp\u003eJava NIO（New I/O，JDK 1.4 引入）从根本上改变了 I/O 编程模型。其核心变革是：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003eBIO\u003c/th\u003e\n\u003cth\u003eNIO\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e数据操作对象\u003c/td\u003e\n\u003ctd\u003eStream（流）\u003c/td\u003e\n\u003ctd\u003eBuffer（缓冲区）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据读写方式\u003c/td\u003e\n\u003ctd\u003e面向流，单向\u003c/td\u003e\n\u003ctd\u003e面向缓冲区，通过 Channel 双向\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e阻塞模式\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e支持非阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多路复用\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eSelector（一个线程管理多个 Channel）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.1 Buffer（缓冲区）\u003c/h3\u003e\n\u003cp\u003eBuffer 是 NIO 的数据容器。所有数据的读写都通过 Buffer 进行——Channel 读数据写入 Buffer，Channel 写数据从 Buffer 读取。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e核心属性\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e约束关系\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003ecapacity\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e缓冲区总容量\u003c/td\u003e\n\u003ctd\u003e创建后不可变\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eposition\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前读/写位置\u003c/td\u003e\n\u003ctd\u003e0 ≤ position ≤ limit\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003elimit\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e可读/写的上限\u003c/td\u003e\n\u003ctd\u003eposition ≤ limit ≤ capacity\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003emark\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e标记位置，供 reset 回退\u003c/td\u003e\n\u003ctd\u003emark ≤ position\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e读写模式切换\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e写模式（初始状态）：\n  position = 写入位置\n  limit = capacity\n\n    ┌─────────────────────────────────────┐\n    │ data data data |                     │\n    └─────────────────────────────────────┘\n    0              pos                   cap/lim\n\n调用 flip() 切换到读模式：\n  limit = position（写了多少就能读多少）\n  position = 0\n\n    ┌─────────────────────────────────────┐\n    │ data data data |                     │\n    └─────────────────────────────────────┘\n    0/pos          lim                   cap\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e关键操作\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003cth\u003eposition\u003c/th\u003e\n\u003cth\u003elimit\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eflip()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e写模式 → 读模式\u003c/td\u003e\n\u003ctd\u003e→ 0\u003c/td\u003e\n\u003ctd\u003e→ 原 position\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eclear()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e清空缓冲区（不擦数据）\u003c/td\u003e\n\u003ctd\u003e→ 0\u003c/td\u003e\n\u003ctd\u003e→ capacity\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecompact()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e压缩：未读数据移到头部\u003c/td\u003e\n\u003ctd\u003e→ 剩余数据之后\u003c/td\u003e\n\u003ctd\u003e→ capacity\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003erewind()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e重新读取\u003c/td\u003e\n\u003ctd\u003e→ 0\u003c/td\u003e\n\u003ctd\u003e不变\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003emark()\u003c/code\u003e / \u003ccode\u003ereset()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e标记 / 回退到标记位\u003c/td\u003e\n\u003ctd\u003ereset 时 → mark\u003c/td\u003e\n\u003ctd\u003e不变\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.2 Channel（通道）\u003c/h3\u003e\n\u003cp\u003eChannel 是 NIO 中数据传输的通道。与 Stream 的区别：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003eStream\u003c/th\u003e\n\u003cth\u003eChannel\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e方向\u003c/td\u003e\n\u003ctd\u003e单向（InputStream 或 OutputStream）\u003c/td\u003e\n\u003ctd\u003e双向（可读可写）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e始终阻塞\u003c/td\u003e\n\u003ctd\u003e支持非阻塞模式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据交互\u003c/td\u003e\n\u003ctd\u003e直接读写字节/字符\u003c/td\u003e\n\u003ctd\u003e必须通过 Buffer\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e零拷贝\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003etransferTo()\u003c/code\u003e/\u003ccode\u003etransferFrom()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e主要实现类\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eChannel\u003c/th\u003e\n\u003cth\u003e用途\u003c/th\u003e\n\u003cth\u003e支持非阻塞\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eFileChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e文件读写\u003c/td\u003e\n\u003ctd\u003e否（文件 I/O 不支持非阻塞）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSocketChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTCP 客户端\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eServerSocketChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTCP 服务端\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eDatagramChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eUDP\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eChannel 间直接传输\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 零拷贝：数据不经过用户空间，直接在内核中从源 Channel 传到目标 Channel\nFileChannel source = new FileInputStream(\u0026quot;source.dat\u0026quot;).getChannel();\nFileChannel target = new FileOutputStream(\u0026quot;target.dat\u0026quot;).getChannel();\nsource.transferTo(0, source.size(), target);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.3 Scatter / Gather\u003c/h3\u003e\n\u003cp\u003eNIO 支持将数据分散读取到多个 Buffer（Scatter）或从多个 Buffer 聚集写入一个 Channel（Gather）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Scatter Read：一次读取分散到多个 Buffer\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body   = ByteBuffer.allocate(1024);\nchannel.read(new ByteBuffer[]{header, body});\n// 先填满 header，再填 body\n\n// Gather Write：多个 Buffer 的数据聚集写入一个 Channel\nchannel.write(new ByteBuffer[]{header, body});\n// 先写 header 中 position~limit 的数据，再写 body\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e适用场景：协议解析中 header 和 body 分开处理的场景。\u003c/p\u003e\n\u003ch3\u003e2.4 Selector（多路复用器）\u003c/h3\u003e\n\u003cp\u003eSelector 是 NIO 实现高并发的关键。它允许\u003cstrong\u003e单个线程监控多个 Channel 的 I/O 事件\u003c/strong\u003e，只有当 Channel 上有就绪事件时才进行处理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e事件类型\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e事件\u003c/th\u003e\n\u003cth\u003eSelectionKey 常量\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e连接就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_CONNECT\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSocketChannel 完成连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e接收就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_ACCEPT\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eServerSocketChannel 有新连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_READ\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eChannel 有数据可读\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_WRITE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eChannel 可以写数据\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eSelector 工作流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSelector selector = Selector.open();\n\n// 1. 注册 Channel 到 Selector\nServerSocketChannel serverChannel = ServerSocketChannel.open();\nserverChannel.configureBlocking(false);\nserverChannel.bind(new InetSocketAddress(8080));\nserverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n// 2. 事件循环\nwhile (true) {\n    selector.select();  // 阻塞直到有就绪事件\n    Set\u0026lt;SelectionKey\u0026gt; selectedKeys = selector.selectedKeys();\n    Iterator\u0026lt;SelectionKey\u0026gt; iter = selectedKeys.iterator();\n\n    while (iter.hasNext()) {\n        SelectionKey key = iter.next();\n\n        if (key.isAcceptable()) {\n            // 处理新连接\n            SocketChannel client = serverChannel.accept();\n            client.configureBlocking(false);\n            client.register(selector, SelectionKey.OP_READ);\n        } else if (key.isReadable()) {\n            // 处理可读事件\n            SocketChannel client = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            client.read(buffer);\n            // 处理数据...\n        }\n\n        iter.remove();  // 必须手动移除已处理的 key\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSelector 的本质\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 Linux 上，\u003ccode\u003eSelector.select()\u003c/code\u003e 底层调用的是 \u003ccode\u003eepoll\u003c/code\u003e。epoll 是 Linux 内核提供的高性能 I/O 多路复用机制：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e多路复用实现\u003c/th\u003e\n\u003cth\u003e时间复杂度\u003c/th\u003e\n\u003cth\u003e连接数限制\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eselect\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003e1024（FD_SETSIZE）\u003c/td\u003e\n\u003ctd\u003e每次调用需拷贝全部 fd 集合\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epoll\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003e无限制\u003c/td\u003e\n\u003ctd\u003e与 select 类似，但无 fd 数量限制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eepoll\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003e无限制\u003c/td\u003e\n\u003ctd\u003e事件驱动，仅返回就绪的 fd\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eepoll 的高效源于\u003cstrong\u003e事件回调机制\u003c/strong\u003e：不再遍历所有 fd，而是内核在 fd 就绪时主动通知。\u003c/p\u003e\n\u003ch2\u003e三、NIO 网络模型 vs BIO 网络模型\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eBIO 模型（一连接一线程）：\n\n  客户端 1 ──→ [线程 1] ──→ read() 阻塞等待\n  客户端 2 ──→ [线程 2] ──→ read() 阻塞等待\n  客户端 N ──→ [线程 N] ──→ read() 阻塞等待\n\n  线程数 = 连接数（线性增长）\n\n\nNIO 模型（Reactor / 多路复用）：\n\n  客户端 1 ─┐\n  客户端 2 ─┼─→ [Selector] ─→ [线程] ─→ 处理就绪事件\n  客户端 N ─┘\n\n  线程数 = 常量（1 个或少量线程处理所有连接）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003eBIO\u003c/th\u003e\n\u003cth\u003eNIO\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e线程模型\u003c/td\u003e\n\u003ctd\u003e一连接一线程\u003c/td\u003e\n\u003ctd\u003e一线程管理多连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发能力\u003c/td\u003e\n\u003ctd\u003e受限于线程数（通常数千）\u003c/td\u003e\n\u003ctd\u003e轻松支撑万级连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCPU 利用率\u003c/td\u003e\n\u003ctd\u003e线程大量时间在等待\u003c/td\u003e\n\u003ctd\u003e仅在有事件时才处理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e编程复杂度\u003c/td\u003e\n\u003ctd\u003e简单直观\u003c/td\u003e\n\u003ctd\u003e较高（状态机、Buffer 管理）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e适用场景\u003c/td\u003e\n\u003ctd\u003e连接数少、每个连接数据量大\u003c/td\u003e\n\u003ctd\u003e连接数多、每个连接数据量小\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e四、Reactor 模式\u003c/h2\u003e\n\u003cp\u003eNIO 的 Selector 机制是 Reactor 模式的基础。Reactor 模式有三种经典变体：\u003c/p\u003e\n\u003ch3\u003e4.1 单 Reactor 单线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e所有 I/O 操作和业务处理在一个线程中完成：\n\n  [Reactor 线程]\n    → accept 新连接\n    → read 数据\n    → 处理业务\n    → write 响应\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优点：无线程切换开销。\u003cbr\u003e缺点：无法利用多核，业务处理阻塞会导致其他连接无法响应。\u003c/p\u003e\n\u003ch3\u003e4.2 单 Reactor 多线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eReactor 线程负责 I/O，业务处理分发到线程池：\n\n  [Reactor 线程] → accept / read / write\n        ↓ 分发\n  [线程池] → 业务处理\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优点：业务处理与 I/O 解耦。\u003cbr\u003e缺点：单 Reactor 线程处理所有 I/O，高并发下可能成为瓶颈。\u003c/p\u003e\n\u003ch3\u003e4.3 主从 Reactor（Netty 采用的模型）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003emainReactor 负责 accept，subReactor 负责 read/write：\n\n  [mainReactor] → accept 新连接 → 分配给 subReactor\n  [subReactor 1] → read / write（管理一部分连接）\n  [subReactor 2] → read / write（管理一部分连接）\n        ↓ 分发\n  [业务线程池] → 业务处理\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优点：accept 和 I/O 分离，多个 subReactor 可以利用多核，是高性能网络框架的标准模型。\u003c/p\u003e\n\u003cp\u003eNetty 的线程模型正是主从 Reactor 的实现：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNetty 概念\u003c/th\u003e\n\u003cth\u003e对应角色\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eBossGroup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003emainReactor（处理 accept）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eWorkerGroup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003esubReactor（处理 read/write）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eChannelPipeline\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eI/O 事件的处理链\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eEventLoop\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e绑定到单线程的事件循环\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e五、NIO 的工程实践要点\u003c/h2\u003e\n\u003ch3\u003e5.1 Buffer 使用陷阱\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e解决方案\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e忘记 \u003ccode\u003eflip()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e写完数据后直接读，position 在末尾导致读不到数据\u003c/td\u003e\n\u003ctd\u003e读之前必须调用 \u003ccode\u003eflip()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eclear()\u003c/code\u003e vs \u003ccode\u003ecompact()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eclear()\u003c/code\u003e 丢弃所有数据，\u003ccode\u003ecompact()\u003c/code\u003e 保留未读数据\u003c/td\u003e\n\u003ctd\u003e有未读数据时用 \u003ccode\u003ecompact()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e半包/粘包\u003c/td\u003e\n\u003ctd\u003eTCP 是流协议，一次读取可能不完整或包含多条消息\u003c/td\u003e\n\u003ctd\u003e基于长度或分隔符的协议解析\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e5.2 Direct Buffer vs Heap Buffer\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e类型\u003c/th\u003e\n\u003cth\u003e分配位置\u003c/th\u003e\n\u003cth\u003e分配速度\u003c/th\u003e\n\u003cth\u003eI/O 性能\u003c/th\u003e\n\u003cth\u003eGC 影响\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eHeap Buffer\u003c/td\u003e\n\u003ctd\u003eJVM 堆\u003c/td\u003e\n\u003ctd\u003e快\u003c/td\u003e\n\u003ctd\u003e需要一次额外拷贝\u003c/td\u003e\n\u003ctd\u003e受 GC 管理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDirect Buffer\u003c/td\u003e\n\u003ctd\u003e本地内存\u003c/td\u003e\n\u003ctd\u003e慢\u003c/td\u003e\n\u003ctd\u003e直接 I/O，减少拷贝\u003c/td\u003e\n\u003ctd\u003e不受 GC 直接管理\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e使用建议\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e频繁分配/释放的小 Buffer → Heap Buffer\u003c/li\u003e\n\u003cli\u003e长期存活、用于 I/O 操作的大 Buffer → Direct Buffer\u003c/li\u003e\n\u003cli\u003e生产环境中使用 Direct Buffer 时需要注意内存泄漏（手动管理或使用池化机制）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e5.3 Pipe：线程间通信\u003c/h3\u003e\n\u003cp\u003eNIO 提供了 \u003ccode\u003ePipe\u003c/code\u003e 用于同一 JVM 内线程间的数据传输：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ePipe pipe = Pipe.open();\n\n// 写线程\nPipe.SinkChannel sink = pipe.sink();\nByteBuffer buf = ByteBuffer.wrap(\u0026quot;data\u0026quot;.getBytes());\nsink.write(buf);\n\n// 读线程\nPipe.SourceChannel source = pipe.source();\nByteBuffer readBuf = ByteBuffer.allocate(1024);\nsource.read(readBuf);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava I/O 体系的演进反映了一个核心的架构思想：\u003cstrong\u003e从同步阻塞到事件驱动，从资源换并发到复用换并发\u003c/strong\u003e。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模型\u003c/th\u003e\n\u003cth\u003e核心抽象\u003c/th\u003e\n\u003cth\u003e线程模型\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eBIO\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eStream\u003c/td\u003e\n\u003ctd\u003e一连接一线程\u003c/td\u003e\n\u003ctd\u003e连接数少、数据量大（文件传输）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eNIO\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eChannel + Buffer + Selector\u003c/td\u003e\n\u003ctd\u003e多路复用\u003c/td\u003e\n\u003ctd\u003e连接数多、数据量小（即时通讯、API 网关）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e关键认知：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eNIO 不是比 BIO 快\u003c/strong\u003e。在单连接大数据量传输场景下，BIO 的简单模型可能更高效\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNIO 的优势在于可扩展性\u003c/strong\u003e。它能用极少的线程管理大量连接，这是 BIO 无法做到的\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e生产环境不要裸写 NIO\u003c/strong\u003e。直接使用 NIO API 编程极其复杂（半包处理、空轮询 bug、线程模型），应使用 Netty 等成熟框架\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI/O 模型的选择不取决于哪个\u0026quot;更先进\u0026quot;，而取决于业务的连接模式和数据特征。理解底层模型的差异，才能做出正确的技术选型。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"19:T5870,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003eJava 中的大部分同步工具（ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）都基于 AbstractQueuedSynchronizer（AQS）实现。理解 AQS，就等于掌握了 Java 并发编程的底层脉络。本文从设计思想出发，逐层深入 AQS 的数据结构、核心流程和源码实现，并通过 ReentrantLock 串联全局，最后梳理 AQS 在 JUC 中的应用全景。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eAQS 是什么？\u003c/h2\u003e\n\u003cp\u003eAQS（AbstractQueuedSynchronizer）是 \u003ccode\u003ejava.util.concurrent.locks\u003c/code\u003e 包中的一个\u003cstrong\u003e抽象类\u003c/strong\u003e，是构建锁和同步器的基础框架。Doug Lea 设计 AQS 的核心目标是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e降低构建锁和同步器的工作量\u003c/li\u003e\n\u003cli\u003e避免在多个位置处理竞争问题\u003c/li\u003e\n\u003cli\u003e在基于 AQS 的同步器中，阻塞只可能在一个时刻发生，降低上下文切换开销，提高吞吐量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAQS 支持两种工作模式：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e典型实现\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e独占模式（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e同一时刻只能有一个线程获取到锁\u003c/td\u003e\n\u003ctd\u003eReentrantLock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e共享模式（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e同一时刻可以有多个线程同时获取\u003c/td\u003e\n\u003ctd\u003eCountDownLatch、ReadWriteLock、Semaphore\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e无论哪种模式，本质上都是对 AQS 内部一个 \u003cstrong\u003e\u003ccode\u003estate\u003c/code\u003e 变量\u003c/strong\u003e的获取和释放。\u003c/p\u003e\n\u003ch2\u003eAQS 的整体架构\u003c/h2\u003e\n\u003cp\u003eAQS 框架共分为\u003cstrong\u003e五层\u003c/strong\u003e，自上而下由浅入深：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e层次\u003c/th\u003e\n\u003cth\u003e内容\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e第一层\u003c/td\u003e\n\u003ctd\u003eAPI 层\u003c/td\u003e\n\u003ctd\u003e自定义同步器需重写的方法（tryAcquire、tryRelease 等）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第二层\u003c/td\u003e\n\u003ctd\u003e获取/释放方法\u003c/td\u003e\n\u003ctd\u003eacquire、release、acquireShared、releaseShared\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第三层\u003c/td\u003e\n\u003ctd\u003e队列操作\u003c/td\u003e\n\u003ctd\u003eaddWaiter、acquireQueued、shouldParkAfterFailedAcquire\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第四层\u003c/td\u003e\n\u003ctd\u003e线程阻塞/唤醒\u003c/td\u003e\n\u003ctd\u003eLockSupport.park / unpark\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第五层\u003c/td\u003e\n\u003ctd\u003e基础数据\u003c/td\u003e\n\u003ctd\u003estate、Node、CLH 变体队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当接入自定义同步器时，\u003cstrong\u003e只需重写第一层的部分方法即可\u003c/strong\u003e，不需要关注底层实现。当加锁或解锁操作触发时，沿着第一层到第五层逐层深入。\u003c/p\u003e\n\u003ch2\u003e核心数据结构\u003c/h2\u003e\n\u003ch3\u003e同步状态 State\u003c/h3\u003e\n\u003cp\u003eAQS 使用一个 \u003ccode\u003evolatile int\u003c/code\u003e 类型的成员变量 \u003ccode\u003estate\u003c/code\u003e 来表示同步状态：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate volatile int state;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eState 的含义由具体的同步器定义，例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eReentrantLock\u003c/strong\u003e：state 表示锁被重入的次数，0 表示未被持有\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e：state 表示可用许可的数量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e：state 表示计数器的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAQS 提供三个方法操作 state，均为 \u003ccode\u003efinal\u003c/code\u003e 修饰，子类不可重写：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003egetState()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e获取当前 state 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003esetState(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e设置 state 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecompareAndSetState(int, int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCAS 方式更新 state\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eCLH 变体队列与 Node 节点\u003c/h3\u003e\n\u003cp\u003eAQS 的核心思想是：如果请求的共享资源空闲，就将当前线程设置为有效的工作线程，并将资源设置为锁定状态；\u003cstrong\u003e如果资源被占用，就通过一个 CLH 变体的 FIFO 双向队列来管理等待线程\u003c/strong\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCLH 队列以其发明者 Craig、Landin 和 Hagersten 命名，原始 CLH 是单向链表。AQS 中的变体是虚拟双向队列，通过将每条请求线程封装成 Node 节点来实现锁的分配。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNode 节点的关键属性：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethread\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e该节点代表的线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ewaitStatus\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e当前节点在队列中的等待状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eprev\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e前驱指针\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e后继指针\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enextWaiter\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e指向下一个处于 CONDITION 状态的节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003ewaitStatus\u003c/code\u003e 的枚举值：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e值\u003c/th\u003e\n\u003cth\u003e名称\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e默认值\u003c/td\u003e\n\u003ctd\u003eNode 初始化时的状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003eCANCELLED\u003c/td\u003e\n\u003ctd\u003e线程获取锁的请求已取消\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003eSIGNAL\u003c/td\u003e\n\u003ctd\u003e后继节点的线程需要被唤醒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-2\u003c/td\u003e\n\u003ctd\u003eCONDITION\u003c/td\u003e\n\u003ctd\u003e节点在条件队列中，等待 Condition 唤醒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-3\u003c/td\u003e\n\u003ctd\u003ePROPAGATE\u003c/td\u003e\n\u003ctd\u003e共享模式下，释放操作需要向后传播\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eAQS 内部还维护了\u003cstrong\u003e两种队列\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e同步队列（Sync Queue）\u003c/strong\u003e：获取资源失败的线程进入此队列自旋等待，当前驱节点是头节点时尝试获取资源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e条件队列（Condition Queue）\u003c/strong\u003e：基于 \u003ccode\u003eCondition\u003c/code\u003e 实现，调用 \u003ccode\u003eawait()\u003c/code\u003e 时线程进入条件队列，调用 \u003ccode\u003esignal()\u003c/code\u003e 时转移到同步队列\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意：双向链表的\u003cstrong\u003e头节点是一个虚节点\u003c/strong\u003e（不存储实际线程信息），真正的第一个有效节点从第二个开始。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e自定义同步器需要重写的方法\u003c/h2\u003e\n\u003cp\u003eAQS 采用\u003cstrong\u003e模板方法模式\u003c/strong\u003e，自定义同步器只需根据需要重写以下方法：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryAcquire(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e尝试获取资源，成功返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryRelease(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e尝试释放资源，成功返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryAcquireShared(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e尝试获取资源，负数=失败，0=成功但无剩余，正数=成功且有剩余\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryReleaseShared(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e尝试释放资源，如果释放后允许唤醒后续节点返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eisHeldExclusively()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e当前线程是否独占资源，用到 Condition 时需实现\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e独占模式实现 \u003ccode\u003etryAcquire-tryRelease\u003c/code\u003e，共享模式实现 \u003ccode\u003etryAcquireShared-tryReleaseShared\u003c/code\u003e。AQS 也支持同时实现两种模式，如 \u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003e通过 ReentrantLock 理解加锁流程\u003c/h2\u003e\n\u003cp\u003eReentrantLock 是 AQS 独占模式最典型的实现。我们以\u003cstrong\u003e非公平锁\u003c/strong\u003e为例，完整追踪加锁流程。\u003c/p\u003e\n\u003ch3\u003e第一步：lock()\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock.NonfairSync\nfinal void lock() {\n    if (compareAndSetState(0, 1))           // 直接 CAS 尝试获取锁\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);                          // 失败则进入 AQS 框架流程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e非公平锁上来就尝试 CAS 抢锁（不管队列中有没有等待线程），这是它\u0026quot;非公平\u0026quot;的体现。\u003c/p\u003e\n\u003ch3\u003e第二步：acquire()\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// AbstractQueuedSynchronizer\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026amp;\u0026amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这一行代码浓缩了整个加锁流程的四个步骤：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etryAcquire → addWaiter → acquireQueued → selfInterrupt\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003etryAcquire\u003c/strong\u003e：尝试获取锁（由子类实现）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eaddWaiter\u003c/strong\u003e：获取失败，将当前线程封装为 Node 加入队列尾部\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eacquireQueued\u003c/strong\u003e：在队列中自旋等待，直到获取到锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eselfInterrupt\u003c/strong\u003e：如果等待过程中被中断过，补上中断\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e第三步：tryAcquire（公平 vs 非公平）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e非公平锁\u003c/strong\u003e的实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {   // 直接 CAS，不检查队列\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {  // 可重入逻辑\n        int nextc = c + acquires;\n        if (nextc \u0026lt; 0) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e公平锁\u003c/strong\u003e的区别仅在于多了一个 \u003ccode\u003ehasQueuedPredecessors()\u003c/code\u003e 检查：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (c == 0) {\n    if (!hasQueuedPredecessors() \u0026amp;\u0026amp;   // 公平锁：先检查队列中是否有等待线程\n        compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁类型\u003c/th\u003e\n\u003cth\u003estate == 0 时的行为\u003c/th\u003e\n\u003cth\u003e可重入逻辑\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e非公平锁\u003c/td\u003e\n\u003ctd\u003e直接 CAS 抢锁\u003c/td\u003e\n\u003ctd\u003e相同：state + 1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平锁\u003c/td\u003e\n\u003ctd\u003e先检查队列再 CAS\u003c/td\u003e\n\u003ctd\u003e相同：state + 1\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e第四步：addWaiter — 入队\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    Node pred = tail;\n    if (pred != null) {            // 队列已初始化，尝试快速入队\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);                     // 快速入队失败或队列未初始化\n    return node;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eenq()\u003c/code\u003e 方法通过\u003cstrong\u003e自旋 + CAS\u003c/strong\u003e 确保入队成功：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) {                         // 队列为空，初始化\n            if (compareAndSetHead(new Node()))    // 创建虚拟头节点\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e线程获取锁的过程可以形象理解为：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程1获取锁成功 → 线程2申请锁失败 → 线程2入队等待 → 线程3申请失败 → 线程3排在线程2后面 → ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e第五步：acquireQueued — 自旋获取锁\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {   // 前驱是头节点，尝试获取锁\n                setHead(node);                     // 获取成功，当前节点成为新的头节点\n                p.next = null;                     // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp;\n                parkAndCheckInterrupt())           // 获取失败，判断是否需要挂起\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e核心逻辑：\u003cstrong\u003e只有前驱节点是头节点的线程才有资格尝试获取锁\u003c/strong\u003e。获取失败后，通过 \u003ccode\u003eshouldParkAfterFailedAcquire\u003c/code\u003e 判断是否需要挂起（将前驱节点的 waitStatus 设为 SIGNAL），然后通过 \u003ccode\u003eLockSupport.park()\u003c/code\u003e 挂起线程，避免空转浪费 CPU。\u003c/p\u003e\n\u003ch3\u003eshouldParkAfterFailedAcquire 的三种情况\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)        // 前驱已经是 SIGNAL，可以安全挂起\n        return true;\n    if (ws \u0026gt; 0) {                 // 前驱已取消，向前找到有效节点\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus \u0026gt; 0);\n        pred.next = node;\n    } else {                      // 前驱状态为 0 或 PROPAGATE，设为 SIGNAL\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e前驱 waitStatus\u003c/th\u003e\n\u003cth\u003e处理\u003c/th\u003e\n\u003cth\u003e是否挂起\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eSIGNAL (-1)\u003c/td\u003e\n\u003ctd\u003e直接返回 true\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCANCELLED (\u0026gt;0)\u003c/td\u003e\n\u003ctd\u003e跳过所有取消节点，重新链接\u003c/td\u003e\n\u003ctd\u003e否，下次循环再判断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e0 或 PROPAGATE\u003c/td\u003e\n\u003ctd\u003eCAS 设为 SIGNAL\u003c/td\u003e\n\u003ctd\u003e否，下次循环再判断\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e解锁流程\u003c/h2\u003e\n\u003cp\u003eReentrantLock 解锁时\u003cstrong\u003e不区分公平和非公平\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock\npublic void unlock() {\n    sync.release(1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// AbstractQueuedSynchronizer\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null \u0026amp;\u0026amp; h.waitStatus != 0)\n            unparkSuccessor(h);          // 唤醒后继节点\n        return true;\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003etryRelease — 可重入锁的释放\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock.Sync\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;       // state 减 1\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {                         // 只有 state 减到 0，锁才真正释放\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eunparkSuccessor — 唤醒后继线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void unparkSuccessor(Node node) {\n    int ws = node.waitStatus;\n    if (ws \u0026lt; 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    Node s = node.next;\n    if (s == null || s.waitStatus \u0026gt; 0) {\n        s = null;\n        // 从尾部向前遍历，找到第一个非取消状态的节点\n        for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev)\n            if (t.waitStatus \u0026lt;= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);    // 唤醒线程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e为什么要从后向前遍历？\u003c/strong\u003e 两个原因：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eaddWaiter\u003c/code\u003e 中节点入队不是原子操作——\u003ccode\u003enode.prev = pred\u003c/code\u003e 和 \u003ccode\u003ecompareAndSetTail\u003c/code\u003e 完成后，\u003ccode\u003epred.next = node\u003c/code\u003e 可能还未执行。此时从前向后遍历会断链。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecancelAcquire\u003c/code\u003e 产生 CANCELLED 节点时，先断开的是 next 指针，prev 指针未断开。因此从后向前遍历才能保证遍历完整。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eCANCELLED 节点的处理\u003c/h2\u003e\n\u003cp\u003e当 \u003ccode\u003eacquireQueued\u003c/code\u003e 中发生异常时，会执行 \u003ccode\u003ecancelAcquire(node)\u003c/code\u003e 将节点标记为 CANCELLED。处理逻辑根据节点位置分为三种情况：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e节点位置\u003c/th\u003e\n\u003cth\u003e处理方式\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e尾节点\u003c/td\u003e\n\u003ctd\u003e将前驱设为新的 tail，其 next 置为 null\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e头节点的后继\u003c/td\u003e\n\u003ctd\u003e唤醒当前节点的后继线程（unparkSuccessor）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e中间节点\u003c/td\u003e\n\u003ctd\u003e将前驱的 next 指向当前节点的后继，跳过当前节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ecancelAcquire\u003c/code\u003e 只操作 next 指针，不操作 prev 指针。因为执行 cancel 时前驱可能已经出队，修改 prev 不安全。prev 指针的清理留给 \u003ccode\u003eshouldParkAfterFailedAcquire\u003c/code\u003e——此方法在获取锁失败时执行，此时共享资源已被占用，前方节点不会变化，修改 prev 是安全的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e中断处理机制\u003c/h2\u003e\n\u003cp\u003eAQS 的 \u003ccode\u003eacquire\u003c/code\u003e 方法是\u003cstrong\u003e不可中断\u003c/strong\u003e的——线程在等待过程中不会响应中断，而是记录中断状态，等获取到锁后再\u0026quot;补上\u0026quot;中断：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026amp;\u0026amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 返回 true 说明被中断过\n        selfInterrupt();                                  // 补上中断\n}\n\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种设计的考量是：线程被唤醒时并不知道原因（可能是前驱释放了锁，也可能是被中断），所以通过 \u003ccode\u003eThread.interrupted()\u003c/code\u003e 检查并清除中断标记，记录下来，最后在获取锁成功后统一补上。\u003c/p\u003e\n\u003ch2\u003epark / unpark 机制\u003c/h2\u003e\n\u003cp\u003eAQS 中线程的阻塞和唤醒通过 \u003ccode\u003eLockSupport\u003c/code\u003e 实现：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLockSupport.park(this)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e阻塞当前线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLockSupport.unpark(thread)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e唤醒指定线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e它们的底层实现是通过 \u003ccode\u003eUnsafe\u003c/code\u003e 类调用 CPU 原语。相比 \u003ccode\u003eObject.wait/notify\u003c/code\u003e，park/unpark 的优势在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不需要在同步块中使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunpark\u003c/code\u003e 可以先于 \u003ccode\u003epark\u003c/code\u003e 调用（基于许可机制）\u003c/li\u003e\n\u003cli\u003e可以精确唤醒指定线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在 AQS 中使用 park 的主要目的是：\u003cstrong\u003e让排队等待的线程挂起，停止自旋以避免浪费 CPU 资源\u003c/strong\u003e，并在需要时通过 unpark 精确唤醒。\u003c/p\u003e\n\u003ch2\u003eAQS 在 JUC 中的应用场景\u003c/h2\u003e\n\u003cp\u003eAQS 是 JUC 包的基石，几乎所有同步工具都构建在它之上：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e同步工具\u003c/th\u003e\n\u003cth\u003e如何使用 AQS\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eReentrantLock\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示锁的重入次数。获取锁时 state+1，释放时 state-1。state 为 0 表示锁空闲。同时记录持有锁的线程用于重入检测。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示可用许可数。\u003ccode\u003eacquireShared\u003c/code\u003e 减少计数，\u003ccode\u003etryReleaseShared\u003c/code\u003e 增加计数。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示计数器。每次 \u003ccode\u003ecountDown()\u003c/code\u003e 减 1，\u003ccode\u003eawait()\u003c/code\u003e 等待 state 变为 0 后所有线程被唤醒。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eReentrantReadWriteLock\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 的高 16 位保存读锁持有次数，低 16 位保存写锁持有次数。读锁用共享模式，写锁用独占模式。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eThreadPoolExecutor\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eWorker 内部类继承 AQS，利用独占模式实现对工作线程的状态管理。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eState 在不同同步器中的语义\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eReentrantLock:       state = 重入次数 (0 = 空闲)\nSemaphore:           state = 可用许可数\nCountDownLatch:      state = 剩余计数 (0 = 所有线程放行)\nReadWriteLock:       state = [高16位:读锁次数][低16位:写锁次数]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e自定义同步器示例\u003c/h2\u003e\n\u003cp\u003e理解 AQS 后，我们可以用极少的代码实现一个简单的互斥锁：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SimpleLock {\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    public void lock()   { sync.acquire(1); }\n    public void unlock() { sync.release(1); }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) throws InterruptedException {\n    SimpleLock lock = new SimpleLock();\n    int[] count = {0};\n\n    Runnable task = () -\u0026gt; {\n        lock.lock();\n        try {\n            for (int i = 0; i \u0026lt; 10000; i++) count[0]++;\n        } finally {\n            lock.unlock();\n        }\n    };\n\n    Thread t1 = new Thread(task);\n    Thread t2 = new Thread(task);\n    t1.start(); t2.start();\n    t1.join();  t2.join();\n    System.out.println(count[0]);  // 始终输出 20000\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只需重写 \u003ccode\u003etryAcquire\u003c/code\u003e 和 \u003ccode\u003etryRelease\u003c/code\u003e，AQS 就接管了排队、阻塞、唤醒、中断处理等全部复杂逻辑。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eAQS 的设计精髓可以归纳为以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e一个 state 变量统一抽象\u003c/strong\u003e：不同的同步器通过赋予 state 不同的语义（重入次数、许可数、计数器等），复用同一套框架\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCLH 变体双向队列管理等待线程\u003c/strong\u003e：通过 FIFO 队列保证公平性，通过 CAS + 自旋保证入队的线程安全\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模板方法模式降低接入成本\u003c/strong\u003e：自定义同步器只需实现 tryAcquire/tryRelease 等少量方法，框架处理全部排队和唤醒逻辑\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epark/unpark 精确控制线程状态\u003c/strong\u003e：避免自旋空转浪费 CPU，同时支持精确唤醒\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从后向前遍历保证正确性\u003c/strong\u003e：在非原子入队操作和 CANCELLED 节点处理中，始终保证能遍历到所有有效节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAQS 是 Doug Lea 在并发编程领域的杰作。理解了 AQS，就理解了 JUC 包中绝大部分同步工具的底层运作方式。它不仅是面试的高频考点，更是我们在实际工程中设计自定义同步器时可以直接借鉴的框架。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/middleware/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"中间件\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2021-11-20\",\"children\":\"2021年11月20日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"Java并发编程：从内存模型到并发工具的设计哲学\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}],[\"$\",\"$L13\",\"并发编程\",{\"href\":\"/blog/tag/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"并发编程\"}],[\"$\",\"$L13\",\"JMM\",{\"href\":\"/blog/tag/JMM/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"JMM\"}],[\"$\",\"$L13\",\"JUC\",{\"href\":\"/blog/tag/JUC/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"JUC\"}],[\"$\",\"$L13\",\"线程池\",{\"href\":\"/blog/tag/%E7%BA%BF%E7%A8%8B%E6%B1%A0/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"线程池\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/middleware/深入理解JVM：从类加载到垃圾回收的全链路剖析\",\"title\":\"深入理解JVM：从类加载到垃圾回收的全链路剖析\",\"description\":\"系统剖析JVM核心机制，从类加载的双亲委派模型到运行时内存布局，从PermGen到Metaspace的演进，再到七大垃圾收集器的设计原理与选型策略，构建完整的JVM知识体系。\",\"pubDate\":\"2021-06-15\",\"tags\":[\"JVM\",\"Java\",\"垃圾回收\",\"类加载\",\"性能调优\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/middleware/Java IO模型演进：从BIO到NIO的范式变革\",\"title\":\"Java I/O模型演进：从BIO到NIO的范式变革\",\"description\":\"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。\",\"pubDate\":\"2022-04-18\",\"tags\":[\"Java\",\"NIO\",\"I/O\",\"Netty\",\"网络编程\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"Java\":{\"prev\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"并发编程\":{\"prev\":null,\"next\":{\"slug\":\"engineering/middleware/深入理解AQS：Java并发的基石\",\"title\":\"深入理解AQS：Java并发的基石\",\"description\":\"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。\",\"pubDate\":\"2025-12-28\",\"tags\":[\"Java\",\"并发编程\",\"AQS\",\"ReentrantLock\",\"JUC\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"}},\"JMM\":{\"prev\":null,\"next\":null},\"JUC\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:tagNav:并发编程:next\"},\"线程池\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L1a\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Java并发编程：从内存模型到并发工具的设计哲学 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Java并发编程：从内存模型到并发工具的设计哲学\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2021-11-20\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Java并发编程：从内存模型到并发工具的设计哲学\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
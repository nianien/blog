1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/fffdcdb4fb651185.css","style"]
0:{"P":null,"b":"wlOkUxTzHfxl8sQA11M8Z","p":"","c":["","blog","engineering","middleware","%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%9F%B3",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/middleware/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%9F%B3","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/fffdcdb4fb651185.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/middleware/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%9F%B3","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","N_R1y47-DNB-gxQEjVdqQv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1a:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T5870,<blockquote>
<p>Java 中的大部分同步工具（ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）都基于 AbstractQueuedSynchronizer（AQS）实现。理解 AQS，就等于掌握了 Java 并发编程的底层脉络。本文从设计思想出发，逐层深入 AQS 的数据结构、核心流程和源码实现，并通过 ReentrantLock 串联全局，最后梳理 AQS 在 JUC 中的应用全景。</p>
</blockquote>
<h2>AQS 是什么？</h2>
<p>AQS（AbstractQueuedSynchronizer）是 <code>java.util.concurrent.locks</code> 包中的一个<strong>抽象类</strong>，是构建锁和同步器的基础框架。Doug Lea 设计 AQS 的核心目标是：</p>
<ul>
<li>降低构建锁和同步器的工作量</li>
<li>避免在多个位置处理竞争问题</li>
<li>在基于 AQS 的同步器中，阻塞只可能在一个时刻发生，降低上下文切换开销，提高吞吐量</li>
</ul>
<p>AQS 支持两种工作模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>典型实现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>独占模式（Exclusive）</strong></td>
<td>同一时刻只能有一个线程获取到锁</td>
<td>ReentrantLock</td>
</tr>
<tr>
<td><strong>共享模式（Shared）</strong></td>
<td>同一时刻可以有多个线程同时获取</td>
<td>CountDownLatch、ReadWriteLock、Semaphore</td>
</tr>
</tbody></table>
<p>无论哪种模式，本质上都是对 AQS 内部一个 <strong><code>state</code> 变量</strong>的获取和释放。</p>
<h2>AQS 的整体架构</h2>
<p>AQS 框架共分为<strong>五层</strong>，自上而下由浅入深：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>第一层</td>
<td>API 层</td>
<td>自定义同步器需重写的方法（tryAcquire、tryRelease 等）</td>
</tr>
<tr>
<td>第二层</td>
<td>获取/释放方法</td>
<td>acquire、release、acquireShared、releaseShared</td>
</tr>
<tr>
<td>第三层</td>
<td>队列操作</td>
<td>addWaiter、acquireQueued、shouldParkAfterFailedAcquire</td>
</tr>
<tr>
<td>第四层</td>
<td>线程阻塞/唤醒</td>
<td>LockSupport.park / unpark</td>
</tr>
<tr>
<td>第五层</td>
<td>基础数据</td>
<td>state、Node、CLH 变体队列</td>
</tr>
</tbody></table>
<p>当接入自定义同步器时，<strong>只需重写第一层的部分方法即可</strong>，不需要关注底层实现。当加锁或解锁操作触发时，沿着第一层到第五层逐层深入。</p>
<h2>核心数据结构</h2>
<h3>同步状态 State</h3>
<p>AQS 使用一个 <code>volatile int</code> 类型的成员变量 <code>state</code> 来表示同步状态：</p>
<pre><code class="language-java">private volatile int state;
</code></pre>
<p>State 的含义由具体的同步器定义，例如：</p>
<ul>
<li><strong>ReentrantLock</strong>：state 表示锁被重入的次数，0 表示未被持有</li>
<li><strong>Semaphore</strong>：state 表示可用许可的数量</li>
<li><strong>CountDownLatch</strong>：state 表示计数器的值</li>
</ul>
<p>AQS 提供三个方法操作 state，均为 <code>final</code> 修饰，子类不可重写：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getState()</code></td>
<td>获取当前 state 值</td>
</tr>
<tr>
<td><code>setState(int)</code></td>
<td>设置 state 值</td>
</tr>
<tr>
<td><code>compareAndSetState(int, int)</code></td>
<td>CAS 方式更新 state</td>
</tr>
</tbody></table>
<h3>CLH 变体队列与 Node 节点</h3>
<p>AQS 的核心思想是：如果请求的共享资源空闲，就将当前线程设置为有效的工作线程，并将资源设置为锁定状态；<strong>如果资源被占用，就通过一个 CLH 变体的 FIFO 双向队列来管理等待线程</strong>。</p>
<blockquote>
<p>CLH 队列以其发明者 Craig、Landin 和 Hagersten 命名，原始 CLH 是单向链表。AQS 中的变体是虚拟双向队列，通过将每条请求线程封装成 Node 节点来实现锁的分配。</p>
</blockquote>
<p>Node 节点的关键属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>thread</code></td>
<td>该节点代表的线程</td>
</tr>
<tr>
<td><code>waitStatus</code></td>
<td>当前节点在队列中的等待状态</td>
</tr>
<tr>
<td><code>prev</code></td>
<td>前驱指针</td>
</tr>
<tr>
<td><code>next</code></td>
<td>后继指针</td>
</tr>
<tr>
<td><code>nextWaiter</code></td>
<td>指向下一个处于 CONDITION 状态的节点</td>
</tr>
</tbody></table>
<p><code>waitStatus</code> 的枚举值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>默认值</td>
<td>Node 初始化时的状态</td>
</tr>
<tr>
<td>1</td>
<td>CANCELLED</td>
<td>线程获取锁的请求已取消</td>
</tr>
<tr>
<td>-1</td>
<td>SIGNAL</td>
<td>后继节点的线程需要被唤醒</td>
</tr>
<tr>
<td>-2</td>
<td>CONDITION</td>
<td>节点在条件队列中，等待 Condition 唤醒</td>
</tr>
<tr>
<td>-3</td>
<td>PROPAGATE</td>
<td>共享模式下，释放操作需要向后传播</td>
</tr>
</tbody></table>
<p>AQS 内部还维护了<strong>两种队列</strong>：</p>
<ul>
<li><strong>同步队列（Sync Queue）</strong>：获取资源失败的线程进入此队列自旋等待，当前驱节点是头节点时尝试获取资源</li>
<li><strong>条件队列（Condition Queue）</strong>：基于 <code>Condition</code> 实现，调用 <code>await()</code> 时线程进入条件队列，调用 <code>signal()</code> 时转移到同步队列</li>
</ul>
<blockquote>
<p>注意：双向链表的<strong>头节点是一个虚节点</strong>（不存储实际线程信息），真正的第一个有效节点从第二个开始。</p>
</blockquote>
<h2>自定义同步器需要重写的方法</h2>
<p>AQS 采用<strong>模板方法模式</strong>，自定义同步器只需根据需要重写以下方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tryAcquire(int)</code></td>
<td>独占</td>
<td>尝试获取资源，成功返回 true</td>
</tr>
<tr>
<td><code>tryRelease(int)</code></td>
<td>独占</td>
<td>尝试释放资源，成功返回 true</td>
</tr>
<tr>
<td><code>tryAcquireShared(int)</code></td>
<td>共享</td>
<td>尝试获取资源，负数=失败，0=成功但无剩余，正数=成功且有剩余</td>
</tr>
<tr>
<td><code>tryReleaseShared(int)</code></td>
<td>共享</td>
<td>尝试释放资源，如果释放后允许唤醒后续节点返回 true</td>
</tr>
<tr>
<td><code>isHeldExclusively()</code></td>
<td>独占</td>
<td>当前线程是否独占资源，用到 Condition 时需实现</td>
</tr>
</tbody></table>
<p>独占模式实现 <code>tryAcquire-tryRelease</code>，共享模式实现 <code>tryAcquireShared-tryReleaseShared</code>。AQS 也支持同时实现两种模式，如 <code>ReentrantReadWriteLock</code>。</p>
<h2>通过 ReentrantLock 理解加锁流程</h2>
<p>ReentrantLock 是 AQS 独占模式最典型的实现。我们以<strong>非公平锁</strong>为例，完整追踪加锁流程。</p>
<h3>第一步：lock()</h3>
<pre><code class="language-java">// ReentrantLock.NonfairSync
final void lock() {
    if (compareAndSetState(0, 1))           // 直接 CAS 尝试获取锁
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);                          // 失败则进入 AQS 框架流程
}
</code></pre>
<p>非公平锁上来就尝试 CAS 抢锁（不管队列中有没有等待线程），这是它&quot;非公平&quot;的体现。</p>
<h3>第二步：acquire()</h3>
<pre><code class="language-java">// AbstractQueuedSynchronizer
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<p>这一行代码浓缩了整个加锁流程的四个步骤：</p>
<pre><code>tryAcquire → addWaiter → acquireQueued → selfInterrupt
</code></pre>
<ol>
<li><strong>tryAcquire</strong>：尝试获取锁（由子类实现）</li>
<li><strong>addWaiter</strong>：获取失败，将当前线程封装为 Node 加入队列尾部</li>
<li><strong>acquireQueued</strong>：在队列中自旋等待，直到获取到锁</li>
<li><strong>selfInterrupt</strong>：如果等待过程中被中断过，补上中断</li>
</ol>
<h3>第三步：tryAcquire（公平 vs 非公平）</h3>
<p><strong>非公平锁</strong>的实现：</p>
<pre><code class="language-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {   // 直接 CAS，不检查队列
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {  // 可重入逻辑
        int nextc = c + acquires;
        if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p><strong>公平锁</strong>的区别仅在于多了一个 <code>hasQueuedPredecessors()</code> 检查：</p>
<pre><code class="language-java">if (c == 0) {
    if (!hasQueuedPredecessors() &amp;&amp;   // 公平锁：先检查队列中是否有等待线程
        compareAndSetState(0, acquires)) {
        setExclusiveOwnerThread(current);
        return true;
    }
}
</code></pre>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>state == 0 时的行为</th>
<th>可重入逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>非公平锁</td>
<td>直接 CAS 抢锁</td>
<td>相同：state + 1</td>
</tr>
<tr>
<td>公平锁</td>
<td>先检查队列再 CAS</td>
<td>相同：state + 1</td>
</tr>
</tbody></table>
<h3>第四步：addWaiter — 入队</h3>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    if (pred != null) {            // 队列已初始化，尝试快速入队
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);                     // 快速入队失败或队列未初始化
    return node;
}
</code></pre>
<p><code>enq()</code> 方法通过<strong>自旋 + CAS</strong> 确保入队成功：</p>
<pre><code class="language-java">private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) {                         // 队列为空，初始化
            if (compareAndSetHead(new Node()))    // 创建虚拟头节点
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<p>线程获取锁的过程可以形象理解为：</p>
<pre><code>线程1获取锁成功 → 线程2申请锁失败 → 线程2入队等待 → 线程3申请失败 → 线程3排在线程2后面 → ...
</code></pre>
<h3>第五步：acquireQueued — 自旋获取锁</h3>
<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {   // 前驱是头节点，尝试获取锁
                setHead(node);                     // 获取成功，当前节点成为新的头节点
                p.next = null;                     // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())           // 获取失败，判断是否需要挂起
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>核心逻辑：<strong>只有前驱节点是头节点的线程才有资格尝试获取锁</strong>。获取失败后，通过 <code>shouldParkAfterFailedAcquire</code> 判断是否需要挂起（将前驱节点的 waitStatus 设为 SIGNAL），然后通过 <code>LockSupport.park()</code> 挂起线程，避免空转浪费 CPU。</p>
<h3>shouldParkAfterFailedAcquire 的三种情况</h3>
<pre><code class="language-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)        // 前驱已经是 SIGNAL，可以安全挂起
        return true;
    if (ws &gt; 0) {                 // 前驱已取消，向前找到有效节点
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {                      // 前驱状态为 0 或 PROPAGATE，设为 SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<table>
<thead>
<tr>
<th>前驱 waitStatus</th>
<th>处理</th>
<th>是否挂起</th>
</tr>
</thead>
<tbody><tr>
<td>SIGNAL (-1)</td>
<td>直接返回 true</td>
<td>是</td>
</tr>
<tr>
<td>CANCELLED (&gt;0)</td>
<td>跳过所有取消节点，重新链接</td>
<td>否，下次循环再判断</td>
</tr>
<tr>
<td>0 或 PROPAGATE</td>
<td>CAS 设为 SIGNAL</td>
<td>否，下次循环再判断</td>
</tr>
</tbody></table>
<h2>解锁流程</h2>
<p>ReentrantLock 解锁时<strong>不区分公平和非公平</strong>：</p>
<pre><code class="language-java">// ReentrantLock
public void unlock() {
    sync.release(1);
}
</code></pre>
<pre><code class="language-java">// AbstractQueuedSynchronizer
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);          // 唤醒后继节点
        return true;
    }
    return false;
}
</code></pre>
<h3>tryRelease — 可重入锁的释放</h3>
<pre><code class="language-java">// ReentrantLock.Sync
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;       // state 减 1
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {                         // 只有 state 减到 0，锁才真正释放
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<h3>unparkSuccessor — 唤醒后继线程</h3>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        // 从尾部向前遍历，找到第一个非取消状态的节点
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);    // 唤醒线程
}
</code></pre>
<blockquote>
<p><strong>为什么要从后向前遍历？</strong> 两个原因：</p>
<ol>
<li><code>addWaiter</code> 中节点入队不是原子操作——<code>node.prev = pred</code> 和 <code>compareAndSetTail</code> 完成后，<code>pred.next = node</code> 可能还未执行。此时从前向后遍历会断链。</li>
<li><code>cancelAcquire</code> 产生 CANCELLED 节点时，先断开的是 next 指针，prev 指针未断开。因此从后向前遍历才能保证遍历完整。</li>
</ol>
</blockquote>
<h2>CANCELLED 节点的处理</h2>
<p>当 <code>acquireQueued</code> 中发生异常时，会执行 <code>cancelAcquire(node)</code> 将节点标记为 CANCELLED。处理逻辑根据节点位置分为三种情况：</p>
<table>
<thead>
<tr>
<th>节点位置</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>尾节点</td>
<td>将前驱设为新的 tail，其 next 置为 null</td>
</tr>
<tr>
<td>头节点的后继</td>
<td>唤醒当前节点的后继线程（unparkSuccessor）</td>
</tr>
<tr>
<td>中间节点</td>
<td>将前驱的 next 指向当前节点的后继，跳过当前节点</td>
</tr>
</tbody></table>
<blockquote>
<p><code>cancelAcquire</code> 只操作 next 指针，不操作 prev 指针。因为执行 cancel 时前驱可能已经出队，修改 prev 不安全。prev 指针的清理留给 <code>shouldParkAfterFailedAcquire</code>——此方法在获取锁失败时执行，此时共享资源已被占用，前方节点不会变化，修改 prev 是安全的。</p>
</blockquote>
<h2>中断处理机制</h2>
<p>AQS 的 <code>acquire</code> 方法是<strong>不可中断</strong>的——线程在等待过程中不会响应中断，而是记录中断状态，等获取到锁后再&quot;补上&quot;中断：</p>
<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 返回 true 说明被中断过
        selfInterrupt();                                  // 补上中断
}

static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
</code></pre>
<p>这种设计的考量是：线程被唤醒时并不知道原因（可能是前驱释放了锁，也可能是被中断），所以通过 <code>Thread.interrupted()</code> 检查并清除中断标记，记录下来，最后在获取锁成功后统一补上。</p>
<h2>park / unpark 机制</h2>
<p>AQS 中线程的阻塞和唤醒通过 <code>LockSupport</code> 实现：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>LockSupport.park(this)</code></td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td><code>LockSupport.unpark(thread)</code></td>
<td>唤醒指定线程</td>
</tr>
</tbody></table>
<p>它们的底层实现是通过 <code>Unsafe</code> 类调用 CPU 原语。相比 <code>Object.wait/notify</code>，park/unpark 的优势在于：</p>
<ul>
<li>不需要在同步块中使用</li>
<li><code>unpark</code> 可以先于 <code>park</code> 调用（基于许可机制）</li>
<li>可以精确唤醒指定线程</li>
</ul>
<p>在 AQS 中使用 park 的主要目的是：<strong>让排队等待的线程挂起，停止自旋以避免浪费 CPU 资源</strong>，并在需要时通过 unpark 精确唤醒。</p>
<h2>AQS 在 JUC 中的应用场景</h2>
<p>AQS 是 JUC 包的基石，几乎所有同步工具都构建在它之上：</p>
<table>
<thead>
<tr>
<th>同步工具</th>
<th>如何使用 AQS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ReentrantLock</strong></td>
<td>state 表示锁的重入次数。获取锁时 state+1，释放时 state-1。state 为 0 表示锁空闲。同时记录持有锁的线程用于重入检测。</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>state 表示可用许可数。<code>acquireShared</code> 减少计数，<code>tryReleaseShared</code> 增加计数。</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>state 表示计数器。每次 <code>countDown()</code> 减 1，<code>await()</code> 等待 state 变为 0 后所有线程被唤醒。</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>state 的高 16 位保存读锁持有次数，低 16 位保存写锁持有次数。读锁用共享模式，写锁用独占模式。</td>
</tr>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>Worker 内部类继承 AQS，利用独占模式实现对工作线程的状态管理。</td>
</tr>
</tbody></table>
<h3>State 在不同同步器中的语义</h3>
<pre><code>ReentrantLock:       state = 重入次数 (0 = 空闲)
Semaphore:           state = 可用许可数
CountDownLatch:      state = 剩余计数 (0 = 所有线程放行)
ReadWriteLock:       state = [高16位:读锁次数][低16位:写锁次数]
</code></pre>
<h2>自定义同步器示例</h2>
<p>理解 AQS 后，我们可以用极少的代码实现一个简单的互斥锁：</p>
<pre><code class="language-java">public class SimpleLock {

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            return compareAndSetState(0, 1);
        }

        @Override
        protected boolean tryRelease(int arg) {
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
    }

    private final Sync sync = new Sync();

    public void lock()   { sync.acquire(1); }
    public void unlock() { sync.release(1); }
}
</code></pre>
<p>使用：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    SimpleLock lock = new SimpleLock();
    int[] count = {0};

    Runnable task = () -&gt; {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10000; i++) count[0]++;
        } finally {
            lock.unlock();
        }
    };

    Thread t1 = new Thread(task);
    Thread t2 = new Thread(task);
    t1.start(); t2.start();
    t1.join();  t2.join();
    System.out.println(count[0]);  // 始终输出 20000
}
</code></pre>
<p>只需重写 <code>tryAcquire</code> 和 <code>tryRelease</code>，AQS 就接管了排队、阻塞、唤醒、中断处理等全部复杂逻辑。</p>
<h2>总结</h2>
<p>AQS 的设计精髓可以归纳为以下几点：</p>
<ol>
<li><strong>一个 state 变量统一抽象</strong>：不同的同步器通过赋予 state 不同的语义（重入次数、许可数、计数器等），复用同一套框架</li>
<li><strong>CLH 变体双向队列管理等待线程</strong>：通过 FIFO 队列保证公平性，通过 CAS + 自旋保证入队的线程安全</li>
<li><strong>模板方法模式降低接入成本</strong>：自定义同步器只需实现 tryAcquire/tryRelease 等少量方法，框架处理全部排队和唤醒逻辑</li>
<li><strong>park/unpark 精确控制线程状态</strong>：避免自旋空转浪费 CPU，同时支持精确唤醒</li>
<li><strong>从后向前遍历保证正确性</strong>：在非原子入队操作和 CANCELLED 节点处理中，始终保证能遍历到所有有效节点</li>
</ol>
<blockquote>
<p>AQS 是 Doug Lea 在并发编程领域的杰作。理解了 AQS，就理解了 JUC 包中绝大部分同步工具的底层运作方式。它不仅是面试的高频考点，更是我们在实际工程中设计自定义同步器时可以直接借鉴的框架。</p>
</blockquote>
17:T4849,<h2>服务注册中心 <a href="#scroller-1" id="scroller-1"></a></h2>
<p>前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。</p>
<p>并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景下做正确的技术选型。</p>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>Eureka</strong></th>
<th><strong>Zookeeper</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Etcd</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一致性协议</td>
<td>AP</td>
<td>CP（Paxos算法）</td>
<td>CP（Raft算法）</td>
<td>CP（Raft算法）</td>
</tr>
<tr>
<td>健康检查</td>
<td>TTL(Time To Live)</td>
<td>TCP Keep Alive</td>
<td>TTL\HTTP\TCP\Script</td>
<td>Lease TTL KeepAlive</td>
</tr>
<tr>
<td>watch/long polling</td>
<td>不支持</td>
<td>watch</td>
<td>long polling</td>
<td>watch</td>
</tr>
<tr>
<td>雪崩保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>安全与权限</td>
<td>不支持</td>
<td>ACL</td>
<td>ACL</td>
<td>RBAC</td>
</tr>
<tr>
<td>是否支持多数据中心</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有管理界面</td>
<td>是</td>
<td>否（可用第三方ZkTools）</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Spring Cloud 集成</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Dubbo 集成</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>K8S 集成</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>我们可以看出，四种技术类型对Spring Cloud的支持度都很高。Spring Cloud是微服务架构的一站式解决方案，我们平时构建微服务的过程中需要做的的如 配置管理、服务发现、负载均衡、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作。Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<p>Spring Cloud包含了多个不同开源产品，来保证一站式的微服务解决方案，如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p>
<h2>Spring Cloud 框架下实现 <a href="#scroller-2" id="scroller-2"></a></h2>
<p>Spring Cloud为服务治理做了一层抽象，这样能够支持多种不同的服务治理框架，比如：Netflix Eureka、Consul。我们这边就以这两个为例子，看看服务治理是如何实现。</p>
<blockquote>
<p><em>在Spring Cloud服务治理抽象层的作用下，可以无缝地切换服务治理实现，且不影响任何其他的服务注册、发现、调用逻辑。</em></p>
<p><em>所以，下面我们通过介绍这两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。</em></p>
</blockquote>
<h3>2.Spring Cloud Eureka <a href="#scroller-3" id="scroller-3"></a></h3>
<p>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。</p>
<p>通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p>
<p>下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。</p>
<h4>2.1.创建注册中心 <a href="#scroller-4" id="scroller-4"></a></h4>
<p>创建一个Spring Cloud项目，我们命名为micro-service-center，并在<code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="language-xml"> &lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
<p>表明这个项目中可以没有Java代码，也不执行任何代码，只是为了聚合工程或者传递依赖，所以可以把src文件夹删了。这是一个父级项目，因为我们还要在下面建立Eureka的注册中心、客户端等多个子项目 。</p>
<p>在micro-service-center下，新建一个命名为 eureka-service 的Module，依旧是Spring Cloud 项目，建完之后，pom.xml做如下改动：</p>
<pre><code class="language-xml">&lt;xml&gt;
    &lt;!--在子工程中添加父工程名称--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.microservice&lt;/groupId&gt;
        &lt;artifactId&gt;center&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;dependencies&gt;
        &lt;!--加入 eureka 服务 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/xml&gt;
</code></pre>
<p>改完之后，回到父项目micro-service-center，修改pom中的信息：</p>
<pre><code class="language-xml">&lt;xml&gt;
    &lt;groupId&gt;com.microservice&lt;/groupId&gt;
    &lt;artifactId&gt;center&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;name&gt;center&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;!--在父工程添加子工程名称--&gt;
    &lt;modules&gt;
        &lt;module&gt;eureka-service&lt;/module&gt;
        &lt;module&gt;eureka-client&lt;/module&gt;
    &lt;/modules&gt;
&lt;/xml&gt;
</code></pre>
<p>对两个项目进行clean + install，应该是成功的。</p>
<p>eureka-service我们是作为注册中心来用的，所以在它的主类Application中加入<code>@EnableEurekaServer</code>注解，就能开启注册中心功能。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
        System.out.println(&quot;Start Eureka Service&quot;);
    }
}
</code></pre>
<p>但是默认情况下，该注册中心也会把自己当做客户端，那就变成自己注册自己了，这个是可以剔除的，我们看一下它的YAML中的详细配置，注释比较清楚：</p>
<pre><code class="language-yaml">  server:
    port: 1000
  spring:
    application:
      name: eureka-server
  eureka:
    instance:
      hostname: localhost
    client:
    register-with-eureka: false  # 不作为客户端进行注册
    fetch-registry: false  # 不获取注册列表
    service-url:  # 注册地址，客户端需要注册到该地址中
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<p>文中的注释还是比较清楚的。 这边可以看到，端口号是1000，所以当工程启动之后，访问 <a href="http://localhost:1000/">http://localhost:1000/</a> 是可以看到Eureka注册中心页面的。其中还没有发现任何服务。</p>
<p><img src="/images/blog/engineering/microservice-image_7_1.png" alt="image_7_1.png"></p>
<h4>2.1.创建客户端 <a href="#scroller-5" id="scroller-5"></a></h4>
<p>目前服务中心还是空的，所以我们创建一个能够提供服务的客户端，并将其注册到注册中心去。</p>
<p>同样的，我们创建一个Spring Cloud的子项目，命名为<code>eureka-client</code>，<code>pom.xml</code>中的配置如下：</p>
<pre><code class="language-xml">  
&lt;xml&gt;
    &lt;!--在子工程中添加父工程名称--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.microservice&lt;/groupId&gt;
        &lt;artifactId&gt;center&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;dependencies&gt;
        &lt;!--加入 eureka 服务 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/xml&gt;
</code></pre>
<p>在应用主类Application文件中通过加上<code>@EnableDiscoveryClient</code>注解，该注解保证当前服务被Eureka当成provider发现。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
        System.out.println(&quot;start client!&quot;);
    }
}jC
</code></pre>
<p>在YAML文件上加上如下配置：</p>
<pre><code class="language-yaml">server:
  port: 1001
spring:
  application:
    name: eureka-client
eureka:
  client:
    service-url:  # 这边就保证了注册到 eureka-service 这个注册中心去
      defaultZone: http://localhost:1000/eureka/
</code></pre>
<p><code>spring.application.name</code>属性，指定了微服务的名称，在调用的时候可以通过该名称进行服务访问。<code>eureka.client.serviceUrl.defaultZone</code>属性对应服务注册中心的配置内容，指定服务注册中心的位置。</p>
<p>大家看到，这边端口设置为1001，那是因为要在本机上测试 服务提供方 和 服务注册中心，所以<code>server的port</code>属性需设置不同的端口。</p>
<p>最后，我们再写一个接口，通过DiscoveryClient对象，在客户端中获取注册中心的所有服务信息。</p>
<pre><code class="language-java">  @Controller
  @RequestMapping(&quot;/eurekacenter&quot;)
  public class EuServiceController {
  
    @Autowired
    DiscoveryClient discoveryClient;
    
    @RequestMapping(value = &quot;/service&quot;, method = {RequestMethod.GET})
    @ResponseBody
    public String getServiceInfo() {
       return  &quot;service:&quot;+discoveryClient.getServices()+&quot; , memo:&quot;+discoveryClient.description();
    }
}
</code></pre>
<p>这时候跑一下试试看，继续访问之前的地址：<a href="http://localhost:1000/">http://localhost:1000/</a> ，可以看到Eureka注册中心页面已经包含一个我们定义的服务了，就是上面新建的 100端口的服务。</p>
<p><img src="/images/blog/engineering/microservice-image_7_2.png" alt="image_7_2.png"></p>
<p>同样，我们可以调用上面的那个获取注册服务信息的接口，从服务发现的角度看看有多少个服务被注册到注册中心去。 <a href="http://localhost:1001/eurekacenter/service">http://localhost:1001/eurekacenter/service</a></p>
<p><img src="/images/blog/engineering/microservice-image_7_3.png" alt="image_7_3.png"></p>
<p>如上图所示，方括号中的<code>eureka-client</code>通过Spring Cloud定义的 getServiceInfo 接口在eureka的实现中获取到的所有服务清单，他是一个String的List，如果注册了多个提供者，就会全部显示。</p>
<h3>2.Spring Cloud Consul <a href="#scroller-6" id="scroller-6"></a></h3>
<p>Consul 用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更具“一站式”特征，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 之类的）。</p>
<p>而Spring Cloud Consul ，是将其作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。</p>
<h4>2.2.Consul 的优势 <a href="#scroller-7" id="scroller-7"></a></h4>
<p>1、使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接。</p>
<p>2、支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持，上面表格中有体现。</p>
<p>3、支持健康检查。</p>
<p>4、支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。</p>
<p>5、官方提供 web 管理界面, etcd 无此功能。</p>
<h4>2.2.Consul的特性 <a href="#scroller-8" id="scroller-8"></a></h4>
<p>1、服务发现</p>
<p>2、健康检查</p>
<p>3、Key/Value存储</p>
<p>4、多数据中心</p>
<h4>2.2.安装Consul注册中心 <a href="#scroller-9" id="scroller-9"></a></h4>
<p>1、官方下载64版本 ：<a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a></p>
<p>2、解压后复制到目录 /usr/local/bin 下</p>
<p>3、启动终端，先看下啥版本的</p>
<pre><code class="language-sh">liyifei@MacPro ~ % consul --version
Consul v1.10.4
Revision 7bbad6fe
Protocol spoken by default, understands to (agent will automatically use protocol &gt;when speaking to compatible agents)
</code></pre>
<p>4、执行安装命令，可以看到他的 Client Addr 的端口为8500。所以访问 8500端口站点，<a href="http://127.0.0.1:8500/ui/dc1/services">http://127.0.0.1:8500/ui/dc1/services</a></p>
<pre><code class="language-sh">  liyifei@MacPro ~ % consul agent -dev
  ==&gt; Starting Consul agent...
             Version: &#39;1.10.4&#39;
             Node ID: &#39;6db154b4-62ff-e67d-e745-1a7270fa1ce8&#39;
           Node name: &#39;B000000147796DS&#39;
          Datacenter: &#39;dc1&#39; (Segment: &#39;&lt;all&gt;&#39;)
              Server: true (Bootstrap: false)
         Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)
        Cluster Addr: 127.0.0.(LAN: 8301, WAN: 8302)
           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false
</code></pre>
<p><img src="/images/blog/engineering/microservice-image_7_4.png" alt="image_7_4.png"></p>
<p>我们可以看到，现在没有客户端注册上来，只有一个自身的实例。</p>
<h4>2.2.创建服务提供者 <a href="#scroller-10" id="scroller-10"></a></h4>
<p>由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。</p>
<p>我们在micro-service-center下新建一个cloud项目consul-client，该项目pom文件添加如下：</p>
<pre><code class="language-xml">&lt;xml&gt;
  &lt;!--    在子工程中添加父工程名称--&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.microservice&lt;/groupId&gt;
    &lt;artifactId&gt;center&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  
  &lt;dependencies&gt;
    &lt;!--        Consul服务发现--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--        Consul健康检查--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/xml&gt;
</code></pre>
<p>然后修改一下<code>application.yml的配置信息</code>，将consul配置写入，注释应该很清楚了，如下：</p>
<pre><code class="language-yaml">spring:
  application:
    name: consul-producer # 当前服务的名称
  cloud:
    consul: # 以下为Consuk注册中心的地址，如果安装的不是这个host和port，这边可以调整
      host: localhost
      port: 8500
server:
  port: 850# 当前服务的端口
</code></pre>
<p>同样的，我们要在应用主类Application文件中通过加上<code>@EnableDiscoveryClient</code>注解，该注解保证当前服务被Consul当成provider发现。</p>
<p>大家看到这个做法跟Eureka一样，因为Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，</p>
<p>程序上不需要做改变，只需要引入不同的服务治理依赖，并配置相关的配置属性 就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class ConsulClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}
</code></pre>
<p>修改完成之后，我们就可以把这个服务提供者启动了，然后再去注册中心查看服务的注册情况，就可以看到被注册进来的Provider（consul-producer）：</p>
<p><img src="/images/blog/engineering/microservice-image_7_5.png" alt="image_7_5.png"></p>
<h2>总结 <a href="#scroller-11" id="scroller-11"></a></h2>
<p>除了 Eureka、Consul，还有其他的的注册中心技术，如Zookeeper、Nocas等。但无论何种注册中心技术，本质上都是为了解决微服务中的如下问题：</p>
<p><strong>解耦服务之间相互依赖的细节</strong></p>
<p>我们知道服务之间的远程调用必须要知道对方的IP、端口信息。我们可以在调用方直接配置被调用方的IP、端口，这种调用方直接依赖IP、端口的方式存在明显的问题，如被调用的IP、端口变化后，调用方法也要同步修改。</p>
<p>通过服务发现，将服务之间IP与端口的依赖转化为服务名的依赖，服务名可以根据具微服务业务来做标识，因此，屏蔽、解耦服务之间的依赖细节是服务发现与注册解决的第一个问题。</p>
<p><strong>对微服务进行动态管理</strong></p>
<p>在微服务架构中，服务众多，服务之间的相互依赖也错综复杂，无论是服务主动停止，意外挂掉，还是因为流量增加对服务实现进行扩容，这些服务数据或状态上的动态变化，都需要尽快的通知到被调用方，被调用方才采取相应的措施。因此，对于服务注册与发现要实时管理者服务的数据与状态，包括服务的注册上线、服务主动下线，异常服务的剔除。</p>
18:T2b20,<p><a href="https://baijiahao.baidu.com/s?id=1769207484615537227">转载</a></p>
<h4>引言</h4>
<h4>1、队列应用场景：</h4>
<p>MQ（Message Queue，消息队列）<br><strong>消息队列在实际应用中常用的使用场景（优点）</strong>：<code>异步处理</code>，<code>应用解耦</code>，<code>流量削锋</code>和<code>消息通讯</code>四个场景。</p>
<h4>2、目前使用较多的消息队列：</h4>
<p>有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ。</p>
<h4>3、如何选型（目前现状）：</h4>
<p>ActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。最早大家都用 ActiveMQ，但是现在确实大家用的不多了，社区也不是很活跃，不推荐用这个了；</p>
<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，可视化的管理界面比较友好；</p>
<p>不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），它是纯Java开发，它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则老老实实用 RabbitMQ 吧，毕竟RabbitMQ有活跃的开源社区，绝对不会黄。</p>
<p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>
<p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，适合产生大量数据的互联网服务的数据收集业务等。社区活跃度很高，何况几乎是全世界这个领域的事实性规范。kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。</p>
<h4>4、使用消息队列缺点：</h4>
<ul>
<li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，整套系统崩溃了。</li>
<li>系统复杂性提高：加MQ进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li>
<li>一致性问题：A系统处理完了直接返回成功了，后面的如果失败了，这数据就不一致了。</li>
</ul>
<h4>一、RabbitMQ</h4>
<h4>1、RabbitMQ概述</h4>
<p><code>AMQP</code>，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层<strong>标准高级消息队列协议</strong>，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
<p><code>RabbitMQ</code>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。</p>
<p>RabbitMQ 是比较有代表性的，因为是<code>基于主从（非分布式）做高可用性</code>的。</p>
<h4>2、RabbitMQ原理图</h4>
<p>RabbitMQ通过<code>信道</code>的方式传输数据，将消息发布到交换机上，消息拥有一个路邮键，由消息创建时设定，通过队列路由键，可以把队列绑定到交换机上，消息到达交换机后，RabbitMQ将消息的路由键与队列的路由键进行匹配（不同的交换机有不同的路由规则），匹配到相应的队列，消息投递到队列的队列中供消费者消费。</p>
<blockquote>
<p>多个消费者可以订阅同一个Queue，消息将以<code>循环（round-robin）</code>的方式发送给消费者，每条消息只会发给一个订阅的消费者，而不是每个消费者都收到所有的消息并处理。</p>
</blockquote>
<blockquote>
<p>每个Channel运行在独立的线程上，多个线程共享同一个socket。</p>
</blockquote>
<p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/dfde605794cc90a31ce1223c54218372.jpeg@c_1,w_901,h_315,x_0,y_0" alt=""><br><strong>相关概念：</strong></p>
<ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；</li>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li>Channel（信道）：消息推送使用的通道；</li>
<li>Exchange（交换器）：用于接受、分配消息；</li>
<li>Queue（队列）：用于存储生产者的消息；</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；【最大255个字节】</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上；【最大255个字节】</li>
<li>vhost（虚拟主机）每个Rabbit都能创建很多vhost，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。</li>
</ul>
<h4>3、RabbitMQ常用的三种交换机</h4>
<p><strong>RabbitMQ常用的三种Exchange</strong>：fanout,direct,topic</p>
<h4>（1）Direct Exchange ：</h4>
<p>直连型交换机，根据消息携带的路由键将消息投递给对应队列。<br>　　大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key。　然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。</p>
<h4>（2）Fanout Exchange：</h4>
<p>扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。</p>
<h4>（3）Topic Exchange：</h4>
<p>主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。<br>　　<br><strong>性能排序</strong>：fanout &gt; direct &gt;&gt; topic。</p>
<h4>4、 RabbitMQ集群元数据</h4>
<p>RabbitMQ集群会始终同步四种类型的内部元数据：</p>
<ul>
<li>a. 队列元数据：队列名称和它的属性</li>
<li>b. 交换器元数据：交换器名称、类型和属性</li>
<li>c. 绑定元数据：一张简单的表格展示了如何将消息路由到队列</li>
<li>d. vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性</li>
</ul>
<h4>5、RabbitMQ镜像集群</h4>
<p><strong>RabbitMQ 有三种模式</strong>：单机模式、普通集群模式（无高可用性）、<code>镜像集群模式</code>（高可用性）。</p>
<p><code>镜像队列</code>将需要消费的队列变成镜像队列，存在于多个节点，实现RabbitMQ的高可用，保证 100% 数据不丢失。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在消费者消费数据时临时拉取，缺点就是集群内部的<code>同步通讯</code>会占去大量的网络带宽。<br><img src="https://pic.rmb.bdstatic.com/bjh/beautify/53a92fdedade9355420e866bbdb51be1.jpeg@c_1,w_613,h_390,x_0,y_0" alt=""></p>
<h4>二、RocketMQ</h4>
<p><code>RocketMQ</code>是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目。用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p>
<p><strong>RocketMQ缺点：</strong></p>
<ul>
<li>单机支持1万以上持久化队列；</li>
<li>RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。</li>
<li>模型简单，接口易用（JMS的接口很多场合并不太实用）；</li>
<li>性能非常好，可以允许大量堆积消息在Broker中；</li>
<li>支持多种消费模式，包括集群消费、广播消费等；</li>
<li>各个环节分布式扩展设计，支持主从和高可用；</li>
<li>开发度较活跃，版本更新很快。</li>
</ul>
<p><strong>RocketMQ缺点：</strong></p>
<ul>
<li>支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟</li>
<li>维护RocketMQ需要专业的团队</li>
<li>商业版收费，有许多功能是不对外提供的。</li>
<li>没有在MQ核心里实现JMS等接口</li>
</ul>
<h4>三、kafka</h4>
<h4>1、kafka概述</h4>
<p><code>kafka</code>是Linkedin于2010年12月份开源的<code>消息发布订阅</code>系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。作为hadoop生态系统的一部分，被各种商业公司广泛应用。</p>
<p><strong>kafka优点：</strong></p>
<ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<p><strong>kafka缺点：</strong></p>
<ul>
<li>快速持久化：可以在O(1)的系统开销下进行消息持久化；</li>
<li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li>
<li>完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；</li>
<li>支持同步和异步复制两种高可用机制；</li>
<li>支持数据批量发送和拉取；</li>
<li>零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；</li>
<li>数据迁移、扩容对用户透明；</li>
<li>无需停机即可扩展机器；</li>
<li>其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制</li>
</ul>
<h4>2、kafka原理图</h4>
<p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/3d90e1705de49c669f22628af2f6004a.jpeg@c_1,w_1010,h_651,x_0,y_0" alt=""><br><img src="https://pic.rmb.bdstatic.com/bjh/beautify/a5531d658050ce7abecb5ad4242d92ab.jpeg@c_1,w_1002,h_300,x_0,y_0" alt=""></p>
<h4>四、总结</h4>
<p><img src="/images/blog/engineering/middleware-img_20250723_04.png" alt="img_20250723_04.png">{: .full-width}</p>
19:T454,<h1>Maven使用技巧</h1>
<h3>1、使用maven.config定制化配置</h3>
<p>Located within the project&#39;s <strong>top level directory</strong>, the files</p>
<ul>
<li><code>maven.config</code></li>
<li><code>jvm.config</code></li>
<li><code>extensions.xml</code></li>
</ul>
<p>contain project specific configuration for running Maven.</p>
<p>This directory is part of the project and may be checked in into your version control.</p>
<blockquote>
<p>ref：<a href="https://maven.apache.org/configure.html">https://maven.apache.org/configure.html</a></p>
</blockquote>
<p>常见配置如：</p>
<pre><code class="language-bash">-Dmaven.test.skip=true
--settings
/Users/skyfalling/.m2/settings.xml
</code></pre>
<p>There must not be a whitespace after <code>--settings,</code>With the introduction of <code>maven 3.9</code>, there was a BREAKING CHANGE that affects the parsing of the <code>maven.config</code> file:</p>
<p>Each line in <code>.mvn/maven.config</code> is now interpreted as a single argument. That is, if the file contains multiple arguments, these must now be placed on separate lines.</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/middleware/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"中间件"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-03-25","children":"2024年03月25日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"深入理解AQS：Java并发的基石"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","Java",{"href":"/blog/tag/Java/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Java"}],["$","$L13","并发编程",{"href":"/blog/tag/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"并发编程"}],["$","$L13","AQS",{"href":"/blog/tag/AQS/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"AQS"}],["$","$L13","ReentrantLock",{"href":"/blog/tag/ReentrantLock/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"ReentrantLock"}],["$","$L13","JUC",{"href":"/blog/tag/JUC/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"JUC"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/architecture/服务注册与发现（实践篇）","title":"服务注册与发现（实践篇）","description":"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景...","pubDate":"2024-03-24","tags":["微服务","服务发现","工程实践"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/middleware/RabbitMQ、RocketMQ、Kafka区别","title":"RabbitMQ、RocketMQ、Kafka区别","description":"MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ","pubDate":"2024-03-31","tags":["消息队列","中间件","技术选型"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"Java":{"prev":null,"next":{"slug":"engineering/tooling/Maven使用技巧","title":"Maven使用技巧","description":"手把手教你如何在工作中巧妙使用Maven，提升开发效率。","pubDate":"2024-04-03","tags":["Maven","Java","构建工具"],"heroImage":"$undefined","content":"$19"}},"并发编程":{"prev":null,"next":null},"AQS":{"prev":null,"next":null},"ReentrantLock":{"prev":null,"next":null},"JUC":{"prev":null,"next":null}}}]}],["$","$L1a",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"深入理解AQS：Java并发的基石 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。"}],["$","meta","2",{"property":"og:title","content":"深入理解AQS：Java并发的基石"}],["$","meta","3",{"property":"og:description","content":"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-03-25"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"深入理解AQS：Java并发的基石"}],["$","meta","9",{"name":"twitter:description","content":"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

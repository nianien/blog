<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/66b421ed9771e9de.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>深入理解AQS：Java并发的基石 - Skyfalling Blog</title><meta name="description" content="系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。"/><meta property="og:title" content="深入理解AQS：Java并发的基石"/><meta property="og:description" content="系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2025-12-28"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="深入理解AQS：Java并发的基石"/><meta name="twitter:description" content="系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/middleware/page/1/">中间件</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2025-12-28">2025年12月28日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">深入理解AQS：Java并发的基石</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/1/">并发编程</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/AQS/page/1/">AQS</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/ReentrantLock/page/1/">ReentrantLock</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/JUC/page/1/">JUC</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><blockquote>
<p>Java 中的大部分同步工具（ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）都基于 AbstractQueuedSynchronizer（AQS）实现。理解 AQS，就等于掌握了 Java 并发编程的底层脉络。本文从设计思想出发，逐层深入 AQS 的数据结构、核心流程和源码实现，并通过 ReentrantLock 串联全局，最后梳理 AQS 在 JUC 中的应用全景。</p>
</blockquote>
<h2>AQS 是什么？</h2>
<p>AQS（AbstractQueuedSynchronizer）是 <code>java.util.concurrent.locks</code> 包中的一个<strong>抽象类</strong>，是构建锁和同步器的基础框架。Doug Lea 设计 AQS 的核心目标是：</p>
<ul>
<li>降低构建锁和同步器的工作量</li>
<li>避免在多个位置处理竞争问题</li>
<li>在基于 AQS 的同步器中，阻塞只可能在一个时刻发生，降低上下文切换开销，提高吞吐量</li>
</ul>
<p>AQS 支持两种工作模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>典型实现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>独占模式（Exclusive）</strong></td>
<td>同一时刻只能有一个线程获取到锁</td>
<td>ReentrantLock</td>
</tr>
<tr>
<td><strong>共享模式（Shared）</strong></td>
<td>同一时刻可以有多个线程同时获取</td>
<td>CountDownLatch、ReadWriteLock、Semaphore</td>
</tr>
</tbody></table>
<p>无论哪种模式，本质上都是对 AQS 内部一个 <strong><code>state</code> 变量</strong>的获取和释放。</p>
<h2>AQS 的整体架构</h2>
<p>AQS 框架共分为<strong>五层</strong>，自上而下由浅入深：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>第一层</td>
<td>API 层</td>
<td>自定义同步器需重写的方法（tryAcquire、tryRelease 等）</td>
</tr>
<tr>
<td>第二层</td>
<td>获取/释放方法</td>
<td>acquire、release、acquireShared、releaseShared</td>
</tr>
<tr>
<td>第三层</td>
<td>队列操作</td>
<td>addWaiter、acquireQueued、shouldParkAfterFailedAcquire</td>
</tr>
<tr>
<td>第四层</td>
<td>线程阻塞/唤醒</td>
<td>LockSupport.park / unpark</td>
</tr>
<tr>
<td>第五层</td>
<td>基础数据</td>
<td>state、Node、CLH 变体队列</td>
</tr>
</tbody></table>
<p>当接入自定义同步器时，<strong>只需重写第一层的部分方法即可</strong>，不需要关注底层实现。当加锁或解锁操作触发时，沿着第一层到第五层逐层深入。</p>
<h2>核心数据结构</h2>
<h3>同步状态 State</h3>
<p>AQS 使用一个 <code>volatile int</code> 类型的成员变量 <code>state</code> 来表示同步状态：</p>
<pre><code class="language-java">private volatile int state;
</code></pre>
<p>State 的含义由具体的同步器定义，例如：</p>
<ul>
<li><strong>ReentrantLock</strong>：state 表示锁被重入的次数，0 表示未被持有</li>
<li><strong>Semaphore</strong>：state 表示可用许可的数量</li>
<li><strong>CountDownLatch</strong>：state 表示计数器的值</li>
</ul>
<p>AQS 提供三个方法操作 state，均为 <code>final</code> 修饰，子类不可重写：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getState()</code></td>
<td>获取当前 state 值</td>
</tr>
<tr>
<td><code>setState(int)</code></td>
<td>设置 state 值</td>
</tr>
<tr>
<td><code>compareAndSetState(int, int)</code></td>
<td>CAS 方式更新 state</td>
</tr>
</tbody></table>
<h3>CLH 变体队列与 Node 节点</h3>
<p>AQS 的核心思想是：如果请求的共享资源空闲，就将当前线程设置为有效的工作线程，并将资源设置为锁定状态；<strong>如果资源被占用，就通过一个 CLH 变体的 FIFO 双向队列来管理等待线程</strong>。</p>
<blockquote>
<p>CLH 队列以其发明者 Craig、Landin 和 Hagersten 命名，原始 CLH 是单向链表。AQS 中的变体是虚拟双向队列，通过将每条请求线程封装成 Node 节点来实现锁的分配。</p>
</blockquote>
<p>Node 节点的关键属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>thread</code></td>
<td>该节点代表的线程</td>
</tr>
<tr>
<td><code>waitStatus</code></td>
<td>当前节点在队列中的等待状态</td>
</tr>
<tr>
<td><code>prev</code></td>
<td>前驱指针</td>
</tr>
<tr>
<td><code>next</code></td>
<td>后继指针</td>
</tr>
<tr>
<td><code>nextWaiter</code></td>
<td>指向下一个处于 CONDITION 状态的节点</td>
</tr>
</tbody></table>
<p><code>waitStatus</code> 的枚举值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>默认值</td>
<td>Node 初始化时的状态</td>
</tr>
<tr>
<td>1</td>
<td>CANCELLED</td>
<td>线程获取锁的请求已取消</td>
</tr>
<tr>
<td>-1</td>
<td>SIGNAL</td>
<td>后继节点的线程需要被唤醒</td>
</tr>
<tr>
<td>-2</td>
<td>CONDITION</td>
<td>节点在条件队列中，等待 Condition 唤醒</td>
</tr>
<tr>
<td>-3</td>
<td>PROPAGATE</td>
<td>共享模式下，释放操作需要向后传播</td>
</tr>
</tbody></table>
<p>AQS 内部还维护了<strong>两种队列</strong>：</p>
<ul>
<li><strong>同步队列（Sync Queue）</strong>：获取资源失败的线程进入此队列自旋等待，当前驱节点是头节点时尝试获取资源</li>
<li><strong>条件队列（Condition Queue）</strong>：基于 <code>Condition</code> 实现，调用 <code>await()</code> 时线程进入条件队列，调用 <code>signal()</code> 时转移到同步队列</li>
</ul>
<blockquote>
<p>注意：双向链表的<strong>头节点是一个虚节点</strong>（不存储实际线程信息），真正的第一个有效节点从第二个开始。</p>
</blockquote>
<h2>自定义同步器需要重写的方法</h2>
<p>AQS 采用<strong>模板方法模式</strong>，自定义同步器只需根据需要重写以下方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tryAcquire(int)</code></td>
<td>独占</td>
<td>尝试获取资源，成功返回 true</td>
</tr>
<tr>
<td><code>tryRelease(int)</code></td>
<td>独占</td>
<td>尝试释放资源，成功返回 true</td>
</tr>
<tr>
<td><code>tryAcquireShared(int)</code></td>
<td>共享</td>
<td>尝试获取资源，负数=失败，0=成功但无剩余，正数=成功且有剩余</td>
</tr>
<tr>
<td><code>tryReleaseShared(int)</code></td>
<td>共享</td>
<td>尝试释放资源，如果释放后允许唤醒后续节点返回 true</td>
</tr>
<tr>
<td><code>isHeldExclusively()</code></td>
<td>独占</td>
<td>当前线程是否独占资源，用到 Condition 时需实现</td>
</tr>
</tbody></table>
<p>独占模式实现 <code>tryAcquire-tryRelease</code>，共享模式实现 <code>tryAcquireShared-tryReleaseShared</code>。AQS 也支持同时实现两种模式，如 <code>ReentrantReadWriteLock</code>。</p>
<h2>通过 ReentrantLock 理解加锁流程</h2>
<p>ReentrantLock 是 AQS 独占模式最典型的实现。我们以<strong>非公平锁</strong>为例，完整追踪加锁流程。</p>
<h3>第一步：lock()</h3>
<pre><code class="language-java">// ReentrantLock.NonfairSync
final void lock() {
    if (compareAndSetState(0, 1))           // 直接 CAS 尝试获取锁
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);                          // 失败则进入 AQS 框架流程
}
</code></pre>
<p>非公平锁上来就尝试 CAS 抢锁（不管队列中有没有等待线程），这是它&quot;非公平&quot;的体现。</p>
<h3>第二步：acquire()</h3>
<pre><code class="language-java">// AbstractQueuedSynchronizer
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<p>这一行代码浓缩了整个加锁流程的四个步骤：</p>
<pre><code>tryAcquire → addWaiter → acquireQueued → selfInterrupt
</code></pre>
<ol>
<li><strong>tryAcquire</strong>：尝试获取锁（由子类实现）</li>
<li><strong>addWaiter</strong>：获取失败，将当前线程封装为 Node 加入队列尾部</li>
<li><strong>acquireQueued</strong>：在队列中自旋等待，直到获取到锁</li>
<li><strong>selfInterrupt</strong>：如果等待过程中被中断过，补上中断</li>
</ol>
<h3>第三步：tryAcquire（公平 vs 非公平）</h3>
<p><strong>非公平锁</strong>的实现：</p>
<pre><code class="language-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {   // 直接 CAS，不检查队列
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {  // 可重入逻辑
        int nextc = c + acquires;
        if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p><strong>公平锁</strong>的区别仅在于多了一个 <code>hasQueuedPredecessors()</code> 检查：</p>
<pre><code class="language-java">if (c == 0) {
    if (!hasQueuedPredecessors() &amp;&amp;   // 公平锁：先检查队列中是否有等待线程
        compareAndSetState(0, acquires)) {
        setExclusiveOwnerThread(current);
        return true;
    }
}
</code></pre>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>state == 0 时的行为</th>
<th>可重入逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>非公平锁</td>
<td>直接 CAS 抢锁</td>
<td>相同：state + 1</td>
</tr>
<tr>
<td>公平锁</td>
<td>先检查队列再 CAS</td>
<td>相同：state + 1</td>
</tr>
</tbody></table>
<h3>第四步：addWaiter — 入队</h3>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    if (pred != null) {            // 队列已初始化，尝试快速入队
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);                     // 快速入队失败或队列未初始化
    return node;
}
</code></pre>
<p><code>enq()</code> 方法通过<strong>自旋 + CAS</strong> 确保入队成功：</p>
<pre><code class="language-java">private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) {                         // 队列为空，初始化
            if (compareAndSetHead(new Node()))    // 创建虚拟头节点
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<p>线程获取锁的过程可以形象理解为：</p>
<pre><code>线程1获取锁成功 → 线程2申请锁失败 → 线程2入队等待 → 线程3申请失败 → 线程3排在线程2后面 → ...
</code></pre>
<h3>第五步：acquireQueued — 自旋获取锁</h3>
<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {   // 前驱是头节点，尝试获取锁
                setHead(node);                     // 获取成功，当前节点成为新的头节点
                p.next = null;                     // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())           // 获取失败，判断是否需要挂起
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>核心逻辑：<strong>只有前驱节点是头节点的线程才有资格尝试获取锁</strong>。获取失败后，通过 <code>shouldParkAfterFailedAcquire</code> 判断是否需要挂起（将前驱节点的 waitStatus 设为 SIGNAL），然后通过 <code>LockSupport.park()</code> 挂起线程，避免空转浪费 CPU。</p>
<h3>shouldParkAfterFailedAcquire 的三种情况</h3>
<pre><code class="language-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)        // 前驱已经是 SIGNAL，可以安全挂起
        return true;
    if (ws &gt; 0) {                 // 前驱已取消，向前找到有效节点
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {                      // 前驱状态为 0 或 PROPAGATE，设为 SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<table>
<thead>
<tr>
<th>前驱 waitStatus</th>
<th>处理</th>
<th>是否挂起</th>
</tr>
</thead>
<tbody><tr>
<td>SIGNAL (-1)</td>
<td>直接返回 true</td>
<td>是</td>
</tr>
<tr>
<td>CANCELLED (&gt;0)</td>
<td>跳过所有取消节点，重新链接</td>
<td>否，下次循环再判断</td>
</tr>
<tr>
<td>0 或 PROPAGATE</td>
<td>CAS 设为 SIGNAL</td>
<td>否，下次循环再判断</td>
</tr>
</tbody></table>
<h2>解锁流程</h2>
<p>ReentrantLock 解锁时<strong>不区分公平和非公平</strong>：</p>
<pre><code class="language-java">// ReentrantLock
public void unlock() {
    sync.release(1);
}
</code></pre>
<pre><code class="language-java">// AbstractQueuedSynchronizer
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);          // 唤醒后继节点
        return true;
    }
    return false;
}
</code></pre>
<h3>tryRelease — 可重入锁的释放</h3>
<pre><code class="language-java">// ReentrantLock.Sync
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;       // state 减 1
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {                         // 只有 state 减到 0，锁才真正释放
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<h3>unparkSuccessor — 唤醒后继线程</h3>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        // 从尾部向前遍历，找到第一个非取消状态的节点
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);    // 唤醒线程
}
</code></pre>
<blockquote>
<p><strong>为什么要从后向前遍历？</strong> 两个原因：</p>
<ol>
<li><code>addWaiter</code> 中节点入队不是原子操作——<code>node.prev = pred</code> 和 <code>compareAndSetTail</code> 完成后，<code>pred.next = node</code> 可能还未执行。此时从前向后遍历会断链。</li>
<li><code>cancelAcquire</code> 产生 CANCELLED 节点时，先断开的是 next 指针，prev 指针未断开。因此从后向前遍历才能保证遍历完整。</li>
</ol>
</blockquote>
<h2>CANCELLED 节点的处理</h2>
<p>当 <code>acquireQueued</code> 中发生异常时，会执行 <code>cancelAcquire(node)</code> 将节点标记为 CANCELLED。处理逻辑根据节点位置分为三种情况：</p>
<table>
<thead>
<tr>
<th>节点位置</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>尾节点</td>
<td>将前驱设为新的 tail，其 next 置为 null</td>
</tr>
<tr>
<td>头节点的后继</td>
<td>唤醒当前节点的后继线程（unparkSuccessor）</td>
</tr>
<tr>
<td>中间节点</td>
<td>将前驱的 next 指向当前节点的后继，跳过当前节点</td>
</tr>
</tbody></table>
<blockquote>
<p><code>cancelAcquire</code> 只操作 next 指针，不操作 prev 指针。因为执行 cancel 时前驱可能已经出队，修改 prev 不安全。prev 指针的清理留给 <code>shouldParkAfterFailedAcquire</code>——此方法在获取锁失败时执行，此时共享资源已被占用，前方节点不会变化，修改 prev 是安全的。</p>
</blockquote>
<h2>中断处理机制</h2>
<p>AQS 的 <code>acquire</code> 方法是<strong>不可中断</strong>的——线程在等待过程中不会响应中断，而是记录中断状态，等获取到锁后再&quot;补上&quot;中断：</p>
<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 返回 true 说明被中断过
        selfInterrupt();                                  // 补上中断
}

static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
</code></pre>
<p>这种设计的考量是：线程被唤醒时并不知道原因（可能是前驱释放了锁，也可能是被中断），所以通过 <code>Thread.interrupted()</code> 检查并清除中断标记，记录下来，最后在获取锁成功后统一补上。</p>
<h2>park / unpark 机制</h2>
<p>AQS 中线程的阻塞和唤醒通过 <code>LockSupport</code> 实现：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>LockSupport.park(this)</code></td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td><code>LockSupport.unpark(thread)</code></td>
<td>唤醒指定线程</td>
</tr>
</tbody></table>
<p>它们的底层实现是通过 <code>Unsafe</code> 类调用 CPU 原语。相比 <code>Object.wait/notify</code>，park/unpark 的优势在于：</p>
<ul>
<li>不需要在同步块中使用</li>
<li><code>unpark</code> 可以先于 <code>park</code> 调用（基于许可机制）</li>
<li>可以精确唤醒指定线程</li>
</ul>
<p>在 AQS 中使用 park 的主要目的是：<strong>让排队等待的线程挂起，停止自旋以避免浪费 CPU 资源</strong>，并在需要时通过 unpark 精确唤醒。</p>
<h2>AQS 在 JUC 中的应用场景</h2>
<p>AQS 是 JUC 包的基石，几乎所有同步工具都构建在它之上：</p>
<table>
<thead>
<tr>
<th>同步工具</th>
<th>如何使用 AQS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ReentrantLock</strong></td>
<td>state 表示锁的重入次数。获取锁时 state+1，释放时 state-1。state 为 0 表示锁空闲。同时记录持有锁的线程用于重入检测。</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>state 表示可用许可数。<code>acquireShared</code> 减少计数，<code>tryReleaseShared</code> 增加计数。</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>state 表示计数器。每次 <code>countDown()</code> 减 1，<code>await()</code> 等待 state 变为 0 后所有线程被唤醒。</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>state 的高 16 位保存读锁持有次数，低 16 位保存写锁持有次数。读锁用共享模式，写锁用独占模式。</td>
</tr>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>Worker 内部类继承 AQS，利用独占模式实现对工作线程的状态管理。</td>
</tr>
</tbody></table>
<h3>State 在不同同步器中的语义</h3>
<pre><code>ReentrantLock:       state = 重入次数 (0 = 空闲)
Semaphore:           state = 可用许可数
CountDownLatch:      state = 剩余计数 (0 = 所有线程放行)
ReadWriteLock:       state = [高16位:读锁次数][低16位:写锁次数]
</code></pre>
<h2>自定义同步器示例</h2>
<p>理解 AQS 后，我们可以用极少的代码实现一个简单的互斥锁：</p>
<pre><code class="language-java">public class SimpleLock {

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            return compareAndSetState(0, 1);
        }

        @Override
        protected boolean tryRelease(int arg) {
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
    }

    private final Sync sync = new Sync();

    public void lock()   { sync.acquire(1); }
    public void unlock() { sync.release(1); }
}
</code></pre>
<p>使用：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    SimpleLock lock = new SimpleLock();
    int[] count = {0};

    Runnable task = () -&gt; {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10000; i++) count[0]++;
        } finally {
            lock.unlock();
        }
    };

    Thread t1 = new Thread(task);
    Thread t2 = new Thread(task);
    t1.start(); t2.start();
    t1.join();  t2.join();
    System.out.println(count[0]);  // 始终输出 20000
}
</code></pre>
<p>只需重写 <code>tryAcquire</code> 和 <code>tryRelease</code>，AQS 就接管了排队、阻塞、唤醒、中断处理等全部复杂逻辑。</p>
<h2>总结</h2>
<p>AQS 的设计精髓可以归纳为以下几点：</p>
<ol>
<li><strong>一个 state 变量统一抽象</strong>：不同的同步器通过赋予 state 不同的语义（重入次数、许可数、计数器等），复用同一套框架</li>
<li><strong>CLH 变体双向队列管理等待线程</strong>：通过 FIFO 队列保证公平性，通过 CAS + 自旋保证入队的线程安全</li>
<li><strong>模板方法模式降低接入成本</strong>：自定义同步器只需实现 tryAcquire/tryRelease 等少量方法，框架处理全部排队和唤醒逻辑</li>
<li><strong>park/unpark 精确控制线程状态</strong>：避免自旋空转浪费 CPU，同时支持精确唤醒</li>
<li><strong>从后向前遍历保证正确性</strong>：在非原子入队操作和 CANCELLED 节点处理中，始终保证能遍历到所有有效节点</li>
</ol>
<blockquote>
<p>AQS 是 Doug Lea 在并发编程领域的杰作。理解了 AQS，就理解了 JUC 包中绝大部分同步工具的底层运作方式。它不仅是面试的高频考点，更是我们在实际工程中设计自定义同步器时可以直接借鉴的框架。</p>
</blockquote>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/66b421ed9771e9de.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"C33gYo3klV3feVWcJcf5W\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"middleware\",\"%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%9F%B3\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/middleware/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%9F%B3\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/66b421ed9771e9de.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/middleware/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AQS%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%9A%84%E5%9F%BA%E7%9F%B3\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"9SBKPFi4LkFUW_QxTiW_yv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1b:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T5870,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003eJava 中的大部分同步工具（ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）都基于 AbstractQueuedSynchronizer（AQS）实现。理解 AQS，就等于掌握了 Java 并发编程的底层脉络。本文从设计思想出发，逐层深入 AQS 的数据结构、核心流程和源码实现，并通过 ReentrantLock 串联全局，最后梳理 AQS 在 JUC 中的应用全景。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eAQS 是什么？\u003c/h2\u003e\n\u003cp\u003eAQS（AbstractQueuedSynchronizer）是 \u003ccode\u003ejava.util.concurrent.locks\u003c/code\u003e 包中的一个\u003cstrong\u003e抽象类\u003c/strong\u003e，是构建锁和同步器的基础框架。Doug Lea 设计 AQS 的核心目标是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e降低构建锁和同步器的工作量\u003c/li\u003e\n\u003cli\u003e避免在多个位置处理竞争问题\u003c/li\u003e\n\u003cli\u003e在基于 AQS 的同步器中，阻塞只可能在一个时刻发生，降低上下文切换开销，提高吞吐量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAQS 支持两种工作模式：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e典型实现\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e独占模式（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e同一时刻只能有一个线程获取到锁\u003c/td\u003e\n\u003ctd\u003eReentrantLock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e共享模式（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e同一时刻可以有多个线程同时获取\u003c/td\u003e\n\u003ctd\u003eCountDownLatch、ReadWriteLock、Semaphore\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e无论哪种模式，本质上都是对 AQS 内部一个 \u003cstrong\u003e\u003ccode\u003estate\u003c/code\u003e 变量\u003c/strong\u003e的获取和释放。\u003c/p\u003e\n\u003ch2\u003eAQS 的整体架构\u003c/h2\u003e\n\u003cp\u003eAQS 框架共分为\u003cstrong\u003e五层\u003c/strong\u003e，自上而下由浅入深：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e层次\u003c/th\u003e\n\u003cth\u003e内容\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e第一层\u003c/td\u003e\n\u003ctd\u003eAPI 层\u003c/td\u003e\n\u003ctd\u003e自定义同步器需重写的方法（tryAcquire、tryRelease 等）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第二层\u003c/td\u003e\n\u003ctd\u003e获取/释放方法\u003c/td\u003e\n\u003ctd\u003eacquire、release、acquireShared、releaseShared\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第三层\u003c/td\u003e\n\u003ctd\u003e队列操作\u003c/td\u003e\n\u003ctd\u003eaddWaiter、acquireQueued、shouldParkAfterFailedAcquire\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第四层\u003c/td\u003e\n\u003ctd\u003e线程阻塞/唤醒\u003c/td\u003e\n\u003ctd\u003eLockSupport.park / unpark\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第五层\u003c/td\u003e\n\u003ctd\u003e基础数据\u003c/td\u003e\n\u003ctd\u003estate、Node、CLH 变体队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当接入自定义同步器时，\u003cstrong\u003e只需重写第一层的部分方法即可\u003c/strong\u003e，不需要关注底层实现。当加锁或解锁操作触发时，沿着第一层到第五层逐层深入。\u003c/p\u003e\n\u003ch2\u003e核心数据结构\u003c/h2\u003e\n\u003ch3\u003e同步状态 State\u003c/h3\u003e\n\u003cp\u003eAQS 使用一个 \u003ccode\u003evolatile int\u003c/code\u003e 类型的成员变量 \u003ccode\u003estate\u003c/code\u003e 来表示同步状态：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate volatile int state;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eState 的含义由具体的同步器定义，例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eReentrantLock\u003c/strong\u003e：state 表示锁被重入的次数，0 表示未被持有\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e：state 表示可用许可的数量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e：state 表示计数器的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAQS 提供三个方法操作 state，均为 \u003ccode\u003efinal\u003c/code\u003e 修饰，子类不可重写：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003egetState()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e获取当前 state 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003esetState(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e设置 state 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecompareAndSetState(int, int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCAS 方式更新 state\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eCLH 变体队列与 Node 节点\u003c/h3\u003e\n\u003cp\u003eAQS 的核心思想是：如果请求的共享资源空闲，就将当前线程设置为有效的工作线程，并将资源设置为锁定状态；\u003cstrong\u003e如果资源被占用，就通过一个 CLH 变体的 FIFO 双向队列来管理等待线程\u003c/strong\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCLH 队列以其发明者 Craig、Landin 和 Hagersten 命名，原始 CLH 是单向链表。AQS 中的变体是虚拟双向队列，通过将每条请求线程封装成 Node 节点来实现锁的分配。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNode 节点的关键属性：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethread\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e该节点代表的线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ewaitStatus\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e当前节点在队列中的等待状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eprev\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e前驱指针\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e后继指针\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enextWaiter\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e指向下一个处于 CONDITION 状态的节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003ewaitStatus\u003c/code\u003e 的枚举值：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e值\u003c/th\u003e\n\u003cth\u003e名称\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e默认值\u003c/td\u003e\n\u003ctd\u003eNode 初始化时的状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003eCANCELLED\u003c/td\u003e\n\u003ctd\u003e线程获取锁的请求已取消\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003eSIGNAL\u003c/td\u003e\n\u003ctd\u003e后继节点的线程需要被唤醒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-2\u003c/td\u003e\n\u003ctd\u003eCONDITION\u003c/td\u003e\n\u003ctd\u003e节点在条件队列中，等待 Condition 唤醒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-3\u003c/td\u003e\n\u003ctd\u003ePROPAGATE\u003c/td\u003e\n\u003ctd\u003e共享模式下，释放操作需要向后传播\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eAQS 内部还维护了\u003cstrong\u003e两种队列\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e同步队列（Sync Queue）\u003c/strong\u003e：获取资源失败的线程进入此队列自旋等待，当前驱节点是头节点时尝试获取资源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e条件队列（Condition Queue）\u003c/strong\u003e：基于 \u003ccode\u003eCondition\u003c/code\u003e 实现，调用 \u003ccode\u003eawait()\u003c/code\u003e 时线程进入条件队列，调用 \u003ccode\u003esignal()\u003c/code\u003e 时转移到同步队列\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意：双向链表的\u003cstrong\u003e头节点是一个虚节点\u003c/strong\u003e（不存储实际线程信息），真正的第一个有效节点从第二个开始。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e自定义同步器需要重写的方法\u003c/h2\u003e\n\u003cp\u003eAQS 采用\u003cstrong\u003e模板方法模式\u003c/strong\u003e，自定义同步器只需根据需要重写以下方法：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryAcquire(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e尝试获取资源，成功返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryRelease(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e尝试释放资源，成功返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryAcquireShared(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e尝试获取资源，负数=失败，0=成功但无剩余，正数=成功且有剩余\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryReleaseShared(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e尝试释放资源，如果释放后允许唤醒后续节点返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eisHeldExclusively()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e当前线程是否独占资源，用到 Condition 时需实现\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e独占模式实现 \u003ccode\u003etryAcquire-tryRelease\u003c/code\u003e，共享模式实现 \u003ccode\u003etryAcquireShared-tryReleaseShared\u003c/code\u003e。AQS 也支持同时实现两种模式，如 \u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003e通过 ReentrantLock 理解加锁流程\u003c/h2\u003e\n\u003cp\u003eReentrantLock 是 AQS 独占模式最典型的实现。我们以\u003cstrong\u003e非公平锁\u003c/strong\u003e为例，完整追踪加锁流程。\u003c/p\u003e\n\u003ch3\u003e第一步：lock()\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock.NonfairSync\nfinal void lock() {\n    if (compareAndSetState(0, 1))           // 直接 CAS 尝试获取锁\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);                          // 失败则进入 AQS 框架流程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e非公平锁上来就尝试 CAS 抢锁（不管队列中有没有等待线程），这是它\u0026quot;非公平\u0026quot;的体现。\u003c/p\u003e\n\u003ch3\u003e第二步：acquire()\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// AbstractQueuedSynchronizer\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026amp;\u0026amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这一行代码浓缩了整个加锁流程的四个步骤：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etryAcquire → addWaiter → acquireQueued → selfInterrupt\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003etryAcquire\u003c/strong\u003e：尝试获取锁（由子类实现）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eaddWaiter\u003c/strong\u003e：获取失败，将当前线程封装为 Node 加入队列尾部\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eacquireQueued\u003c/strong\u003e：在队列中自旋等待，直到获取到锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eselfInterrupt\u003c/strong\u003e：如果等待过程中被中断过，补上中断\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e第三步：tryAcquire（公平 vs 非公平）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e非公平锁\u003c/strong\u003e的实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {   // 直接 CAS，不检查队列\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {  // 可重入逻辑\n        int nextc = c + acquires;\n        if (nextc \u0026lt; 0) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e公平锁\u003c/strong\u003e的区别仅在于多了一个 \u003ccode\u003ehasQueuedPredecessors()\u003c/code\u003e 检查：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (c == 0) {\n    if (!hasQueuedPredecessors() \u0026amp;\u0026amp;   // 公平锁：先检查队列中是否有等待线程\n        compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁类型\u003c/th\u003e\n\u003cth\u003estate == 0 时的行为\u003c/th\u003e\n\u003cth\u003e可重入逻辑\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e非公平锁\u003c/td\u003e\n\u003ctd\u003e直接 CAS 抢锁\u003c/td\u003e\n\u003ctd\u003e相同：state + 1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平锁\u003c/td\u003e\n\u003ctd\u003e先检查队列再 CAS\u003c/td\u003e\n\u003ctd\u003e相同：state + 1\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e第四步：addWaiter — 入队\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    Node pred = tail;\n    if (pred != null) {            // 队列已初始化，尝试快速入队\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);                     // 快速入队失败或队列未初始化\n    return node;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eenq()\u003c/code\u003e 方法通过\u003cstrong\u003e自旋 + CAS\u003c/strong\u003e 确保入队成功：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) {                         // 队列为空，初始化\n            if (compareAndSetHead(new Node()))    // 创建虚拟头节点\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e线程获取锁的过程可以形象理解为：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程1获取锁成功 → 线程2申请锁失败 → 线程2入队等待 → 线程3申请失败 → 线程3排在线程2后面 → ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e第五步：acquireQueued — 自旋获取锁\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {   // 前驱是头节点，尝试获取锁\n                setHead(node);                     // 获取成功，当前节点成为新的头节点\n                p.next = null;                     // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp;\n                parkAndCheckInterrupt())           // 获取失败，判断是否需要挂起\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e核心逻辑：\u003cstrong\u003e只有前驱节点是头节点的线程才有资格尝试获取锁\u003c/strong\u003e。获取失败后，通过 \u003ccode\u003eshouldParkAfterFailedAcquire\u003c/code\u003e 判断是否需要挂起（将前驱节点的 waitStatus 设为 SIGNAL），然后通过 \u003ccode\u003eLockSupport.park()\u003c/code\u003e 挂起线程，避免空转浪费 CPU。\u003c/p\u003e\n\u003ch3\u003eshouldParkAfterFailedAcquire 的三种情况\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)        // 前驱已经是 SIGNAL，可以安全挂起\n        return true;\n    if (ws \u0026gt; 0) {                 // 前驱已取消，向前找到有效节点\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus \u0026gt; 0);\n        pred.next = node;\n    } else {                      // 前驱状态为 0 或 PROPAGATE，设为 SIGNAL\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e前驱 waitStatus\u003c/th\u003e\n\u003cth\u003e处理\u003c/th\u003e\n\u003cth\u003e是否挂起\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eSIGNAL (-1)\u003c/td\u003e\n\u003ctd\u003e直接返回 true\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCANCELLED (\u0026gt;0)\u003c/td\u003e\n\u003ctd\u003e跳过所有取消节点，重新链接\u003c/td\u003e\n\u003ctd\u003e否，下次循环再判断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e0 或 PROPAGATE\u003c/td\u003e\n\u003ctd\u003eCAS 设为 SIGNAL\u003c/td\u003e\n\u003ctd\u003e否，下次循环再判断\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e解锁流程\u003c/h2\u003e\n\u003cp\u003eReentrantLock 解锁时\u003cstrong\u003e不区分公平和非公平\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock\npublic void unlock() {\n    sync.release(1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// AbstractQueuedSynchronizer\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null \u0026amp;\u0026amp; h.waitStatus != 0)\n            unparkSuccessor(h);          // 唤醒后继节点\n        return true;\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003etryRelease — 可重入锁的释放\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock.Sync\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;       // state 减 1\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {                         // 只有 state 减到 0，锁才真正释放\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eunparkSuccessor — 唤醒后继线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void unparkSuccessor(Node node) {\n    int ws = node.waitStatus;\n    if (ws \u0026lt; 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    Node s = node.next;\n    if (s == null || s.waitStatus \u0026gt; 0) {\n        s = null;\n        // 从尾部向前遍历，找到第一个非取消状态的节点\n        for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev)\n            if (t.waitStatus \u0026lt;= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);    // 唤醒线程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e为什么要从后向前遍历？\u003c/strong\u003e 两个原因：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eaddWaiter\u003c/code\u003e 中节点入队不是原子操作——\u003ccode\u003enode.prev = pred\u003c/code\u003e 和 \u003ccode\u003ecompareAndSetTail\u003c/code\u003e 完成后，\u003ccode\u003epred.next = node\u003c/code\u003e 可能还未执行。此时从前向后遍历会断链。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecancelAcquire\u003c/code\u003e 产生 CANCELLED 节点时，先断开的是 next 指针，prev 指针未断开。因此从后向前遍历才能保证遍历完整。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eCANCELLED 节点的处理\u003c/h2\u003e\n\u003cp\u003e当 \u003ccode\u003eacquireQueued\u003c/code\u003e 中发生异常时，会执行 \u003ccode\u003ecancelAcquire(node)\u003c/code\u003e 将节点标记为 CANCELLED。处理逻辑根据节点位置分为三种情况：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e节点位置\u003c/th\u003e\n\u003cth\u003e处理方式\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e尾节点\u003c/td\u003e\n\u003ctd\u003e将前驱设为新的 tail，其 next 置为 null\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e头节点的后继\u003c/td\u003e\n\u003ctd\u003e唤醒当前节点的后继线程（unparkSuccessor）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e中间节点\u003c/td\u003e\n\u003ctd\u003e将前驱的 next 指向当前节点的后继，跳过当前节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ecancelAcquire\u003c/code\u003e 只操作 next 指针，不操作 prev 指针。因为执行 cancel 时前驱可能已经出队，修改 prev 不安全。prev 指针的清理留给 \u003ccode\u003eshouldParkAfterFailedAcquire\u003c/code\u003e——此方法在获取锁失败时执行，此时共享资源已被占用，前方节点不会变化，修改 prev 是安全的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e中断处理机制\u003c/h2\u003e\n\u003cp\u003eAQS 的 \u003ccode\u003eacquire\u003c/code\u003e 方法是\u003cstrong\u003e不可中断\u003c/strong\u003e的——线程在等待过程中不会响应中断，而是记录中断状态，等获取到锁后再\u0026quot;补上\u0026quot;中断：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026amp;\u0026amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 返回 true 说明被中断过\n        selfInterrupt();                                  // 补上中断\n}\n\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种设计的考量是：线程被唤醒时并不知道原因（可能是前驱释放了锁，也可能是被中断），所以通过 \u003ccode\u003eThread.interrupted()\u003c/code\u003e 检查并清除中断标记，记录下来，最后在获取锁成功后统一补上。\u003c/p\u003e\n\u003ch2\u003epark / unpark 机制\u003c/h2\u003e\n\u003cp\u003eAQS 中线程的阻塞和唤醒通过 \u003ccode\u003eLockSupport\u003c/code\u003e 实现：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLockSupport.park(this)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e阻塞当前线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLockSupport.unpark(thread)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e唤醒指定线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e它们的底层实现是通过 \u003ccode\u003eUnsafe\u003c/code\u003e 类调用 CPU 原语。相比 \u003ccode\u003eObject.wait/notify\u003c/code\u003e，park/unpark 的优势在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不需要在同步块中使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunpark\u003c/code\u003e 可以先于 \u003ccode\u003epark\u003c/code\u003e 调用（基于许可机制）\u003c/li\u003e\n\u003cli\u003e可以精确唤醒指定线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在 AQS 中使用 park 的主要目的是：\u003cstrong\u003e让排队等待的线程挂起，停止自旋以避免浪费 CPU 资源\u003c/strong\u003e，并在需要时通过 unpark 精确唤醒。\u003c/p\u003e\n\u003ch2\u003eAQS 在 JUC 中的应用场景\u003c/h2\u003e\n\u003cp\u003eAQS 是 JUC 包的基石，几乎所有同步工具都构建在它之上：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e同步工具\u003c/th\u003e\n\u003cth\u003e如何使用 AQS\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eReentrantLock\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示锁的重入次数。获取锁时 state+1，释放时 state-1。state 为 0 表示锁空闲。同时记录持有锁的线程用于重入检测。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示可用许可数。\u003ccode\u003eacquireShared\u003c/code\u003e 减少计数，\u003ccode\u003etryReleaseShared\u003c/code\u003e 增加计数。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示计数器。每次 \u003ccode\u003ecountDown()\u003c/code\u003e 减 1，\u003ccode\u003eawait()\u003c/code\u003e 等待 state 变为 0 后所有线程被唤醒。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eReentrantReadWriteLock\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 的高 16 位保存读锁持有次数，低 16 位保存写锁持有次数。读锁用共享模式，写锁用独占模式。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eThreadPoolExecutor\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eWorker 内部类继承 AQS，利用独占模式实现对工作线程的状态管理。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eState 在不同同步器中的语义\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eReentrantLock:       state = 重入次数 (0 = 空闲)\nSemaphore:           state = 可用许可数\nCountDownLatch:      state = 剩余计数 (0 = 所有线程放行)\nReadWriteLock:       state = [高16位:读锁次数][低16位:写锁次数]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e自定义同步器示例\u003c/h2\u003e\n\u003cp\u003e理解 AQS 后，我们可以用极少的代码实现一个简单的互斥锁：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SimpleLock {\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    public void lock()   { sync.acquire(1); }\n    public void unlock() { sync.release(1); }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) throws InterruptedException {\n    SimpleLock lock = new SimpleLock();\n    int[] count = {0};\n\n    Runnable task = () -\u0026gt; {\n        lock.lock();\n        try {\n            for (int i = 0; i \u0026lt; 10000; i++) count[0]++;\n        } finally {\n            lock.unlock();\n        }\n    };\n\n    Thread t1 = new Thread(task);\n    Thread t2 = new Thread(task);\n    t1.start(); t2.start();\n    t1.join();  t2.join();\n    System.out.println(count[0]);  // 始终输出 20000\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只需重写 \u003ccode\u003etryAcquire\u003c/code\u003e 和 \u003ccode\u003etryRelease\u003c/code\u003e，AQS 就接管了排队、阻塞、唤醒、中断处理等全部复杂逻辑。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eAQS 的设计精髓可以归纳为以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e一个 state 变量统一抽象\u003c/strong\u003e：不同的同步器通过赋予 state 不同的语义（重入次数、许可数、计数器等），复用同一套框架\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCLH 变体双向队列管理等待线程\u003c/strong\u003e：通过 FIFO 队列保证公平性，通过 CAS + 自旋保证入队的线程安全\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模板方法模式降低接入成本\u003c/strong\u003e：自定义同步器只需实现 tryAcquire/tryRelease 等少量方法，框架处理全部排队和唤醒逻辑\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epark/unpark 精确控制线程状态\u003c/strong\u003e：避免自旋空转浪费 CPU，同时支持精确唤醒\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从后向前遍历保证正确性\u003c/strong\u003e：在非原子入队操作和 CANCELLED 节点处理中，始终保证能遍历到所有有效节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAQS 是 Doug Lea 在并发编程领域的杰作。理解了 AQS，就理解了 JUC 包中绝大部分同步工具的底层运作方式。它不仅是面试的高频考点，更是我们在实际工程中设计自定义同步器时可以直接借鉴的框架。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"17:Td28a,"])</script><script>self.__next_f.push([1,"\u003ch1\u003ePrompt Engineering for Agents: 面向 Agent 的提示词工程\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAgentic 系列第 06 篇。前文我们讨论了 Tool Calling 的设计哲学与工程实践，LLM 已经具备了\u0026quot;使用工具\u0026quot;的能力。但工具只是 Agent 的四肢，Prompt 才是 Agent 的大脑皮层——它定义了 Agent 如何感知、如何推理、如何决策、如何行动。\u003c/p\u003e\n\u003cp\u003e本文的核心观点：\u003cstrong\u003eAgent 的 Prompt 不是\u0026quot;聊天提示词\u0026quot;，而是\u0026quot;系统接口规范\u0026quot;。\u003c/strong\u003e Chatbot 的 Prompt 追求对话自然，Agent 的 Prompt 追求行为可控。这两者的设计哲学截然不同。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e1. 从\u0026quot;对话技巧\u0026quot;到\u0026quot;接口规范\u0026quot;\u003c/h2\u003e\n\u003cp\u003e大多数人对 Prompt Engineering 的印象停留在\u0026quot;写好提示词让 AI 回答更好\u0026quot;的阶段。这在 Chatbot 场景下基本成立——你调整措辞、给几个例子、加一句\u0026quot;请一步一步思考\u0026quot;，模型输出的质量就会改善。\u003c/p\u003e\n\u003cp\u003e但 Agent 场景完全不同。\u003c/p\u003e\n\u003cp\u003eAgent 的 Prompt 不是写给\u0026quot;一个聊天助手\u0026quot;的，而是写给\u0026quot;一个程序运行时\u0026quot;的。它的目的不是让输出\u0026quot;看起来更好\u0026quot;，而是让输出\u003cstrong\u003e可解析、可路由、可执行\u003c/strong\u003e。一个 Agent Prompt 的失败，不是\u0026quot;回答不够好\u0026quot;，而是\u003cstrong\u003e系统崩溃\u003c/strong\u003e——JSON 解析失败、工具调用参数错误、无限循环、状态机卡死。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003eChatbot Prompt\u003c/th\u003e\n\u003cth\u003eAgent Prompt\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e目标\u003c/td\u003e\n\u003ctd\u003e自然、有帮助的回复\u003c/td\u003e\n\u003ctd\u003e可解析、可执行的结构化输出\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e消费者\u003c/td\u003e\n\u003ctd\u003e人类用户\u003c/td\u003e\n\u003ctd\u003e程序代码（Parser / Router / Executor）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e失败模式\u003c/td\u003e\n\u003ctd\u003e回答质量下降\u003c/td\u003e\n\u003ctd\u003e系统崩溃、无限循环、安全漏洞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e格式要求\u003c/td\u003e\n\u003ctd\u003e宽松，Markdown 即可\u003c/td\u003e\n\u003ctd\u003e严格，JSON / XML / 特定 Schema\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e可测试性\u003c/td\u003e\n\u003ctd\u003e主观评估\u003c/td\u003e\n\u003ctd\u003e可自动化断言\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e版本管理\u003c/td\u003e\n\u003ctd\u003e通常不管理\u003c/td\u003e\n\u003ctd\u003e必须版本控制，等同于代码\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这意味着，\u003cstrong\u003eAgent 的 Prompt Engineering 本质上是一种接口设计（Interface Design）\u003c/strong\u003e，而不是文案写作。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e2. Agent Prompt 的分层架构\u003c/h2\u003e\n\u003cp\u003e一个成熟的 Agent 系统，发送给 LLM 的 Prompt 不是一坨字符串，而是多个层次动态组装的结果。\u003c/p\u003e\n\u003ch3\u003e2.1 四层结构\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e┌─────────────────────────────────────────────────────┐\n│                   Final Prompt                       │\n│  ┌───────────────────────────────────────────────┐  │\n│  │  Layer 1: System Prompt (静态)                 │  │\n│  │  - 身份定义（你是谁，你的职责是什么）            │  │\n│  │  - 行为约束（必须做什么，禁止做什么）            │  │\n│  │  - 输出格式规范（JSON Schema / XML 模板）       │  │\n│  ├───────────────────────────────────────────────┤  │\n│  │  Layer 2: Context Injection (动态)             │  │\n│  │  - 可用工具列表及其描述                         │  │\n│  │  - 历史对话摘要 / 关键事实                      │  │\n│  │  - 当前系统状态（已完成步骤、中间结果）           │  │\n│  │  - 检索到的外部知识（RAG 结果）                  │  │\n│  ├───────────────────────────────────────────────┤  │\n│  │  Layer 3: User Input (外部)                    │  │\n│  │  - 用户的原始请求                               │  │\n│  │  - 或上一步 Agent 的输出（在 Multi-Agent 中）    │  │\n│  ├───────────────────────────────────────────────┤  │\n│  │  Layer 4: Constraints \u0026amp; Guardrails (静态+动态)  │  │\n│  │  - 安全边界（禁止调用的工具、禁止访问的数据）     │  │\n│  │  - 输出限制（最大步骤数、Token 预算）            │  │\n│  │  - 当前 Turn 的特殊指令                         │  │\n│  └───────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.2 组装过程\u003c/h3\u003e\n\u003cp\u003ePrompt 组装不是简单的字符串拼接，而是一个有优先级、有裁剪策略的构建过程：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                  Token Budget: 8000\n                       │\n      ┌────────────────┼────────────────┐\n      │                │                │\n      ▼                ▼                ▼\n System Prompt    Context Injection   User Input\n (固定预算:2000)  (弹性预算:4500)    (固定预算:1500)\n      │                │                │\n      │          ┌─────┴─────┐          │\n      │          │           │          │\n      │      Tool Descs   History       │\n      │      (1500 max)  (3000 max)     │\n      │          │           │          │\n      │          │     [若超预算]        │\n      │          │     → 压缩/截断      │\n      │          │           │          │\n      ▼          ▼           ▼          ▼\n     ┌──────────────────────────────────┐\n     │      Prompt Assembler            │\n     │  1. 拼装各层                      │\n     │  2. 计算总 Token                  │\n     │  3. 若超预算 → 压缩 Context 层    │\n     │  4. 注入 Constraints              │\n     └──────────────────────────────────┘\n                    │\n                    ▼\n              Final Prompt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e关键设计决策：\u003cstrong\u003eSystem Prompt 和 User Input 的预算是固定的，Context Injection 的预算是弹性的。\u003c/strong\u003e 当总 Token 超出预算时，优先压缩 Context 层（截断历史、精简工具描述），而非删减 System Prompt 中的行为约束。因为行为约束一旦丢失，Agent 的行为就不可控了。\u003c/p\u003e\n\u003ch3\u003e2.3 Python 示例：Prompt 组装器\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass, field\n\n@dataclass\nclass PromptLayer:\n    content: str\n    priority: int        # 越高越不容易被裁剪\n    max_tokens: int\n    compressible: bool   # 是否允许被压缩\n\n@dataclass\nclass PromptAssembler:\n    total_budget: int = 8000\n    layers: list[PromptLayer] = field(default_factory=list)\n\n    def add_layer(self, layer: PromptLayer):\n        self.layers.append(layer)\n\n    def assemble(self) -\u0026gt; str:\n        # 按优先级排序：高优先级最后处理（最不容易被裁剪）\n        sorted_layers = sorted(self.layers, key=lambda l: l.priority)\n\n        total_used = sum(estimate_tokens(l.content) for l in self.layers)\n\n        if total_used \u0026gt; self.total_budget:\n            overflow = total_used - self.total_budget\n            # 从低优先级开始压缩\n            for layer in sorted_layers:\n                if not layer.compressible:\n                    continue\n                available_cut = estimate_tokens(layer.content) - 100  # 至少保留 100 token\n                cut = min(overflow, available_cut)\n                layer.content = truncate_to_tokens(layer.content,\n                                                    estimate_tokens(layer.content) - cut)\n                overflow -= cut\n                if overflow \u0026lt;= 0:\n                    break\n\n        # 按原始顺序拼装\n        return \u0026quot;\\n\\n\u0026quot;.join(l.content for l in self.layers)\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 四种关键 Agent Prompt 设计模式\u003c/h2\u003e\n\u003cp\u003eAgent 系统中，不同角色的 Agent 需要不同风格的 Prompt。以下是四种最核心的设计模式，每种都给出完整可用的 Prompt 示例。\u003c/p\u003e\n\u003ch3\u003e3.1 Router Prompt：意图路由\u003c/h3\u003e\n\u003cp\u003eRouter 的职责是根据用户输入\u003cstrong\u003e选择正确的工具或子流程\u003c/strong\u003e，而不是自己去执行任务。它是 Agent 系统的\u0026quot;交通警察\u0026quot;。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eROUTER_PROMPT = \u0026quot;\u0026quot;\u0026quot;You are a request router. Your ONLY job is to analyze the user\u0026#39;s\nrequest and select the appropriate tool. Do NOT attempt to answer the question yourself.\n\n## Available Tools\n{tool_descriptions}\n\n## Routing Rules\n1. If the request involves real-time data (weather, stock prices, news) → use `web_search`\n2. If the request involves the user\u0026#39;s own data (files, emails, calendar) → use `data_query`\n3. If the request involves code generation or debugging → use `code_assistant`\n4. If the request involves image generation or editing → use `image_tool`\n5. If the request is ambiguous, ask a clarifying question instead of guessing.\n6. If NO tool matches, respond with tool_name: \u0026quot;none\u0026quot; and explain why.\n\n## Output Format (strict JSON, no markdown fence)\n{{\n  \u0026quot;reasoning\u0026quot;: \u0026quot;\u0026lt;one sentence explaining your routing decision\u0026gt;\u0026quot;,\n  \u0026quot;tool_name\u0026quot;: \u0026quot;\u0026lt;exact tool name from the list above, or \u0026#39;none\u0026#39;\u0026gt;\u0026quot;,\n  \u0026quot;tool_input\u0026quot;: {{\u0026lt;parameters to pass to the selected tool\u0026gt;}},\n  \u0026quot;confidence\u0026quot;: \u0026lt;float between 0.0 and 1.0\u0026gt;\n}}\n\n## Critical Constraints\n- NEVER fabricate a tool name not in the list.\n- NEVER return free-form text. ALWAYS return valid JSON.\n- If confidence \u0026lt; 0.6, set tool_name to \u0026quot;none\u0026quot; and ask for clarification.\n\u0026quot;\u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e设计要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e明确告诉 LLM \u0026quot;你不负责回答问题\u0026quot;，避免它自作主张直接回答\u003c/li\u003e\n\u003cli\u003e提供确定性的路由规则（if-then），减少 LLM 的自由裁量空间\u003c/li\u003e\n\u003cli\u003e要求输出 confidence 分数，让调用方可以做二次判断\u003c/li\u003e\n\u003cli\u003e兜底规则：没有匹配的工具时，显式输出 \u0026quot;none\u0026quot;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.2 Planner Prompt：任务规划\u003c/h3\u003e\n\u003cp\u003ePlanner 的职责是将一个复杂请求\u003cstrong\u003e分解为可执行的子任务列表\u003c/strong\u003e。它是 Agent 的\u0026quot;项目经理\u0026quot;。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ePLANNER_PROMPT = \u0026quot;\u0026quot;\u0026quot;You are a task planner. Given a complex user request, decompose it\ninto a sequence of concrete, executable sub-tasks.\n\n## Planning Principles\n1. Each sub-task must be independently executable by a single tool call.\n2. Sub-tasks should be ordered by dependency — a task can only depend on tasks before it.\n3. Minimize the number of steps. Do NOT over-decompose simple requests.\n4. If a request can be done in ONE tool call, return a plan with ONE step.\n\n## Available Tools\n{tool_descriptions}\n\n## Output Format (strict JSON)\n{{\n  \u0026quot;analysis\u0026quot;: \u0026quot;\u0026lt;brief analysis of the request\u0026#39;s complexity and required resources\u0026gt;\u0026quot;,\n  \u0026quot;plan\u0026quot;: [\n    {{\n      \u0026quot;step_id\u0026quot;: 1,\n      \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;what this step does\u0026gt;\u0026quot;,\n      \u0026quot;tool_name\u0026quot;: \u0026quot;\u0026lt;tool to use\u0026gt;\u0026quot;,\n      \u0026quot;tool_input\u0026quot;: {{\u0026lt;parameters\u0026gt;}},\n      \u0026quot;depends_on\u0026quot;: []\n    }},\n    {{\n      \u0026quot;step_id\u0026quot;: 2,\n      \u0026quot;description\u0026quot;: \u0026quot;\u0026lt;what this step does\u0026gt;\u0026quot;,\n      \u0026quot;tool_name\u0026quot;: \u0026quot;\u0026lt;tool to use\u0026gt;\u0026quot;,\n      \u0026quot;tool_input\u0026quot;: {{\u0026lt;parameters, can reference $step_1_result\u0026gt;}},\n      \u0026quot;depends_on\u0026quot;: [1]\n    }}\n  ],\n  \u0026quot;estimated_steps\u0026quot;: \u0026lt;int\u0026gt;,\n  \u0026quot;can_parallelize\u0026quot;: [\u0026lt;list of step_id groups that can run concurrently\u0026gt;]\n}}\n\n## Constraints\n- Maximum 8 steps. If the task seems to need more, simplify or ask the user to narrow scope.\n- NEVER include steps like \u0026quot;verify result\u0026quot; or \u0026quot;report to user\u0026quot; — those are handled by the system.\n- Use $step_N_result to reference the output of a previous step.\n\u0026quot;\u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e设计要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026quot;最小化步骤数\u0026quot;原则防止 LLM 过度分解（这是规划器最常见的问题）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edepends_on\u003c/code\u003e 字段使得执行引擎可以识别并行机会\u003c/li\u003e\n\u003cli\u003e明确设置步骤上限（8 步），避免 LLM 生成无休止的计划\u003c/li\u003e\n\u003cli\u003e禁止 LLM 添加\u0026quot;元步骤\u0026quot;（验证、汇报），这些是系统层的职责\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.3 Executor Prompt：执行操作\u003c/h3\u003e\n\u003cp\u003eExecutor 的职责是\u003cstrong\u003e执行单个具体操作\u003c/strong\u003e，并以严格的格式返回结果。它是 Agent 的\u0026quot;操作工\u0026quot;。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eEXECUTOR_PROMPT = \u0026quot;\u0026quot;\u0026quot;You are a task executor. You will receive a specific sub-task and\nmust execute it using the provided tool.\n\n## Current Task\n{task_description}\n\n## Tool to Use\nName: {tool_name}\nSchema: {tool_schema}\n\n## Context from Previous Steps\n{previous_results}\n\n## Execution Rules\n1. Call the tool EXACTLY ONCE with the correct parameters.\n2. Do NOT deviate from the task description.\n3. Do NOT call tools not specified for this task.\n4. If the tool call fails, report the error — do NOT retry or improvise.\n\n## Output Format (strict JSON)\n{{\n  \u0026quot;tool_call\u0026quot;: {{\n    \u0026quot;name\u0026quot;: \u0026quot;{tool_name}\u0026quot;,\n    \u0026quot;arguments\u0026quot;: {{\u0026lt;filled parameters\u0026gt;}}\n  }},\n  \u0026quot;explanation\u0026quot;: \u0026quot;\u0026lt;one sentence on why these parameters were chosen\u0026gt;\u0026quot;\n}}\n\u0026quot;\u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e设计要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExecutor 的设计哲学是\u0026quot;最小权限\u0026quot;——只做被告知的事\u003c/li\u003e\n\u003cli\u003e严禁 Executor 自主决策，发现错误只能上报，不能自行重试\u003c/li\u003e\n\u003cli\u003e这种设计让 Executor 成为一个确定性单元，便于测试和审计\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.4 Reflector Prompt：结果反思\u003c/h3\u003e\n\u003cp\u003eReflector 的职责是\u003cstrong\u003e评估执行结果\u003c/strong\u003e，判断是否达成目标，如果未达成则提出修正方案。它是 Agent 的\u0026quot;质量检查员\u0026quot;。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eREFLECTOR_PROMPT = \u0026quot;\u0026quot;\u0026quot;You are a result evaluator. Given the original user request and the\nexecution result, determine whether the task has been completed successfully.\n\n## Original Request\n{user_request}\n\n## Execution Plan\n{plan}\n\n## Execution Results\n{results}\n\n## Evaluation Criteria\n1. Completeness: Does the result fully address the user\u0026#39;s request?\n2. Correctness: Is the result factually and logically correct?\n3. Format: Is the result in the expected format?\n\n## Output Format (strict JSON)\n{{\n  \u0026quot;evaluation\u0026quot;: {{\n    \u0026quot;completeness\u0026quot;: {{\u0026quot;score\u0026quot;: \u0026lt;1-5\u0026gt;, \u0026quot;reason\u0026quot;: \u0026quot;\u0026lt;explanation\u0026gt;\u0026quot;}},\n    \u0026quot;correctness\u0026quot;: {{\u0026quot;score\u0026quot;: \u0026lt;1-5\u0026gt;, \u0026quot;reason\u0026quot;: \u0026quot;\u0026lt;explanation\u0026gt;\u0026quot;}},\n    \u0026quot;format\u0026quot;: {{\u0026quot;score\u0026quot;: \u0026lt;1-5\u0026gt;, \u0026quot;reason\u0026quot;: \u0026quot;\u0026lt;explanation\u0026gt;\u0026quot;}}\n  }},\n  \u0026quot;overall_pass\u0026quot;: \u0026lt;true|false\u0026gt;,\n  \u0026quot;action\u0026quot;: \u0026quot;\u0026lt;one of: \u0026#39;accept\u0026#39;, \u0026#39;retry_step\u0026#39;, \u0026#39;replan\u0026#39;, \u0026#39;escalate\u0026#39;\u0026gt;\u0026quot;,\n  \u0026quot;retry_details\u0026quot;: {{\n    \u0026quot;step_id\u0026quot;: \u0026lt;which step to retry, if applicable\u0026gt;,\n    \u0026quot;modification\u0026quot;: \u0026quot;\u0026lt;what to change in the retry\u0026gt;\u0026quot;\n  }}\n}}\n\n## Decision Rules\n- If all scores \u0026gt;= 4: action = \u0026quot;accept\u0026quot;\n- If any score \u0026lt;= 2 and retry_count \u0026lt; 3: action = \u0026quot;retry_step\u0026quot; or \u0026quot;replan\u0026quot;\n- If retry_count \u0026gt;= 3: action = \u0026quot;escalate\u0026quot; (ask user for help)\n- NEVER accept a result with correctness score \u0026lt;= 2.\n\u0026quot;\u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e设计要点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e多维度评估（完整性、正确性、格式）而非简单的 pass/fail\u003c/li\u003e\n\u003cli\u003e明确的决策规则，减少 LLM 判断的主观性\u003c/li\u003e\n\u003cli\u003eretry_count 上限防止无限重试循环\u003c/li\u003e\n\u003cli\u003e\u0026quot;escalate\u0026quot; 作为最终兜底——承认失败比无限循环好得多\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.5 四种模式的协作\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eUser Request\n     │\n     ▼\n ┌────────┐     tool_name + input     ┌──────────┐\n │ Router │ ──── (简单请求直接执行) ───→│ Executor │──→ Result\n └────┬───┘                           └──────────┘\n      │ (复杂请求)                          ▲\n      ▼                                    │\n ┌─────────┐    plan[step_1..N]     ┌──────┴───┐\n │ Planner │ ─────────────────────→│ Executor  │\n └─────────┘                       │ (per step)│\n                                   └──────┬───┘\n                                          │ results\n                                          ▼\n                                   ┌───────────┐\n                                   │ Reflector  │\n                                   └─────┬─────┘\n                                         │\n                              ┌──────────┼──────────┐\n                              │          │          │\n                           accept    retry_step   replan\n                              │          │          │\n                              ▼          ▼          ▼\n                           Return    Executor    Planner\n                           to User  (重试该步)   (重新规划)\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e4. Chain-of-Thought 在 Agent 中的应用\u003c/h2\u003e\n\u003ch3\u003e4.1 标准 CoT vs Agent CoT\u003c/h3\u003e\n\u003cp\u003e标准的 Chain-of-Thought（CoT）是一种推理增强技术——\u0026quot;Let\u0026#39;s think step by step\u0026quot;。但在 Agent 中，CoT 的用途和形式有本质不同：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003e标准 CoT\u003c/th\u003e\n\u003cth\u003eAgent CoT\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e目的\u003c/td\u003e\n\u003ctd\u003e提高推理准确性\u003c/td\u003e\n\u003ctd\u003e让中间推理过程可审计、可路由\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e消费者\u003c/td\u003e\n\u003ctd\u003e最终输出的一部分\u003c/td\u003e\n\u003ctd\u003eAgent Runtime 的中间状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e格式\u003c/td\u003e\n\u003ctd\u003e自然语言\u003c/td\u003e\n\u003ctd\u003e结构化（通常嵌入 JSON 的某个字段）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否返回用户\u003c/td\u003e\n\u003ctd\u003e通常是\u003c/td\u003e\n\u003ctd\u003e通常不是（内部消费）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eAgent 的 CoT 更像是一个\u003cstrong\u003e内部日志\u003c/strong\u003e，而非用户可见的推理过程。它的首要目标是让系统（而非人类）能够理解和利用中间推理。\u003c/p\u003e\n\u003ch3\u003e4.2 Scratchpad 模式\u003c/h3\u003e\n\u003cp\u003eScratchpad 模式是 Agent CoT 的典型实现——在 Prompt 中显式开辟一个\u0026quot;草稿区\u0026quot;，让 LLM 在其中进行中间推理，然后输出最终决策。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eSCRATCHPAD_PROMPT = \u0026quot;\u0026quot;\u0026quot;Analyze the user\u0026#39;s request and decide on an action.\n\n## User Request\n{user_request}\n\n## Available Tools\n{tools}\n\n## Instructions\nUse the \u0026lt;scratchpad\u0026gt; section to think through your decision. This section will NOT be\nshown to the user. Then provide your final action in the \u0026lt;action\u0026gt; section.\n\n\u0026lt;scratchpad\u0026gt;\nThink through:\n1. What is the user actually asking for?\n2. Which tools could help? What are the pros/cons of each?\n3. What information am I missing?\n4. What\u0026#39;s the simplest approach that works?\n\u0026lt;/scratchpad\u0026gt;\n\n\u0026lt;action\u0026gt;\nReturn strict JSON here:\n{{\u0026quot;tool_name\u0026quot;: \u0026quot;...\u0026quot;, \u0026quot;tool_input\u0026quot;: {{...}}, \u0026quot;reasoning_summary\u0026quot;: \u0026quot;...\u0026quot;}}\n\u0026lt;/action\u0026gt;\n\u0026quot;\u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRuntime 解析时，只提取 \u003ccode\u003e\u0026lt;action\u0026gt;\u003c/code\u003e 标签中的内容作为执行指令，\u003ccode\u003e\u0026lt;scratchpad\u0026gt;\u003c/code\u003e 的内容记录到日志中用于调试和审计。\u003c/p\u003e\n\u003ch3\u003e4.3 显式推理 vs 隐式推理的 Trade-off\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e显式推理（Explicit Reasoning）：\u003c/strong\u003e 在 Prompt 中要求 LLM 输出推理过程。\u003c/p\u003e\n\u003cp\u003e优势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可审计，出了问题能追溯\u0026quot;为什么做了这个决策\u0026quot;\u003c/li\u003e\n\u003cli\u003e推理质量通常更高（CoT 效应）\u003c/li\u003e\n\u003cli\u003e便于调试\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e劣势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e消耗更多 Token（推理内容可能占输出的 50%+）\u003c/li\u003e\n\u003cli\u003e增加延迟\u003c/li\u003e\n\u003cli\u003e推理内容可能包含敏感的内部逻辑\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e隐式推理（Implicit Reasoning）：\u003c/strong\u003e 直接要求 LLM 输出最终决策，不要求中间过程。\u003c/p\u003e\n\u003cp\u003e优势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eToken 用量更低，延迟更短\u003c/li\u003e\n\u003cli\u003e输出更简洁，解析更简单\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e劣势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e黑盒，无法理解决策过程\u003c/li\u003e\n\u003cli\u003e在复杂场景下准确率下降明显\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e工程决策建议：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRouter 和 Executor（简单、确定性高）：倾向隐式推理，追求速度\u003c/li\u003e\n\u003cli\u003ePlanner 和 Reflector（复杂、需要判断）：必须显式推理，追求准确性和可审计性\u003c/li\u003e\n\u003cli\u003e在系统稳定后，可以通过 A/B 测试逐步将显式推理切换为隐式推理以降低成本\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e5. Few-shot vs Zero-shot 在 Agent 场景的选择\u003c/h2\u003e\n\u003cp\u003e这是 Agent Prompt 设计中一个重要但常被忽视的决策点。\u003c/p\u003e\n\u003ch3\u003e5.1 决策矩阵\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e                    输出结构化程度\n                 低 ◄──────────► 高\n                 │                │\n  任务复杂度  高  │  Few-shot      │  Zero-shot + Schema\n                 │  (复杂规划)     │  (结构化反思)\n                 │                │\n              低  │  Zero-shot     │  Zero-shot + Schema\n                 │  (简单对话)     │  (工具调用)\n                 │                │\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 工具调用：Zero-shot 优先\u003c/h3\u003e\n\u003cp\u003e工具调用场景天然适合 Zero-shot。原因是 \u003cstrong\u003eJSON Schema 本身就是最好的\u0026quot;示例\u0026quot;\u003c/strong\u003e——它精确定义了每个参数的名称、类型、描述和约束，比任何 Few-shot 示例都更完整。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 工具调用不需要 few-shot，Schema 就是最好的约束\ntool_schema = {\n    \u0026quot;name\u0026quot;: \u0026quot;search_database\u0026quot;,\n    \u0026quot;description\u0026quot;: \u0026quot;Search the product database with filters\u0026quot;,\n    \u0026quot;parameters\u0026quot;: {\n        \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;,\n        \u0026quot;properties\u0026quot;: {\n            \u0026quot;query\u0026quot;: {\u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Search keywords\u0026quot;},\n            \u0026quot;category\u0026quot;: {\n                \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;,\n                \u0026quot;enum\u0026quot;: [\u0026quot;electronics\u0026quot;, \u0026quot;clothing\u0026quot;, \u0026quot;books\u0026quot;],\n                \u0026quot;description\u0026quot;: \u0026quot;Product category filter\u0026quot;\n            },\n            \u0026quot;max_results\u0026quot;: {\n                \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot;,\n                \u0026quot;default\u0026quot;: 10,\n                \u0026quot;minimum\u0026quot;: 1,\n                \u0026quot;maximum\u0026quot;: 100\n            }\n        },\n        \u0026quot;required\u0026quot;: [\u0026quot;query\u0026quot;]\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e加 Few-shot 反而可能引入问题：LLM 可能过度拟合示例中的具体值，而不是理解 Schema 的通用约束。\u003c/p\u003e\n\u003ch3\u003e5.3 复杂规划：Few-shot 有价值\u003c/h3\u003e\n\u003cp\u003e规划场景是 Few-shot 真正发挥价值的地方。因为\u0026quot;好的计划\u0026quot;是一个模糊的概念——仅凭输出格式定义不足以引导 LLM 产出高质量的计划。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ePLANNER_WITH_EXAMPLES = \u0026quot;\u0026quot;\u0026quot;You are a task planner.\n\n## Example 1: Multi-step data analysis\nUser: \u0026quot;Compare last month\u0026#39;s sales with the same period last year and visualize the trend\u0026quot;\nPlan:\n[\n  {{\u0026quot;step_id\u0026quot;: 1, \u0026quot;tool\u0026quot;: \u0026quot;data_query\u0026quot;, \u0026quot;input\u0026quot;: \u0026quot;sales data for 2025-07\u0026quot;, \u0026quot;depends_on\u0026quot;: []}},\n  {{\u0026quot;step_id\u0026quot;: 2, \u0026quot;tool\u0026quot;: \u0026quot;data_query\u0026quot;, \u0026quot;input\u0026quot;: \u0026quot;sales data for 2024-07\u0026quot;, \u0026quot;depends_on\u0026quot;: []}},\n  {{\u0026quot;step_id\u0026quot;: 3, \u0026quot;tool\u0026quot;: \u0026quot;data_compare\u0026quot;, \u0026quot;input\u0026quot;: \u0026quot;$step_1_result, $step_2_result\u0026quot;, \u0026quot;depends_on\u0026quot;: [1, 2]}},\n  {{\u0026quot;step_id\u0026quot;: 4, \u0026quot;tool\u0026quot;: \u0026quot;chart_gen\u0026quot;, \u0026quot;input\u0026quot;: \u0026quot;$step_3_result, type=line\u0026quot;, \u0026quot;depends_on\u0026quot;: [3]}}\n]\nNote: Steps 1 and 2 can run in parallel since they have no dependencies.\n\n## Example 2: Simple single-step task\nUser: \u0026quot;What\u0026#39;s the weather in Tokyo?\u0026quot;\nPlan:\n[\n  {{\u0026quot;step_id\u0026quot;: 1, \u0026quot;tool\u0026quot;: \u0026quot;weather_api\u0026quot;, \u0026quot;input\u0026quot;: \u0026quot;Tokyo\u0026quot;, \u0026quot;depends_on\u0026quot;: []}}\n]\nNote: Simple requests should NOT be over-decomposed.\n\n## Now plan for:\nUser: \u0026quot;{user_request}\u0026quot;\n\u0026quot;\u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFew-shot 示例在这里传递了两个关键信息：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e粒度标准\u003c/strong\u003e——什么程度的分解是合适的\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e并行意识\u003c/strong\u003e——独立步骤应该标记为可并行\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e5.4 反思评估：Zero-shot + 结构化输出\u003c/h3\u003e\n\u003cp\u003e反思（Reflection）场景适合 Zero-shot + 结构化输出。原因是反思本质上是\u0026quot;评判\u0026quot;，而评判标准已经通过评估维度（completeness / correctness / format）和评分规则完整定义了。给出 Few-shot 示例反而可能让 LLM 锚定在示例的评分上，而不是独立评估当前结果。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e总结决策原则：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e格式约束充分（JSON Schema / 评分规则）→ Zero-shot\u003c/li\u003e\n\u003cli\u003e需要传递\u0026quot;风格\u0026quot;或\u0026quot;粒度标准\u0026quot; → Few-shot\u003c/li\u003e\n\u003cli\u003e两者都可以时 → 优先 Zero-shot（更省 Token，更不容易过拟合）\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e6. Prompt 工程化实践\u003c/h2\u003e\n\u003cp\u003e当 Agent 系统超过原型阶段，Prompt 管理就变成了一个严肃的工程问题。\u003c/p\u003e\n\u003ch3\u003e6.1 Prompt 模板化\u003c/h3\u003e\n\u003cp\u003e核心思想：\u003cstrong\u003e分离静态结构和动态内容\u003c/strong\u003e。静态部分（身份定义、行为规则、输出格式）是模板，动态部分（工具列表、历史消息、当前状态）通过变量注入。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom typing import Any\nfrom string import Template\nimport hashlib\nimport json\nfrom datetime import datetime\n\n\nclass PromptTemplate:\n    \u0026quot;\u0026quot;\u0026quot;可管理、可版本化、可测试的 Prompt 模板\u0026quot;\u0026quot;\u0026quot;\n\n    def __init__(self, name: str, template: str, version: str,\n                 required_vars: list[str], metadata: dict | None = None):\n        self.name = name\n        self.template = template\n        self.version = version\n        self.required_vars = required_vars\n        self.metadata = metadata or {}\n        self._hash = hashlib.sha256(template.encode()).hexdigest()[:12]\n\n    def render(self, **kwargs) -\u0026gt; str:\n        # 校验所有必需变量都已提供\n        missing = set(self.required_vars) - set(kwargs.keys())\n        if missing:\n            raise ValueError(f\u0026quot;Missing required variables: {missing}\u0026quot;)\n\n        # 渲染模板\n        rendered = self.template\n        for key, value in kwargs.items():\n            placeholder = \u0026quot;{\u0026quot; + key + \u0026quot;}\u0026quot;\n            if isinstance(value, (dict, list)):\n                value = json.dumps(value, indent=2, ensure_ascii=False)\n            rendered = rendered.replace(placeholder, str(value))\n\n        return rendered\n\n    def fingerprint(self) -\u0026gt; str:\n        \u0026quot;\u0026quot;\u0026quot;返回模板内容的哈希指纹，用于版本追踪\u0026quot;\u0026quot;\u0026quot;\n        return f\u0026quot;{self.name}@{self.version}#{self._hash}\u0026quot;\n\n\nclass PromptRegistry:\n    \u0026quot;\u0026quot;\u0026quot;Prompt 模板注册中心：集中管理所有 Agent 使用的 Prompt\u0026quot;\u0026quot;\u0026quot;\n\n    def __init__(self):\n        self._templates: dict[str, dict[str, PromptTemplate]] = {}  # name -\u0026gt; {version -\u0026gt; template}\n\n    def register(self, template: PromptTemplate):\n        if template.name not in self._templates:\n            self._templates[template.name] = {}\n        self._templates[template.name][template.version] = template\n\n    def get(self, name: str, version: str = \u0026quot;latest\u0026quot;) -\u0026gt; PromptTemplate:\n        if name not in self._templates:\n            raise KeyError(f\u0026quot;Template \u0026#39;{name}\u0026#39; not found\u0026quot;)\n\n        versions = self._templates[name]\n        if version == \u0026quot;latest\u0026quot;:\n            latest_version = sorted(versions.keys())[-1]\n            return versions[latest_version]\n\n        if version not in versions:\n            raise KeyError(f\u0026quot;Version \u0026#39;{version}\u0026#39; not found for template \u0026#39;{name}\u0026#39;\u0026quot;)\n        return versions[version]\n\n    def list_all(self) -\u0026gt; dict[str, list[str]]:\n        return {name: sorted(vers.keys()) for name, vers in self._templates.items()}\n\n\n# ── 使用示例 ──\n\nregistry = PromptRegistry()\n\n# 注册 Router Prompt v1\nregistry.register(PromptTemplate(\n    name=\u0026quot;router\u0026quot;,\n    version=\u0026quot;1.0\u0026quot;,\n    template=\u0026quot;\u0026quot;\u0026quot;You are a request router.\nAvailable tools: {tool_descriptions}\nRoute the following request: {user_input}\nOutput JSON: {{\u0026quot;tool_name\u0026quot;: \u0026quot;...\u0026quot;, \u0026quot;tool_input\u0026quot;: {{...}}}}\u0026quot;\u0026quot;\u0026quot;,\n    required_vars=[\u0026quot;tool_descriptions\u0026quot;, \u0026quot;user_input\u0026quot;],\n    metadata={\u0026quot;author\u0026quot;: \u0026quot;agent-team\u0026quot;, \u0026quot;last_tested\u0026quot;: \u0026quot;2025-08-10\u0026quot;}\n))\n\n# 注册 Router Prompt v2（增加了 confidence 字段）\nregistry.register(PromptTemplate(\n    name=\u0026quot;router\u0026quot;,\n    version=\u0026quot;2.0\u0026quot;,\n    template=\u0026quot;\u0026quot;\u0026quot;You are a request router. Your ONLY job is to route, not to answer.\nAvailable tools: {tool_descriptions}\nRoute the following request: {user_input}\nOutput JSON: {{\u0026quot;tool_name\u0026quot;: \u0026quot;...\u0026quot;, \u0026quot;tool_input\u0026quot;: {{...}}, \u0026quot;confidence\u0026quot;: \u0026lt;0.0-1.0\u0026gt;}}\u0026quot;\u0026quot;\u0026quot;,\n    required_vars=[\u0026quot;tool_descriptions\u0026quot;, \u0026quot;user_input\u0026quot;],\n    metadata={\u0026quot;author\u0026quot;: \u0026quot;agent-team\u0026quot;, \u0026quot;last_tested\u0026quot;: \u0026quot;2025-08-13\u0026quot;}\n))\n\n# 获取并渲染\nrouter_prompt = registry.get(\u0026quot;router\u0026quot;, version=\u0026quot;2.0\u0026quot;)\nfinal_prompt = router_prompt.render(\n    tool_descriptions=\u0026quot;1. web_search: Search the web\\n2. calculator: Do math\u0026quot;,\n    user_input=\u0026quot;What is 42 * 17?\u0026quot;\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2 Prompt 版本控制\u003c/h3\u003e\n\u003cp\u003e为什么 Prompt 需要版本控制？因为 \u003cstrong\u003ePrompt 是 Agent 行为的源代码\u003c/strong\u003e。改一个词可能导致 Agent 行为的巨大变化——从正确路由变成错误路由，从结构化输出变成自由文本。\u003c/p\u003e\n\u003cp\u003e版本控制策略：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprompts/\n├── router/\n│   ├── v1.0.txt          # 初始版本\n│   ├── v1.1.txt          # 修复：低 confidence 时的行为\n│   ├── v2.0.txt          # 重大变更：新增 confidence 字段\n│   └── changelog.md      # 变更记录\n├── planner/\n│   ├── v1.0.txt\n│   └── v1.1.txt\n├── executor/\n│   └── v1.0.txt\n└── reflector/\n    └── v1.0.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e关键实践：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e每次 Prompt 变更都有对应的测试结果\u003c/strong\u003e（下面会详述）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e生产环境使用固定版本号\u003c/strong\u003e，而非 \u0026quot;latest\u0026quot;\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持灰度发布\u003c/strong\u003e：新版 Prompt 可以先对 10% 的流量生效\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e保留回滚能力\u003c/strong\u003e：发现新版 Prompt 导致问题时，立即切回旧版\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e6.3 Prompt 测试\u003c/h3\u003e\n\u003cp\u003ePrompt 测试的核心挑战是 LLM 输出的非确定性。我们不能像测试普通函数那样做精确断言，但可以做\u003cstrong\u003e结构化断言\u003c/strong\u003e和\u003cstrong\u003e统计性断言\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom dataclasses import dataclass\n\n@dataclass\nclass PromptTestCase:\n    name: str\n    input_vars: dict[str, Any]       # 模板变量\n    assertions: list[dict]            # 断言列表\n\n    # 断言类型：\n    # {\u0026quot;type\u0026quot;: \u0026quot;json_valid\u0026quot;}                           → 输出是合法 JSON\n    # {\u0026quot;type\u0026quot;: \u0026quot;has_field\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;tool_name\u0026quot;}      → JSON 中包含指定字段\n    # {\u0026quot;type\u0026quot;: \u0026quot;field_in\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;tool_name\u0026quot;, \u0026quot;values\u0026quot;: [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;]} → 字段值在范围内\n    # {\u0026quot;type\u0026quot;: \u0026quot;no_field\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;apology\u0026quot;}         → 不包含某字段（防止 LLM 废话）\n    # {\u0026quot;type\u0026quot;: \u0026quot;max_tokens\u0026quot;, \u0026quot;limit\u0026quot;: 200}             → 输出长度不超过限制\n\n\nclass PromptTestRunner:\n    def __init__(self, llm_client, template: PromptTemplate):\n        self.llm = llm_client\n        self.template = template\n\n    def run_test(self, test_case: PromptTestCase, n_runs: int = 5) -\u0026gt; dict:\n        \u0026quot;\u0026quot;\u0026quot;对同一个测试用例运行 N 次，统计通过率\u0026quot;\u0026quot;\u0026quot;\n        prompt = self.template.render(**test_case.input_vars)\n        results = []\n\n        for _ in range(n_runs):\n            output = self.llm.generate(prompt)\n            pass_all = True\n            details = []\n\n            for assertion in test_case.assertions:\n                passed = self._check_assertion(output, assertion)\n                details.append({\u0026quot;assertion\u0026quot;: assertion, \u0026quot;passed\u0026quot;: passed})\n                if not passed:\n                    pass_all = False\n\n            results.append({\u0026quot;output\u0026quot;: output, \u0026quot;passed\u0026quot;: pass_all, \u0026quot;details\u0026quot;: details})\n\n        pass_rate = sum(1 for r in results if r[\u0026quot;passed\u0026quot;]) / n_runs\n        return {\n            \u0026quot;test_case\u0026quot;: test_case.name,\n            \u0026quot;template\u0026quot;: self.template.fingerprint(),\n            \u0026quot;n_runs\u0026quot;: n_runs,\n            \u0026quot;pass_rate\u0026quot;: pass_rate,\n            \u0026quot;results\u0026quot;: results\n        }\n\n    def _check_assertion(self, output: str, assertion: dict) -\u0026gt; bool:\n        if assertion[\u0026quot;type\u0026quot;] == \u0026quot;json_valid\u0026quot;:\n            try:\n                json.loads(output)\n                return True\n            except json.JSONDecodeError:\n                return False\n\n        if assertion[\u0026quot;type\u0026quot;] == \u0026quot;has_field\u0026quot;:\n            try:\n                data = json.loads(output)\n                return assertion[\u0026quot;field\u0026quot;] in data\n            except (json.JSONDecodeError, TypeError):\n                return False\n\n        if assertion[\u0026quot;type\u0026quot;] == \u0026quot;field_in\u0026quot;:\n            try:\n                data = json.loads(output)\n                return data.get(assertion[\u0026quot;field\u0026quot;]) in assertion[\u0026quot;values\u0026quot;]\n            except (json.JSONDecodeError, TypeError):\n                return False\n\n        return False  # 未知断言类型\n\n\n# ── 测试用例示例 ──\n\ntest_cases = [\n    PromptTestCase(\n        name=\u0026quot;math_request_should_route_to_calculator\u0026quot;,\n        input_vars={\n            \u0026quot;tool_descriptions\u0026quot;: \u0026quot;1. web_search: Search the web\\n2. calculator: Do math\u0026quot;,\n            \u0026quot;user_input\u0026quot;: \u0026quot;What is 1024 * 768?\u0026quot;\n        },\n        assertions=[\n            {\u0026quot;type\u0026quot;: \u0026quot;json_valid\u0026quot;},\n            {\u0026quot;type\u0026quot;: \u0026quot;has_field\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;tool_name\u0026quot;},\n            {\u0026quot;type\u0026quot;: \u0026quot;field_in\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;tool_name\u0026quot;, \u0026quot;values\u0026quot;: [\u0026quot;calculator\u0026quot;]},\n        ]\n    ),\n    PromptTestCase(\n        name=\u0026quot;ambiguous_request_should_not_guess\u0026quot;,\n        input_vars={\n            \u0026quot;tool_descriptions\u0026quot;: \u0026quot;1. web_search: Search the web\\n2. calculator: Do math\u0026quot;,\n            \u0026quot;user_input\u0026quot;: \u0026quot;Help me with my project\u0026quot;\n        },\n        assertions=[\n            {\u0026quot;type\u0026quot;: \u0026quot;json_valid\u0026quot;},\n            {\u0026quot;type\u0026quot;: \u0026quot;has_field\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;tool_name\u0026quot;},\n            {\u0026quot;type\u0026quot;: \u0026quot;field_in\u0026quot;, \u0026quot;field\u0026quot;: \u0026quot;tool_name\u0026quot;, \u0026quot;values\u0026quot;: [\u0026quot;none\u0026quot;]},\n        ]\n    ),\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e测试策略建议：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e每个 Prompt 版本至少 10 个测试用例，覆盖正常路径、边界情况和对抗输入\u003c/li\u003e\n\u003cli\u003e每个测试用例运行 5-10 次，要求通过率 \u0026gt;= 90%（而非 100%，因为 LLM 输出非确定性）\u003c/li\u003e\n\u003cli\u003e将测试集纳入 CI，每次 Prompt 变更触发回归测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e6.4 Prompt 组合：模块化拼装\u003c/h3\u003e\n\u003cp\u003e复杂 Agent 的 Prompt 往往由多个模块组合而成。与其维护一个巨大的单体 Prompt，不如将其拆分为可复用的模块：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass PromptComposer:\n    \u0026quot;\u0026quot;\u0026quot;将多个 Prompt 模块按顺序组合\u0026quot;\u0026quot;\u0026quot;\n\n    def __init__(self):\n        self._modules: list[tuple[str, PromptTemplate]] = []\n\n    def add(self, section_name: str, template: PromptTemplate):\n        self._modules.append((section_name, template))\n        return self  # 支持链式调用\n\n    def compose(self, **all_vars) -\u0026gt; str:\n        sections = []\n        for section_name, template in self._modules:\n            # 每个模块只取自己需要的变量\n            relevant_vars = {k: v for k, v in all_vars.items()\n                           if k in template.required_vars}\n            rendered = template.render(**relevant_vars)\n            sections.append(f\u0026quot;## {section_name}\\n{rendered}\u0026quot;)\n        return \u0026quot;\\n\\n\u0026quot;.join(sections)\n\n\n# 使用方式\nidentity_module = PromptTemplate(\n    name=\u0026quot;identity\u0026quot;, version=\u0026quot;1.0\u0026quot;,\n    template=\u0026quot;You are {agent_role}. {agent_description}\u0026quot;,\n    required_vars=[\u0026quot;agent_role\u0026quot;, \u0026quot;agent_description\u0026quot;]\n)\n\ntools_module = PromptTemplate(\n    name=\u0026quot;tools\u0026quot;, version=\u0026quot;1.0\u0026quot;,\n    template=\u0026quot;Available tools:\\n{tool_descriptions}\u0026quot;,\n    required_vars=[\u0026quot;tool_descriptions\u0026quot;]\n)\n\noutput_format_module = PromptTemplate(\n    name=\u0026quot;output_format\u0026quot;, version=\u0026quot;1.0\u0026quot;,\n    template=\u0026quot;You MUST respond in the following JSON format:\\n{json_schema}\u0026quot;,\n    required_vars=[\u0026quot;json_schema\u0026quot;]\n)\n\nconstraints_module = PromptTemplate(\n    name=\u0026quot;constraints\u0026quot;, version=\u0026quot;1.0\u0026quot;,\n    template=\u0026quot;Constraints:\\n{constraint_list}\u0026quot;,\n    required_vars=[\u0026quot;constraint_list\u0026quot;]\n)\n\n# 组合\ncomposer = PromptComposer()\ncomposer.add(\u0026quot;Identity\u0026quot;, identity_module) \\\n        .add(\u0026quot;Tools\u0026quot;, tools_module) \\\n        .add(\u0026quot;Output Format\u0026quot;, output_format_module) \\\n        .add(\u0026quot;Constraints\u0026quot;, constraints_module)\n\nfinal_prompt = composer.compose(\n    agent_role=\u0026quot;a task router\u0026quot;,\n    agent_description=\u0026quot;You route user requests to the appropriate tool.\u0026quot;,\n    tool_descriptions=\u0026quot;1. search: web search\\n2. calc: calculator\u0026quot;,\n    json_schema=\u0026#39;{\u0026quot;tool_name\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;tool_input\u0026quot;: \u0026quot;object\u0026quot;}\u0026#39;,\n    constraint_list=\u0026quot;- Never fabricate tool names\\n- Always return valid JSON\u0026quot;\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e模块化的好处：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e同一个 \u003ccode\u003eoutput_format_module\u003c/code\u003e 可以被 Router、Planner、Executor 共享\u003c/li\u003e\n\u003cli\u003e修改 constraints 不需要触碰 identity 和 tools 部分\u003c/li\u003e\n\u003cli\u003e每个模块可以独立测试和版本控制\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e7. Context Window 管理\u003c/h2\u003e\n\u003cp\u003eAgent 的 Context Window 管理是一个独特且关键的工程挑战。与 Chatbot 的\u0026quot;对话越长体验越差\u0026quot;不同，Agent 的 context 膨胀会直接导致\u003cstrong\u003e系统性故障\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e7.1 Agent 的 Context 膨胀问题\u003c/h3\u003e\n\u003cp\u003eAgent 的 context 会从三个维度快速膨胀：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTurn 1:  System(2000) + User(200) + Response(500)              = 2,700 tokens\nTurn 2:  + Tool_Result(3000) + Response(800)                   = 6,500 tokens\nTurn 3:  + Tool_Result(5000) + Error_Msg(1000) + Response(600) = 13,100 tokens\nTurn 4:  + Tool_Result(2000) + Response(400)                   = 15,500 tokens\nTurn 5:  + RAG_Context(4000) + Response(1000)                  = 20,500 tokens\n  ...\nTurn 10: 很容易突破 50,000 tokens\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e三大膨胀源：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e工具返回值\u003c/strong\u003e：一次数据库查询可能返回几千 token 的 JSON，一次网页抓取可能返回上万 token\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e历史消息积累\u003c/strong\u003e：每一轮的 user message + assistant response + tool calls 都在累积\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e错误信息\u003c/strong\u003e：工具调用失败的 traceback、重试过程中的冗余信息\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e7.2 消息压缩策略\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e策略 1：摘要压缩（Summarization）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e将早期的对话历史压缩为摘要，只保留关键事实和决策结果。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef compress_history(messages: list[dict], llm_client,\n                     keep_recent: int = 4) -\u0026gt; list[dict]:\n    \u0026quot;\u0026quot;\u0026quot;将早期历史压缩为摘要，保留最近 N 轮完整消息\u0026quot;\u0026quot;\u0026quot;\n    if len(messages) \u0026lt;= keep_recent:\n        return messages\n\n    old_messages = messages[:-keep_recent]\n    recent_messages = messages[-keep_recent:]\n\n    # 用 LLM 生成摘要\n    summary_prompt = f\u0026quot;\u0026quot;\u0026quot;Summarize the following conversation history into key facts\nand decisions. Keep only information that might be needed for future steps.\nBe concise — maximum 200 words.\n\n{format_messages(old_messages)}\u0026quot;\u0026quot;\u0026quot;\n\n    summary = llm_client.generate(summary_prompt)\n\n    # 将摘要作为一条 system message 注入\n    summary_message = {\n        \u0026quot;role\u0026quot;: \u0026quot;system\u0026quot;,\n        \u0026quot;content\u0026quot;: f\u0026quot;[Conversation Summary]\\n{summary}\u0026quot;\n    }\n\n    return [summary_message] + recent_messages\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e策略 2：滑动窗口（Sliding Window）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e更简单粗暴——只保留最近 N 条消息，丢弃更早的消息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef sliding_window(messages: list[dict], max_messages: int = 10) -\u0026gt; list[dict]:\n    \u0026quot;\u0026quot;\u0026quot;保留 system message + 最近 N 条消息\u0026quot;\u0026quot;\u0026quot;\n    system_msgs = [m for m in messages if m[\u0026quot;role\u0026quot;] == \u0026quot;system\u0026quot;]\n    non_system = [m for m in messages if m[\u0026quot;role\u0026quot;] != \u0026quot;system\u0026quot;]\n    return system_msgs + non_system[-max_messages:]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e策略 3：选择性保留（Selective Retention）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e根据消息的\u0026quot;重要性\u0026quot;决定保留还是丢弃。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef selective_retain(messages: list[dict], token_budget: int) -\u0026gt; list[dict]:\n    \u0026quot;\u0026quot;\u0026quot;按重要性保留消息，直到填满 token 预算\u0026quot;\u0026quot;\u0026quot;\n\n    def importance_score(msg: dict) -\u0026gt; int:\n        if msg[\u0026quot;role\u0026quot;] == \u0026quot;system\u0026quot;:\n            return 100  # 永远保留\n        if msg.get(\u0026quot;is_final_result\u0026quot;):\n            return 90   # 最终结果必须保留\n        if msg[\u0026quot;role\u0026quot;] == \u0026quot;user\u0026quot;:\n            return 80   # 用户输入高优先\n        if msg.get(\u0026quot;tool_error\u0026quot;):\n            return 20   # 错误信息低优先（已经被处理过了）\n        if msg.get(\u0026quot;tool_result\u0026quot;):\n            return 40   # 工具结果中等优先\n        return 50\n\n    scored = [(importance_score(m), i, m) for i, m in enumerate(messages)]\n    scored.sort(key=lambda x: (-x[0], x[1]))  # 按重要性降序，原始顺序升序\n\n    retained = []\n    used_tokens = 0\n    for score, idx, msg in scored:\n        msg_tokens = estimate_tokens(msg[\u0026quot;content\u0026quot;])\n        if used_tokens + msg_tokens \u0026lt;= token_budget:\n            retained.append((idx, msg))\n            used_tokens += msg_tokens\n\n    # 恢复原始顺序\n    retained.sort(key=lambda x: x[0])\n    return [msg for _, msg in retained]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e7.3 Token 预算分配\u003c/h3\u003e\n\u003cp\u003e一个经验性的 Token 预算分配方案（以 8K context window 为例）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTotal Context Window: 8,192 tokens\n                    │\n    ┌───────────────┼───────────────┐\n    │               │               │\nSystem Prompt    Working Area     Reserved for\n  ~25%            ~60%            Output ~15%\n (2,048)         (4,915)          (1,229)\n    │               │\n    │         ┌─────┴──────┐\n    │         │            │\n    │    Tool Descs    History + State\n    │     ~15%          ~45%\n    │    (1,229)       (3,686)\n    │\n    ├── Identity \u0026amp; Role: 500\n    ├── Behavior Rules: 800\n    ├── Output Format: 500\n    └── Constraints: 248\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e关键原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eOutput Reserved 不能省\u003c/strong\u003e：如果留给输出的空间不足，LLM 会输出截断的 JSON，导致解析失败\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSystem Prompt 预算固定\u003c/strong\u003e：行为约束不能因为 context 紧张而被裁剪\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHistory 是最大的压缩空间\u003c/strong\u003e：优先在这里节省 Token\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具描述可以按需加载\u003c/strong\u003e：如果 Router 已经选定了工具，后续 Executor 只需要注入被选中工具的描述，而非全部工具\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e7.4 工具返回值的处理\u003c/h3\u003e\n\u003cp\u003e工具返回值是 context 膨胀的最大单点源头。以下是几种处理策略：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef process_tool_result(result: str, max_tokens: int = 1500) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;处理工具返回值，防止 context 爆炸\u0026quot;\u0026quot;\u0026quot;\n\n    result_tokens = estimate_tokens(result)\n\n    if result_tokens \u0026lt;= max_tokens:\n        return result\n\n    # 策略 1：截断（适用于文本类结果）\n    if is_text(result):\n        return truncate_to_tokens(result, max_tokens) + \u0026quot;\\n[... truncated]\u0026quot;\n\n    # 策略 2：提取摘要（适用于 JSON 类结果）\n    if is_json(result):\n        data = json.loads(result)\n        if isinstance(data, list):\n            # 只保留前 N 条记录 + 总数信息\n            summary = {\n                \u0026quot;total_count\u0026quot;: len(data),\n                \u0026quot;showing_first\u0026quot;: 5,\n                \u0026quot;records\u0026quot;: data[:5],\n                \u0026quot;note\u0026quot;: f\u0026quot;Truncated from {len(data)} records. Request specific filters for more.\u0026quot;\n            }\n            return json.dumps(summary, ensure_ascii=False, indent=2)\n\n    # 策略 3：兜底截断\n    return truncate_to_tokens(result, max_tokens) + \u0026quot;\\n[... truncated]\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 常见陷阱\u003c/h2\u003e\n\u003ch3\u003e8.1 Prompt 太长导致 LLM \u0026quot;忘记\u0026quot;关键指令\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e现象：\u003c/strong\u003e System Prompt 有 3000 token，其中包含 20 条行为规则。LLM 在前几轮严格遵守，但随着 context 变长，开始\u0026quot;遗忘\u0026quot;中间的规则——尤其是第 8-15 条。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原因：\u003c/strong\u003e LLM 对 prompt 中不同位置内容的\u0026quot;注意力\u0026quot;不均匀。开头和结尾的内容通常被更好地遵循（primacy effect 和 recency effect），中间的内容最容易被忽略。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e应对：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将最关键的规则放在 System Prompt 的开头和结尾\u003c/li\u003e\n\u003cli\u003e将规则数量控制在 7 条以内（与人类工作记忆容量一致，也利于 LLM）\u003c/li\u003e\n\u003cli\u003e在消息末尾添加 reminder：\u0026quot;Remember: always output valid JSON. Never fabricate tool names.\u0026quot;\u003c/li\u003e\n\u003cli\u003e按当前 Turn 的需要动态注入最相关的规则子集，而非每次都注入全部规则\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e8.2 工具描述和 System Prompt 冲突\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e现象：\u003c/strong\u003e System Prompt 说\u0026quot;不要执行任何数据删除操作\u0026quot;，但某个工具的 description 中包含\u0026quot;Deletes records matching the query\u0026quot;。LLM 收到删除请求时，行为不确定——有时遵循 System Prompt 的禁令，有时遵循工具描述的能力。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原因：\u003c/strong\u003e LLM 看到的是拼装后的完整 prompt，它不理解\u0026quot;System Prompt 优先级高于工具描述\u0026quot;这个层级关系。两段相互矛盾的文本让 LLM 陷入冲突。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e应对：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 Prompt 组装阶段做\u003cstrong\u003e一致性检查\u003c/strong\u003e：扫描工具描述中的关键词，与 System Prompt 的禁止列表做匹配\u003c/li\u003e\n\u003cli\u003e如果某个工具被禁用，\u003cstrong\u003e直接不注入它的描述\u003c/strong\u003e，而不是注入描述然后在 System Prompt 中禁止\u003c/li\u003e\n\u003cli\u003e在 System Prompt 中明确声明优先级：\u0026quot;If any tool description conflicts with these rules, these rules take priority.\u0026quot;\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e8.3 过度约束导致 LLM 无法灵活应对\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e现象：\u003c/strong\u003e 为了保证安全，System Prompt 中加了大量限制：\u0026quot;只能调用列表中的工具\u0026quot;、\u0026quot;只能输出 JSON\u0026quot;、\u0026quot;不能包含任何解释\u0026quot;、\u0026quot;不能问用户问题\u0026quot;、\u0026quot;必须在一次调用中完成\u0026quot;......结果 LLM 在遇到无法处理的请求时，输出空 JSON 或无意义的工具调用，而不是合理地拒绝或请求澄清。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原因：\u003c/strong\u003e 过度约束堵死了 LLM 所有的\u0026quot;逃生通道\u0026quot;。它没有被允许说\u0026quot;我不知道\u0026quot;或\u0026quot;我需要更多信息\u0026quot;，所以只能在约束框架内硬凑一个输出。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e应对：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e永远为 LLM 保留一个\u0026quot;安全出口\u0026quot;：允许它输出 \u003ccode\u003e{\u0026quot;action\u0026quot;: \u0026quot;clarify\u0026quot;, \u0026quot;question\u0026quot;: \u0026quot;...\u0026quot;}\u003c/code\u003e 或 \u003ccode\u003e{\u0026quot;action\u0026quot;: \u0026quot;refuse\u0026quot;, \u0026quot;reason\u0026quot;: \u0026quot;...\u0026quot;}\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e区分\u0026quot;硬约束\u0026quot;和\u0026quot;软约束\u0026quot;：硬约束（安全规则）不可违反，软约束（输出偏好）在特殊情况下可以放松\u003c/li\u003e\n\u003cli\u003e将约束从\u0026quot;禁止列表\u0026quot;改为\u0026quot;优先级列表\u0026quot;：先尝试 X，如果不行可以 Y，最后可以 Z\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e8.4 Prompt Injection 在 Agent 中的放大效应\u003c/h3\u003e\n\u003cp\u003e在 Chatbot 中，Prompt Injection 最多让模型输出不当内容。但在 Agent 中，Prompt Injection 可能触发\u003cstrong\u003e真实的工具调用\u003c/strong\u003e——删除数据、发送邮件、调用 API。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e应对：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用户输入和系统指令之间必须有明确的分隔标记\u003c/li\u003e\n\u003cli\u003e工具调用前做参数校验（schema validation），而非完全信任 LLM 输出\u003c/li\u003e\n\u003cli\u003e高危操作（删除、支付、发送）增加人工确认步骤\u003c/li\u003e\n\u003cli\u003e将用户输入视为\u0026quot;不可信数据\u0026quot;，在 Prompt 中明确标注：\u003ccode\u003e[USER INPUT - UNTRUSTED]: {user_message}\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e9. 结语：从 Prompt 到 Runtime\u003c/h2\u003e\n\u003cp\u003ePrompt Engineering for Agents 的本质是\u003cstrong\u003e为 LLM 定义一套可编程的行为接口\u003c/strong\u003e。我们在本文中讨论了分层架构、设计模式、推理策略、测试方法和 context 管理——这些都是让 Agent \u0026quot;可控\u0026quot;的基础设施。\u003c/p\u003e\n\u003cp\u003e但 Prompt 本身只是 Agent 系统的一个组件。再好的 Prompt 也需要一个可靠的 Runtime 来驱动——处理 LLM 的响应、管理状态机的转换、执行工具调用、处理错误和重试。\u003c/p\u003e\n\u003cp\u003e下一篇文章《Agent Runtime from Scratch: 不依赖框架构建 Agent》将从零开始实现一个完整的 Agent 运行时。我们会把本文设计的 Prompt 模式，放进一个真实可运行的控制循环中，展示 Prompt、工具、状态管理和错误处理如何在代码层面协同工作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e进一步思考：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ePrompt 的自动优化\u003c/strong\u003e：如果我们有了 Prompt 测试框架和评估指标，是否可以用搜索算法（DSPy 的思路）自动优化 Prompt？这和手工调优的 trade-off 在哪里？\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eMulti-Model Prompt 策略\u003c/strong\u003e：Router 用小模型（快、便宜），Planner 用大模型（准、贵），Executor 用中等模型。不同模型对 Prompt 的响应特性不同，如何为不同模型定制 Prompt？\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ePrompt 的可解释性\u003c/strong\u003e：当 Agent 做出错误决策时，我们如何从 Prompt 和输出中定位问题根因？这需要什么样的 observability 基础设施？\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e动态 Prompt 生成\u003c/strong\u003e：是否可以让一个 \u0026quot;Meta-Agent\u0026quot; 根据当前任务特征，动态生成最合适的 Prompt？这会引入什么样的复杂性和风险？\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e系列导航\u003c/strong\u003e：本文是 Agentic 系列的第 06 篇。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e上一篇：\u003ca href=\"/blog/engineering/agentic/05-Tool%20Calling%20Deep%20Dive\"\u003e05 | Tool Calling Deep Dive\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e下一篇：\u003ca href=\"/blog/engineering/agentic/07-Agent%20Runtime%20from%20Scratch\"\u003e07 | Agent Runtime from Scratch\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e完整目录：\u003ca href=\"/blog/engineering/agentic/01-From%20LLM%20to%20Agent\"\u003e01 | From LLM to Agent\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"18:T9c80,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eAgent Runtime from Scratch: 不依赖框架构建 Agent\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e框架是加速器，不是知识的替代品。\u003c/p\u003e\n\u003cp\u003e本文是 Agentic 系列第 07 篇，也是 Phase 2 的收官之作。我们将抛开所有框架，用纯 Python 从零构建一个功能完整的 Agent Runtime。这是系列中代码量最大的一篇——每一行代码都指向同一个目标：让你彻底理解 Agent 的运行本质。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e1. 为什么要自己写 Agent Runtime？\u003c/h2\u003e\n\u003cp\u003e前几篇我们理解了控制循环（第 04 篇）、Tool Calling（第 05 篇）、Prompt 工程（第 06 篇）。但这些还停留在概念层面。现在的问题是：\u003cstrong\u003e不用 LangChain、不用 LangGraph——你能写出一个 Agent 吗？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e自建 Runtime 的价值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e透明性\u003c/strong\u003e：每一行代码你都清楚，出了问题知道往哪里看\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可控性\u003c/strong\u003e：精确控制重试策略、超时机制、消息压缩、工具调度，而不被框架的默认行为绑架\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e本质理解\u003c/strong\u003e：理解了 Runtime 本质，用任何框架时都能一眼看出它在做什么、哪里做得不好\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e更现实的原因：\u003cstrong\u003e生产环境中很多 Agent 系统最终都走向了自研\u003c/strong\u003e。框架在 PoC 阶段很方便，但到了需要精细控制 Token 成本、自定义 Observability、与内部基础设施深度集成时，框架往往成为障碍。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 架构设计\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003e┌───────────────────────────────────────────────────┐\n│                   AgentRuntime                     │\n│                (Core Control Loop)                 │\n│                                                    │\n│  ┌────────────┐  ┌──────────────┐  ┌───────────┐ │\n│  │ LLMClient  │  │MessageManager│  │ StateStore │ │\n│  │ chat()     │  │ append()     │  │ save()     │ │\n│  │ stream()   │  │ compress()   │  │ load()     │ │\n│  │ retry()    │  │ count_tokens │  │ clear()    │ │\n│  └─────┬──────┘  └──────┬───────┘  └───────────┘ │\n│        │                │                          │\n│        ▼                ▼                          │\n│  ┌────────────────────────────────────┐            │\n│  │          Runtime Loop              │            │\n│  │  while not done and turns \u0026lt; max:   │            │\n│  │    response = llm.chat(messages)   │            │\n│  │    if tool_calls:                  │            │\n│  │      results = executor.run()      │            │\n│  │    else: done = True               │            │\n│  └──────────┬─────────────────────────┘            │\n│       ┌─────┴──────┐                               │\n│       ▼            ▼                                │\n│  ┌──────────┐ ┌────────────┐                       │\n│  │ToolRegist│ │ToolExecutor│                       │\n│  │ register │ │ execute()  │                       │\n│  │ schema() │ │ parallel() │                       │\n│  └──────────┘ └────────────┘                       │\n└───────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心设计原则——职责分离\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模块\u003c/th\u003e\n\u003cth\u003e职责\u003c/th\u003e\n\u003cth\u003e边界\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLLMClient\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e封装模型调用，处理重试\u003c/td\u003e\n\u003ctd\u003e只管\u0026quot;调 API\u0026quot;，不管消息历史\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eToolRegistry\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e注册工具，生成 JSON Schema\u003c/td\u003e\n\u003ctd\u003e只管\u0026quot;有哪些工具\u0026quot;，不管怎么调\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eToolExecutor\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e解析 tool_calls，分发执行\u003c/td\u003e\n\u003ctd\u003e只管\u0026quot;执行工具\u0026quot;，不管谁触发的\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eMessageManager\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e管理消息列表，Token 计数和压缩\u003c/td\u003e\n\u003ctd\u003e只管\u0026quot;消息\u0026quot;，不管消息从哪来\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eAgentRuntime\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e组装一切，驱动控制循环\u003c/td\u003e\n\u003ctd\u003e只管\u0026quot;编排\u0026quot;，不自己做具体事\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e任何模块可独立替换。换 Anthropic API？只改 \u003ccode\u003eLLMClient\u003c/code\u003e。状态存 Redis？只改 \u003ccode\u003eStateStore\u003c/code\u003e。Runtime 本身不需要变动。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 逐步构建\u003c/h2\u003e\n\u003ch3\u003eStep 1: LLMClient — 封装模型调用\u003c/h3\u003e\n\u003cp\u003e封装 OpenAI 兼容接口，支持 \u003ccode\u003etools\u003c/code\u003e / \u003ccode\u003etool_choice\u003c/code\u003e，处理流式/非流式，实现指数退避重试。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# llm_client.py\nimport time, json, logging\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Generator\nfrom openai import OpenAI, APIError, RateLimitError, APITimeoutError\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ToolCall:\n    id: str\n    name: str\n    arguments: dict\n\n@dataclass\nclass LLMResponse:\n    content: Optional[str] = None\n    tool_calls: list[ToolCall] = field(default_factory=list)\n    usage: dict = field(default_factory=dict)\n    finish_reason: str = \u0026quot;\u0026quot;\n\n    @property\n    def has_tool_calls(self) -\u0026gt; bool:\n        return len(self.tool_calls) \u0026gt; 0\n\nclass LLMClient:\n    RETRYABLE_ERRORS = (RateLimitError, APITimeoutError, APIError)\n\n    def __init__(self, model=\u0026quot;gpt-4o\u0026quot;, base_url=None, api_key=None,\n                 max_retries=3, retry_base_delay=1.0, timeout=60.0):\n        self.model = model\n        self.max_retries = max_retries\n        self.retry_base_delay = retry_base_delay\n        self.client = OpenAI(base_url=base_url, api_key=api_key, timeout=timeout)\n\n    def chat(self, messages, tools=None, tool_choice=\u0026quot;auto\u0026quot;, temperature=0.0):\n        kwargs = {\u0026quot;model\u0026quot;: self.model, \u0026quot;messages\u0026quot;: messages,\n                  \u0026quot;temperature\u0026quot;: temperature}\n        if tools:\n            kwargs[\u0026quot;tools\u0026quot;] = tools\n            kwargs[\u0026quot;tool_choice\u0026quot;] = tool_choice\n        raw = self._call_with_retry(**kwargs)\n        return self._parse_response(raw)\n\n    def stream(self, messages, tools=None, tool_choice=\u0026quot;auto\u0026quot;,\n               temperature=0.0) -\u0026gt; Generator[LLMResponse, None, None]:\n        kwargs = {\u0026quot;model\u0026quot;: self.model, \u0026quot;messages\u0026quot;: messages,\n                  \u0026quot;temperature\u0026quot;: temperature, \u0026quot;stream\u0026quot;: True}\n        if tools:\n            kwargs[\u0026quot;tools\u0026quot;] = tools\n            kwargs[\u0026quot;tool_choice\u0026quot;] = tool_choice\n\n        accumulated_tool_calls: dict[int, dict] = {}\n        for chunk in self._call_with_retry(**kwargs):\n            delta = chunk.choices[0].delta if chunk.choices else None\n            if not delta:\n                continue\n            if delta.content:\n                yield LLMResponse(content=delta.content)\n            # 流式下 tool_calls 分片到达，需要累积拼装\n            if delta.tool_calls:\n                for tc in delta.tool_calls:\n                    idx = tc.index\n                    if idx not in accumulated_tool_calls:\n                        accumulated_tool_calls[idx] = {\n                            \u0026quot;id\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;arguments\u0026quot;: \u0026quot;\u0026quot;}\n                    if tc.id: accumulated_tool_calls[idx][\u0026quot;id\u0026quot;] = tc.id\n                    if tc.function.name:\n                        accumulated_tool_calls[idx][\u0026quot;name\u0026quot;] = tc.function.name\n                    if tc.function.arguments:\n                        accumulated_tool_calls[idx][\u0026quot;arguments\u0026quot;] += \\\n                            tc.function.arguments\n\n        if accumulated_tool_calls:\n            tool_calls = []\n            for d in accumulated_tool_calls.values():\n                args = json.loads(d[\u0026quot;arguments\u0026quot;]) if d[\u0026quot;arguments\u0026quot;] else {}\n                tool_calls.append(ToolCall(d[\u0026quot;id\u0026quot;], d[\u0026quot;name\u0026quot;], args))\n            yield LLMResponse(tool_calls=tool_calls)\n\n    def _call_with_retry(self, **kwargs):\n        last_error = None\n        for attempt in range(self.max_retries + 1):\n            try:\n                return self.client.chat.completions.create(**kwargs)\n            except self.RETRYABLE_ERRORS as e:\n                last_error = e\n                if attempt \u0026lt; self.max_retries:\n                    delay = self.retry_base_delay * (2 ** attempt)\n                    logger.warning(f\u0026quot;Retry {attempt+1} in {delay}s: {e}\u0026quot;)\n                    time.sleep(delay)\n        raise last_error\n\n    def _parse_response(self, raw) -\u0026gt; LLMResponse:\n        choice = raw.choices[0]\n        msg = choice.message\n        tool_calls = []\n        if msg.tool_calls:\n            for tc in msg.tool_calls:\n                args = json.loads(tc.function.arguments) \\\n                    if tc.function.arguments else {}\n                tool_calls.append(ToolCall(tc.id, tc.function.name, args))\n        return LLMResponse(\n            content=msg.content, tool_calls=tool_calls,\n            usage={\u0026quot;prompt_tokens\u0026quot;: raw.usage.prompt_tokens,\n                   \u0026quot;completion_tokens\u0026quot;: raw.usage.completion_tokens,\n                   \u0026quot;total_tokens\u0026quot;: raw.usage.total_tokens},\n            finish_reason=choice.finish_reason)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e关键设计决策\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e统一 \u003ccode\u003eLLMResponse\u003c/code\u003e\u003c/strong\u003e：无论底层用什么模型，Runtime 只看到同一结构——适配器模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e重试只针对可恢复错误\u003c/strong\u003e：\u003ccode\u003eRateLimitError\u003c/code\u003e 值得重试，\u003ccode\u003eAuthenticationError\u003c/code\u003e 重试一万次也没用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e流式 tool_calls 累积拼装\u003c/strong\u003e：OpenAI 把 tool_calls 拆成多个 chunk（先发 name，再逐步发 arguments），必须在客户端拼装。这是容易踩的坑。\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3\u003eStep 2: ToolRegistry — 工具注册与发现\u003c/h3\u003e\n\u003cp\u003e用装饰器注册函数，通过 type hints 和 docstring 自动生成 OpenAI 格式的 JSON Schema。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# tool_registry.py\nimport inspect, json\nfrom typing import Any, Callable, Optional, get_type_hints\n\nTYPE_MAP = {str: \u0026quot;string\u0026quot;, int: \u0026quot;integer\u0026quot;, float: \u0026quot;number\u0026quot;,\n            bool: \u0026quot;boolean\u0026quot;, list: \u0026quot;array\u0026quot;, dict: \u0026quot;object\u0026quot;}\n\nclass ToolRegistry:\n    def __init__(self):\n        self._tools: dict[str, Callable] = {}\n        self._schemas: dict[str, dict] = {}\n\n    def tool(self, name=None, description=None):\n        \u0026quot;\u0026quot;\u0026quot;装饰器注册工具\u0026quot;\u0026quot;\u0026quot;\n        def decorator(func):\n            n = name or func.__name__\n            d = description or (func.__doc__ or \u0026quot;\u0026quot;).strip().split(\u0026quot;\\n\u0026quot;)[0]\n            self._tools[n] = func\n            self._schemas[n] = self._gen_schema(func, n, d)\n            return func\n        return decorator\n\n    def register(self, func, name=None, description=None):\n        \u0026quot;\u0026quot;\u0026quot;命令式注册（适用于无法加装饰器的场景）\u0026quot;\u0026quot;\u0026quot;\n        n = name or func.__name__\n        d = description or (func.__doc__ or \u0026quot;\u0026quot;).strip().split(\u0026quot;\\n\u0026quot;)[0]\n        self._tools[n] = func\n        self._schemas[n] = self._gen_schema(func, n, d)\n\n    def get_function(self, name): return self._tools.get(name)\n    def get_all_schemas(self): return list(self._schemas.values())\n    def list_tools(self): return list(self._tools.keys())\n\n    def _gen_schema(self, func, name, description):\n        sig = inspect.signature(func)\n        hints = get_type_hints(func)\n        properties, required = {}, []\n        for pname, param in sig.parameters.items():\n            if pname in (\u0026quot;self\u0026quot;, \u0026quot;cls\u0026quot;): continue\n            ptype = hints.get(pname, str)\n            prop = {\u0026quot;type\u0026quot;: TYPE_MAP.get(ptype, \u0026quot;string\u0026quot;)}\n            # 从 Google 风格 docstring 提取参数描述\n            pdesc = self._param_desc(func, pname)\n            if pdesc: prop[\u0026quot;description\u0026quot;] = pdesc\n            properties[pname] = prop\n            if param.default is inspect.Parameter.empty:\n                required.append(pname)\n        return {\u0026quot;type\u0026quot;: \u0026quot;function\u0026quot;, \u0026quot;function\u0026quot;: {\n            \u0026quot;name\u0026quot;: name, \u0026quot;description\u0026quot;: description,\n            \u0026quot;parameters\u0026quot;: {\u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;,\n                           \u0026quot;properties\u0026quot;: properties, \u0026quot;required\u0026quot;: required}}}\n\n    @staticmethod\n    def _param_desc(func, param_name):\n        doc = func.__doc__ or \u0026quot;\u0026quot;\n        in_args = False\n        for line in doc.split(\u0026quot;\\n\u0026quot;):\n            s = line.strip()\n            if s.lower().startswith(\u0026quot;args:\u0026quot;): in_args = True; continue\n            if in_args and param_name + \u0026quot;:\u0026quot; in s:\n                return s.split(\u0026quot;:\u0026quot;, 1)[1].strip()\n        return \u0026quot;\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e验证效果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eregistry = ToolRegistry()\n\n@registry.tool()\ndef web_search(query: str, max_results: int = 5) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;搜索网页内容\n    Args:\n        query: 搜索关键词\n        max_results: 最大返回结果数量\n    \u0026quot;\u0026quot;\u0026quot;\n    return f\u0026quot;Results for: {query}\u0026quot;\n\n# 输出 OpenAI 格式的 tool schema\n# {\u0026quot;type\u0026quot;:\u0026quot;function\u0026quot;,\u0026quot;function\u0026quot;:{\u0026quot;name\u0026quot;:\u0026quot;web_search\u0026quot;,\u0026quot;description\u0026quot;:\u0026quot;搜索网页内容\u0026quot;,\n#  \u0026quot;parameters\u0026quot;:{\u0026quot;type\u0026quot;:\u0026quot;object\u0026quot;,\u0026quot;properties\u0026quot;:{\u0026quot;query\u0026quot;:{\u0026quot;type\u0026quot;:\u0026quot;string\u0026quot;,\n#  \u0026quot;description\u0026quot;:\u0026quot;搜索关键词\u0026quot;},\u0026quot;max_results\u0026quot;:{\u0026quot;type\u0026quot;:\u0026quot;integer\u0026quot;,\n#  \u0026quot;description\u0026quot;:\u0026quot;最大返回结果数量\u0026quot;}},\u0026quot;required\u0026quot;:[\u0026quot;query\u0026quot;]}}}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch3\u003eStep 3: ToolExecutor — 工具执行与结果处理\u003c/h3\u003e\n\u003cp\u003e接收 LLM 返回的 \u003ccode\u003etool_calls\u003c/code\u003e，分发执行，收集结果，处理异常。支持串行和并行两种模式。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# tool_executor.py\nimport json, time, logging, traceback\nfrom concurrent.futures import ThreadPoolExecutor, TimeoutError as FTE\nfrom dataclasses import dataclass\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ToolResult:\n    tool_call_id: str\n    name: str\n    result: str\n    success: bool\n    duration_ms: float = 0.0\n\nclass ToolExecutor:\n    def __init__(self, registry, default_timeout=30.0, max_workers=4):\n        self.registry = registry\n        self.default_timeout = default_timeout\n        self.max_workers = max_workers\n\n    def execute(self, tool_calls) -\u0026gt; list[ToolResult]:\n        \u0026quot;\u0026quot;\u0026quot;串行执行\u0026quot;\u0026quot;\u0026quot;\n        return [self._run_one(tc) for tc in tool_calls]\n\n    def execute_parallel(self, tool_calls) -\u0026gt; list[ToolResult]:\n        \u0026quot;\u0026quot;\u0026quot;并行执行（LLM 一次返回多个 tool_calls 时使用）\u0026quot;\u0026quot;\u0026quot;\n        if len(tool_calls) \u0026lt;= 1:\n            return self.execute(tool_calls)\n        results = []\n        with ThreadPoolExecutor(max_workers=self.max_workers) as pool:\n            futures = {pool.submit(self._run_one, tc): tc for tc in tool_calls}\n            for fut in futures:\n                try:\n                    results.append(fut.result(timeout=self.default_timeout))\n                except FTE:\n                    tc = futures[fut]\n                    results.append(ToolResult(\n                        tc.id, tc.name,\n                        f\u0026quot;Error: \u0026#39;{tc.name}\u0026#39; timed out after \u0026quot;\n                        f\u0026quot;{self.default_timeout}s\u0026quot;, False))\n        return results\n\n    def _run_one(self, tool_call) -\u0026gt; ToolResult:\n        start = time.monotonic()\n        func = self.registry.get_function(tool_call.name)\n        if not func:\n            return ToolResult(tool_call.id, tool_call.name,\n                f\u0026quot;Error: Unknown tool \u0026#39;{tool_call.name}\u0026#39;. \u0026quot;\n                f\u0026quot;Available: {self.registry.list_tools()}\u0026quot;, False)\n        try:\n            result = func(**tool_call.arguments)\n            if not isinstance(result, str):\n                result = json.dumps(result, ensure_ascii=False, default=str)\n            ms = (time.monotonic() - start) * 1000\n            logger.info(f\u0026quot;Tool \u0026#39;{tool_call.name}\u0026#39; OK in {ms:.0f}ms\u0026quot;)\n            return ToolResult(tool_call.id, tool_call.name, result, True, ms)\n        except Exception as e:\n            ms = (time.monotonic() - start) * 1000\n            msg = f\u0026quot;Error: {type(e).__name__}: {e}\u0026quot;\n            logger.error(f\u0026quot;{msg}\\n{traceback.format_exc()}\u0026quot;)\n            return ToolResult(tool_call.id, tool_call.name, msg, False, ms)\n\n    @staticmethod\n    def results_to_messages(results):\n        return [{\u0026quot;role\u0026quot;: \u0026quot;tool\u0026quot;, \u0026quot;tool_call_id\u0026quot;: r.tool_call_id,\n                 \u0026quot;content\u0026quot;: r.result} for r in results]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e串行 vs 并行的 Trade-off\u003c/strong\u003e：串行简单可调试；并行在 LLM 同时返回多个独立 tool_calls 时显著降低延迟。LLM 在一次响应中返回多个 tool_calls 本身就隐含了\u0026quot;它们之间无依赖\u0026quot;——否则它会分成多轮调用。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eStep 4: MessageManager — 消息历史管理与压缩\u003c/h3\u003e\n\u003cp\u003e解决 Agent 长对话中最常遇到的问题：\u003cstrong\u003e消息越来越多，Context Window 不够用了\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# message_manager.py\nimport json, logging, tiktoken\nfrom typing import Optional\nfrom copy import deepcopy\n\nlogger = logging.getLogger(__name__)\n\nclass MessageManager:\n    def __init__(self, system_prompt=\u0026quot;\u0026quot;, model=\u0026quot;gpt-4o\u0026quot;,\n                 max_tokens=120000, compression_threshold=0.75):\n        self.system_prompt = system_prompt\n        self.max_tokens = max_tokens\n        self.compression_threshold = compression_threshold\n        try: self.enc = tiktoken.encoding_for_model(model)\n        except KeyError: self.enc = tiktoken.get_encoding(\u0026quot;cl100k_base\u0026quot;)\n        self._messages: list[dict] = []\n\n    def append(self, msg):\n        self._messages.append(msg)\n        self._maybe_compress()\n\n    def extend(self, msgs):\n        self._messages.extend(msgs)\n        self._maybe_compress()\n\n    def get_messages(self):\n        out = []\n        if self.system_prompt:\n            out.append({\u0026quot;role\u0026quot;: \u0026quot;system\u0026quot;, \u0026quot;content\u0026quot;: self.system_prompt})\n        out.extend(deepcopy(self._messages))\n        return out\n\n    def count_tokens(self, msgs=None):\n        msgs = msgs or self.get_messages()\n        total = 2  # priming tokens\n        for m in msgs:\n            total += 4  # per-message overhead\n            for v in m.values():\n                if isinstance(v, str): total += len(self.enc.encode(v))\n                elif isinstance(v, list):\n                    total += len(self.enc.encode(json.dumps(v)))\n        return total\n\n    def _maybe_compress(self):\n        threshold = int(self.max_tokens * self.compression_threshold)\n        if self.count_tokens() \u0026lt;= threshold: return\n        logger.info(\u0026quot;Token threshold exceeded, compressing...\u0026quot;)\n        self._sliding_window_compress(threshold)\n\n    def _sliding_window_compress(self, target):\n        \u0026quot;\u0026quot;\u0026quot;从最早的消息移除，保持 tool_call 对完整性。\n\n        关键约束：assistant(tool_calls) 后面的 tool(result) 消息必须\n        一起移除，否则 OpenAI API 会报错。\n        \u0026quot;\u0026quot;\u0026quot;\n        msgs, i = self._messages, 0\n        while i \u0026lt; len(msgs):\n            remaining = msgs[i:]\n            sys_msgs = ([{\u0026quot;role\u0026quot;:\u0026quot;system\u0026quot;,\u0026quot;content\u0026quot;:self.system_prompt}]\n                        if self.system_prompt else [])\n            if self.count_tokens(sys_msgs + remaining) \u0026lt;= target: break\n            i += 1\n            # 如果刚移除的是含 tool_calls 的 assistant，连续移除后续 tool 消息\n            if (i \u0026gt; 0 and msgs[i-1].get(\u0026quot;role\u0026quot;) == \u0026quot;assistant\u0026quot;\n                    and msgs[i-1].get(\u0026quot;tool_calls\u0026quot;)):\n                while i \u0026lt; len(msgs) and msgs[i].get(\u0026quot;role\u0026quot;) == \u0026quot;tool\u0026quot;:\n                    i += 1\n        if i \u0026gt; 0:\n            summary = {\u0026quot;role\u0026quot;: \u0026quot;system\u0026quot;, \u0026quot;content\u0026quot;:\n                f\u0026quot;[{i} earlier messages removed to fit context window.]\u0026quot;}\n            self._messages = [summary] + msgs[i:]\n            logger.info(f\u0026quot;Removed {i} msgs, tokens: {self.count_tokens()}\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e三个关键点\u003c/strong\u003e：System Prompt 始终保留不参与压缩；tool_call 对必须保持完整（\u003ccode\u003eassistant\u003c/code\u003e + 后续 \u003ccode\u003etool\u003c/code\u003e 消息一起删或一起留）；在 75% 时就触发压缩，给回复留够空间。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3\u003eStep 5: StateStore — 状态持久化\u003c/h3\u003e\n\u003cp\u003e简单的键值存储，生产中替换为 Redis 或数据库即可。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# state_store.py\nimport json\nfrom typing import Any, Optional\nfrom pathlib import Path\n\nclass StateStore:\n    def __init__(self, store_dir=\u0026quot;.agent_state\u0026quot;):\n        self.dir = Path(store_dir)\n        self.dir.mkdir(parents=True, exist_ok=True)\n        self._cache: dict[str, Any] = {}\n\n    def save(self, key, value):\n        self._cache[key] = value\n        (self.dir / f\u0026quot;{key}.json\u0026quot;).write_text(\n            json.dumps(value, ensure_ascii=False, indent=2, default=str))\n\n    def load(self, key, default=None):\n        if key in self._cache: return self._cache[key]\n        f = self.dir / f\u0026quot;{key}.json\u0026quot;\n        if f.exists():\n            v = json.loads(f.read_text())\n            self._cache[key] = v\n            return v\n        return default\n\n    def clear(self, key=None):\n        if key:\n            self._cache.pop(key, None)\n            (self.dir / f\u0026quot;{key}.json\u0026quot;).unlink(missing_ok=True)\n        else:\n            self._cache.clear()\n            for f in self.dir.glob(\u0026quot;*.json\u0026quot;): f.unlink()\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e4. 核心 Runtime Loop\u003c/h2\u003e\n\u003cp\u003e所有模块就绪，组装成完整的 \u003ccode\u003eAgentRuntime\u003c/code\u003e。这是整篇文章的核心。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# agent_runtime.py\nimport json, time, logging\nfrom dataclasses import dataclass, field\nfrom typing import Optional, Callable\nfrom collections import Counter\n\nfrom llm_client import LLMClient, LLMResponse\nfrom tool_registry import ToolRegistry\nfrom tool_executor import ToolExecutor\nfrom message_manager import MessageManager\nfrom state_store import StateStore\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass RuntimeConfig:\n    max_turns: int = 20               # 最大循环轮次\n    max_total_time: float = 300.0     # 最大总执行时间（秒）\n    parallel_tool_calls: bool = True  # 是否并行执行工具\n    loop_detection_window: int = 4    # 死循环检测窗口\n    loop_detection_threshold: int = 3 # 相同调用出现次数阈值\n\n@dataclass\nclass AgentResult:\n    content: str\n    turns: int = 0\n    total_tokens: int = 0\n    tool_calls_made: list[dict] = field(default_factory=list)\n    duration_ms: float = 0.0\n    stopped_reason: str = \u0026quot;\u0026quot;\n\nclass AgentRuntime:\n    def __init__(self, llm: LLMClient, registry: ToolRegistry,\n                 system_prompt=\u0026quot;You are a helpful assistant.\u0026quot;,\n                 config: Optional[RuntimeConfig] = None):\n        self.llm = llm\n        self.registry = registry\n        self.executor = ToolExecutor(registry)\n        self.config = config or RuntimeConfig()\n        self.messages = MessageManager(system_prompt=system_prompt,\n                                       model=llm.model)\n        self.state = StateStore()\n        self.on_tool_start: Optional[Callable] = None\n        self.on_tool_end: Optional[Callable] = None\n\n    def run(self, user_input: str) -\u0026gt; AgentResult:\n        start_time = time.monotonic()\n        self.messages.append({\u0026quot;role\u0026quot;: \u0026quot;user\u0026quot;, \u0026quot;content\u0026quot;: user_input})\n        tools = self.registry.get_all_schemas() or None\n\n        turns, total_tokens, all_tc = 0, 0, []\n        tc_history: list[str] = []\n        final_content, stopped = \u0026quot;\u0026quot;, \u0026quot;completed\u0026quot;\n\n        while turns \u0026lt; self.config.max_turns:\n            turns += 1\n\n            # ── 全局超时检查 ─────────────────────────────\n            if time.monotonic() - start_time \u0026gt; self.config.max_total_time:\n                stopped = f\u0026quot;timeout ({self.config.max_total_time}s)\u0026quot;\n                break\n\n            # ── 调用 LLM ────────────────────────────────\n            logger.info(f\u0026quot;Turn {turns}: calling LLM...\u0026quot;)\n            resp = self.llm.chat(self.messages.get_messages(), tools=tools)\n            total_tokens += resp.usage.get(\u0026quot;total_tokens\u0026quot;, 0)\n\n            # ── 情况 1: 有 tool_calls → 执行工具 ────────\n            if resp.has_tool_calls:\n                # 构建 assistant 消息（必须包含 tool_calls 字段）\n                asst = {\u0026quot;role\u0026quot;: \u0026quot;assistant\u0026quot;, \u0026quot;content\u0026quot;: resp.content,\n                        \u0026quot;tool_calls\u0026quot;: [\n                    {\u0026quot;id\u0026quot;: tc.id, \u0026quot;type\u0026quot;: \u0026quot;function\u0026quot;,\n                     \u0026quot;function\u0026quot;: {\u0026quot;name\u0026quot;: tc.name,\n                                  \u0026quot;arguments\u0026quot;: json.dumps(tc.arguments)}}\n                    for tc in resp.tool_calls]}\n                self.messages.append(asst)\n\n                # 死循环检测\n                sig = json.dumps([(tc.name, tc.arguments)\n                                  for tc in resp.tool_calls], sort_keys=True)\n                tc_history.append(sig)\n                if self._detect_loop(tc_history):\n                    stopped = \u0026quot;loop_detected\u0026quot;\n                    final_content = (\u0026quot;I\u0026#39;m repeating the same actions. \u0026quot;\n                                     \u0026quot;Stopping to summarize findings.\u0026quot;)\n                    break\n\n                # 执行\n                if self.on_tool_start: self.on_tool_start(resp.tool_calls)\n                if self.config.parallel_tool_calls and len(resp.tool_calls) \u0026gt; 1:\n                    results = self.executor.execute_parallel(resp.tool_calls)\n                else:\n                    results = self.executor.execute(resp.tool_calls)\n                if self.on_tool_end: self.on_tool_end(results)\n\n                for tc, r in zip(resp.tool_calls, results):\n                    all_tc.append({\u0026quot;turn\u0026quot;: turns, \u0026quot;name\u0026quot;: tc.name,\n                        \u0026quot;arguments\u0026quot;: tc.arguments,\n                        \u0026quot;success\u0026quot;: r.success, \u0026quot;duration_ms\u0026quot;: r.duration_ms})\n\n                self.messages.extend(ToolExecutor.results_to_messages(results))\n\n            # ── 情况 2: 纯文本 → 任务完成 ───────────────\n            else:\n                final_content = resp.content or \u0026quot;\u0026quot;\n                self.messages.append(\n                    {\u0026quot;role\u0026quot;: \u0026quot;assistant\u0026quot;, \u0026quot;content\u0026quot;: final_content})\n                break\n        else:\n            stopped = f\u0026quot;max_turns ({self.config.max_turns})\u0026quot;\n\n        return AgentResult(\n            content=final_content, turns=turns, total_tokens=total_tokens,\n            tool_calls_made=all_tc,\n            duration_ms=(time.monotonic() - start_time) * 1000,\n            stopped_reason=stopped)\n\n    def _detect_loop(self, history):\n        \u0026quot;\u0026quot;\u0026quot;滑动窗口 + 频次统计，同时捕获连续重复和交替重复\u0026quot;\u0026quot;\u0026quot;\n        w = self.config.loop_detection_window\n        t = self.config.loop_detection_threshold\n        if len(history) \u0026lt; t: return False\n        return any(c \u0026gt;= t for c in Counter(history[-w:]).values())\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e核心循环解读\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e两种退出路径\u003c/strong\u003e——这是 Agent 与 Workflow 的本质区别：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eresp.has_tool_calls == True   → 继续（还有事要做）\nresp.has_tool_calls == False  → break（LLM 认为任务完成了）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e为什么 assistant 消息必须包含 tool_calls 字段？\u003c/strong\u003e 这是 OpenAI API 的协议约束。消息流必须是：\u003ccode\u003euser\u003c/code\u003e → \u003ccode\u003eassistant(tool_calls)\u003c/code\u003e → \u003ccode\u003etool(result)\u003c/code\u003e → \u003ccode\u003eassistant(final)\u003c/code\u003e。打破这个顺序会报错。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e死循环检测\u003c/strong\u003e用滑动窗口而非简单的\u0026quot;连续 N 次相同\u0026quot;，因为 LLM 有时会在两个工具间交替调用（A→B→A→B→...），这也是死循环，但不是\u0026quot;连续相同\u0026quot;。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e5. 高级特性\u003c/h2\u003e\n\u003ch3\u003e5.1 Streaming 支持\u003c/h3\u003e\n\u003cp\u003e流式模式下需要边输出文本、边判断是否有 tool_calls：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 添加到 AgentRuntime\ndef run_stream(self, user_input: str):\n    self.messages.append({\u0026quot;role\u0026quot;: \u0026quot;user\u0026quot;, \u0026quot;content\u0026quot;: user_input})\n    tools = self.registry.get_all_schemas() or None\n    turns = 0\n\n    while turns \u0026lt; self.config.max_turns:\n        turns += 1\n        content, final_tc = \u0026quot;\u0026quot;, None\n\n        for chunk in self.llm.stream(self.messages.get_messages(), tools=tools):\n            if chunk.content:\n                content += chunk.content\n                yield {\u0026quot;type\u0026quot;: \u0026quot;text\u0026quot;, \u0026quot;content\u0026quot;: chunk.content}\n            if chunk.tool_calls:\n                final_tc = chunk.tool_calls\n\n        if final_tc:\n            yield {\u0026quot;type\u0026quot;: \u0026quot;tool_start\u0026quot;,\n                   \u0026quot;calls\u0026quot;: [{\u0026quot;name\u0026quot;:tc.name} for tc in final_tc]}\n            asst = {\u0026quot;role\u0026quot;: \u0026quot;assistant\u0026quot;, \u0026quot;content\u0026quot;: content,\n                    \u0026quot;tool_calls\u0026quot;: [\n                {\u0026quot;id\u0026quot;:tc.id, \u0026quot;type\u0026quot;:\u0026quot;function\u0026quot;,\n                 \u0026quot;function\u0026quot;:{\u0026quot;name\u0026quot;:tc.name,\n                             \u0026quot;arguments\u0026quot;:json.dumps(tc.arguments)}}\n                for tc in final_tc]}\n            self.messages.append(asst)\n            results = self.executor.execute(final_tc)\n            self.messages.extend(ToolExecutor.results_to_messages(results))\n            yield {\u0026quot;type\u0026quot;: \u0026quot;tool_end\u0026quot;,\n                   \u0026quot;results\u0026quot;: [{\u0026quot;name\u0026quot;:r.name, \u0026quot;ok\u0026quot;:r.success} for r in results]}\n        else:\n            self.messages.append({\u0026quot;role\u0026quot;:\u0026quot;assistant\u0026quot;,\u0026quot;content\u0026quot;:content})\n            yield {\u0026quot;type\u0026quot;: \u0026quot;done\u0026quot;, \u0026quot;content\u0026quot;: content}\n            break\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 超时控制的两层设计\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e┌──────────────────────────────────────┐\n│ 全局超时 (max_total_time = 300s)     │\n│  ┌──────┐ ┌──────┐ ┌──────┐        │\n│  │Tool 1│ │Tool 2│ │Tool 3│        │\n│  │30s   │ │30s   │ │30s   │        │\n│  └──────┘ └──────┘ └──────┘        │\n│ 单工具超时 (default_timeout = 30s)   │\n└──────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e单工具超时在 \u003ccode\u003eToolExecutor\u003c/code\u003e 中通过 \u003ccode\u003eThreadPoolExecutor.result(timeout=30)\u003c/code\u003e 控制；全局超时在 Runtime 每轮循环开始时检查 elapsed time。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e6. 完整示例：研究助手 Agent\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# research_agent.py\nimport json, os, logging\nfrom agent_runtime import AgentRuntime, RuntimeConfig\nfrom llm_client import LLMClient\nfrom tool_registry import ToolRegistry\n\nlogging.basicConfig(level=logging.INFO,\n    format=\u0026quot;%(asctime)s [%(levelname)s] %(name)s: %(message)s\u0026quot;)\n\nregistry = ToolRegistry()\n\n@registry.tool()\ndef web_search(query: str, max_results: int = 5) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;搜索网页内容\n    Args:\n        query: 搜索关键词\n        max_results: 最大返回数量\n    \u0026quot;\u0026quot;\u0026quot;\n    # 生产环境替换为 SerpAPI / Bing API\n    return json.dumps([{\u0026quot;title\u0026quot;: f\u0026quot;Result {i+1} for \u0026#39;{query}\u0026#39;\u0026quot;,\n        \u0026quot;url\u0026quot;: f\u0026quot;https://example.com/article-{i+1}\u0026quot;,\n        \u0026quot;snippet\u0026quot;: f\u0026quot;Detailed article about {query}, section {i+1}...\u0026quot;}\n        for i in range(min(max_results, 3))], ensure_ascii=False)\n\n@registry.tool()\ndef read_url(url: str) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;读取网页内容\n    Args:\n        url: 网页地址\n    \u0026quot;\u0026quot;\u0026quot;\n    # 生产环境替换为 requests + BeautifulSoup\n    return (f\u0026quot;[Content from {url}]\\n\u0026quot;\n            f\u0026quot;Key points: 1) Fundamental concepts 2) Best practices \u0026quot;\n            f\u0026quot;3) Common pitfalls 4) Case studies and benchmarks\u0026quot;)\n\n@registry.tool()\ndef write_file(filename: str, content: str) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;写入文件\n    Args:\n        filename: 文件名\n        content: 文本内容\n    \u0026quot;\u0026quot;\u0026quot;\n    os.makedirs(\u0026quot;output\u0026quot;, exist_ok=True)\n    path = os.path.join(\u0026quot;output\u0026quot;, os.path.basename(filename))\n    with open(path, \u0026quot;w\u0026quot;) as f: f.write(content)\n    return f\u0026quot;Wrote {len(content)} chars to {path}\u0026quot;\n\n@registry.tool()\ndef ask_user(question: str) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;向用户提问\n    Args:\n        question: 问题\n    \u0026quot;\u0026quot;\u0026quot;\n    print(f\u0026quot;\\nAgent asks: {question}\u0026quot;)\n    return input(\u0026quot;Your answer: \u0026quot;)\n\nSYSTEM_PROMPT = \u0026quot;\u0026quot;\u0026quot;You are a research assistant. Workflow:\n1. Search for information using web_search\n2. Read promising articles using read_url (at least 2 sources)\n3. Synthesize into a report and save with write_file\n4. Present a summary. Use ask_user if the topic is unclear.\u0026quot;\u0026quot;\u0026quot;\n\nagent = AgentRuntime(\n    llm=LLMClient(model=\u0026quot;gpt-4o\u0026quot;, api_key=os.environ.get(\u0026quot;OPENAI_API_KEY\u0026quot;)),\n    registry=registry,\n    system_prompt=SYSTEM_PROMPT,\n    config=RuntimeConfig(max_turns=15, max_total_time=120.0))\n\nif __name__ == \u0026quot;__main__\u0026quot;:\n    result = agent.run(\u0026quot;研究 Python asyncio 最佳实践，整理成技术报告并保存。\u0026quot;)\n    print(f\u0026quot;\\n{\u0026#39;=\u0026#39;*50}\\nTurns: {result.turns} | Tokens: {result.total_tokens} \u0026quot;\n          f\u0026quot;| {result.duration_ms:.0f}ms | {result.stopped_reason}\u0026quot;)\n    for tc in result.tool_calls_made:\n        print(f\u0026quot;  Turn {tc[\u0026#39;turn\u0026#39;]}: {tc[\u0026#39;name\u0026#39;]}() \u0026quot;\n              f\u0026quot;{\u0026#39;OK\u0026#39; if tc[\u0026#39;success\u0026#39;] else \u0026#39;FAIL\u0026#39;} {tc[\u0026#39;duration_ms\u0026#39;]:.0f}ms\u0026quot;)\n    print(f\u0026quot;\\n{result.content[:300]}\u0026quot;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e执行 Trace\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eTurn 1: calling LLM...  → web_search(\u0026quot;Python asyncio best practices\u0026quot;)\nTurn 2: calling LLM...  → read_url(url1) + read_url(url2)  [parallel]\nTurn 3: calling LLM...  → web_search(\u0026quot;asyncio common pitfalls\u0026quot;)\nTurn 4: calling LLM...  → read_url(url3)\nTurn 5: calling LLM...  → write_file(\u0026quot;asyncio-report.md\u0026quot;, ...)\nTurn 6: calling LLM...  → [no tool_calls] → Done\n\n==================================================\nTurns: 6 | Tokens: 8432 | 13245ms | completed\n  Turn 1: web_search() OK 45ms\n  Turn 2: read_url() OK 120ms\n  Turn 2: read_url() OK 135ms\n  Turn 3: web_search() OK 38ms\n  Turn 4: read_url() OK 110ms\n  Turn 5: write_file() OK 5ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意 Turn 2：LLM 返回了两个 \u003ccode\u003eread_url\u003c/code\u003e，Runtime 自动并行执行。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e7. 与框架对比\u003c/h2\u003e\n\u003ch3\u003e自建 vs 框架\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003e自建 Runtime\u003c/th\u003e\n\u003cth\u003e框架（LangChain 等）\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e透明性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e完全透明\u003c/td\u003e\n\u003ctd\u003e需要读框架源码\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e调试\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e直接 breakpoint\u003c/td\u003e\n\u003ctd\u003e需要理解框架抽象层\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e定制\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e任何行为可改\u003c/td\u003e\n\u003ctd\u003e受 API 设计约束\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e依赖\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eopenai\u003c/code\u003e + \u003ccode\u003etiktoken\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e几十个传递依赖\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e边界情况\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e自己发现和处理\u003c/td\u003e\n\u003ctd\u003e社区帮你踩过坑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e生态集成\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e每个都要自己写\u003c/td\u003e\n\u003ctd\u003e现成的 VectorStore/Retriever\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e开发速度\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e初期更慢\u003c/td\u003e\n\u003ctd\u003e有模板更快\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e决策建议\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e学习阶段\u003c/strong\u003e：一定要自建一次。不理解原理就用框架，永远无法判断框架是否在坑你。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePoC / Hackathon\u003c/strong\u003e：用框架，速度第一。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e生产系统\u003c/strong\u003e：自建核心 Runtime + 选择性使用框架组件（如只用 LangChain 的 Retriever）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e基础设施团队\u003c/strong\u003e：自建。你们的需求框架大概率满足不了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 结语：Phase 2 完成\u003c/h2\u003e\n\u003cp\u003e到这里，Phase 2 四篇文章全部完成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e第 04 篇\u003c/strong\u003e：理解控制循环 — Observe → Think → Act → Reflect\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第 05 篇\u003c/strong\u003e：深入 Tool Calling — JSON Schema、Function Calling、Structured Output\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第 06 篇\u003c/strong\u003e：Prompt Engineering — System Prompt 设计、工具选择引导、Reflection Prompt\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第 07 篇（本篇）\u003c/strong\u003e：把以上所有知识组装成可运行的 Agent Runtime\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e此刻你有能力\u003cstrong\u003e不依赖任何框架，从零构建功能完整的 Agent 系统\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e但如果你运行过这个 Agent，会很快发现几个问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e没有记忆\u003c/strong\u003e：每次启动都是白纸，不记得上次的对话\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不会计划\u003c/strong\u003e：面对复杂任务只是一步步试，没有全局规划\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e一个不够用\u003c/strong\u003e：有些任务需要不同角色的 Agent 协作\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这就是 Phase 3 要解决的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e第 08 篇\u003c/strong\u003e：Memory Architecture — Agent 的状态与记忆体系\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第 09 篇\u003c/strong\u003e：RAG as Cognitive Memory — 检索增强生成的工程实践\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第 10 篇\u003c/strong\u003e：Planning and Reflection — 从 ReAct 到分层规划\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第 11 篇\u003c/strong\u003e：Multi-Agent Collaboration — 多 Agent 协作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePhase 2 给了你造一把锤子的能力。Phase 3 将教你如何造一个工具箱。\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e系列导航\u003c/strong\u003e：本文是 Agentic 系列的第 07 篇。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e上一篇：\u003ca href=\"/blog/engineering/agentic/06-Prompt%20Engineering%20for%20Agents\"\u003e06 | Prompt Engineering for Agents\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e下一篇：\u003ca href=\"/blog/engineering/agentic/08-Memory%20Architecture\"\u003e08 | Memory Architecture\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e完整目录：\u003ca href=\"/blog/engineering/agentic/01-From%20LLM%20to%20Agent\"\u003e01 | From LLM to Agent\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"19:T4fc0,"])</script><script>self.__next_f.push([1,"\u003cp\u003e你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。\u003c/p\u003e\n\u003cp\u003e另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) \nand name in(sql\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缩略下印如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004,...) \nand name in(\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,...)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -\u0026gt; ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver -\u0026gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从\u003cstrong\u003eDataSource  -\u0026gt; Connection -\u0026gt; Driver\u003c/strong\u003e三个环节进行入手：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e一、SQL Profile监控\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1、驱动层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\u0026amp;logger=Slf4JLogger\u0026amp;profileSQL=true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2、连接层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如\u003ca href=\"https://p6spy.readthedocs.io/en/latest/\"\u003eP6Spy\u003c/a\u003e、\u003ca href=\"https://github.com/arthurblake/log4jdbc\"\u003elog4jdbc\u003c/a\u003e 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epyspy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:p6spy:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3、数据源层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e可以通过对DataSource进行代理实现SQL监控\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eP6Spy：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Bean\n@Primary\npublic DataSource spyDataSource(@Autowired DataSource dataSource) {\n  // wrap a datasource using P6SpyDataSource\n  return new P6DataSource(dataSource);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic DataSource spyDataSource(DataSource dataSource) {\n    // wrap the provided dataSource\n  return new DataSource() {\n    @Override\n    public Connection getConnection() throws SQLException {\n      // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection());\n    }\n      \n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n       // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection(username, password));\n     }\n      //...\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。\u003c/p\u003e\n\u003cp\u003e第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。\u003c/p\u003e\n\u003cp\u003e第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。\u003c/p\u003e\n\u003cp\u003e排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface DataSourceConfig extends HasBizDef {\n\n    /**\n     * 数据源名称，必须与KDB申请时填写的一致\n     */String bizName();\n\n    /**\n     * 获取当前可用区单库只读的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate read() {\n        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), \u0026quot;read\u0026quot;);\n    }   \n\n    /**\n     * 获取当前可用区单库读写的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate write() {\n        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), \u0026quot;write\u0026quot;);\n    }\t\n  //....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eenum class AdDataSources(\n    private val bizDef: BizDef,\n    private val forTest: AdDataSources? = null,\n    private val usingNewZk: Boolean = false\n) : DataSourceConfig{\n    adFansTopProfileDashboardTest,\n    adFansTopProfileDashboard,\n    adChargeTest,\n    adCharge,\n    adChargeReadOnly,\n    adDspReadOnlyTest,\n    adDspReadOnly;\n    public open fun bizName(): String {\n        return bizDef.bizName\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？\u003c/p\u003e\n\u003cp\u003e具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static ListenableDataSource\u0026lt;Failover\u0026lt;Instance\u0026gt;\u0026gt; create(Instance i) {\n   //...\n   try {\n       return supplyWithRetry(\n        DATA_SOURCE_BUILD_RETRY,\n        DATA_SOURCE_BUILD_RETRY_DELAY,\n        () -\u0026gt; new ListenableDataSource\u0026lt;\u0026gt;(\n              bizName, \n              new HikariDataSource(config), ds -\u0026gt; i.toString(), i),\n              DataSourceFactory::needRetry);\n                               \n  } catch (Throwable e) {/**/}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e二、动态修改加载类\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e成本最低的方式就是直接修改这段代码，将其中\u0026#x7684;\u003cem\u003e\u0026#x6E;ew HikariDataSource(config)\u003c/em\u003e\u0026#x4FEE;改\u0026#x6210;\u003cem\u003e\u0026#x6E;ew P6DataSource(new HikariDataSource(config))，\u003c/em\u003e\u0026#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？\u003c/p\u003e\n\u003cp\u003e首先我们来分析一下，有哪些手段可以修改Java字节码？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案一、编译时修改，需要开发maven插件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（不使用maven插件的同学咋办？）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案二、加载时修改，重写类加载器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要在代码中指定特定的类加载器，用有一定的侵入式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案三、运行时修改，使用JavaAgent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要修改应用启动参数，运维成本有点高\u003c/p\u003e\n\u003cp\u003e首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下面是对动态启动Java Agent技术的解释\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSee \u003ca href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description\"\u003ethe java.lang.instrument package documentation\u003c/a\u003e…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGetting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. \u003ca href=\"https://stackoverflow.com/a/19912148/2711488\"\u003eThis answer\u003c/a\u003e demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAs mentioned in \u003ca href=\"https://stackoverflow.com/questions/56787777/?noredirect=1\u0026lq=1#comment100160373_56787777\"\u003ethis comment\u003c/a\u003e, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e字节码工具对比\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用bytebuddy修改字节码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在实现代码之前，我们回过头来再看一下快手的数据源生成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ListenableDataSource\u0026lt;\u0026gt;(bizName, new HikariDataSource(config), ds -\u0026gt; i.toString());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DelegatingDataSource implements DataSource {\n   //...\n  public DelegatingDataSource(DataSource targetDataSource) {\n    this.setTargetDataSource(targetDataSource);\n   }\n\n  public void setTargetDataSource(@Nullable DataSource targetDataSource) {\n      this.targetDataSource = targetDataSource;\n  }\n  //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n        this.targetDataSource = new P6DataSource(targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么具体如何修改字节码呢？这里是\u003ca href=\"https://bytebuddy.net/#/tutorial\"\u003e官方文档\u003c/a\u003e，原理我们不做赘述，直接介绍实现了。实现方式有三种：\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1、类文件替换\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n  .redefine(NewDelegatingDataSource.class)\n  .name(DelegatingDataSource.class.getName())\n  .make()\n  .load(Thread.currentThread().getContextClassLoader(), \n        ClassReloadingStrategy.fromInstalledAgent());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2、操作字节码：\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .redefine(DelegatingDataSource.class)\n    //重写DelegatingDataSource#setTargetDataSource方法\n    .method(named(\u0026quot;setTargetDataSource\u0026quot;))\n    .intercept(MyImplementation.INSTANCE)\n    .make()\n    .load(Thread.currentThread().getContextClassLoader(),\n          ClassReloadingStrategy.fromInstalledAgent());\n\nenum MyImplementation implements Implementation {\n\nINSTANCE; // singleton\n\n  @Override\n  public InstrumentedType prepare(InstrumentedType instrumentedType) {\n  return instrumentedType;\n  }\n  \n  @Override\n  public ByteCodeAppender appender(Target implementationTarget) {\n  return MyAppender.INSTANCE;\n  }\n  \n}\n//字节码定义\nenum MyAppender implements ByteCodeAppender {\n\nINSTANCE; // singleton\n\n@Override\npublic Size apply(MethodVisitor methodVisitor,\n        Implementation.Context implementationContext,\n        MethodDescription instrumentedMethod) {\n  Label label0 = new Label();\n  methodVisitor.visitLabel(label0);\n  methodVisitor.visitLineNumber(70, label0);\n  methodVisitor.visitVarInsn(ALOAD, 0);\n  methodVisitor.visitTypeInsn(NEW, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;);\n  methodVisitor.visitInsn(DUP);\n  methodVisitor.visitVarInsn(ALOAD, 1);\n  methodVisitor.visitMethodInsn(INVOKESPECIAL, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;, \u0026quot;\u0026lt;init\u0026gt;\u0026quot;, \u0026quot;(Ljavax/sql/DataSource;)V\u0026quot;, false);\n  methodVisitor.visitFieldInsn(PUTFIELD, \u0026quot;org/springframework/jdbc/datasource/DelegatingDataSource\u0026quot;, \u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;);\n  Label label1 = new Label();\n  methodVisitor.visitLabel(label1);\n  methodVisitor.visitLineNumber(71, label1);\n  methodVisitor.visitInsn(RETURN);\n  Label label2 = new Label();\n  methodVisitor.visitLabel(label2);\n  methodVisitor.visitLocalVariable(\u0026quot;this\u0026quot;, \u0026quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;\u0026quot;, null, label0, label2, 0);\n  methodVisitor.visitLocalVariable(\u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;, null, label0, label2, 1);\n  methodVisitor.visitMaxs(4, 2);\n  return new Size(4, 2);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？\u003c/p\u003e\n\u003cp\u003e我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e3、利用byte-buddy的Advice\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public static void redefine() {\n   new ByteBuddy()\n     .redefine(DelegatingDataSource.class)\n     .visit(Advice.to(Decorator.class)\n            .on(ElementMatchers.named(\u0026quot;setTargetDataSource\u0026quot;)))\n     .make()\n     .load(Thread.currentThread().getContextClassLoader(),\n           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();\n }\n\nstatic class Decorator {\n\n  //在方法开始插入代码\n  @Advice.OnMethodEnter\n    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {\n    dataSource = new P6DataSource(dataSource);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebyte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n  //插入的代码\n  targetDataSource = new P6DataSource(targetDataSource);\n  this.targetDataSource = targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。\u003c/li\u003e\n\u003cli\u003e使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e三、自动生效\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;dependency\u0026gt;\n  \u0026lt;groupId\u0026gt;com.kuaishou.ad\u0026lt;/groupId\u0026gt;\n  \u0026lt;artifactId\u0026gt;sqllog-spring-boot-starter\u0026lt;/artifactId\u0026gt;\n  \u0026lt;version\u0026gt;制品库查询最新版\u0026lt;/version\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static String[] getConfigurations(File file) {\n  @EnableAutoConfiguration\n  class NoScan {\n    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载\n  }\n  FileClassLoader classLoader = new FileClassLoader(file);\n  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();\n  selector.setBeanClassLoader(classLoader);\n  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));\n  selector.setEnvironment(new StandardEnvironment());\n  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));\n  return configurations;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e四、SQL打印效果\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003esqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eSQL的打印内容分为三部分：\u003c/p\u003e\n\u003cp\u003e第一行，显示执行时间、耗时、SQL操作、数据库连接等信息\u003c/p\u003e\n\u003cp\u003e第二行，显示参数化SQL\u003c/p\u003e\n\u003cp\u003e第三行，显示绑定参数后的实际执行的SQL\u003c/p\u003e\n\u003cp\u003e通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"1a:T5439,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava并发编程：从内存模型到并发工具的设计哲学\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发编程的核心挑战不在于\u0026quot;如何让多个线程同时跑\u0026quot;，而在于\u0026quot;如何让多个线程正确地协作\u0026quot;。理解 Java 内存模型和并发工具的设计原理，是写出正确并发代码的前提。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e并发编程是 Java 工程师的核心能力之一。它涉及从硬件层面的缓存一致性，到语言层面的内存模型，再到 JUC 工具类的 API 设计，是一个纵深很大的知识领域。\u003c/p\u003e\n\u003cp\u003e本文将从底层原理出发，逐层构建 Java 并发编程的知识体系。\u003c/p\u003e\n\u003ch2\u003e一、硬件基础：CPU 缓存与一致性\u003c/h2\u003e\n\u003ch3\u003e1.1 为什么需要缓存\u003c/h3\u003e\n\u003cp\u003e现代 CPU 的运算速度远超主内存的读写速度（差距约 100 倍）。为了弥补这一差距，CPU 引入了多级缓存（L1/L2/L3 Cache）。每个核心拥有独立的 L1/L2 缓存，L3 缓存为所有核心共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCPU Core 0          CPU Core 1\n┌─────────┐        ┌─────────┐\n│ L1 Cache│        │ L1 Cache│\n│ L2 Cache│        │ L2 Cache│\n└────┬────┘        └────┬────┘\n     └────────┬─────────┘\n         L3 Cache（共享）\n              │\n         主内存（RAM）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓存的引入解决了性能问题，但带来了新问题：\u003cstrong\u003e当多个核心各自缓存了同一块数据的副本，其中一个核心修改了数据，如何保证其他核心看到的是最新值？\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 MESI 缓存一致性协议\u003c/h3\u003e\n\u003cp\u003eMESI 是最广泛采用的缓存一致性协议，每个缓存行处于四种状态之一：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e状态\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e对主内存\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eM（Modified）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心修改了数据，与主内存不一致\u003c/td\u003e\n\u003ctd\u003e需要写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eE（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心独占数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eS（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e多个核心共享数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI（Invalid）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e缓存行无效\u003c/td\u003e\n\u003ctd\u003e需从主内存重新加载\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当 Core 0 修改了处于 S 状态的缓存行时：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCore 0 将缓存行状态改为 M\u003c/li\u003e\n\u003cli\u003e通过总线嗅探（Bus Snooping）通知其他核心\u003c/li\u003e\n\u003cli\u003e其他核心将对应缓存行标记为 I\u003c/li\u003e\n\u003cli\u003e其他核心下次读取该数据时，从 Core 0 的缓存或主内存重新加载\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e1.3 缓存行伪共享（False Sharing）\u003c/h3\u003e\n\u003cp\u003e缓存行是缓存操作的最小单位，大小通常为 \u003cstrong\u003e64 字节\u003c/strong\u003e。如果两个无关的变量恰好落在同一缓存行中，一个变量的修改会导致另一个变量的缓存行也失效——这就是伪共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 伪共享示例：head 和 tail 可能在同一缓存行\nclass Queue {\n    volatile long head;  // 生产者频繁修改\n    volatile long tail;  // 消费者频繁修改\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDoug Lea 在 \u003ccode\u003eLinkedTransferQueue\u003c/code\u003e 中的解决方案——填充字节使变量独占一个缓存行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// JDK 7 中的做法\nclass PaddedAtomicReference\u0026lt;T\u0026gt; extends AtomicReference\u0026lt;T\u0026gt; {\n    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;\n}\n\n// JDK 8+ 可以使用 @Contended 注解\n@sun.misc.Contended\nclass QueueNode {\n    volatile long value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二、Java 内存模型（JMM）\u003c/h2\u003e\n\u003ch3\u003e2.1 JMM 的抽象\u003c/h3\u003e\n\u003cp\u003eJava 内存模型（Java Memory Model）定义了\u003cstrong\u003e多线程如何通过共享内存进行通信\u003c/strong\u003e的规则。它并不描述具体的硬件实现，而是提供了一组抽象的可见性和有序性保证。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程 A 工作内存          线程 B 工作内存\n┌──────────────┐      ┌──────────────┐\n│  变量副本      │      │  变量副本      │\n└──────┬───────┘      └──────┬───────┘\n       │    save/load         │\n       └──────────┬───────────┘\n              主内存\n         ┌──────────────┐\n         │  共享变量      │\n         └──────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJMM 定义了 8 种内存交互操作：lock、unlock、read、load、use、assign、store、write。这些操作的组合规则保证了多线程程序的语义正确性。\u003c/p\u003e\n\u003ch3\u003e2.2 三大并发问题\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e根源\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e可见性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程修改了变量，其他线程看不到最新值\u003c/td\u003e\n\u003ctd\u003eCPU 缓存导致各线程工作内存不一致\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e原子性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一组操作被中断导致中间状态暴露\u003c/td\u003e\n\u003ctd\u003e线程切换导致复合操作被打断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e有序性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e代码执行顺序与编写顺序不一致\u003c/td\u003e\n\u003ctd\u003e编译器优化、CPU 指令重排序\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.3 volatile 的语义与实现\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e 是 Java 中最轻量的同步机制，它提供两个保证：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e可见性\u003c/strong\u003e：对 volatile 变量的写操作对所有线程立即可见\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e有序性\u003c/strong\u003e：禁止指令重排序（通过内存屏障实现）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e但不保证原子性\u003c/strong\u003e：\u003ccode\u003evolatile int count; count++\u003c/code\u003e 并不是线程安全的，因为 \u003ccode\u003ecount++\u003c/code\u003e 是读-改-写三步操作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e硬件级实现\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 x86 架构上，对 volatile 变量的写操作会生成一条带 \u003cstrong\u003eLOCK 前缀\u003c/strong\u003e的指令。LOCK 前缀的作用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将当前处理器缓存行的数据写回主内存\u003c/li\u003e\n\u003cli\u003e使其他处理器中缓存该地址的缓存行失效（通过 MESI 协议）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e// JIT 编译后的汇编（x86）\n0x01a3de24: lock addl $0x0,(%esp)  // LOCK 前缀指令\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 P6 及更新的处理器上，LOCK 不再锁总线，而是\u003cstrong\u003e锁缓存行\u003c/strong\u003e（Cache Locking），性能开销远小于总线锁。\u003c/p\u003e\n\u003ch3\u003e2.4 happens-before 规则\u003c/h3\u003e\n\u003cp\u003eJMM 通过 \u003cstrong\u003ehappens-before\u003c/strong\u003e 关系定义了操作间的可见性保证。如果操作 A happens-before 操作 B，则 A 的结果对 B 可见。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e规则\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e程序顺序规则\u003c/td\u003e\n\u003ctd\u003e同一线程中的操作，前面的 happens-before 后面的\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003evolatile 规则\u003c/td\u003e\n\u003ctd\u003evolatile 写 happens-before 后续的 volatile 读\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁规则\u003c/td\u003e\n\u003ctd\u003eunlock happens-before 后续对同一锁的 lock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e传递性\u003c/td\u003e\n\u003ctd\u003e如果 A hb B，B hb C，则 A hb C\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程启动规则\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eThread.start()\u003c/code\u003e happens-before 该线程的每个动作\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程终止规则\u003c/td\u003e\n\u003ctd\u003e线程的所有动作 happens-before 其他线程检测到该线程终止\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e三、锁机制\u003c/h2\u003e\n\u003ch3\u003e3.1 synchronized vs Lock\u003c/h3\u003e\n\u003cp\u003eJava 提供两种锁机制：内置锁（\u003ccode\u003esynchronized\u003c/code\u003e）和显式锁（\u003ccode\u003ejava.util.concurrent.locks.Lock\u003c/code\u003e）。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003esynchronized\u003c/th\u003e\n\u003cth\u003eLock\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e实现层面\u003c/td\u003e\n\u003ctd\u003eJVM 内置（monitorenter/monitorexit）\u003c/td\u003e\n\u003ctd\u003eJava API 层（基于 AQS）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁获取\u003c/td\u003e\n\u003ctd\u003e阻塞式，不可中断\u003c/td\u003e\n\u003ctd\u003e支持非阻塞 \u003ccode\u003etryLock()\u003c/code\u003e、可中断 \u003ccode\u003elockInterruptibly()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁释放\u003c/td\u003e\n\u003ctd\u003e自动释放（退出同步块）\u003c/td\u003e\n\u003ctd\u003e必须在 \u003ccode\u003efinally\u003c/code\u003e 中手动 \u003ccode\u003eunlock()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e条件等待\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eObject.wait()/notify()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCondition.await()/signal()\u003c/code\u003e，支持多条件队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平性\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eReentrantLock(true)\u003c/code\u003e 支持公平锁\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁状态查询\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eisLocked()\u003c/code\u003e、\u003ccode\u003egetHoldCount()\u003c/code\u003e 等\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e选择原则\u003c/strong\u003e：优先使用 \u003ccode\u003esynchronized\u003c/code\u003e（JVM 持续优化，且不会忘记释放锁）；需要高级特性（超时、中断、多条件、公平性）时选择 \u003ccode\u003eLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e3.2 Condition：精确的线程协作\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCondition\u003c/code\u003e 是 \u003ccode\u003eLock\u003c/code\u003e 的配套组件，它替代了 \u003ccode\u003eObject.wait()/notify()\u003c/code\u003e 机制，最大的优势是\u003cstrong\u003e支持多个等待队列\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 使用 Object 的 wait/notify：只有一个等待队列，notifyAll 会唤醒所有线程\n// 使用 Condition：可以创建多个条件队列，signal 只唤醒特定队列中的线程\n\nReentrantLock lock = new ReentrantLock();\nCondition notFull  = lock.newCondition();  // 生产者等待队列\nCondition notEmpty = lock.newCondition();  // 消费者等待队列\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e有界缓冲区实现\u003c/strong\u003e（经典的生产者-消费者模型）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass BoundedBuffer\u0026lt;E\u0026gt; {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n    final Object[] items = new Object[100];\n    int putIndex, takeIndex, count;\n\n    public void put(E e) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();      // 缓冲区满，生产者等待\n            items[putIndex] = e;\n            if (++putIndex == items.length) putIndex = 0;\n            ++count;\n            notEmpty.signal();        // 通知消费者\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();     // 缓冲区空，消费者等待\n            E e = (E) items[takeIndex];\n            if (++takeIndex == items.length) takeIndex = 0;\n            --count;\n            notFull.signal();         // 通知生产者\n            return e;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意 \u003ccode\u003eawait()\u003c/code\u003e 必须在 \u003ccode\u003ewhile\u003c/code\u003e 循环中调用，以防止\u003cstrong\u003e虚假唤醒（Spurious Wakeup）\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e3.3 ReadWriteLock：读写分离\u003c/h3\u003e\n\u003cp\u003e当读操作远多于写操作时，使用排他锁会严重限制并发度。\u003ccode\u003eReadWriteLock\u003c/code\u003e 允许多个线程同时持有读锁，但写锁是排他的。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁状态\u003c/th\u003e\n\u003cth\u003e读锁请求\u003c/th\u003e\n\u003cth\u003e写锁请求\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e无锁\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读锁已持有\u003c/td\u003e\n\u003ctd\u003e允许（共享）\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写锁已持有\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e 的设计决策：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e写锁可降级为读锁\u003c/strong\u003e：持有写锁的线程可以再获取读锁，然后释放写锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e读锁不可升级为写锁\u003c/strong\u003e：防止死锁（多个读线程同时尝试升级会互相等待）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持公平/非公平模式\u003c/strong\u003e：非公平模式下，读锁可能\u0026quot;插队\u0026quot;导致写线程饥饿\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e四、JUC 并发工具类\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.util.concurrent\u003c/code\u003e 包提供了一组高级同步工具，用于解决常见的线程协调问题。\u003c/p\u003e\n\u003ch3\u003e4.1 CountDownLatch：一次性倒计数门闩\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一个或多个线程等待其他线程完成一组操作后再继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCountDownLatch latch = new CountDownLatch(3);  // 计数器初始值 3\n\n// 工作线程\nexecutor.submit(() -\u0026gt; {\n    doTask();\n    latch.countDown();  // 计数器 -1\n});\n\n// 等待线程\nlatch.await();  // 阻塞直到计数器归零\n// 所有任务完成，继续执行\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e一次性\u003c/strong\u003e：计数器归零后无法重置\u003c/li\u003e\n\u003cli\u003e底层基于 AQS 的共享模式实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e典型场景\u003c/strong\u003e：服务启动时等待所有依赖组件初始化完成。\u003c/p\u003e\n\u003ch3\u003e4.2 CyclicBarrier：可重用的屏障\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一组线程互相等待，直到所有线程都到达屏障点，然后同时继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCyclicBarrier barrier = new CyclicBarrier(3, () -\u0026gt; {\n    System.out.println(\u0026quot;所有线程到齐，开始下一阶段\u0026quot;);  // barrierAction\n});\n\n// 每个工作线程\nexecutor.submit(() -\u0026gt; {\n    doPhase1();\n    barrier.await();  // 等待其他线程\n    doPhase2();\n    barrier.await();  // 可以重复使用\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可重用\u003c/strong\u003e：所有线程通过屏障后，计数器自动重置\u003c/li\u003e\n\u003cli\u003e支持 \u003cstrong\u003ebarrierAction\u003c/strong\u003e：所有线程到齐时执行的回调\u003c/li\u003e\n\u003cli\u003e如果某个线程等待超时或被中断，屏障进入 \u003cstrong\u003eBroken\u003c/strong\u003e 状态，所有等待线程收到 \u003ccode\u003eBrokenBarrierException\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.3 Semaphore：信号量\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：控制同时访问某个资源的线程数量。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSemaphore semaphore = new Semaphore(5);  // 最多 5 个并发\n\nexecutor.submit(() -\u0026gt; {\n    semaphore.acquire();    // 获取许可（可用许可 -1）\n    try {\n        accessResource();\n    } finally {\n        semaphore.release();  // 释放许可（可用许可 +1）\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e支持\u003cstrong\u003e公平/非公平\u003c/strong\u003e模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etryAcquire()\u003c/code\u003e 提供非阻塞获取\u003c/li\u003e\n\u003cli\u003e许可数量可以动态增减（\u003ccode\u003erelease()\u003c/code\u003e 可以在未 \u003ccode\u003eacquire()\u003c/code\u003e 的情况下调用）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.4 三者对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e核心语义\u003c/th\u003e\n\u003cth\u003e是否可重用\u003c/th\u003e\n\u003cth\u003e计数方向\u003c/th\u003e\n\u003cth\u003e典型场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程等待 N 个线程\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e递减至 0\u003c/td\u003e\n\u003ctd\u003e主线程等待子任务完成\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCyclicBarrier\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eN 个线程互相等待\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e递增至 N\u003c/td\u003e\n\u003ctd\u003e多阶段并行计算\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e控制并发访问数量\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003e许可的获取与释放\u003c/td\u003e\n\u003ctd\u003e限流、资源池\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e五、生产者-消费者模式\u003c/h2\u003e\n\u003cp\u003e生产者-消费者是并发编程中最经典的协作模式。Java 提供了从底层到高层的多种实现方式。\u003c/p\u003e\n\u003ch3\u003e5.1 三种实现方式对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现方式\u003c/th\u003e\n\u003cth\u003e同步机制\u003c/th\u003e\n\u003cth\u003e通知粒度\u003c/th\u003e\n\u003cth\u003e复杂度\u003c/th\u003e\n\u003cth\u003e推荐度\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003esynchronized + wait/notify\u003c/td\u003e\n\u003ctd\u003e内置锁\u003c/td\u003e\n\u003ctd\u003e全量唤醒（notifyAll）\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e一般\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eLock + Condition\u003c/td\u003e\n\u003ctd\u003e显式锁\u003c/td\u003e\n\u003ctd\u003e精确唤醒（signal）\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBlockingQueue\u003c/td\u003e\n\u003ctd\u003e封装在队列内部\u003c/td\u003e\n\u003ctd\u003e内部自动处理\u003c/td\u003e\n\u003ctd\u003e最低\u003c/td\u003e\n\u003ctd\u003e最推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e为什么 BlockingQueue 是最佳选择\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBlockingQueue\u003c/code\u003e 将同步、等待、通知的逻辑完全封装在 \u003ccode\u003eput()\u003c/code\u003e/\u003ccode\u003etake()\u003c/code\u003e 方法内部，调用方无需关心并发细节：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eBlockingQueue\u0026lt;Task\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(100);\n\n// 生产者\nqueue.put(task);   // 队列满时自动阻塞\n\n// 消费者\nTask task = queue.take();  // 队列空时自动阻塞\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 BlockingQueue 的实现选型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现类\u003c/th\u003e\n\u003cth\u003e底层结构\u003c/th\u003e\n\u003cth\u003e是否有界\u003c/th\u003e\n\u003cth\u003e锁策略\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eArrayBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e数组\u003c/td\u003e\n\u003ctd\u003e有界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e通用场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e链表\u003c/td\u003e\n\u003ctd\u003e可选有界\u003c/td\u003e\n\u003ctd\u003e读写分离锁\u003c/td\u003e\n\u003ctd\u003e吞吐量要求高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSynchronousQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e无容量\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eCAS\u003c/td\u003e\n\u003ctd\u003e直接传递（线程池默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ePriorityBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e堆\u003c/td\u003e\n\u003ctd\u003e无界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e优先级调度\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e六、线程池\u003c/h2\u003e\n\u003ch3\u003e6.1 ThreadPoolExecutor 核心参数\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ThreadPoolExecutor(\n    corePoolSize,      // 核心线程数\n    maximumPoolSize,   // 最大线程数\n    keepAliveTime,     // 非核心线程空闲存活时间\n    TimeUnit.SECONDS,\n    workQueue,         // 任务队列\n    threadFactory,     // 线程工厂\n    rejectedHandler    // 拒绝策略\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e任务提交流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e提交任务\n  → 当前线程数 \u0026lt; corePoolSize？        → 创建核心线程执行\n  → 任务队列未满？                      → 入队等待\n  → 当前线程数 \u0026lt; maximumPoolSize？      → 创建非核心线程执行\n  → 以上都不满足                        → 执行拒绝策略\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2 拒绝策略\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e策略\u003c/th\u003e\n\u003cth\u003e行为\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eAbortPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e抛出 \u003ccode\u003eRejectedExecutionException\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e默认策略，适合需要感知过载的场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCallerRunsPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e由提交线程自己执行任务\u003c/td\u003e\n\u003ctd\u003e反压效果，但可能导致提交线程阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e静默丢弃任务\u003c/td\u003e\n\u003ctd\u003e允许丢失的场景（如日志）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardOldestPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e丢弃队列中最旧的任务\u003c/td\u003e\n\u003ctd\u003e实时性要求高、可接受旧数据丢失\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e6.3 生产阻塞型线程池\u003c/h3\u003e\n\u003cp\u003e标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 使用 \u003ccode\u003eBlockingQueue.offer()\u003c/code\u003e（非阻塞）入队。队列满时不会阻塞提交线程，而是触发拒绝策略。\u003c/p\u003e\n\u003cp\u003e在某些场景下（如需要严格的背压机制），需要让提交线程在队列满时\u003cstrong\u003e阻塞等待\u003c/strong\u003e而非被拒绝。可通过自定义拒绝策略实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThreadPoolExecutor executor = new ThreadPoolExecutor(\n    coreSize, maxSize, 60, TimeUnit.SECONDS,\n    new LinkedBlockingQueue\u0026lt;\u0026gt;(capacity),\n    (runnable, pool) -\u0026gt; {\n        try {\n            // 队列满时，put() 会阻塞提交线程\n            pool.getQueue().put(runnable);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式的优势在于：复用 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 的线程管理能力，同时实现了生产者阻塞语义，避免了手工管理线程的复杂性。\u003c/p\u003e\n\u003ch3\u003e6.4 线程池配置最佳实践\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e任务类型\u003c/th\u003e\n\u003cth\u003e核心线程数建议\u003c/th\u003e\n\u003cth\u003e队列选择\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCPU 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu + 1\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e小容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI/O 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu × 2\u003c/code\u003e 或更高\u003c/td\u003e\n\u003ctd\u003e较大容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e混合型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e拆分为 CPU 池和 I/O 池\u003c/td\u003e\n\u003ctd\u003e各自独立配置\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e关键原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e永远不要使用无界队列\u003c/strong\u003e：\u003ccode\u003eExecutors.newFixedThreadPool()\u003c/code\u003e 默认使用无界的 \u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e，可能导致 OOM\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e为线程池命名\u003c/strong\u003e：自定义 \u003ccode\u003eThreadFactory\u003c/code\u003e，给线程添加有意义的名称前缀，便于排查问题\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控队列深度\u003c/strong\u003e：线程池队列持续增长是系统过载的信号\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava 并发编程的知识体系可以沿着三个层次理解：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e硬件层\u003c/strong\u003e：CPU 缓存、MESI 协议、缓存行伪共享——这是并发问题的物理根源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模型层\u003c/strong\u003e：JMM、happens-before、volatile/synchronized 语义——这是 Java 对硬件差异的抽象屏蔽\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具层\u003c/strong\u003e：Lock/Condition、CountDownLatch/CyclicBarrier/Semaphore、BlockingQueue、ThreadPoolExecutor——这是面向工程的并发编程基础设施\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发工具的选择不在于功能的强大，而在于语义的匹配。\u003ccode\u003esynchronized\u003c/code\u003e 足以解决大多数问题；\u003ccode\u003eBlockingQueue\u003c/code\u003e 比手动的 wait/notify 更安全；标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 比自定义线程管理更可靠。优先选择高层抽象，只在确有需要时才下沉到底层机制。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/middleware/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"中间件\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2025-12-28\",\"children\":\"2025年12月28日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"深入理解AQS：Java并发的基石\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}],[\"$\",\"$L13\",\"并发编程\",{\"href\":\"/blog/tag/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"并发编程\"}],[\"$\",\"$L13\",\"AQS\",{\"href\":\"/blog/tag/AQS/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"AQS\"}],[\"$\",\"$L13\",\"ReentrantLock\",{\"href\":\"/blog/tag/ReentrantLock/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"ReentrantLock\"}],[\"$\",\"$L13\",\"JUC\",{\"href\":\"/blog/tag/JUC/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"JUC\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/agentic/06-Prompt Engineering for Agents\",\"title\":\"Prompt Engineering for Agents: 面向 Agent 的提示词工程\",\"description\":\"Agent 的 Prompt 不是聊天提示词，而是系统接口规范。本文系统拆解 Agent Prompt 的分层架构、四种关键设计模式（Router / Planner / Executor / Reflector）、Chain-of-Thought 的 Agent 化应用、Few-shot vs Zero-shot 的场景选择、Prompt 工程化实践（模板化 / 版本控制 / 测试 / 组合），以及 Context Window 管理策略。\",\"pubDate\":\"2025-12-23\",\"tags\":[\"Agentic\",\"AI Engineering\",\"Prompt Engineering\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/agentic/07-Agent Runtime from Scratch\",\"title\":\"Agent Runtime from Scratch: 不依赖框架构建 Agent\",\"description\":\"不依赖 LangChain 等框架，从零实现一个功能完整的 Agent Runtime。逐模块构建 LLMClient、ToolRegistry、ToolExecutor、MessageManager 和核心控制循环，包含并行工具调用、Streaming、超时控制、死循环检测等高级特性，附完整可运行代码。\",\"pubDate\":\"2025-12-28\",\"tags\":[\"Agentic\",\"AI Engineering\",\"Runtime\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"Java\":{\"prev\":{\"slug\":\"engineering/middleware/非侵入式SQL监控\",\"title\":\"非侵入式SQL监控\",\"description\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\",\"pubDate\":\"2024-04-07\",\"tags\":[\"SQL监控\",\"Java\",\"非侵入式\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"},\"next\":null},\"并发编程\":{\"prev\":{\"slug\":\"engineering/middleware/Java并发编程：从内存模型到并发工具的设计哲学\",\"title\":\"Java并发编程：从内存模型到并发工具的设计哲学\",\"description\":\"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。\",\"pubDate\":\"2021-11-20\",\"tags\":[\"Java\",\"并发编程\",\"JMM\",\"JUC\",\"线程池\"],\"heroImage\":\"$undefined\",\"content\":\"$1a\"},\"next\":null},\"AQS\":{\"prev\":null,\"next\":null},\"ReentrantLock\":{\"prev\":null,\"next\":null},\"JUC\":{\"prev\":\"$5:props:children:props:children:props:children:2:props:children:props:tagNav:并发编程:prev\",\"next\":null}}}]}],[\"$\",\"$L1b\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"深入理解AQS：Java并发的基石 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"深入理解AQS：Java并发的基石\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2025-12-28\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"深入理解AQS：Java并发的基石\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
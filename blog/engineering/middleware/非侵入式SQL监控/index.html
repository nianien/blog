<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/fffdcdb4fb651185.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>非侵入式SQL监控 - Skyfalling Blog</title><meta name="description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><meta property="og:title" content="非侵入式SQL监控"/><meta property="og:description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-04-07"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="非侵入式SQL监控"/><meta name="twitter:description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/middleware/page/1/">中间件</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-04-07">2024年04月07日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">非侵入式SQL监控</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/SQL%E7%9B%91%E6%8E%A7/page/1/">SQL监控</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F/page/1/">非侵入式</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><p>你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。</p>
<p>另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) 
and name in(sql
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;)
)
</code></pre>
<p>缩略下印如下：</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004,...) 
and name in(
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,...)
)
</code></pre>
<p>既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -&gt; ORM -&gt; DataSource  -&gt; Connection -&gt; Driver -&gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -&gt; DataSource  -&gt; Connection -&gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从<strong>DataSource  -&gt; Connection -&gt; Driver</strong>三个环节进行入手：</p>
<h3><strong>一、SQL Profile监控</strong></h3>
<h4><strong>1、驱动层监控</strong></h4>
<p>如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：</p>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;logger=Slf4JLogger&amp;profileSQL=true
</code></pre>
<p>基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。</p>
<h4><strong>2、连接层监控</strong></h4>
<p>如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如<a href="https://p6spy.readthedocs.io/en/latest/">P6Spy</a>、<a href="https://github.com/arthurblake/log4jdbc">log4jdbc</a> 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：</p>
<ul>
<li>pyspy</li>
</ul>
<pre><code class="language-properties">jdbc:p6spy:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-properties">jdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<h4><strong>3、数据源层监控</strong></h4>
<p>可以通过对DataSource进行代理实现SQL监控</p>
<ul>
<li>P6Spy：</li>
</ul>
<pre><code class="language-java">@Bean
@Primary
public DataSource spyDataSource(@Autowired DataSource dataSource) {
  // wrap a datasource using P6SpyDataSource
  return new P6DataSource(dataSource);
}
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-java">public DataSource spyDataSource(DataSource dataSource) {
    // wrap the provided dataSource
  return new DataSource() {
    @Override
    public Connection getConnection() throws SQLException {
      // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection());
    }
      
    @Override
    public Connection getConnection(String username, String password) throws SQLException {
       // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection(username, password));
     }
      //...
  };
}
</code></pre>
<p>上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。</p>
<p>第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。</p>
<p>第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。</p>
<p>排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。</p>
<pre><code class="language-java">public interface DataSourceConfig extends HasBizDef {

    /**
     * 数据源名称，必须与KDB申请时填写的一致
     */String bizName();

    /**
     * 获取当前可用区单库只读的JdbcTemplate
     */
    default NamedParameterJdbcTemplate read() {
        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), &quot;read&quot;);
    }   

    /**
     * 获取当前可用区单库读写的JdbcTemplate
     */
    default NamedParameterJdbcTemplate write() {
        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), &quot;write&quot;);
    }	
  //....
}
</code></pre>
<p>DefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:</p>
<pre><code class="language-kotlin">enum class AdDataSources(
    private val bizDef: BizDef,
    private val forTest: AdDataSources? = null,
    private val usingNewZk: Boolean = false
) : DataSourceConfig{
    adFansTopProfileDashboardTest,
    adFansTopProfileDashboard,
    adChargeTest,
    adCharge,
    adChargeReadOnly,
    adDspReadOnlyTest,
    adDspReadOnly;
    public open fun bizName(): String {
        return bizDef.bizName
    }
}
</code></pre>
<p>如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？</p>
<p>具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：</p>
<pre><code class="language-java">public static ListenableDataSource&lt;Failover&lt;Instance&gt;&gt; create(Instance i) {
   //...
   try {
       return supplyWithRetry(
        DATA_SOURCE_BUILD_RETRY,
        DATA_SOURCE_BUILD_RETRY_DELAY,
        () -&gt; new ListenableDataSource&lt;&gt;(
              bizName, 
              new HikariDataSource(config), ds -&gt; i.toString(), i),
              DataSourceFactory::needRetry);
                               
  } catch (Throwable e) {/**/}
}
</code></pre>
<p>由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?</p>
<h3><strong>二、动态修改加载类</strong></h3>
<p>成本最低的方式就是直接修改这段代码，将其中&#x7684;<em>&#x6E;ew HikariDataSource(config)</em>&#x4FEE;改&#x6210;<em>&#x6E;ew P6DataSource(new HikariDataSource(config))，</em>&#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？</p>
<p>首先我们来分析一下，有哪些手段可以修改Java字节码？</p>
<ul>
<li>方案一、编译时修改，需要开发maven插件</li>
</ul>
<p>（不使用maven插件的同学咋办？）</p>
<ul>
<li>方案二、加载时修改，重写类加载器</li>
</ul>
<p>需要在代码中指定特定的类加载器，用有一定的侵入式</p>
<ul>
<li>方案三、运行时修改，使用JavaAgent</li>
</ul>
<p>需要修改应用启动参数，运维成本有点高</p>
<p>首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。</p>
<p><em>下面是对动态启动Java Agent技术的解释</em></p>
<blockquote>
<p>Note that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.</p>
</blockquote>
<blockquote>
<p>See <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description">the java.lang.instrument package documentation</a>…</p>
</blockquote>
<blockquote>
<p>Getting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. <a href="https://stackoverflow.com/a/19912148/2711488">This answer</a> demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.</p>
</blockquote>
<blockquote>
<p>However, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.</p>
</blockquote>
<blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/questions/56787777/?noredirect=1&lq=1#comment100160373_56787777">this comment</a>, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.</p>
</blockquote>
<ul>
<li>字节码工具对比</li>
</ul>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png" alt="图片"></p>
<ul>
<li>使用bytebuddy修改字节码</li>
</ul>
<p>在实现代码之前，我们回过头来再看一下快手的数据源生成：</p>
<pre><code class="language-java">new ListenableDataSource&lt;&gt;(bizName, new HikariDataSource(config), ds -&gt; i.toString());
</code></pre>
<p>这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：</p>
<pre><code class="language-java">public class DelegatingDataSource implements DataSource {
   //...
  public DelegatingDataSource(DataSource targetDataSource) {
    this.setTargetDataSource(targetDataSource);
   }

  public void setTargetDataSource(@Nullable DataSource targetDataSource) {
      this.targetDataSource = targetDataSource;
  }
  //...
}
</code></pre>
<p>因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
        this.targetDataSource = new P6DataSource(targetDataSource;
}
</code></pre>
<p>那么具体如何修改字节码呢？这里是<a href="https://bytebuddy.net/#/tutorial">官方文档</a>，原理我们不做赘述，直接介绍实现了。实现方式有三种：</p>
<h4><strong>1、类文件替换</strong></h4>
<p>假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：</p>
<pre><code class="language-java">new ByteBuddy()
  .redefine(NewDelegatingDataSource.class)
  .name(DelegatingDataSource.class.getName())
  .make()
  .load(Thread.currentThread().getContextClassLoader(), 
        ClassReloadingStrategy.fromInstalledAgent());
</code></pre>
<h4><strong>2、操作字节码：</strong></h4>
<pre><code class="language-java">new ByteBuddy()
    .redefine(DelegatingDataSource.class)
    //重写DelegatingDataSource#setTargetDataSource方法
    .method(named(&quot;setTargetDataSource&quot;))
    .intercept(MyImplementation.INSTANCE)
    .make()
    .load(Thread.currentThread().getContextClassLoader(),
          ClassReloadingStrategy.fromInstalledAgent());

enum MyImplementation implements Implementation {

INSTANCE; // singleton

  @Override
  public InstrumentedType prepare(InstrumentedType instrumentedType) {
  return instrumentedType;
  }
  
  @Override
  public ByteCodeAppender appender(Target implementationTarget) {
  return MyAppender.INSTANCE;
  }
  
}
//字节码定义
enum MyAppender implements ByteCodeAppender {

INSTANCE; // singleton

@Override
public Size apply(MethodVisitor methodVisitor,
        Implementation.Context implementationContext,
        MethodDescription instrumentedMethod) {
  Label label0 = new Label();
  methodVisitor.visitLabel(label0);
  methodVisitor.visitLineNumber(70, label0);
  methodVisitor.visitVarInsn(ALOAD, 0);
  methodVisitor.visitTypeInsn(NEW, &quot;com/p6spy/engine/spy/P6DataSource&quot;);
  methodVisitor.visitInsn(DUP);
  methodVisitor.visitVarInsn(ALOAD, 1);
  methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;com/p6spy/engine/spy/P6DataSource&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljavax/sql/DataSource;)V&quot;, false);
  methodVisitor.visitFieldInsn(PUTFIELD, &quot;org/springframework/jdbc/datasource/DelegatingDataSource&quot;, &quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;);
  Label label1 = new Label();
  methodVisitor.visitLabel(label1);
  methodVisitor.visitLineNumber(71, label1);
  methodVisitor.visitInsn(RETURN);
  Label label2 = new Label();
  methodVisitor.visitLabel(label2);
  methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;&quot;, null, label0, label2, 0);
  methodVisitor.visitLocalVariable(&quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;, null, label0, label2, 1);
  methodVisitor.visitMaxs(4, 2);
  return new Size(4, 2);
  }
}
</code></pre>
<p>上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？</p>
<p>我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9" alt="图片"></p>
<h4><strong>3、利用byte-buddy的Advice</strong></h4>
<pre><code class="language-java"> public static void redefine() {
   new ByteBuddy()
     .redefine(DelegatingDataSource.class)
     .visit(Advice.to(Decorator.class)
            .on(ElementMatchers.named(&quot;setTargetDataSource&quot;)))
     .make()
     .load(Thread.currentThread().getContextClassLoader(),
           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();
 }

static class Decorator {

  //在方法开始插入代码
  @Advice.OnMethodEnter
    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {
    dataSource = new P6DataSource(dataSource);
  }
}
</code></pre>
<p>byte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
  //插入的代码
  targetDataSource = new P6DataSource(targetDataSource);
  this.targetDataSource = targetDataSource;
}
</code></pre>
<p>注：</p>
<ol>
<li>动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。</li>
<li>使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。</li>
</ol>
<h3><strong>三、自动生效</strong></h3>
<p>前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.kuaishou.ad&lt;/groupId&gt;
  &lt;artifactId&gt;sqllog-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;制品库查询最新版&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。</p>
<pre><code class="language-java">private static String[] getConfigurations(File file) {
  @EnableAutoConfiguration
  class NoScan {
    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载
  }
  FileClassLoader classLoader = new FileClassLoader(file);
  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();
  selector.setBeanClassLoader(classLoader);
  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));
  selector.setEnvironment(new StandardEnvironment());
  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));
  return configurations;
}
</code></pre>
<h3><strong>四、SQL打印效果</strong></h3>
<p>sqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44" alt=""></p>
<p>SQL的打印内容分为三部分：</p>
<p>第一行，显示执行时间、耗时、SQL操作、数据库连接等信息</p>
<p>第二行，显示参数化SQL</p>
<p>第三行，显示绑定参数后的实际执行的SQL</p>
<p>通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/fffdcdb4fb651185.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"4aRcYmzY73SZxx_H909yZ\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"middleware\",\"%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/middleware/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fffdcdb4fb651185.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/middleware/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"vCt6rvVzZIdljGpXHpIqnv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1a:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T4fc0,"])</script><script>self.__next_f.push([1,"\u003cp\u003e你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。\u003c/p\u003e\n\u003cp\u003e另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) \nand name in(sql\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缩略下印如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004,...) \nand name in(\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,...)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -\u0026gt; ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver -\u0026gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从\u003cstrong\u003eDataSource  -\u0026gt; Connection -\u0026gt; Driver\u003c/strong\u003e三个环节进行入手：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e一、SQL Profile监控\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1、驱动层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\u0026amp;logger=Slf4JLogger\u0026amp;profileSQL=true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2、连接层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如\u003ca href=\"https://p6spy.readthedocs.io/en/latest/\"\u003eP6Spy\u003c/a\u003e、\u003ca href=\"https://github.com/arthurblake/log4jdbc\"\u003elog4jdbc\u003c/a\u003e 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epyspy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:p6spy:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3、数据源层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e可以通过对DataSource进行代理实现SQL监控\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eP6Spy：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Bean\n@Primary\npublic DataSource spyDataSource(@Autowired DataSource dataSource) {\n  // wrap a datasource using P6SpyDataSource\n  return new P6DataSource(dataSource);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic DataSource spyDataSource(DataSource dataSource) {\n    // wrap the provided dataSource\n  return new DataSource() {\n    @Override\n    public Connection getConnection() throws SQLException {\n      // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection());\n    }\n      \n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n       // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection(username, password));\n     }\n      //...\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。\u003c/p\u003e\n\u003cp\u003e第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。\u003c/p\u003e\n\u003cp\u003e第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。\u003c/p\u003e\n\u003cp\u003e排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface DataSourceConfig extends HasBizDef {\n\n    /**\n     * 数据源名称，必须与KDB申请时填写的一致\n     */String bizName();\n\n    /**\n     * 获取当前可用区单库只读的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate read() {\n        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), \u0026quot;read\u0026quot;);\n    }   \n\n    /**\n     * 获取当前可用区单库读写的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate write() {\n        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), \u0026quot;write\u0026quot;);\n    }\t\n  //....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eenum class AdDataSources(\n    private val bizDef: BizDef,\n    private val forTest: AdDataSources? = null,\n    private val usingNewZk: Boolean = false\n) : DataSourceConfig{\n    adFansTopProfileDashboardTest,\n    adFansTopProfileDashboard,\n    adChargeTest,\n    adCharge,\n    adChargeReadOnly,\n    adDspReadOnlyTest,\n    adDspReadOnly;\n    public open fun bizName(): String {\n        return bizDef.bizName\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？\u003c/p\u003e\n\u003cp\u003e具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static ListenableDataSource\u0026lt;Failover\u0026lt;Instance\u0026gt;\u0026gt; create(Instance i) {\n   //...\n   try {\n       return supplyWithRetry(\n        DATA_SOURCE_BUILD_RETRY,\n        DATA_SOURCE_BUILD_RETRY_DELAY,\n        () -\u0026gt; new ListenableDataSource\u0026lt;\u0026gt;(\n              bizName, \n              new HikariDataSource(config), ds -\u0026gt; i.toString(), i),\n              DataSourceFactory::needRetry);\n                               \n  } catch (Throwable e) {/**/}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e二、动态修改加载类\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e成本最低的方式就是直接修改这段代码，将其中\u0026#x7684;\u003cem\u003e\u0026#x6E;ew HikariDataSource(config)\u003c/em\u003e\u0026#x4FEE;改\u0026#x6210;\u003cem\u003e\u0026#x6E;ew P6DataSource(new HikariDataSource(config))，\u003c/em\u003e\u0026#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？\u003c/p\u003e\n\u003cp\u003e首先我们来分析一下，有哪些手段可以修改Java字节码？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案一、编译时修改，需要开发maven插件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（不使用maven插件的同学咋办？）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案二、加载时修改，重写类加载器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要在代码中指定特定的类加载器，用有一定的侵入式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案三、运行时修改，使用JavaAgent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要修改应用启动参数，运维成本有点高\u003c/p\u003e\n\u003cp\u003e首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下面是对动态启动Java Agent技术的解释\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSee \u003ca href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description\"\u003ethe java.lang.instrument package documentation\u003c/a\u003e…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGetting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. \u003ca href=\"https://stackoverflow.com/a/19912148/2711488\"\u003eThis answer\u003c/a\u003e demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAs mentioned in \u003ca href=\"https://stackoverflow.com/questions/56787777/?noredirect=1\u0026lq=1#comment100160373_56787777\"\u003ethis comment\u003c/a\u003e, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e字节码工具对比\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用bytebuddy修改字节码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在实现代码之前，我们回过头来再看一下快手的数据源生成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ListenableDataSource\u0026lt;\u0026gt;(bizName, new HikariDataSource(config), ds -\u0026gt; i.toString());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DelegatingDataSource implements DataSource {\n   //...\n  public DelegatingDataSource(DataSource targetDataSource) {\n    this.setTargetDataSource(targetDataSource);\n   }\n\n  public void setTargetDataSource(@Nullable DataSource targetDataSource) {\n      this.targetDataSource = targetDataSource;\n  }\n  //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n        this.targetDataSource = new P6DataSource(targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么具体如何修改字节码呢？这里是\u003ca href=\"https://bytebuddy.net/#/tutorial\"\u003e官方文档\u003c/a\u003e，原理我们不做赘述，直接介绍实现了。实现方式有三种：\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1、类文件替换\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n  .redefine(NewDelegatingDataSource.class)\n  .name(DelegatingDataSource.class.getName())\n  .make()\n  .load(Thread.currentThread().getContextClassLoader(), \n        ClassReloadingStrategy.fromInstalledAgent());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2、操作字节码：\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .redefine(DelegatingDataSource.class)\n    //重写DelegatingDataSource#setTargetDataSource方法\n    .method(named(\u0026quot;setTargetDataSource\u0026quot;))\n    .intercept(MyImplementation.INSTANCE)\n    .make()\n    .load(Thread.currentThread().getContextClassLoader(),\n          ClassReloadingStrategy.fromInstalledAgent());\n\nenum MyImplementation implements Implementation {\n\nINSTANCE; // singleton\n\n  @Override\n  public InstrumentedType prepare(InstrumentedType instrumentedType) {\n  return instrumentedType;\n  }\n  \n  @Override\n  public ByteCodeAppender appender(Target implementationTarget) {\n  return MyAppender.INSTANCE;\n  }\n  \n}\n//字节码定义\nenum MyAppender implements ByteCodeAppender {\n\nINSTANCE; // singleton\n\n@Override\npublic Size apply(MethodVisitor methodVisitor,\n        Implementation.Context implementationContext,\n        MethodDescription instrumentedMethod) {\n  Label label0 = new Label();\n  methodVisitor.visitLabel(label0);\n  methodVisitor.visitLineNumber(70, label0);\n  methodVisitor.visitVarInsn(ALOAD, 0);\n  methodVisitor.visitTypeInsn(NEW, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;);\n  methodVisitor.visitInsn(DUP);\n  methodVisitor.visitVarInsn(ALOAD, 1);\n  methodVisitor.visitMethodInsn(INVOKESPECIAL, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;, \u0026quot;\u0026lt;init\u0026gt;\u0026quot;, \u0026quot;(Ljavax/sql/DataSource;)V\u0026quot;, false);\n  methodVisitor.visitFieldInsn(PUTFIELD, \u0026quot;org/springframework/jdbc/datasource/DelegatingDataSource\u0026quot;, \u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;);\n  Label label1 = new Label();\n  methodVisitor.visitLabel(label1);\n  methodVisitor.visitLineNumber(71, label1);\n  methodVisitor.visitInsn(RETURN);\n  Label label2 = new Label();\n  methodVisitor.visitLabel(label2);\n  methodVisitor.visitLocalVariable(\u0026quot;this\u0026quot;, \u0026quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;\u0026quot;, null, label0, label2, 0);\n  methodVisitor.visitLocalVariable(\u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;, null, label0, label2, 1);\n  methodVisitor.visitMaxs(4, 2);\n  return new Size(4, 2);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？\u003c/p\u003e\n\u003cp\u003e我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e3、利用byte-buddy的Advice\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public static void redefine() {\n   new ByteBuddy()\n     .redefine(DelegatingDataSource.class)\n     .visit(Advice.to(Decorator.class)\n            .on(ElementMatchers.named(\u0026quot;setTargetDataSource\u0026quot;)))\n     .make()\n     .load(Thread.currentThread().getContextClassLoader(),\n           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();\n }\n\nstatic class Decorator {\n\n  //在方法开始插入代码\n  @Advice.OnMethodEnter\n    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {\n    dataSource = new P6DataSource(dataSource);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebyte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n  //插入的代码\n  targetDataSource = new P6DataSource(targetDataSource);\n  this.targetDataSource = targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。\u003c/li\u003e\n\u003cli\u003e使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e三、自动生效\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;dependency\u0026gt;\n  \u0026lt;groupId\u0026gt;com.kuaishou.ad\u0026lt;/groupId\u0026gt;\n  \u0026lt;artifactId\u0026gt;sqllog-spring-boot-starter\u0026lt;/artifactId\u0026gt;\n  \u0026lt;version\u0026gt;制品库查询最新版\u0026lt;/version\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static String[] getConfigurations(File file) {\n  @EnableAutoConfiguration\n  class NoScan {\n    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载\n  }\n  FileClassLoader classLoader = new FileClassLoader(file);\n  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();\n  selector.setBeanClassLoader(classLoader);\n  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));\n  selector.setEnvironment(new StandardEnvironment());\n  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));\n  return configurations;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e四、SQL打印效果\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003esqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eSQL的打印内容分为三部分：\u003c/p\u003e\n\u003cp\u003e第一行，显示执行时间、耗时、SQL操作、数据库连接等信息\u003c/p\u003e\n\u003cp\u003e第二行，显示参数化SQL\u003c/p\u003e\n\u003cp\u003e第三行，显示绑定参数后的实际执行的SQL\u003c/p\u003e\n\u003cp\u003e通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T59f6,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eGit 常用命令速查手册\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文按使用场景组织，覆盖日常开发中最常用的 Git 操作。每条命令附带简要说明，部分附有使用示例。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e1. 配置\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看当前配置\ngit config --list\n\n# 设置用户信息（全局）\ngit config --global user.name \u0026quot;Your Name\u0026quot;\ngit config --global user.email \u0026quot;your@email.com\u0026quot;\n\n# 仅对当前仓库设置（去掉 --global）\ngit config user.name \u0026quot;Your Name\u0026quot;\n\n# 设置默认编辑器\ngit config --global core.editor \u0026quot;vim\u0026quot;\n\n# 设置默认分支名\ngit config --global init.defaultBranch main\n\n# 配置命令别名\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.st status\ngit config --global alias.lg \u0026quot;log --oneline --graph --all\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 仓库初始化与克隆\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 初始化新仓库\ngit init\n\n# 克隆远程仓库\ngit clone \u0026lt;url\u0026gt;\n\n# 克隆指定分支\ngit clone -b \u0026lt;branch\u0026gt; \u0026lt;url\u0026gt;\n\n# 浅克隆（只拉最近 1 次提交，适合大仓库）\ngit clone --depth 1 \u0026lt;url\u0026gt;\n\n# 克隆并指定本地目录名\ngit clone \u0026lt;url\u0026gt; my-project\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 文件追踪与暂存\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看工作区状态\ngit status\n\n# 简洁模式\ngit status -s\n\n# 添加文件到暂存区\ngit add \u0026lt;file\u0026gt;\ngit add .                    # 当前目录所有变更\ngit add -A                   # 整个仓库所有变更\ngit add -p                   # 交互式选择要暂存的代码块\n\n# 取消暂存（保留工作区修改）\ngit restore --staged \u0026lt;file\u0026gt;\ngit reset HEAD \u0026lt;file\u0026gt;        # 旧写法，效果相同\n\n# 丢弃工作区修改（危险操作，不可恢复）\ngit restore \u0026lt;file\u0026gt;\ngit checkout -- \u0026lt;file\u0026gt;       # 旧写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e取消跟踪已版本控制的文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 不再追踪文件改动（文件保留在仓库中，但本地修改不再显示为 dirty）\ngit update-index --assume-unchanged \u0026lt;filePath\u0026gt;\n\n# 恢复追踪\ngit update-index --no-assume-unchanged \u0026lt;filePath\u0026gt;\n\n# 查看所有被 assume-unchanged 的文件\ngit ls-files -v | grep \u0026#39;^h\u0026#39;\n\n# 从版本控制中删除文件（但保留本地文件）\ngit rm --cached \u0026lt;filePath\u0026gt;\n\n# 从版本控制中删除文件夹\ngit rm -r -f --cached \u0026lt;dirPath\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e--assume-unchanged\u003c/code\u003e vs \u003ccode\u003e--skip-worktree\u003c/code\u003e\u003c/strong\u003e：两者都能让 Git 忽略本地修改，但语义不同。\u003ccode\u003e--assume-unchanged\u003c/code\u003e 是性能优化提示（告诉 Git \u0026quot;这个文件不会变\u0026quot;），\u003ccode\u003e--skip-worktree\u003c/code\u003e 是明确的意图声明（\u0026quot;我故意修改了这个文件，但不想提交\u0026quot;）。对于本地配置文件的修改，推荐使用 \u003ccode\u003e--skip-worktree\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit update-index --skip-worktree \u0026lt;filePath\u0026gt;\ngit update-index --no-skip-worktree \u0026lt;filePath\u0026gt;\ngit ls-files -v | grep \u0026#39;^S\u0026#39;    # 查看所有 skip-worktree 文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e4. 提交\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 提交暂存区内容\ngit commit -m \u0026quot;commit message\u0026quot;\n\n# 添加并提交所有已跟踪文件的修改（不含新文件）\ngit commit -am \u0026quot;commit message\u0026quot;\n\n# 修改最近一次提交的信息（未推送到远程时使用）\ngit commit --amend -m \u0026quot;new message\u0026quot;\n\n# 修改最近一次提交，追加文件但不改消息\ngit commit --amend --no-edit\n\n# 创建空提交（可用于触发 CI）\ngit commit --allow-empty -m \u0026quot;trigger build\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e5. 分支管理\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看本地分支\ngit branch\n\n# 查看所有分支（含远程）\ngit branch -a\n\n# 查看分支及最后一次提交\ngit branch -v\n\n# 创建分支\ngit branch \u0026lt;name\u0026gt;\n\n# 创建并切换\ngit checkout -b \u0026lt;name\u0026gt;\ngit switch -c \u0026lt;name\u0026gt;         # 推荐新写法\n\n# 切换分支\ngit checkout \u0026lt;name\u0026gt;\ngit switch \u0026lt;name\u0026gt;            # 推荐新写法\n\n# 重命名当前分支\ngit branch -m \u0026lt;new-name\u0026gt;\n\n# 删除本地分支（已合并）\ngit branch -d \u0026lt;name\u0026gt;\n\n# 强制删除本地分支（未合并也删）\ngit branch -D \u0026lt;name\u0026gt;\n\n# 删除远程分支\ngit push origin --delete \u0026lt;name\u0026gt;\n\n# 查看已合并到当前分支的分支\ngit branch --merged\n\n# 查看未合并到当前分支的分支\ngit branch --no-merged\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e6. 合并与变基\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 合并指定分支到当前分支\ngit merge \u0026lt;branch\u0026gt;\n\n# 合并时不使用 fast-forward（保留合并提交记录）\ngit merge --no-ff \u0026lt;branch\u0026gt;\n\n# 只生成一个合并提交（压缩对方所有提交）\ngit merge --squash \u0026lt;branch\u0026gt;\n\n# 变基（将当前分支的提交移到目标分支的最新提交之后）\ngit rebase \u0026lt;branch\u0026gt;\n\n# 交互式变基（修改/合并/删除/排序最近 N 次提交）\ngit rebase -i HEAD~N\n\n# 变基冲突后继续 / 跳过 / 终止\ngit rebase --continue\ngit rebase --skip\ngit rebase --abort\n\n# 合并冲突后终止合并\ngit merge --abort\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCherry-pick\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 将某个提交应用到当前分支\ngit cherry-pick \u0026lt;commit-hash\u0026gt;\n\n# 连续多个提交\ngit cherry-pick \u0026lt;hash1\u0026gt; \u0026lt;hash2\u0026gt;\n\n# 只暂存不提交\ngit cherry-pick \u0026lt;hash\u0026gt; --no-commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e7. 远程协作\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看远程仓库\ngit remote -v\n\n# 添加远程仓库\ngit remote add origin \u0026lt;url\u0026gt;\n\n# 修改远程仓库地址\ngit remote set-url origin \u0026lt;new-url\u0026gt;\n\n# 拉取远程更新（不合并）\ngit fetch\ngit fetch --all              # 拉取所有远程\ngit fetch --prune            # 同时清理已删除的远程分支引用\n\n# 拉取并合并（= fetch + merge）\ngit pull\n\n# 拉取并变基（= fetch + rebase，保持线性历史）\ngit pull --rebase\n\n# 推送\ngit push\ngit push origin \u0026lt;branch\u0026gt;\n\n# 首次推送并建立追踪关系\ngit push -u origin \u0026lt;branch\u0026gt;\n\n# 强制推送（覆盖远程历史，团队协作慎用）\ngit push --force\n\n# 安全的强制推送（远程有新提交时会拒绝）\ngit push --force-with-lease\n\n# 推送所有分支\ngit push --all\n\n# 推送所有标签\ngit push --tags\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 暂存工作区（Stash）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 暂存当前工作区和暂存区的修改\ngit stash\n\n# 带描述信息\ngit stash save \u0026quot;work in progress: feature X\u0026quot;\ngit stash push -m \u0026quot;description\u0026quot;   # 推荐新写法\n\n# 暂存时包含未跟踪的文件\ngit stash -u\n\n# 暂存时包含所有文件（含 .gitignore 忽略的）\ngit stash -a\n\n# 查看 stash 列表\ngit stash list\n\n# 恢复最近的 stash（保留 stash 记录）\ngit stash apply\n\n# 恢复并删除最近的 stash\ngit stash pop\n\n# 恢复指定的 stash\ngit stash apply stash@{2}\n\n# 删除指定 stash\ngit stash drop stash@{0}\n\n# 清空所有 stash\ngit stash clear\n\n# 查看某个 stash 的内容\ngit stash show -p stash@{0}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e9. 日志与差异\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看提交日志\ngit log\n\n# 简洁单行显示\ngit log --oneline\n\n# 图形化显示分支合并历史\ngit log --oneline --graph --all\n\n# 显示每次提交的文件变更统计\ngit log --stat\n\n# 显示每次提交的具体修改\ngit log -p\n\n# 最近 N 次提交\ngit log -n 5\n\n# 按作者过滤\ngit log --author=\u0026quot;name\u0026quot;\n\n# 按时间范围过滤\ngit log --since=\u0026quot;2024-01-01\u0026quot; --until=\u0026quot;2024-06-30\u0026quot;\n\n# 按提交信息关键字搜索\ngit log --grep=\u0026quot;fix bug\u0026quot;\n\n# 搜索某段代码的变更历史\ngit log -S \u0026quot;functionName\u0026quot;\n\n# 查看某个文件的提交历史\ngit log -- \u0026lt;file\u0026gt;\ngit log --follow -- \u0026lt;file\u0026gt;   # 包含重命名前的历史\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e差异对比\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 工作区 vs 暂存区\ngit diff\n\n# 暂存区 vs 最新提交\ngit diff --staged\ngit diff --cached            # 同义\n\n# 两个分支之间的差异\ngit diff \u0026lt;branch1\u0026gt;..\u0026lt;branch2\u0026gt;\n\n# 两个提交之间的差异\ngit diff \u0026lt;commit1\u0026gt;..\u0026lt;commit2\u0026gt;\n\n# 只看文件名列表\ngit diff --name-only\n\n# 查看文件改动统计\ngit diff --stat\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e10. 撤销与回退\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 撤销工作区修改（未暂存）\ngit restore \u0026lt;file\u0026gt;\n\n# 撤销暂存（保留工作区修改）\ngit restore --staged \u0026lt;file\u0026gt;\n\n# 回退到某个提交（保留修改在工作区）\ngit reset --soft \u0026lt;commit\u0026gt;\n\n# 回退到某个提交（保留修改在暂存区）\ngit reset --mixed \u0026lt;commit\u0026gt;     # 默认模式\n\n# 回退到某个提交（丢弃所有修改，危险操作）\ngit reset --hard \u0026lt;commit\u0026gt;\n\n# 回退最近 N 次提交\ngit reset --soft HEAD~N\n\n# 创建一个新提交来撤销指定提交（安全的回退方式，不改写历史）\ngit revert \u0026lt;commit\u0026gt;\n\n# 撤销多个连续提交\ngit revert \u0026lt;older-commit\u0026gt;..\u0026lt;newer-commit\u0026gt;\n\n# 只修改工作区不自动提交\ngit revert --no-commit \u0026lt;commit\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ereset\u003c/code\u003e vs \u003ccode\u003erevert\u003c/code\u003e\u003c/strong\u003e：\u003ccode\u003ereset\u003c/code\u003e 改写提交历史（适合未推送的本地提交），\u003ccode\u003erevert\u003c/code\u003e 创建新提交来撤销（适合已推送的公共分支）。在多人协作的分支上，永远优先使用 \u003ccode\u003erevert\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e11. 标签\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看所有标签\ngit tag\n\n# 按模式过滤\ngit tag -l \u0026quot;v1.*\u0026quot;\n\n# 创建轻量标签\ngit tag \u0026lt;tag-name\u0026gt;\n\n# 创建附注标签（推荐）\ngit tag -a \u0026lt;tag-name\u0026gt; -m \u0026quot;description\u0026quot;\n\n# 给历史提交打标签\ngit tag -a \u0026lt;tag-name\u0026gt; \u0026lt;commit-hash\u0026gt;\n\n# 查看标签详情\ngit show \u0026lt;tag-name\u0026gt;\n\n# 推送单个标签到远程\ngit push origin \u0026lt;tag-name\u0026gt;\n\n# 推送所有标签\ngit push origin --tags\n\n# 删除本地标签\ngit tag -d \u0026lt;tag-name\u0026gt;\n\n# 删除远程标签\ngit push origin --delete \u0026lt;tag-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e12. 子模块\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 添加子模块\ngit submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt;\n\n# 克隆含子模块的仓库\ngit clone --recurse-submodules \u0026lt;url\u0026gt;\n\n# 已克隆后初始化子模块\ngit submodule init\ngit submodule update\n\n# 一步到位\ngit submodule update --init --recursive\n\n# 更新所有子模块到最新\ngit submodule update --remote\n\n# 删除子模块\ngit submodule deinit \u0026lt;path\u0026gt;\ngit rm \u0026lt;path\u0026gt;\nrm -rf .git/modules/\u0026lt;path\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e13. Worktree（多工作目录）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 为指定分支创建一个独立的工作目录（无需 stash 即可同时处理多个分支）\ngit worktree add \u0026lt;path\u0026gt; \u0026lt;branch\u0026gt;\n\n# 创建新分支并建立 worktree\ngit worktree add -b \u0026lt;new-branch\u0026gt; \u0026lt;path\u0026gt;\n\n# 查看所有 worktree\ngit worktree list\n\n# 删除 worktree\ngit worktree remove \u0026lt;path\u0026gt;\n\n# 清理无效的 worktree 引用\ngit worktree prune\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e14. 查找与定位\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查找引入 bug 的提交（二分法）\ngit bisect start\ngit bisect bad                # 当前版本有 bug\ngit bisect good \u0026lt;commit\u0026gt;      # 某个已知正常的版本\n# Git 自动切换到中间版本，测试后标记 good/bad，直到定位到具体提交\ngit bisect reset              # 结束 bisect\n\n# 查看某行代码的最后修改人和提交\ngit blame \u0026lt;file\u0026gt;\ngit blame -L 10,20 \u0026lt;file\u0026gt;    # 只看第 10-20 行\n\n# 在所有提交中搜索内容\ngit grep \u0026quot;pattern\u0026quot;\ngit grep \u0026quot;pattern\u0026quot; \u0026lt;branch\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e15. 清理\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 预览将被清理的未跟踪文件\ngit clean -n\n\n# 删除未跟踪的文件\ngit clean -f\n\n# 删除未跟踪的文件和目录\ngit clean -fd\n\n# 删除未跟踪的文件（含 .gitignore 忽略的文件）\ngit clean -fdx\n\n# 垃圾回收（压缩历史，清理悬空对象）\ngit gc\n\n# 清理远程已删除的分支引用\ngit remote prune origin\ngit fetch --prune             # 等价\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e16. 常见场景速查\u003c/h2\u003e\n\u003ch3\u003e撤销最近一次提交但保留代码\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit reset --soft HEAD~1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e合并多次提交为一个\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit rebase -i HEAD~3\n# 编辑器中将后两个 pick 改为 squash (或 s)，保存退出\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e从其他分支拿一个文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit checkout \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt;\ngit restore --source \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt;   # 推荐新写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e找回误删的分支或提交\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看所有引用变更记录（包括已删除的）\ngit reflog\n\n# 基于 reflog 中的哈希恢复\ngit checkout -b recovered-branch \u0026lt;hash\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e修改历史提交的作者信息\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit rebase -i \u0026lt;commit\u0026gt;^\n# 将目标提交标记为 edit，保存退出\ngit commit --amend --author=\u0026quot;Name \u0026lt;email\u0026gt;\u0026quot; --no-edit\ngit rebase --continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e统计代码贡献\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 按作者统计提交数\ngit shortlog -sn\n\n# 统计某人的代码行数增删\ngit log --author=\u0026quot;name\u0026quot; --numstat --pretty=\u0026quot;%H\u0026quot; | awk \u0026#39;NF==3 {add+=$1; del+=$2} END {print \u0026quot;+\u0026quot;add, \u0026quot;-\u0026quot;del}\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e临时切到其他分支修 bug，不想 stash\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 用 worktree 在另一个目录打开 hotfix 分支，互不干扰\ngit worktree add ../hotfix-dir hotfix/issue-123\n\n# 修完后删除\ngit worktree remove ../hotfix-dir\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e只克隆仓库的某个子目录（Sparse Checkout）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone --filter=blob:none --sparse \u0026lt;url\u0026gt;\ncd \u0026lt;repo\u0026gt;\ngit sparse-checkout set path/to/subdir\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e把未提交的修改生成补丁发给别人\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 生成补丁文件\ngit diff \u0026gt; my-changes.patch\n\n# 对方应用补丁\ngit apply my-changes.patch\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e把已提交的 commit 生成补丁\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 生成最近 3 次提交的补丁文件（每个提交一个 .patch 文件）\ngit format-patch -3\n\n# 对方应用\ngit am *.patch\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e17. .gitignore\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# .gitignore 文件常用模式\n\n# 忽略所有 .log 文件\n*.log\n\n# 但保留 important.log\n!important.log\n\n# 忽略根目录下的 build 文件夹（不影响子目录中的 build）\n/build/\n\n# 忽略所有目录下的 node_modules\nnode_modules/\n\n# 忽略所有 .env 文件（防止泄露密钥）\n.env\n.env.*\n\n# 忽略 IDE 配置\n.idea/\n.vscode/\n*.swp\n*.swo\n*~\n\n# 忽略操作系统文件\n.DS_Store\nThumbs.db\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# .gitignore 已经添加规则，但文件之前已被跟踪？需要先从缓存中移除\ngit rm --cached \u0026lt;file\u0026gt;\ngit commit -m \u0026quot;stop tracking \u0026lt;file\u0026gt;\u0026quot;\n\n# 检查某个文件为什么被忽略\ngit check-ignore -v \u0026lt;file\u0026gt;\n\n# 列出所有被忽略的文件\ngit status --ignored\n\n# 全局 gitignore（对所有仓库生效）\ngit config --global core.excludesfile ~/.gitignore_global\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e18. Git Hooks\u003c/h2\u003e\n\u003cp\u003eGit Hooks 是在特定事件（提交、推送等）发生时自动执行的脚本，存放在 \u003ccode\u003e.git/hooks/\u003c/code\u003e 目录下。\u003c/p\u003e\n\u003ch3\u003e常用 Hook 类型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eHook\u003c/th\u003e\n\u003cth\u003e触发时机\u003c/th\u003e\n\u003cth\u003e典型用途\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-commit\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit commit\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e代码格式检查、lint、单元测试\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecommit-msg\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e提交信息写入后\u003c/td\u003e\n\u003ctd\u003e校验 commit message 格式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-push\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit push\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e运行测试、阻止推送到 main\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epost-merge\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit merge\u003c/code\u003e 完成后\u003c/td\u003e\n\u003ctd\u003e自动安装依赖\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-rebase\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit rebase\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e阻止对公共分支变基\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epost-checkout\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit checkout\u003c/code\u003e 完成后\u003c/td\u003e\n\u003ctd\u003e环境初始化\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e示例：pre-commit 检查是否有 console.log\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/sh\n# .git/hooks/pre-commit\n\nif git diff --cached --name-only | grep -E \u0026#39;\\.(js|ts|tsx)$\u0026#39; | xargs grep -l \u0026#39;console\\.log\u0026#39; 2\u0026gt;/dev/null; then\n    echo \u0026quot;Error: console.log found in staged files\u0026quot;\n    exit 1\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e使用 Husky 管理 Hooks（推荐）\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e.git/hooks/\u003c/code\u003e 不会被提交到仓库，团队共享不方便。\u003ca href=\"https://typicode.github.io/husky/\"\u003eHusky\u003c/a\u003e 解决了这个问题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装\nnpm install husky -D\nnpx husky init\n\n# 添加 pre-commit hook\necho \u0026quot;npm run lint\u0026quot; \u0026gt; .husky/pre-commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e19. Git LFS（大文件存储）\u003c/h2\u003e\n\u003cp\u003eGit 不擅长处理大文件（二进制、模型文件、设计稿等），Git LFS 用指针文件替代大文件，实际内容存储在单独的 LFS 服务器上。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装（macOS）\nbrew install git-lfs\n\n# 在仓库中启用\ngit lfs install\n\n# 追踪特定类型的大文件\ngit lfs track \u0026quot;*.psd\u0026quot;\ngit lfs track \u0026quot;*.zip\u0026quot;\ngit lfs track \u0026quot;models/**\u0026quot;\n\n# 追踪规则保存在 .gitattributes 中，需要提交\ngit add .gitattributes\ngit commit -m \u0026quot;track large files with LFS\u0026quot;\n\n# 后续正常 add/commit/push，LFS 文件会自动走 LFS 通道\ngit add large-file.psd\ngit commit -m \u0026quot;add design file\u0026quot;\ngit push\n\n# 查看当前 LFS 追踪的文件模式\ngit lfs track\n\n# 查看 LFS 管理的文件列表\ngit lfs ls-files\n\n# 拉取所有 LFS 文件（克隆后可能需要）\ngit lfs pull\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e20. Git Archive（导出代码）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 导出当前 HEAD 为 zip\ngit archive --format=zip HEAD -o project.zip\n\n# 导出指定分支\ngit archive --format=tar.gz release/v1.0 -o release-v1.0.tar.gz\n\n# 只导出某个子目录\ngit archive HEAD --prefix=src/ -- src/ -o src-only.zip\n\n# 导出两个版本之间的差异文件\ngit diff --name-only v1.0 v2.0 | xargs git archive HEAD -o diff-files.zip --\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e21. 交互式变基详解\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003egit rebase -i\u003c/code\u003e 是最强大的提交历史编辑工具，编辑器中每行一个提交，支持以下操作：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003cth\u003e缩写\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epick\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留该提交（默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ereword\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003er\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留提交但修改提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eedit\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ee\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e暂停在该提交，允许修改内容\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003esquash\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003es\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并到上一个提交，合并提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003efixup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ef\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并到上一个提交，丢弃本条提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003edrop\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ed\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e删除该提交\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e典型场景\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 合并最近 4 次提交为 1 个\ngit rebase -i HEAD~4\n# 编辑器中：第一个保持 pick，其余改为 squash 或 fixup\n\n# 调整提交顺序：直接在编辑器中拖动行的位置\n\n# 拆分一个提交为多个\ngit rebase -i HEAD~3\n# 将目标提交标记为 edit，保存退出\ngit reset HEAD~1              # 撤回提交但保留文件修改\ngit add file1 \u0026amp;\u0026amp; git commit -m \u0026quot;part 1\u0026quot;\ngit add file2 \u0026amp;\u0026amp; git commit -m \u0026quot;part 2\u0026quot;\ngit rebase --continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e22. 签名与验证\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 配置 GPG 签名\ngit config --global user.signingkey \u0026lt;GPG-KEY-ID\u0026gt;\ngit config --global commit.gpgsign true    # 默认对所有提交签名\n\n# 签名提交\ngit commit -S -m \u0026quot;signed commit\u0026quot;\n\n# 签名标签\ngit tag -s v1.0 -m \u0026quot;signed release\u0026quot;\n\n# 验证提交签名\ngit log --show-signature\n\n# 验证标签签名\ngit tag -v v1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e23. 高级配置技巧\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 自动纠正拼写错误的命令（如 git stauts → git status）\ngit config --global help.autocorrect 10   # 1 秒后自动执行\n\n# 启用 rerere（记住冲突解决方式，下次自动应用）\ngit config --global rerere.enabled true\n\n# diff 时使用更好的算法（对函数移动更友好）\ngit config --global diff.algorithm histogram\n\n# 全局忽略文件权限变更（在 macOS/Windows 上避免无意义的 diff）\ngit config --global core.fileMode false\n\n# 设置 pull 默认使用 rebase（保持线性历史）\ngit config --global pull.rebase true\n\n# 推送时自动设置上游分支\ngit config --global push.autoSetupRemote true\n\n# 多行 commit message 使用 heredoc\ngit commit -m \u0026quot;$(cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39;\nfeat: add user authentication\n\n- Add JWT token generation\n- Add login/logout endpoints\n- Add middleware for protected routes\nEOF\n)\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e24. 速查表\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e想做什么\u003c/th\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e查看状态\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit status\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e添加所有修改\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit add -A\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit commit -m \u0026quot;msg\u0026quot;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e拉取 + 变基\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit pull --rebase\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e推送\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit push\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e新建分支并切换\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit switch -c feat/xxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e合并分支\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit merge --no-ff feat/xxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e暂存工作区\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit stash -u\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e恢复暂存\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit stash pop\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e查看简洁日志\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit log --oneline --graph\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e撤销最近提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit reset --soft HEAD~1\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全回退已推送的提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit revert \u0026lt;hash\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e找回误删内容\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit reflog\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e查看某行代码作者\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit blame \u0026lt;file\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e二分法查 bug\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit bisect start\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e只拿某个提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit cherry-pick \u0026lt;hash\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e导出代码压缩包\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit archive HEAD -o out.zip\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n"])</script><script>self.__next_f.push([1,"18:T2144,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e一个缺失的词\u003c/h2\u003e\n\u003cp\u003e在读这本书之前，我和大多数人一样，把世界分成两类：脆弱的和坚固的。系统要么经不起冲击，要么扛得住冲击。风险管理的目标就是把脆弱的东西变得坚固。\u003c/p\u003e\n\u003cp\u003e塔勒布指出，这个二分法缺了最关键的一类。有些东西不仅扛得住冲击，而且\u003cstrong\u003e在冲击中变得更强\u003c/strong\u003e。他找遍了所有语言，发现没有现成的词来描述这种特性，于是造了一个：Antifragile，反脆弱。\u003c/p\u003e\n\u003cp\u003e脆弱的反义词不是坚固，就像消极的反义词不是中性。坚固只是光谱的中间位置——它抵抗冲击但不从中获益。反脆弱在坚固的另一端，它需要波动、需要压力、需要混乱，才能保持活力。\u003c/p\u003e\n\u003cp\u003e人体就是最典型的反脆弱系统。骨骼在承受压力后变得更致密，肌肉在撕裂后变得更强壮，免疫系统在接触病原体后变得更高效。如果你把一个人关在无菌、无重力、无压力的环境中「保护」起来，你会得到一个极度脆弱的人。\u003c/p\u003e\n\u003cp\u003e这个框架一旦建立，你会发现它无处不在。作为一个长期做系统架构的人，我发现它对我的专业领域和个人生活都产生了深刻影响。\u003c/p\u003e\n\u003ch2\u003e三元组：脆弱、坚固、反脆弱\u003c/h2\u003e\n\u003cp\u003e塔勒布用一个三元组来分析几乎所有事物：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e脆弱\u003c/th\u003e\n\u003cth\u003e坚固\u003c/th\u003e\n\u003cth\u003e反脆弱\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e大型集中式系统\u003c/td\u003e\n\u003ctd\u003e冗余备份系统\u003c/td\u003e\n\u003ctd\u003e分布式自适应系统\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e单一收入来源\u003c/td\u003e\n\u003ctd\u003e稳定的工资\u003c/td\u003e\n\u003ctd\u003e杠铃式收入结构\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e精确预测\u003c/td\u003e\n\u003ctd\u003e保险对冲\u003c/td\u003e\n\u003ctd\u003e从错误中学习的机制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e优化效率\u003c/td\u003e\n\u003ctd\u003e增加冗余\u003c/td\u003e\n\u003ctd\u003e保留可选择性\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这个三元组的价值在于，它让你\u003cstrong\u003e诊断自己的系统处于光谱的哪个位置\u003c/strong\u003e，然后有意识地向反脆弱方向移动。\u003c/p\u003e\n\u003cp\u003e更深的洞见是：我们的文化几乎总在推动我们走向脆弱端。追求效率最大化、消除所有冗余、精确预测未来——这些看似理性的行为，恰恰是脆弱性的来源。\u003c/p\u003e\n\u003ch2\u003e可选择性：反脆弱的核心机制\u003c/h2\u003e\n\u003cp\u003e反脆弱的底层机制是什么？塔勒布给出了一个精炼的答案：\u003cstrong\u003e可选择性（Optionality）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e可选择性意味着：你的下行风险有限，但上行收益没有上限。这不是赌博——赌博是下行风险无限。可选择性是一种精心设计的不对称结构：坏的情况损失很小，好的情况获益很大。用金融术语说，你拥有的不是期货合约（被锁定），而是期权（有权利但没有义务）。\u003c/p\u003e\n\u003cp\u003e这个概念改变了我看待技术决策的方式。过去做架构设计，我习惯性地追求「最优方案」。现在我意识到，\u003cstrong\u003e最优方案往往是最脆弱的方案\u003c/strong\u003e，因为它对初始假设的依赖最大。一旦环境变化，优化过的系统最先崩溃。\u003c/p\u003e\n\u003cp\u003e更好的策略是保留可选择性：不要过早锁定技术栈，不要把所有逻辑耦合在一起，不要为了当前的效率牺牲未来的灵活性。软件工程中很多最佳实践——接口抽象、松耦合、插件化——本质上都是在创造可选择性，只是我们通常不用这个词来描述。\u003c/p\u003e\n\u003ch2\u003e杠铃策略：极端保守 + 极端冒险\u003c/h2\u003e\n\u003cp\u003e塔勒布最具操作性的建议是\u003cstrong\u003e杠铃策略（Barbell Strategy）\u003c/strong\u003e：不要走中间路线，而是同时做两个极端。\u003c/p\u003e\n\u003cp\u003e把 85-90% 的资源放在极端保守的位置（零风险或近似零风险），然后把 10-15% 放在极端冒险的位置（高风险高回报）。完全跳过中间地带。\u003c/p\u003e\n\u003cp\u003e为什么中间地带反而危险？因为中等风险给你一种虚假的安全感——你既没有真正的安全，也没有获得不对称收益的机会。\u003c/p\u003e\n\u003cp\u003e这个思路映射到分布式系统设计非常直接。与其对所有服务采用统一的「中等容错」方案，不如对核心链路做到极端可靠（多机房多活、强一致性），对非核心链路采用极端简化（允许失败、最终一致性、快速降级）。在关键点做到极致，在其余点保持轻量。\u003c/p\u003e\n\u003cp\u003e混沌工程（Chaos Engineering）也是杠铃策略的体现。Netflix 的 Chaos Monkey 在生产环境中随机杀死服务实例，看似制造了风险，实际上是在用可控的小压力来训练系统的反脆弱能力——主动引入波动，让系统在小规模失败中学习。\u003c/p\u003e\n\u003cp\u003e在职业规划上，杠铃策略同样适用。与其追求「还不错」的中间态路径，不如让收入结构变成杠铃形：一端是极度稳定的基本收入（技术咨询、稳定合同），另一端是极度不确定但上行空间巨大的探索（开源项目、技术创业、内容创作）。即使探索端全部失败，稳定端保证你不会陷入困境；但只要有一个成功，回报可能远超预期。\u003c/p\u003e\n\u003ch2\u003e切身利害：系统纠错的前提条件\u003c/h2\u003e\n\u003cp\u003e塔勒布在后续的著作中进一步发展了一个概念：\u003cstrong\u003eSkin in the Game（切身利害）\u003c/strong\u003e。这个概念在《反脆弱》中已有雏形——他认为，一个系统要具备反脆弱性，决策者必须承担自己决策的后果。\u003c/p\u003e\n\u003cp\u003e没有切身利害的决策系统是危险的。银行家用别人的钱冒险，成功了自己拿奖金，失败了纳税人买单——这就是结构性脆弱。决策者和风险承担者之间的分离，是脆弱性最深层的来源之一。\u003c/p\u003e\n\u003cp\u003e这个观察对技术团队的启示很深。当架构师不需要参与运维，当产品经理不需要处理线上故障，当管理者不需要为技术债务付出代价时，系统就自然地滑向脆弱端。「谁设计，谁运维」不仅仅是 DevOps 的口号，它的深层逻辑是通过切身利害来驱动反脆弱性。亚马逊的「You build it, you run it」原则，本质上就在解决这个问题：让做决策的人承担决策的后果。\u003c/p\u003e\n\u003ch2\u003e对个人生活的重新审视\u003c/h2\u003e\n\u003cp\u003e读完这本书后，我开始重新审视自己的生活结构。\u003c/p\u003e\n\u003cp\u003e我发现自己在很多方面都不自觉地追求「坚固」：稳定的工作、固定的收入、可预测的日程、熟悉的技术栈。这些不是坏事，但当所有的稳定性都依赖外部环境不变，我实际上是在和时间对赌。\u003c/p\u003e\n\u003cp\u003e真正改变我思维的是塔勒布关于「压力源」的态度翻转。反脆弱思维认为，\u003cstrong\u003e适度的压力源是系统保持活力的必要条件\u003c/strong\u003e。没有压力的系统不是健康的，而是一个正在慢慢退化的系统。\u003c/p\u003e\n\u003cp\u003e我开始有意识地给自己引入「可控的不确定性」：每年学一门新的编程语言或技术范式，定期换一种工作方式，尝试自己不擅长的领域。这不是为了「充电」或「自我提升」这种鸡汤式的理由，而是一种刻意的系统维护——通过小剂量的波动来避免大规模的脆弱性积累。\u003c/p\u003e\n\u003ch2\u003e反脆弱的局限\u003c/h2\u003e\n\u003cp\u003e公允地说，反脆弱框架在分析层面极其强大，但在操作层面有时过于模糊。「保留可选择性」说起来容易，具体到每一个决策点，什么算可选择性、代价多大才值得、什么时候该锁定而不是继续保留灵活性——这些塔勒布没有给出足够精确的回答。\u003c/p\u003e\n\u003cp\u003e另外，并非所有系统都需要反脆弱——有些场景（核电站的安全系统、航天器的关键组件）需要的就是极致的坚固，而不是在波动中进化。\u003c/p\u003e\n\u003ch2\u003e结语\u003c/h2\u003e\n\u003cp\u003e《反脆弱》给我最大的收获不是一套方法论，而是一种\u003cstrong\u003e认知框架的升级\u003c/strong\u003e——从「如何避免风险」的防御性思维，转向「如何让风险为我所用」的设计性思维。\u003c/p\u003e\n\u003cp\u003e作为一个做系统设计的人，我现在评估架构方案时会多问一个问题：\u003cstrong\u003e这个系统在遇到意外冲击时，是会崩溃、仅仅存活、还是变得更强？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这也许就是塔勒布最核心的洞见：在一个根本无法预测的世界中，比预测更重要的是\u003cstrong\u003e体质\u003c/strong\u003e。不是你能不能预见下一场风暴，而是你的系统是否能在风暴中进化。\u003c/p\u003e\n\u003cp\u003e风会熄灭蜡烛，却能使火越烧越旺。你要做的不是预测风的方向，而是把自己变成火。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"19:T3dc2,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e首先强调一下，Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。其中，最”简单”的方式是通过\u003c/em\u003e\u003ca href=\"https://central.sonatype.org/pages/ossrh-guide.html\"\u003eSonatype OSSRH\u003c/a\u003e\u003cem\u003e仓库来发布jar包。所以，接下来主要介绍如何将jar包发布到Sonatype OSSRH。\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先，先说一下大体的步骤：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e注册Sonatype账号\u003c/li\u003e\n\u003cli\u003e创建Issue，验证域名\u003c/li\u003e\n\u003cli\u003e安装GPG，发布密钥\u003c/li\u003e\n\u003cli\u003e配置Maven，发布构件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里面比较重要和容易出错的是第二步和第三步，下面一一详细介绍。\u003c/p\u003e\n\u003ch4\u003e1、注册Sonatype账号 \u003ca href=\"#bojci\" id=\"bojci\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e第一步很简单，登录官网，注册账号就好了\u003ca href=\"https://issues.sonatype.org/secure/Signup!default.jspa\"\u003eSign up for Jira - Sonatype JIRA\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e注册完成，登陆后的界面如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_60.png\" alt=\"image_60.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2、创建Issue \u003ca href=\"#omwqz\" id=\"omwqz\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这里项目选择：Community Support - Open Source Project Repository Hosting (OSSRH)，问题 类型选择：New Project\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_67.png\" alt=\"image_67.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.1、补充项目信息\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_62.png\" alt=\"image_62.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.2、验证域名 \u003ca href=\"#snbg0\" id=\"snbg0\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e我们需要使用域名作为Group Id，如果你拥有域\u0026#x540D;\u003cem\u003e\u0026#x65;xample.com，则能够使用com.example开头作为Group Id，例如：com.example.myproject。其他一些栗子如下：\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eexample.com -\u0026gt; com.example.domain\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.springframework.org/\"\u003ewww.springframework.org\u003c/a\u003e -\u0026gt; org.springframework\u003c/li\u003e\n\u003cli\u003esubdomain.example.com -\u0026gt; example.com\u003c/li\u003e\n\u003cli\u003egithub.com/yourusername -\u0026gt; io.github.yourusername\u003c/li\u003e\n\u003cli\u003emy-domain.com -\u0026gt; com.my-domain\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e要想使用某个域名作为Group Id，你需要证明拥有该域名，至于如何证明，详见官方文档：\u003ca href=\"https://central.sonatype.org/faq/how-to-set-txt-record\"\u003ehttps://central.sonatype.org/faq/how-to-set-txt-record/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e如果你没有自己的域名，则可以通过代码托管平台的账号关联子域名。假设你托管平台账户名为myusername，那么你可以通过以下托管平台验证Group Id ：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_63.png\" alt=\"image_63.png\"\u003e\u003c/p\u003e\n\u003cp\u003e由于我没有自己的域名，这里我选择使用github账号验证Group Id。点击“新建”按钮，完成提交，之后你的注册邮箱会收到一封邮件，显示创建项目信息：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_65.png\" alt=\"image_65.png\"\u003e\u003c/p\u003e\n\u003cp\u003e稍后还会收到一封审核邮件，提示你进行域名验证，时间延迟大概在十分钟以内。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.3、人工审核及确认\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_66.png\" alt=\"image_66.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我使用的是github账户，按邮件提示，需要在github平台上创建一个指定的临时工程。创建完成之后，可以在issue下面添加评论，触发验证。验证成功后，你会收到一份邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_68.png\" alt=\"image_68.png\"\u003e\u003c/p\u003e\n\u003cp\u003e收到上述邮件，就表示完成了Group Id的验证，此时你就可以使用该Group Id或者子Group Id发布Maven构件了。如上，我填写的Group Id是 “io.github.nianien”，因此，我可以使用 “io.github.nianien”或者 “io.github.nianien.xxx” 作为项目的GroupId发布Maven构件。\u003c/p\u003e\n\u003cp\u003e在通过Maven发布构件之前，我们需要进行Maven配置，这里还需要一些前置工作。\u003c/p\u003e\n\u003ch4\u003e3、安装GPG，创建密钥 \u003ca href=\"#dcxco\" id=\"dcxco\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e安装GPG的方式有多种，这里推荐图形化安装，因为通过命令行安装，由于找不到合适的密钥服务器，发布密钥时会失败。这里给出Mac版本的下载地址：\u003ca href=\"https://releases.gpgtools.org/GPG_Suite-2022.1.dmg\"\u003ehttps://releases.gpgtools.org/GPG_Suite-2022.1.dmg\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建密钥\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_69.png\" alt=\"image_69.png\"\u003e\u003c/p\u003e\n\u003cp\u003e3.1、发布密钥\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_70.png\" alt=\"image_70.png\"\u003e\u003c/p\u003e\n\u003cp\u003e发布成功后，收到一份邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_71.png\" alt=\"image_71.png\"\u003e\u003c/p\u003e\n\u003cp\u003e按照邮件指示操作，完成密钥发布。密钥发布成功之后，下一步就是配置maven settings.xml和工程pom.xml文件。\u003c/p\u003e\n\u003ch4\u003e4、配置Maven，发布构件 \u003ca href=\"#amad1\" id=\"amad1\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e第一步，配置setting.xml文件，添加server节点：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;servers\u0026gt;\n\u0026lt;server\u0026gt;\n    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n    \u0026lt;username\u0026gt;sonatype账户名\u0026lt;/username\u0026gt;\n    \u0026lt;password\u0026gt;sonatype账户密码\u0026lt;/password\u0026gt;\n\u0026lt;/server\u0026gt;\n\u0026lt;/servers\u0026gt;\n\u0026lt;profile\u0026gt;\n  \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n  \u0026lt;properties\u0026gt;\n    \u0026lt;gpg.executable\u0026gt;gpg\u0026lt;/gpg.executable\u0026gt;\n    \u0026lt;gpg.passphrase\u0026gt;创建密钥时使用的密码\u0026lt;/gpg.passphrase\u0026gt;\n    \u0026lt;gpg.homedir\u0026gt;/Users/yourname/.gnupg\u0026lt;/gpg.homedir\u0026gt;\n   \u0026lt;/properties\u0026gt;\n\u0026lt;/profile\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e第二步，配置pom.xml文件，添加必填项\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\n         xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\n    \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\u0026lt;!--已经验证的Group Id--\u0026gt;\n    \u0026lt;groupId\u0026gt;io.github.nianien\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;cudrania\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;1.0.1\u0026lt;/version\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;name\u0026gt;io.github.nianien:cudrania\u0026lt;/name\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;description\u0026gt;support tools for java development\u0026lt;/description\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;url\u0026gt;https://github.com/nianien/cudrania\u0026lt;/url\u0026gt;\n    \u0026lt;properties\u0026gt;\n        \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt;\n        \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt;\n    \u0026lt;/properties\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;licenses\u0026gt;\n        \u0026lt;license\u0026gt;\n            \u0026lt;name\u0026gt;The Apache Software License, Version 2.0\u0026lt;/name\u0026gt;\n            \u0026lt;url\u0026gt;https://www.apache.org/licenses/LICENSE-2.0.txt\u0026lt;/url\u0026gt;\n        \u0026lt;/license\u0026gt;\n    \u0026lt;/licenses\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;developers\u0026gt;\n        \u0026lt;developer\u0026gt;\n            \u0026lt;id\u0026gt;nianien\u0026lt;/id\u0026gt;\n            \u0026lt;name\u0026gt;nianien\u0026lt;/name\u0026gt;\n            \u0026lt;email\u0026gt;nianien@126.com\u0026lt;/email\u0026gt;\n        \u0026lt;/developer\u0026gt;\n    \u0026lt;/developers\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;scm\u0026gt;\n        \u0026lt;connection\u0026gt;https://github.com/nianien/cudrania.git\u0026lt;/connection\u0026gt;\n        \u0026lt;developerConnection\u0026gt;scm:git:ssh://git@github.com:nianien/cudrania.git\n        \u0026lt;/developerConnection\u0026gt;\n        \u0026lt;url\u0026gt;https://github.com/nianien/cudrania\u0026lt;/url\u0026gt;\n    \u0026lt;/scm\u0026gt;\n    \u0026lt;build\u0026gt;\n        \u0026lt;pluginManagement\u0026gt;\n            \u0026lt;plugins\u0026gt;\n                \u0026lt;plugin\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt;\n                    \u0026lt;configuration\u0026gt;\n                        \u0026lt;source\u0026gt;${java.version}\u0026lt;/source\u0026gt;\n                        \u0026lt;target\u0026gt;${java.version}\u0026lt;/target\u0026gt;\n                    \u0026lt;/configuration\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n                \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;jar-no-fork\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n                \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt; \n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.5.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                            \u0026lt;configuration\u0026gt;\n                                \u0026lt;additionalparam\u0026gt;\n                                    -Xdoclint:none\n                                \u0026lt;/additionalparam\u0026gt;\n                            \u0026lt;/configuration\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                \u0026lt;plugin\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;sign-artifacts\u0026lt;/id\u0026gt;\n                            \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;sign\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n            \u0026lt;/plugins\u0026gt;\n        \u0026lt;/pluginManagement\u0026gt;\n        \u0026lt;plugins\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n        \u0026lt;/plugins\u0026gt;\n    \u0026lt;/build\u0026gt;\n\n    \u0026lt;profiles\u0026gt;\u0026lt;!--必填--\u0026gt;\n        \u0026lt;profile\u0026gt;\n            \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n            \u0026lt;build\u0026gt;\n                \u0026lt;plugins\u0026gt;\n                    \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                        \u0026lt;groupId\u0026gt;org.sonatype.plugins\u0026lt;/groupId\u0026gt;\n                        \u0026lt;artifactId\u0026gt;nexus-staging-maven-plugin\u0026lt;/artifactId\u0026gt;\n                        \u0026lt;version\u0026gt;1.6.13\u0026lt;/version\u0026gt;\n                        \u0026lt;extensions\u0026gt;true\u0026lt;/extensions\u0026gt;\n                        \u0026lt;configuration\u0026gt;\n                            \u0026lt;serverId\u0026gt;ossrh\u0026lt;/serverId\u0026gt;\n                            \u0026lt;nexusUrl\u0026gt;https://s01.oss.sonatype.org/\u0026lt;/nexusUrl\u0026gt; \n                          \u0026lt;autoReleaseAfterClose\u0026gt;true\u0026lt;/autoReleaseAfterClose\u0026gt;\n                        \u0026lt;/configuration\u0026gt;\n                    \u0026lt;/plugin\u0026gt;\n                    \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                        \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                        \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;/plugin\u0026gt;\n                \u0026lt;/plugins\u0026gt;\n            \u0026lt;/build\u0026gt;\u0026lt;!--必填--\u0026gt;\n            \u0026lt;distributionManagement\u0026gt;\n                \u0026lt;snapshotRepository\u0026gt;\n                    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n                  \u0026lt;url\u0026gt;https://s01.oss.sonatype.org/content/repositories/snapshots\n                    \u0026lt;/url\u0026gt;\n                \u0026lt;/snapshotRepository\u0026gt;\n                \u0026lt;repository\u0026gt;\n                    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n                    \u0026lt;url\u0026gt;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/\n                    \u0026lt;/url\u0026gt;\n                \u0026lt;/repository\u0026gt;\n            \u0026lt;/distributionManagement\u0026gt;\n        \u0026lt;/profile\u0026gt;\n    \u0026lt;/profiles\u0026gt;\n\n    \u0026lt;dependencies\u0026gt;\u0026lt;!--maven依赖--\u0026gt;\u0026lt;/dependencies\u0026gt;\n\n\u0026lt;/project\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面已经是最精简的pom配置了，我已经把必选项标注好了。这里主要包含两部分内容，一部分是snoatype要求的必备信息，包括：证书、开发者信息、仓库地址和发布地址；另一部分是deploy需要的maven插件列表，大家可以根据实际情况酌情修改。\u003c/p\u003e\n\u003cp\u003e需要说明的是，为了不用默认打包冲突，专门定义了用于发布中央仓库的profile：ossrh，这里只需要添加额外的两个插件：nexus-staging-maven-plugin和maven-gpg-plugin，前者用于jar上传，后者用于密钥签名。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第三步，执行maven命令，发布构件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e配置好pom文件，可以执行maven命令：“mvn clean deploy -Possrh” 进行发布。如果版本号带SNAPSHOT后缀，会发布到snapshots仓库，否则发布到release仓库。\u003c/p\u003e\n\u003cp\u003e这里nexus-staging-maven-plugin插件有一个配置项：autoReleaseAfterClose，如果设置为true的话，推送完成会自动release。第一次发布成功后，会收到一封邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_72.png\" alt=\"image_72.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e\u003cstrong\u003e最后，让jar包更快的在中央仓库被搜索到\u003c/strong\u003e\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e根据邮件提示，Jar包成功发布成功后，大约30分钟后会推到中央仓库，我们可以从仓库地址看到我们发布的Jar包：\u003ca href=\"https://repo1.maven.org/maven2\"\u003ehttps://repo1.maven.org/maven2/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_73.png\" alt=\"image_73.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，其他项目就可以通过maven依赖引用我们的构件了，但是这时候通过中央仓库仍然搜不到我们的Maven构件。按照邮件提示可能会需要四小时，实际情况是我等了5个小时依然搜不到。如果遇到这种情况，我们可以通过在对issue添加评论反馈，会有人工回复进行解决：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_74.png\" alt=\"image_74.png\"\u003e\u003c/p\u003e\n\u003cp\u003e另外，关于mvnrepository与Maven Central的关系，有人咨询，官方也做了解答：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_75.png\" alt=\"image_75.png\"\u003e\u003c/p\u003e\n\u003cp\u003e根据我的实际经验判断，mvnrepository应该是定时同步的，我发布成功后，第二天才能搜到：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_76.png\" alt=\"image_76.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下面是官方指导文档，介绍非常详细，基本上不用在网上搜索其他教程了。\u003c/p\u003e\n\u003ch4\u003e官方参考文档 \u003ca href=\"#dzquo\" id=\"dzquo\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://central.sonatype.org/publish/publish-guide\"\u003ehttps://central.sonatype.org/publish/publish-guide/\u003c/a\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/middleware/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"中间件\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-04-07\",\"children\":\"2024年04月07日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"非侵入式SQL监控\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"SQL监控\",{\"href\":\"/blog/tag/SQL%E7%9B%91%E6%8E%A7/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"SQL监控\"}],[\"$\",\"$L13\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}],[\"$\",\"$L13\",\"非侵入式\",{\"href\":\"/blog/tag/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8F/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"非侵入式\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/tooling/Git常用命令\",\"title\":\"Git 常用命令速查手册\",\"description\":\"一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。\",\"pubDate\":\"2024-04-05\",\"tags\":[\"Git\",\"版本控制\",\"开发工具\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"life/reading/反脆弱：从不确定性中获益的系统设计\",\"title\":\"《反脆弱》：从不确定性中获益的系统设计\",\"description\":\"塔勒布的核心洞见不是「如何抵抗风险」，而是「如何让波动成为养分」。反脆弱不是坚固，而是在压力下变得更强。这个框架对系统架构、职业规划和个人生活都有深刻启示。\",\"pubDate\":\"2024-05-10\",\"tags\":[\"读书笔记\",\"反脆弱\",\"塔勒布\",\"系统设计\",\"风险管理\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"SQL监控\":{\"prev\":null,\"next\":null},\"Java\":{\"prev\":{\"slug\":\"engineering/tooling/Java构件发布到中央仓库\",\"title\":\"Java构件发布到中央仓库\",\"description\":\"Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。其中，最”简单”的方式是通过...\",\"pubDate\":\"2024-04-04\",\"tags\":[\"Maven\",\"Java\",\"开源发布\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"},\"next\":null},\"非侵入式\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L1a\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"非侵入式SQL监控 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"非侵入式SQL监控\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-04-07\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"非侵入式SQL监控\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
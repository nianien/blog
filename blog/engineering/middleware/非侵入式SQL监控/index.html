<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/0458d6941a120cde.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-51baccc14cf1da9e.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>非侵入式SQL监控 - Skyfalling Blog</title><meta name="description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><meta property="og:title" content="非侵入式SQL监控"/><meta property="og:description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-04-07"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="非侵入式SQL监控"/><meta name="twitter:description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-04-07">2024年04月07日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">非侵入式SQL监控</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/page/1/">技术实战</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><p>你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。</p>
<p>另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) 
and name in(sql
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;)
)
</code></pre>
<p>缩略下印如下：</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004,...) 
and name in(
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,...)
)
</code></pre>
<p>既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -&gt; ORM -&gt; DataSource  -&gt; Connection -&gt; Driver -&gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -&gt; DataSource  -&gt; Connection -&gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从<strong>DataSource  -&gt; Connection -&gt; Driver</strong>三个环节进行入手：</p>
<h3><strong>一、SQL Profile监控</strong></h3>
<h4><strong>1、驱动层监控</strong></h4>
<p>如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：</p>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;logger=Slf4JLogger&amp;profileSQL=true
</code></pre>
<p>基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。</p>
<h4><strong>2、连接层监控</strong></h4>
<p>如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如<a href="https://p6spy.readthedocs.io/en/latest/">P6Spy</a>、<a href="https://github.com/arthurblake/log4jdbc">log4jdbc</a> 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：</p>
<ul>
<li>pyspy</li>
</ul>
<pre><code class="language-properties">jdbc:p6spy:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-properties">jdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<h4><strong>3、数据源层监控</strong></h4>
<p>可以通过对DataSource进行代理实现SQL监控</p>
<ul>
<li>P6Spy：</li>
</ul>
<pre><code class="language-java">@Bean
@Primary
public DataSource spyDataSource(@Autowired DataSource dataSource) {
  // wrap a datasource using P6SpyDataSource
  return new P6DataSource(dataSource);
}
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-java">public DataSource spyDataSource(DataSource dataSource) {
    // wrap the provided dataSource
  return new DataSource() {
    @Override
    public Connection getConnection() throws SQLException {
      // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection());
    }
      
    @Override
    public Connection getConnection(String username, String password) throws SQLException {
       // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection(username, password));
     }
      //...
  };
}
</code></pre>
<p>上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。</p>
<p>第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。</p>
<p>第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。</p>
<p>排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。</p>
<pre><code class="language-java">public interface DataSourceConfig extends HasBizDef {

    /**
     * 数据源名称，必须与KDB申请时填写的一致
     */String bizName();

    /**
     * 获取当前可用区单库只读的JdbcTemplate
     */
    default NamedParameterJdbcTemplate read() {
        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), &quot;read&quot;);
    }   

    /**
     * 获取当前可用区单库读写的JdbcTemplate
     */
    default NamedParameterJdbcTemplate write() {
        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), &quot;write&quot;);
    }	
  //....
}
</code></pre>
<p>DefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:</p>
<pre><code class="language-kotlin">enum class AdDataSources(
    private val bizDef: BizDef,
    private val forTest: AdDataSources? = null,
    private val usingNewZk: Boolean = false
) : DataSourceConfig{
    adFansTopProfileDashboardTest,
    adFansTopProfileDashboard,
    adChargeTest,
    adCharge,
    adChargeReadOnly,
    adDspReadOnlyTest,
    adDspReadOnly;
    public open fun bizName(): String {
        return bizDef.bizName
    }
}
</code></pre>
<p>如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？</p>
<p>具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：</p>
<pre><code class="language-java">public static ListenableDataSource&lt;Failover&lt;Instance&gt;&gt; create(Instance i) {
   //...
   try {
       return supplyWithRetry(
        DATA_SOURCE_BUILD_RETRY,
        DATA_SOURCE_BUILD_RETRY_DELAY,
        () -&gt; new ListenableDataSource&lt;&gt;(
              bizName, 
              new HikariDataSource(config), ds -&gt; i.toString(), i),
              DataSourceFactory::needRetry);
                               
  } catch (Throwable e) {/**/}
}
</code></pre>
<p>由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?</p>
<h3><strong>二、动态修改加载类</strong></h3>
<p>成本最低的方式就是直接修改这段代码，将其中&#x7684;<em>&#x6E;ew HikariDataSource(config)</em>&#x4FEE;改&#x6210;<em>&#x6E;ew P6DataSource(new HikariDataSource(config))，</em>&#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？</p>
<p>首先我们来分析一下，有哪些手段可以修改Java字节码？</p>
<ul>
<li>方案一、编译时修改，需要开发maven插件</li>
</ul>
<p>（不使用maven插件的同学咋办？）</p>
<ul>
<li>方案二、加载时修改，重写类加载器</li>
</ul>
<p>需要在代码中指定特定的类加载器，用有一定的侵入式</p>
<ul>
<li>方案三、运行时修改，使用JavaAgent</li>
</ul>
<p>需要修改应用启动参数，运维成本有点高</p>
<p>首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。</p>
<p><em>下面是对动态启动Java Agent技术的解释</em></p>
<blockquote>
<p>Note that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.</p>
</blockquote>
<blockquote>
<p>See <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description">the java.lang.instrument package documentation</a>…</p>
</blockquote>
<blockquote>
<p>Getting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. <a href="https://stackoverflow.com/a/19912148/2711488">This answer</a> demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.</p>
</blockquote>
<blockquote>
<p>However, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.</p>
</blockquote>
<blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/questions/56787777/?noredirect=1&lq=1#comment100160373_56787777">this comment</a>, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.</p>
</blockquote>
<ul>
<li>字节码工具对比</li>
</ul>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png" alt="图片"></p>
<ul>
<li>使用bytebuddy修改字节码</li>
</ul>
<p>在实现代码之前，我们回过头来再看一下快手的数据源生成：</p>
<pre><code class="language-java">new ListenableDataSource&lt;&gt;(bizName, new HikariDataSource(config), ds -&gt; i.toString());
</code></pre>
<p>这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：</p>
<pre><code class="language-java">public class DelegatingDataSource implements DataSource {
   //...
  public DelegatingDataSource(DataSource targetDataSource) {
    this.setTargetDataSource(targetDataSource);
   }

  public void setTargetDataSource(@Nullable DataSource targetDataSource) {
      this.targetDataSource = targetDataSource;
  }
  //...
}
</code></pre>
<p>因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
        this.targetDataSource = new P6DataSource(targetDataSource;
}
</code></pre>
<p>那么具体如何修改字节码呢？这里是<a href="https://bytebuddy.net/#/tutorial">官方文档</a>，原理我们不做赘述，直接介绍实现了。实现方式有三种：</p>
<h4><strong>1、类文件替换</strong></h4>
<p>假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：</p>
<pre><code class="language-java">new ByteBuddy()
  .redefine(NewDelegatingDataSource.class)
  .name(DelegatingDataSource.class.getName())
  .make()
  .load(Thread.currentThread().getContextClassLoader(), 
        ClassReloadingStrategy.fromInstalledAgent());
</code></pre>
<h4><strong>2、操作字节码：</strong></h4>
<pre><code class="language-java">new ByteBuddy()
    .redefine(DelegatingDataSource.class)
    //重写DelegatingDataSource#setTargetDataSource方法
    .method(named(&quot;setTargetDataSource&quot;))
    .intercept(MyImplementation.INSTANCE)
    .make()
    .load(Thread.currentThread().getContextClassLoader(),
          ClassReloadingStrategy.fromInstalledAgent());

enum MyImplementation implements Implementation {

INSTANCE; // singleton

  @Override
  public InstrumentedType prepare(InstrumentedType instrumentedType) {
  return instrumentedType;
  }
  
  @Override
  public ByteCodeAppender appender(Target implementationTarget) {
  return MyAppender.INSTANCE;
  }
  
}
//字节码定义
enum MyAppender implements ByteCodeAppender {

INSTANCE; // singleton

@Override
public Size apply(MethodVisitor methodVisitor,
        Implementation.Context implementationContext,
        MethodDescription instrumentedMethod) {
  Label label0 = new Label();
  methodVisitor.visitLabel(label0);
  methodVisitor.visitLineNumber(70, label0);
  methodVisitor.visitVarInsn(ALOAD, 0);
  methodVisitor.visitTypeInsn(NEW, &quot;com/p6spy/engine/spy/P6DataSource&quot;);
  methodVisitor.visitInsn(DUP);
  methodVisitor.visitVarInsn(ALOAD, 1);
  methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;com/p6spy/engine/spy/P6DataSource&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljavax/sql/DataSource;)V&quot;, false);
  methodVisitor.visitFieldInsn(PUTFIELD, &quot;org/springframework/jdbc/datasource/DelegatingDataSource&quot;, &quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;);
  Label label1 = new Label();
  methodVisitor.visitLabel(label1);
  methodVisitor.visitLineNumber(71, label1);
  methodVisitor.visitInsn(RETURN);
  Label label2 = new Label();
  methodVisitor.visitLabel(label2);
  methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;&quot;, null, label0, label2, 0);
  methodVisitor.visitLocalVariable(&quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;, null, label0, label2, 1);
  methodVisitor.visitMaxs(4, 2);
  return new Size(4, 2);
  }
}
</code></pre>
<p>上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？</p>
<p>我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9" alt="图片"></p>
<h4><strong>3、利用byte-buddy的Advice</strong></h4>
<pre><code class="language-java"> public static void redefine() {
   new ByteBuddy()
     .redefine(DelegatingDataSource.class)
     .visit(Advice.to(Decorator.class)
            .on(ElementMatchers.named(&quot;setTargetDataSource&quot;)))
     .make()
     .load(Thread.currentThread().getContextClassLoader(),
           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();
 }

static class Decorator {

  //在方法开始插入代码
  @Advice.OnMethodEnter
    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {
    dataSource = new P6DataSource(dataSource);
  }
}
</code></pre>
<p>byte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
  //插入的代码
  targetDataSource = new P6DataSource(targetDataSource);
  this.targetDataSource = targetDataSource;
}
</code></pre>
<p>注：</p>
<ol>
<li>动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。</li>
<li>使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。</li>
</ol>
<h3><strong>三、自动生效</strong></h3>
<p>前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.kuaishou.ad&lt;/groupId&gt;
  &lt;artifactId&gt;sqllog-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;制品库查询最新版&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。</p>
<pre><code class="language-java">private static String[] getConfigurations(File file) {
  @EnableAutoConfiguration
  class NoScan {
    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载
  }
  FileClassLoader classLoader = new FileClassLoader(file);
  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();
  selector.setBeanClassLoader(classLoader);
  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));
  selector.setEnvironment(new StandardEnvironment());
  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));
  return configurations;
}
</code></pre>
<h3><strong>四、SQL打印效果</strong></h3>
<p>sqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44" alt=""></p>
<p>SQL的打印内容分为三部分：</p>
<p>第一行，显示执行时间、耗时、SQL操作、数据库连接等信息</p>
<p>第二行，显示参数化SQL</p>
<p>第三行，显示绑定参数后的实际执行的SQL</p>
<p>通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-600 hover:text-gray-800" href="/about/">关于</a><a class="text-gray-600 hover:text-gray-800" href="/blog/">博客</a><a class="text-gray-600 hover:text-gray-800" href="/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-600">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-51baccc14cf1da9e.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n5:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[59665,[],\"MetadataBoundary\"]\n10:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/0458d6941a120cde.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"8CSEQRRrJyhjI8sSOwcIy\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"middleware\",\"%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/middleware/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0458d6941a120cde.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-600\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/middleware/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"W0v1Sa9J8VG7x4-PHg2Ukv\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[74911,[],\"AsyncMetadata\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n19:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n15:T4fc0,"])</script><script>self.__next_f.push([1,"\u003cp\u003e你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。\u003c/p\u003e\n\u003cp\u003e另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) \nand name in(sql\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缩略下印如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004,...) \nand name in(\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,...)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -\u0026gt; ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver -\u0026gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从\u003cstrong\u003eDataSource  -\u0026gt; Connection -\u0026gt; Driver\u003c/strong\u003e三个环节进行入手：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e一、SQL Profile监控\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1、驱动层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\u0026amp;logger=Slf4JLogger\u0026amp;profileSQL=true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2、连接层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如\u003ca href=\"https://p6spy.readthedocs.io/en/latest/\"\u003eP6Spy\u003c/a\u003e、\u003ca href=\"https://github.com/arthurblake/log4jdbc\"\u003elog4jdbc\u003c/a\u003e 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epyspy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:p6spy:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3、数据源层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e可以通过对DataSource进行代理实现SQL监控\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eP6Spy：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Bean\n@Primary\npublic DataSource spyDataSource(@Autowired DataSource dataSource) {\n  // wrap a datasource using P6SpyDataSource\n  return new P6DataSource(dataSource);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic DataSource spyDataSource(DataSource dataSource) {\n    // wrap the provided dataSource\n  return new DataSource() {\n    @Override\n    public Connection getConnection() throws SQLException {\n      // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection());\n    }\n      \n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n       // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection(username, password));\n     }\n      //...\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。\u003c/p\u003e\n\u003cp\u003e第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。\u003c/p\u003e\n\u003cp\u003e第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。\u003c/p\u003e\n\u003cp\u003e排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface DataSourceConfig extends HasBizDef {\n\n    /**\n     * 数据源名称，必须与KDB申请时填写的一致\n     */String bizName();\n\n    /**\n     * 获取当前可用区单库只读的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate read() {\n        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), \u0026quot;read\u0026quot;);\n    }   \n\n    /**\n     * 获取当前可用区单库读写的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate write() {\n        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), \u0026quot;write\u0026quot;);\n    }\t\n  //....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eenum class AdDataSources(\n    private val bizDef: BizDef,\n    private val forTest: AdDataSources? = null,\n    private val usingNewZk: Boolean = false\n) : DataSourceConfig{\n    adFansTopProfileDashboardTest,\n    adFansTopProfileDashboard,\n    adChargeTest,\n    adCharge,\n    adChargeReadOnly,\n    adDspReadOnlyTest,\n    adDspReadOnly;\n    public open fun bizName(): String {\n        return bizDef.bizName\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？\u003c/p\u003e\n\u003cp\u003e具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static ListenableDataSource\u0026lt;Failover\u0026lt;Instance\u0026gt;\u0026gt; create(Instance i) {\n   //...\n   try {\n       return supplyWithRetry(\n        DATA_SOURCE_BUILD_RETRY,\n        DATA_SOURCE_BUILD_RETRY_DELAY,\n        () -\u0026gt; new ListenableDataSource\u0026lt;\u0026gt;(\n              bizName, \n              new HikariDataSource(config), ds -\u0026gt; i.toString(), i),\n              DataSourceFactory::needRetry);\n                               \n  } catch (Throwable e) {/**/}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e二、动态修改加载类\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e成本最低的方式就是直接修改这段代码，将其中\u0026#x7684;\u003cem\u003e\u0026#x6E;ew HikariDataSource(config)\u003c/em\u003e\u0026#x4FEE;改\u0026#x6210;\u003cem\u003e\u0026#x6E;ew P6DataSource(new HikariDataSource(config))，\u003c/em\u003e\u0026#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？\u003c/p\u003e\n\u003cp\u003e首先我们来分析一下，有哪些手段可以修改Java字节码？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案一、编译时修改，需要开发maven插件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（不使用maven插件的同学咋办？）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案二、加载时修改，重写类加载器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要在代码中指定特定的类加载器，用有一定的侵入式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案三、运行时修改，使用JavaAgent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要修改应用启动参数，运维成本有点高\u003c/p\u003e\n\u003cp\u003e首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下面是对动态启动Java Agent技术的解释\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSee \u003ca href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description\"\u003ethe java.lang.instrument package documentation\u003c/a\u003e…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGetting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. \u003ca href=\"https://stackoverflow.com/a/19912148/2711488\"\u003eThis answer\u003c/a\u003e demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAs mentioned in \u003ca href=\"https://stackoverflow.com/questions/56787777/?noredirect=1\u0026lq=1#comment100160373_56787777\"\u003ethis comment\u003c/a\u003e, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e字节码工具对比\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用bytebuddy修改字节码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在实现代码之前，我们回过头来再看一下快手的数据源生成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ListenableDataSource\u0026lt;\u0026gt;(bizName, new HikariDataSource(config), ds -\u0026gt; i.toString());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DelegatingDataSource implements DataSource {\n   //...\n  public DelegatingDataSource(DataSource targetDataSource) {\n    this.setTargetDataSource(targetDataSource);\n   }\n\n  public void setTargetDataSource(@Nullable DataSource targetDataSource) {\n      this.targetDataSource = targetDataSource;\n  }\n  //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n        this.targetDataSource = new P6DataSource(targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么具体如何修改字节码呢？这里是\u003ca href=\"https://bytebuddy.net/#/tutorial\"\u003e官方文档\u003c/a\u003e，原理我们不做赘述，直接介绍实现了。实现方式有三种：\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1、类文件替换\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n  .redefine(NewDelegatingDataSource.class)\n  .name(DelegatingDataSource.class.getName())\n  .make()\n  .load(Thread.currentThread().getContextClassLoader(), \n        ClassReloadingStrategy.fromInstalledAgent());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2、操作字节码：\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .redefine(DelegatingDataSource.class)\n    //重写DelegatingDataSource#setTargetDataSource方法\n    .method(named(\u0026quot;setTargetDataSource\u0026quot;))\n    .intercept(MyImplementation.INSTANCE)\n    .make()\n    .load(Thread.currentThread().getContextClassLoader(),\n          ClassReloadingStrategy.fromInstalledAgent());\n\nenum MyImplementation implements Implementation {\n\nINSTANCE; // singleton\n\n  @Override\n  public InstrumentedType prepare(InstrumentedType instrumentedType) {\n  return instrumentedType;\n  }\n  \n  @Override\n  public ByteCodeAppender appender(Target implementationTarget) {\n  return MyAppender.INSTANCE;\n  }\n  \n}\n//字节码定义\nenum MyAppender implements ByteCodeAppender {\n\nINSTANCE; // singleton\n\n@Override\npublic Size apply(MethodVisitor methodVisitor,\n        Implementation.Context implementationContext,\n        MethodDescription instrumentedMethod) {\n  Label label0 = new Label();\n  methodVisitor.visitLabel(label0);\n  methodVisitor.visitLineNumber(70, label0);\n  methodVisitor.visitVarInsn(ALOAD, 0);\n  methodVisitor.visitTypeInsn(NEW, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;);\n  methodVisitor.visitInsn(DUP);\n  methodVisitor.visitVarInsn(ALOAD, 1);\n  methodVisitor.visitMethodInsn(INVOKESPECIAL, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;, \u0026quot;\u0026lt;init\u0026gt;\u0026quot;, \u0026quot;(Ljavax/sql/DataSource;)V\u0026quot;, false);\n  methodVisitor.visitFieldInsn(PUTFIELD, \u0026quot;org/springframework/jdbc/datasource/DelegatingDataSource\u0026quot;, \u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;);\n  Label label1 = new Label();\n  methodVisitor.visitLabel(label1);\n  methodVisitor.visitLineNumber(71, label1);\n  methodVisitor.visitInsn(RETURN);\n  Label label2 = new Label();\n  methodVisitor.visitLabel(label2);\n  methodVisitor.visitLocalVariable(\u0026quot;this\u0026quot;, \u0026quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;\u0026quot;, null, label0, label2, 0);\n  methodVisitor.visitLocalVariable(\u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;, null, label0, label2, 1);\n  methodVisitor.visitMaxs(4, 2);\n  return new Size(4, 2);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？\u003c/p\u003e\n\u003cp\u003e我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e3、利用byte-buddy的Advice\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public static void redefine() {\n   new ByteBuddy()\n     .redefine(DelegatingDataSource.class)\n     .visit(Advice.to(Decorator.class)\n            .on(ElementMatchers.named(\u0026quot;setTargetDataSource\u0026quot;)))\n     .make()\n     .load(Thread.currentThread().getContextClassLoader(),\n           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();\n }\n\nstatic class Decorator {\n\n  //在方法开始插入代码\n  @Advice.OnMethodEnter\n    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {\n    dataSource = new P6DataSource(dataSource);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebyte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n  //插入的代码\n  targetDataSource = new P6DataSource(targetDataSource);\n  this.targetDataSource = targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。\u003c/li\u003e\n\u003cli\u003e使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e三、自动生效\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;dependency\u0026gt;\n  \u0026lt;groupId\u0026gt;com.kuaishou.ad\u0026lt;/groupId\u0026gt;\n  \u0026lt;artifactId\u0026gt;sqllog-spring-boot-starter\u0026lt;/artifactId\u0026gt;\n  \u0026lt;version\u0026gt;制品库查询最新版\u0026lt;/version\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static String[] getConfigurations(File file) {\n  @EnableAutoConfiguration\n  class NoScan {\n    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载\n  }\n  FileClassLoader classLoader = new FileClassLoader(file);\n  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();\n  selector.setBeanClassLoader(classLoader);\n  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));\n  selector.setEnvironment(new StandardEnvironment());\n  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));\n  return configurations;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e四、SQL打印效果\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003esqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eSQL的打印内容分为三部分：\u003c/p\u003e\n\u003cp\u003e第一行，显示执行时间、耗时、SQL操作、数据库连接等信息\u003c/p\u003e\n\u003cp\u003e第二行，显示参数化SQL\u003c/p\u003e\n\u003cp\u003e第三行，显示绑定参数后的实际执行的SQL\u003c/p\u003e\n\u003cp\u003e通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T59f6,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eGit 常用命令速查手册\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文按使用场景组织，覆盖日常开发中最常用的 Git 操作。每条命令附带简要说明，部分附有使用示例。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e1. 配置\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看当前配置\ngit config --list\n\n# 设置用户信息（全局）\ngit config --global user.name \u0026quot;Your Name\u0026quot;\ngit config --global user.email \u0026quot;your@email.com\u0026quot;\n\n# 仅对当前仓库设置（去掉 --global）\ngit config user.name \u0026quot;Your Name\u0026quot;\n\n# 设置默认编辑器\ngit config --global core.editor \u0026quot;vim\u0026quot;\n\n# 设置默认分支名\ngit config --global init.defaultBranch main\n\n# 配置命令别名\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.st status\ngit config --global alias.lg \u0026quot;log --oneline --graph --all\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 仓库初始化与克隆\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 初始化新仓库\ngit init\n\n# 克隆远程仓库\ngit clone \u0026lt;url\u0026gt;\n\n# 克隆指定分支\ngit clone -b \u0026lt;branch\u0026gt; \u0026lt;url\u0026gt;\n\n# 浅克隆（只拉最近 1 次提交，适合大仓库）\ngit clone --depth 1 \u0026lt;url\u0026gt;\n\n# 克隆并指定本地目录名\ngit clone \u0026lt;url\u0026gt; my-project\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 文件追踪与暂存\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看工作区状态\ngit status\n\n# 简洁模式\ngit status -s\n\n# 添加文件到暂存区\ngit add \u0026lt;file\u0026gt;\ngit add .                    # 当前目录所有变更\ngit add -A                   # 整个仓库所有变更\ngit add -p                   # 交互式选择要暂存的代码块\n\n# 取消暂存（保留工作区修改）\ngit restore --staged \u0026lt;file\u0026gt;\ngit reset HEAD \u0026lt;file\u0026gt;        # 旧写法，效果相同\n\n# 丢弃工作区修改（危险操作，不可恢复）\ngit restore \u0026lt;file\u0026gt;\ngit checkout -- \u0026lt;file\u0026gt;       # 旧写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e取消跟踪已版本控制的文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 不再追踪文件改动（文件保留在仓库中，但本地修改不再显示为 dirty）\ngit update-index --assume-unchanged \u0026lt;filePath\u0026gt;\n\n# 恢复追踪\ngit update-index --no-assume-unchanged \u0026lt;filePath\u0026gt;\n\n# 查看所有被 assume-unchanged 的文件\ngit ls-files -v | grep \u0026#39;^h\u0026#39;\n\n# 从版本控制中删除文件（但保留本地文件）\ngit rm --cached \u0026lt;filePath\u0026gt;\n\n# 从版本控制中删除文件夹\ngit rm -r -f --cached \u0026lt;dirPath\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e--assume-unchanged\u003c/code\u003e vs \u003ccode\u003e--skip-worktree\u003c/code\u003e\u003c/strong\u003e：两者都能让 Git 忽略本地修改，但语义不同。\u003ccode\u003e--assume-unchanged\u003c/code\u003e 是性能优化提示（告诉 Git \u0026quot;这个文件不会变\u0026quot;），\u003ccode\u003e--skip-worktree\u003c/code\u003e 是明确的意图声明（\u0026quot;我故意修改了这个文件，但不想提交\u0026quot;）。对于本地配置文件的修改，推荐使用 \u003ccode\u003e--skip-worktree\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit update-index --skip-worktree \u0026lt;filePath\u0026gt;\ngit update-index --no-skip-worktree \u0026lt;filePath\u0026gt;\ngit ls-files -v | grep \u0026#39;^S\u0026#39;    # 查看所有 skip-worktree 文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e4. 提交\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 提交暂存区内容\ngit commit -m \u0026quot;commit message\u0026quot;\n\n# 添加并提交所有已跟踪文件的修改（不含新文件）\ngit commit -am \u0026quot;commit message\u0026quot;\n\n# 修改最近一次提交的信息（未推送到远程时使用）\ngit commit --amend -m \u0026quot;new message\u0026quot;\n\n# 修改最近一次提交，追加文件但不改消息\ngit commit --amend --no-edit\n\n# 创建空提交（可用于触发 CI）\ngit commit --allow-empty -m \u0026quot;trigger build\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e5. 分支管理\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看本地分支\ngit branch\n\n# 查看所有分支（含远程）\ngit branch -a\n\n# 查看分支及最后一次提交\ngit branch -v\n\n# 创建分支\ngit branch \u0026lt;name\u0026gt;\n\n# 创建并切换\ngit checkout -b \u0026lt;name\u0026gt;\ngit switch -c \u0026lt;name\u0026gt;         # 推荐新写法\n\n# 切换分支\ngit checkout \u0026lt;name\u0026gt;\ngit switch \u0026lt;name\u0026gt;            # 推荐新写法\n\n# 重命名当前分支\ngit branch -m \u0026lt;new-name\u0026gt;\n\n# 删除本地分支（已合并）\ngit branch -d \u0026lt;name\u0026gt;\n\n# 强制删除本地分支（未合并也删）\ngit branch -D \u0026lt;name\u0026gt;\n\n# 删除远程分支\ngit push origin --delete \u0026lt;name\u0026gt;\n\n# 查看已合并到当前分支的分支\ngit branch --merged\n\n# 查看未合并到当前分支的分支\ngit branch --no-merged\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e6. 合并与变基\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 合并指定分支到当前分支\ngit merge \u0026lt;branch\u0026gt;\n\n# 合并时不使用 fast-forward（保留合并提交记录）\ngit merge --no-ff \u0026lt;branch\u0026gt;\n\n# 只生成一个合并提交（压缩对方所有提交）\ngit merge --squash \u0026lt;branch\u0026gt;\n\n# 变基（将当前分支的提交移到目标分支的最新提交之后）\ngit rebase \u0026lt;branch\u0026gt;\n\n# 交互式变基（修改/合并/删除/排序最近 N 次提交）\ngit rebase -i HEAD~N\n\n# 变基冲突后继续 / 跳过 / 终止\ngit rebase --continue\ngit rebase --skip\ngit rebase --abort\n\n# 合并冲突后终止合并\ngit merge --abort\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCherry-pick\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 将某个提交应用到当前分支\ngit cherry-pick \u0026lt;commit-hash\u0026gt;\n\n# 连续多个提交\ngit cherry-pick \u0026lt;hash1\u0026gt; \u0026lt;hash2\u0026gt;\n\n# 只暂存不提交\ngit cherry-pick \u0026lt;hash\u0026gt; --no-commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e7. 远程协作\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看远程仓库\ngit remote -v\n\n# 添加远程仓库\ngit remote add origin \u0026lt;url\u0026gt;\n\n# 修改远程仓库地址\ngit remote set-url origin \u0026lt;new-url\u0026gt;\n\n# 拉取远程更新（不合并）\ngit fetch\ngit fetch --all              # 拉取所有远程\ngit fetch --prune            # 同时清理已删除的远程分支引用\n\n# 拉取并合并（= fetch + merge）\ngit pull\n\n# 拉取并变基（= fetch + rebase，保持线性历史）\ngit pull --rebase\n\n# 推送\ngit push\ngit push origin \u0026lt;branch\u0026gt;\n\n# 首次推送并建立追踪关系\ngit push -u origin \u0026lt;branch\u0026gt;\n\n# 强制推送（覆盖远程历史，团队协作慎用）\ngit push --force\n\n# 安全的强制推送（远程有新提交时会拒绝）\ngit push --force-with-lease\n\n# 推送所有分支\ngit push --all\n\n# 推送所有标签\ngit push --tags\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 暂存工作区（Stash）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 暂存当前工作区和暂存区的修改\ngit stash\n\n# 带描述信息\ngit stash save \u0026quot;work in progress: feature X\u0026quot;\ngit stash push -m \u0026quot;description\u0026quot;   # 推荐新写法\n\n# 暂存时包含未跟踪的文件\ngit stash -u\n\n# 暂存时包含所有文件（含 .gitignore 忽略的）\ngit stash -a\n\n# 查看 stash 列表\ngit stash list\n\n# 恢复最近的 stash（保留 stash 记录）\ngit stash apply\n\n# 恢复并删除最近的 stash\ngit stash pop\n\n# 恢复指定的 stash\ngit stash apply stash@{2}\n\n# 删除指定 stash\ngit stash drop stash@{0}\n\n# 清空所有 stash\ngit stash clear\n\n# 查看某个 stash 的内容\ngit stash show -p stash@{0}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e9. 日志与差异\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看提交日志\ngit log\n\n# 简洁单行显示\ngit log --oneline\n\n# 图形化显示分支合并历史\ngit log --oneline --graph --all\n\n# 显示每次提交的文件变更统计\ngit log --stat\n\n# 显示每次提交的具体修改\ngit log -p\n\n# 最近 N 次提交\ngit log -n 5\n\n# 按作者过滤\ngit log --author=\u0026quot;name\u0026quot;\n\n# 按时间范围过滤\ngit log --since=\u0026quot;2024-01-01\u0026quot; --until=\u0026quot;2024-06-30\u0026quot;\n\n# 按提交信息关键字搜索\ngit log --grep=\u0026quot;fix bug\u0026quot;\n\n# 搜索某段代码的变更历史\ngit log -S \u0026quot;functionName\u0026quot;\n\n# 查看某个文件的提交历史\ngit log -- \u0026lt;file\u0026gt;\ngit log --follow -- \u0026lt;file\u0026gt;   # 包含重命名前的历史\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e差异对比\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 工作区 vs 暂存区\ngit diff\n\n# 暂存区 vs 最新提交\ngit diff --staged\ngit diff --cached            # 同义\n\n# 两个分支之间的差异\ngit diff \u0026lt;branch1\u0026gt;..\u0026lt;branch2\u0026gt;\n\n# 两个提交之间的差异\ngit diff \u0026lt;commit1\u0026gt;..\u0026lt;commit2\u0026gt;\n\n# 只看文件名列表\ngit diff --name-only\n\n# 查看文件改动统计\ngit diff --stat\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e10. 撤销与回退\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 撤销工作区修改（未暂存）\ngit restore \u0026lt;file\u0026gt;\n\n# 撤销暂存（保留工作区修改）\ngit restore --staged \u0026lt;file\u0026gt;\n\n# 回退到某个提交（保留修改在工作区）\ngit reset --soft \u0026lt;commit\u0026gt;\n\n# 回退到某个提交（保留修改在暂存区）\ngit reset --mixed \u0026lt;commit\u0026gt;     # 默认模式\n\n# 回退到某个提交（丢弃所有修改，危险操作）\ngit reset --hard \u0026lt;commit\u0026gt;\n\n# 回退最近 N 次提交\ngit reset --soft HEAD~N\n\n# 创建一个新提交来撤销指定提交（安全的回退方式，不改写历史）\ngit revert \u0026lt;commit\u0026gt;\n\n# 撤销多个连续提交\ngit revert \u0026lt;older-commit\u0026gt;..\u0026lt;newer-commit\u0026gt;\n\n# 只修改工作区不自动提交\ngit revert --no-commit \u0026lt;commit\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ereset\u003c/code\u003e vs \u003ccode\u003erevert\u003c/code\u003e\u003c/strong\u003e：\u003ccode\u003ereset\u003c/code\u003e 改写提交历史（适合未推送的本地提交），\u003ccode\u003erevert\u003c/code\u003e 创建新提交来撤销（适合已推送的公共分支）。在多人协作的分支上，永远优先使用 \u003ccode\u003erevert\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e11. 标签\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看所有标签\ngit tag\n\n# 按模式过滤\ngit tag -l \u0026quot;v1.*\u0026quot;\n\n# 创建轻量标签\ngit tag \u0026lt;tag-name\u0026gt;\n\n# 创建附注标签（推荐）\ngit tag -a \u0026lt;tag-name\u0026gt; -m \u0026quot;description\u0026quot;\n\n# 给历史提交打标签\ngit tag -a \u0026lt;tag-name\u0026gt; \u0026lt;commit-hash\u0026gt;\n\n# 查看标签详情\ngit show \u0026lt;tag-name\u0026gt;\n\n# 推送单个标签到远程\ngit push origin \u0026lt;tag-name\u0026gt;\n\n# 推送所有标签\ngit push origin --tags\n\n# 删除本地标签\ngit tag -d \u0026lt;tag-name\u0026gt;\n\n# 删除远程标签\ngit push origin --delete \u0026lt;tag-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e12. 子模块\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 添加子模块\ngit submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt;\n\n# 克隆含子模块的仓库\ngit clone --recurse-submodules \u0026lt;url\u0026gt;\n\n# 已克隆后初始化子模块\ngit submodule init\ngit submodule update\n\n# 一步到位\ngit submodule update --init --recursive\n\n# 更新所有子模块到最新\ngit submodule update --remote\n\n# 删除子模块\ngit submodule deinit \u0026lt;path\u0026gt;\ngit rm \u0026lt;path\u0026gt;\nrm -rf .git/modules/\u0026lt;path\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e13. Worktree（多工作目录）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 为指定分支创建一个独立的工作目录（无需 stash 即可同时处理多个分支）\ngit worktree add \u0026lt;path\u0026gt; \u0026lt;branch\u0026gt;\n\n# 创建新分支并建立 worktree\ngit worktree add -b \u0026lt;new-branch\u0026gt; \u0026lt;path\u0026gt;\n\n# 查看所有 worktree\ngit worktree list\n\n# 删除 worktree\ngit worktree remove \u0026lt;path\u0026gt;\n\n# 清理无效的 worktree 引用\ngit worktree prune\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e14. 查找与定位\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查找引入 bug 的提交（二分法）\ngit bisect start\ngit bisect bad                # 当前版本有 bug\ngit bisect good \u0026lt;commit\u0026gt;      # 某个已知正常的版本\n# Git 自动切换到中间版本，测试后标记 good/bad，直到定位到具体提交\ngit bisect reset              # 结束 bisect\n\n# 查看某行代码的最后修改人和提交\ngit blame \u0026lt;file\u0026gt;\ngit blame -L 10,20 \u0026lt;file\u0026gt;    # 只看第 10-20 行\n\n# 在所有提交中搜索内容\ngit grep \u0026quot;pattern\u0026quot;\ngit grep \u0026quot;pattern\u0026quot; \u0026lt;branch\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e15. 清理\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 预览将被清理的未跟踪文件\ngit clean -n\n\n# 删除未跟踪的文件\ngit clean -f\n\n# 删除未跟踪的文件和目录\ngit clean -fd\n\n# 删除未跟踪的文件（含 .gitignore 忽略的文件）\ngit clean -fdx\n\n# 垃圾回收（压缩历史，清理悬空对象）\ngit gc\n\n# 清理远程已删除的分支引用\ngit remote prune origin\ngit fetch --prune             # 等价\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e16. 常见场景速查\u003c/h2\u003e\n\u003ch3\u003e撤销最近一次提交但保留代码\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit reset --soft HEAD~1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e合并多次提交为一个\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit rebase -i HEAD~3\n# 编辑器中将后两个 pick 改为 squash (或 s)，保存退出\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e从其他分支拿一个文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit checkout \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt;\ngit restore --source \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt;   # 推荐新写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e找回误删的分支或提交\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看所有引用变更记录（包括已删除的）\ngit reflog\n\n# 基于 reflog 中的哈希恢复\ngit checkout -b recovered-branch \u0026lt;hash\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e修改历史提交的作者信息\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit rebase -i \u0026lt;commit\u0026gt;^\n# 将目标提交标记为 edit，保存退出\ngit commit --amend --author=\u0026quot;Name \u0026lt;email\u0026gt;\u0026quot; --no-edit\ngit rebase --continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e统计代码贡献\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 按作者统计提交数\ngit shortlog -sn\n\n# 统计某人的代码行数增删\ngit log --author=\u0026quot;name\u0026quot; --numstat --pretty=\u0026quot;%H\u0026quot; | awk \u0026#39;NF==3 {add+=$1; del+=$2} END {print \u0026quot;+\u0026quot;add, \u0026quot;-\u0026quot;del}\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e临时切到其他分支修 bug，不想 stash\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 用 worktree 在另一个目录打开 hotfix 分支，互不干扰\ngit worktree add ../hotfix-dir hotfix/issue-123\n\n# 修完后删除\ngit worktree remove ../hotfix-dir\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e只克隆仓库的某个子目录（Sparse Checkout）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone --filter=blob:none --sparse \u0026lt;url\u0026gt;\ncd \u0026lt;repo\u0026gt;\ngit sparse-checkout set path/to/subdir\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e把未提交的修改生成补丁发给别人\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 生成补丁文件\ngit diff \u0026gt; my-changes.patch\n\n# 对方应用补丁\ngit apply my-changes.patch\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e把已提交的 commit 生成补丁\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 生成最近 3 次提交的补丁文件（每个提交一个 .patch 文件）\ngit format-patch -3\n\n# 对方应用\ngit am *.patch\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e17. .gitignore\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# .gitignore 文件常用模式\n\n# 忽略所有 .log 文件\n*.log\n\n# 但保留 important.log\n!important.log\n\n# 忽略根目录下的 build 文件夹（不影响子目录中的 build）\n/build/\n\n# 忽略所有目录下的 node_modules\nnode_modules/\n\n# 忽略所有 .env 文件（防止泄露密钥）\n.env\n.env.*\n\n# 忽略 IDE 配置\n.idea/\n.vscode/\n*.swp\n*.swo\n*~\n\n# 忽略操作系统文件\n.DS_Store\nThumbs.db\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# .gitignore 已经添加规则，但文件之前已被跟踪？需要先从缓存中移除\ngit rm --cached \u0026lt;file\u0026gt;\ngit commit -m \u0026quot;stop tracking \u0026lt;file\u0026gt;\u0026quot;\n\n# 检查某个文件为什么被忽略\ngit check-ignore -v \u0026lt;file\u0026gt;\n\n# 列出所有被忽略的文件\ngit status --ignored\n\n# 全局 gitignore（对所有仓库生效）\ngit config --global core.excludesfile ~/.gitignore_global\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e18. Git Hooks\u003c/h2\u003e\n\u003cp\u003eGit Hooks 是在特定事件（提交、推送等）发生时自动执行的脚本，存放在 \u003ccode\u003e.git/hooks/\u003c/code\u003e 目录下。\u003c/p\u003e\n\u003ch3\u003e常用 Hook 类型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eHook\u003c/th\u003e\n\u003cth\u003e触发时机\u003c/th\u003e\n\u003cth\u003e典型用途\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-commit\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit commit\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e代码格式检查、lint、单元测试\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecommit-msg\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e提交信息写入后\u003c/td\u003e\n\u003ctd\u003e校验 commit message 格式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-push\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit push\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e运行测试、阻止推送到 main\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epost-merge\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit merge\u003c/code\u003e 完成后\u003c/td\u003e\n\u003ctd\u003e自动安装依赖\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-rebase\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit rebase\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e阻止对公共分支变基\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epost-checkout\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit checkout\u003c/code\u003e 完成后\u003c/td\u003e\n\u003ctd\u003e环境初始化\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e示例：pre-commit 检查是否有 console.log\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/sh\n# .git/hooks/pre-commit\n\nif git diff --cached --name-only | grep -E \u0026#39;\\.(js|ts|tsx)$\u0026#39; | xargs grep -l \u0026#39;console\\.log\u0026#39; 2\u0026gt;/dev/null; then\n    echo \u0026quot;Error: console.log found in staged files\u0026quot;\n    exit 1\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e使用 Husky 管理 Hooks（推荐）\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e.git/hooks/\u003c/code\u003e 不会被提交到仓库，团队共享不方便。\u003ca href=\"https://typicode.github.io/husky/\"\u003eHusky\u003c/a\u003e 解决了这个问题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装\nnpm install husky -D\nnpx husky init\n\n# 添加 pre-commit hook\necho \u0026quot;npm run lint\u0026quot; \u0026gt; .husky/pre-commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e19. Git LFS（大文件存储）\u003c/h2\u003e\n\u003cp\u003eGit 不擅长处理大文件（二进制、模型文件、设计稿等），Git LFS 用指针文件替代大文件，实际内容存储在单独的 LFS 服务器上。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装（macOS）\nbrew install git-lfs\n\n# 在仓库中启用\ngit lfs install\n\n# 追踪特定类型的大文件\ngit lfs track \u0026quot;*.psd\u0026quot;\ngit lfs track \u0026quot;*.zip\u0026quot;\ngit lfs track \u0026quot;models/**\u0026quot;\n\n# 追踪规则保存在 .gitattributes 中，需要提交\ngit add .gitattributes\ngit commit -m \u0026quot;track large files with LFS\u0026quot;\n\n# 后续正常 add/commit/push，LFS 文件会自动走 LFS 通道\ngit add large-file.psd\ngit commit -m \u0026quot;add design file\u0026quot;\ngit push\n\n# 查看当前 LFS 追踪的文件模式\ngit lfs track\n\n# 查看 LFS 管理的文件列表\ngit lfs ls-files\n\n# 拉取所有 LFS 文件（克隆后可能需要）\ngit lfs pull\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e20. Git Archive（导出代码）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 导出当前 HEAD 为 zip\ngit archive --format=zip HEAD -o project.zip\n\n# 导出指定分支\ngit archive --format=tar.gz release/v1.0 -o release-v1.0.tar.gz\n\n# 只导出某个子目录\ngit archive HEAD --prefix=src/ -- src/ -o src-only.zip\n\n# 导出两个版本之间的差异文件\ngit diff --name-only v1.0 v2.0 | xargs git archive HEAD -o diff-files.zip --\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e21. 交互式变基详解\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003egit rebase -i\u003c/code\u003e 是最强大的提交历史编辑工具，编辑器中每行一个提交，支持以下操作：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003cth\u003e缩写\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epick\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留该提交（默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ereword\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003er\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留提交但修改提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eedit\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ee\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e暂停在该提交，允许修改内容\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003esquash\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003es\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并到上一个提交，合并提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003efixup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ef\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并到上一个提交，丢弃本条提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003edrop\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ed\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e删除该提交\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e典型场景\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 合并最近 4 次提交为 1 个\ngit rebase -i HEAD~4\n# 编辑器中：第一个保持 pick，其余改为 squash 或 fixup\n\n# 调整提交顺序：直接在编辑器中拖动行的位置\n\n# 拆分一个提交为多个\ngit rebase -i HEAD~3\n# 将目标提交标记为 edit，保存退出\ngit reset HEAD~1              # 撤回提交但保留文件修改\ngit add file1 \u0026amp;\u0026amp; git commit -m \u0026quot;part 1\u0026quot;\ngit add file2 \u0026amp;\u0026amp; git commit -m \u0026quot;part 2\u0026quot;\ngit rebase --continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e22. 签名与验证\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 配置 GPG 签名\ngit config --global user.signingkey \u0026lt;GPG-KEY-ID\u0026gt;\ngit config --global commit.gpgsign true    # 默认对所有提交签名\n\n# 签名提交\ngit commit -S -m \u0026quot;signed commit\u0026quot;\n\n# 签名标签\ngit tag -s v1.0 -m \u0026quot;signed release\u0026quot;\n\n# 验证提交签名\ngit log --show-signature\n\n# 验证标签签名\ngit tag -v v1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e23. 高级配置技巧\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 自动纠正拼写错误的命令（如 git stauts → git status）\ngit config --global help.autocorrect 10   # 1 秒后自动执行\n\n# 启用 rerere（记住冲突解决方式，下次自动应用）\ngit config --global rerere.enabled true\n\n# diff 时使用更好的算法（对函数移动更友好）\ngit config --global diff.algorithm histogram\n\n# 全局忽略文件权限变更（在 macOS/Windows 上避免无意义的 diff）\ngit config --global core.fileMode false\n\n# 设置 pull 默认使用 rebase（保持线性历史）\ngit config --global pull.rebase true\n\n# 推送时自动设置上游分支\ngit config --global push.autoSetupRemote true\n\n# 多行 commit message 使用 heredoc\ngit commit -m \u0026quot;$(cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39;\nfeat: add user authentication\n\n- Add JWT token generation\n- Add login/logout endpoints\n- Add middleware for protected routes\nEOF\n)\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e24. 速查表\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e想做什么\u003c/th\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e查看状态\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit status\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e添加所有修改\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit add -A\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit commit -m \u0026quot;msg\u0026quot;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e拉取 + 变基\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit pull --rebase\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e推送\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit push\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e新建分支并切换\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit switch -c feat/xxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e合并分支\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit merge --no-ff feat/xxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e暂存工作区\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit stash -u\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e恢复暂存\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit stash pop\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e查看简洁日志\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit log --oneline --graph\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e撤销最近提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit reset --soft HEAD~1\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全回退已推送的提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit revert \u0026lt;hash\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e找回误删内容\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit reflog\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e查看某行代码作者\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit blame \u0026lt;file\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e二分法查 bug\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit bisect start\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e只拿某个提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit cherry-pick \u0026lt;hash\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e导出代码压缩包\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit archive HEAD -o out.zip\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n"])</script><script>self.__next_f.push([1,"18:T214d,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e一、AI 正在发生什么：从“更大”到“更能干”\u003c/h2\u003e\n\u003ch3\u003e1）大模型走向“世界建模”\u003c/h3\u003e\n\u003cp\u003e以 GPT 系列、Claude、Gemini、通义等为代表的通用模型，已从语言理解扩展到视觉、语音、视频与动作控制，形成“多模态 +\u003cbr\u003e代理（agentic）”的新范式。斯坦福 HAI《AI Index 2025》指出：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e性能跃升\u003c/strong\u003e：2024 年模型在复杂推理与编程任务中的表现较 2023 年提升 50% 以上；SWE-bench 可解比例从 4.4% 提升至 71.7%。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开源追平\u003c/strong\u003e：开源与闭源模型性能差距从 8% 缩小至 2%，AI 正从“巨头独占”走向“开源共享”。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e成本坍缩\u003c/strong\u003e：达到 GPT-3.5 水平的模型推理成本两年下降 280 倍。AI 的使用门槛正被迅速拉低。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2）科学计算的“AI 第一性”\u003c/h3\u003e\n\u003cp\u003eAlphaFold3、DeepMind 的 GNoME 以及 Earth-2 等项目，标志着 AI 已进入科学研究核心环节。AI\u003cbr\u003e不再仅仅识别模式，而是参与规律发现。生物学、气候模拟、材料科学正经历“生成—推理—验证”范式革命。\u003c/p\u003e\n\u003ch3\u003e3）从“工具”到“基础设施”\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e投资规模\u003c/strong\u003e：2024 年全球 AI 私营投资超 1000 亿美元，其中生成式 AI 占比 30%。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e使用扩散\u003c/strong\u003e：企业采用 AI 的比例已达 78%，其中 65% 经常性使用生成式 AI。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e现实落地\u003c/strong\u003e：Waymo 每周执行 15 万次无人驾驶任务，AI 已成为社会运行基础的一部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e二、为什么重要：效率红利、产业结构与科学范式\u003c/h2\u003e\n\u003ch3\u003e1）效率红利：从“人效提升”到“组织再造”\u003c/h3\u003e\n\u003cp\u003e多项研究显示生成式 AI 对知识工作者生产率提升 15%–40%。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客服实验表明，新手员工在 AI 辅助下解决率提升 35%。\u003c/li\u003e\n\u003cli\u003e开发者使用代码助手后任务完成速度提升 25%。\u003cbr\u003e这种提升不仅体现在个体效率，更在于组织结构的重塑：未来企业将从“分工协作”进化为“人机协作”。AI 成为企业内部“第二大脑”，承担分析、生成与验证任务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2）产业结构：从“软件吞噬世界”到“智能重写行业”\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e医疗\u003c/strong\u003e：AI 影像识别准确率已超专家平均水平；药物研发周期可缩短 40%。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e制造\u003c/strong\u003e：AI 驱动的质量检测与预测性维护提升生产良率 15%。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e金融\u003c/strong\u003e：AI 在风险建模与客服中广泛部署，节省运营成本 30%。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e交通\u003c/strong\u003e：智能调度与自动驾驶结合，城市拥堵时间下降 20%。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAI 不再是“应用层创新”，而是推动整个产业链价值重新分配的“中枢技术”。\u003c/p\u003e\n\u003ch3\u003e3）科学范式：AI 成为“假设生成器”\u003c/h3\u003e\n\u003cp\u003e过去的科研范式是“假设—实验—验证”，AI 让科学进入“生成—推理—验证”阶段。它能从数据中发现潜在规律，提前模拟实验结果，再由人类科学家进行验证。AI\u003cbr\u003e正成为科学家的共创者。\u003c/p\u003e\n\u003ch2\u003e三、挑战并非“副作用”，而是“主战场”\u003c/h2\u003e\n\u003ch3\u003e1）就业与能力结构的再平衡\u003c/h3\u003e\n\u003cp\u003eAI 替代的不是人，而是重复性脑力劳动。自动化趋势导致职业结构重塑：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单一技能岗位萎缩；跨学科与创造型岗位上升。\u003c/li\u003e\n\u003cli\u003e教育体系需从“知识传授”转向“思维训练”与“人机协作能力培养”。\u003cbr\u003e未来社会将形成“人机共生”的劳动力生态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2）伦理与可靠性：从“黑箱能力”到“可验证智能”\u003c/h3\u003e\n\u003cp\u003e算法偏见、虚假内容（Deepfake）与隐私泄露成为公众焦虑源。伦理治理的核心是三点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e可解释性\u003c/strong\u003e：模型需能说明其决策逻辑。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e公平性\u003c/strong\u003e：避免因训练数据导致歧视。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e隐私保护\u003c/strong\u003e：确保数据使用安全、可控、可追踪。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAI 必须从“能用”迈向“可信”。负责任 AI（Responsible AI）将成为行业标准。\u003c/p\u003e\n\u003ch3\u003e3）技术安全与失控风险\u003c/h3\u003e\n\u003cp\u003eAI 的失真（hallucination）问题在决策系统中风险极高。自主代理（Agent）可能因目标偏差造成不可预期行为。\u003cbr\u003e防范思路：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e训练阶段强化“人类反馈对齐（RLHF）”；\u003c/li\u003e\n\u003cli\u003e推理阶段嵌入安全策略与审计机制；\u003c/li\u003e\n\u003cli\u003e对外接口增加人类在环（Human-in-the-loop）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e四、如何落地：面向企业的 8 条实践路线\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e用例优先，分层推进\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e增产层：客服、文案、数据整理等快速落地；\u003c/li\u003e\n\u003cli\u003e提质层：代码助手、策略优化、运维自动化；\u003c/li\u003e\n\u003cli\u003e创新层：Agent 工厂与自主决策系统。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e三层模型栈设计\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e任务层：小模型 + 本地推理；\u003c/li\u003e\n\u003cli\u003e通用层：API 调用闭源大模型；\u003c/li\u003e\n\u003cli\u003e中间件层：记忆、RAG、工作流编排。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e数据治理前置\u003c/strong\u003e：统一数据契约、提示语标准化、评测数据资产化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e安全与合规即设计约束\u003c/strong\u003e：遵循隐私最小化与可追溯原则，将治理要求前置到架构设计。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e工程化评测体系\u003c/strong\u003e：建立功能、安全、成本三维评测框架，持续 A/B 测试与安全红队化。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAgent 权限与审计机制\u003c/strong\u003e：限制外部调用权限，提供日志可追踪与回滚机制。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e组织与人才升级\u003c/strong\u003e：新角色包括 AI 产品经理、数据提示工程师、RAI 审核官。跨职能小队成为创新主力。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eROI 量化与节奏控制\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e短期衡量节省工时与质量提升；\u003c/li\u003e\n\u003cli\u003e中期衡量转化率与延迟优化；\u003c/li\u003e\n\u003cli\u003e长期关注新收入占比与边际成本下降。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e五、政策与社会：从原则到制度化共识\u003c/h2\u003e\n\u003cp\u003eAI 治理正从理念走向法规：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e**欧盟《AI 法案》**确立风险分级监管体系，高风险场景强制审查；2027 年前全面实施。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e美国 AI 行政令\u003c/strong\u003e强调透明、安全与版权保护，但更新迭代频繁，治理仍在探索中。\u003c/li\u003e\n\u003cli\u003e**中国《生成式 AI 暂行办法》**聚焦安全、合规与社会责任，强化模型备案与输出审查。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e未来治理方向是 \u003cstrong\u003e全球互认 + 本地差异化实施\u003c/strong\u003e。企业合规体系需同时满足多法域要求。\u003c/p\u003e\n\u003ch2\u003e六、反常识与纠偏\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eAI 提效不是万能药\u003c/strong\u003e：若流程与组织不变，AI 只会加重管理负担。流程再造是关键。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e小模型 + 工具链更具性价比\u003c/strong\u003e：多数结构化任务无需大模型；RAG + 检索即够用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全是创新的前提\u003c/strong\u003e：早期建立安全闸门反而能加快迭代，减少上线风险。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e七、面向 2030 的三种情景\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eA：智能官能化（Augmented Intelligence）\u003c/strong\u003e\u003cbr\u003e小模型普及，AI 成为每个岗位的“副驾驶”。组织形态重构，人均产出翻倍。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eB：代理自治化（Agentic Automation）\u003c/strong\u003e\u003cbr\u003eAgent 网络接管企业内部流程，人类负责规则与异常决策。对齐与审计成为关键能力。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eC：科学范式跃迁（AI-native Science）\u003c/strong\u003e\u003cbr\u003e世界模型成为科学研究新实验室，药物与气候研究周期缩短数倍。AI 成为基础设施。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现实将是 A→B→C 的递进演化。每个阶段都需新的治理模式与社会契约。\u003c/p\u003e\n\u003ch2\u003e八、结语：让 AI 成为“可复利的社会能力”\u003c/h2\u003e\n\u003cp\u003eAI 的未来，不是取代人类，而是\u003cstrong\u003e重塑人类能力边界\u003c/strong\u003e。\u003cbr\u003e真正的关键，不在于模型多强，而在于我们能否：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e以真实问题驱动；\u003c/li\u003e\n\u003cli\u003e以安全和伦理兜底；\u003c/li\u003e\n\u003cli\u003e以工程化与制度化保证复利。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当人类学会以“结构化理性”驾驭智能，AI 将从风口变成文明底座。\u003cbr\u003e它既是工具，更是镜子——照见我们对智慧与秩序的共同追求。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-04-07\",\"children\":\"2024年04月07日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"非侵入式SQL监控\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L5\",\"技术实战\",{\"href\":\"/blog/tag/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"技术实战\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$11\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/tooling/Git常用命令\",\"title\":\"Git 常用命令速查手册\",\"description\":\"一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。\",\"pubDate\":\"2024-04-05\",\"tags\":[\"Git\",\"技术实战\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"insights/technology/人工智能的未来—机遇与挑战\",\"title\":\"人工智能的未来：机遇、挑战与行动路线图\",\"description\":\"过去十年，AI 从“可用”走向“有用”，从“模型演示”走向“生产系统”。2024—2025 年尤为关键：多模态大模型跃迁、开源权重追平、产业投资破纪录、治理规则成型。今天谈AI，不再只是技术叙事，而是战略、制度与社会协同的综合工程。\",\"pubDate\":\"2025-1-29\",\"tags\":[\"人工智能\",\"大语言模型\",\"技术洞察\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"技术实战\":{\"prev\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":null}}}]}],[\"$\",\"$L19\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"非侵入式SQL监控 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"非侵入式SQL监控\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-04-07\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"非侵入式SQL监控\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
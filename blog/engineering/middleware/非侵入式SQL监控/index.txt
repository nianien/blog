1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-51baccc14cf1da9e.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
5:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
7:I[59665,[],"OutletBoundary"]
a:I[74911,[],"AsyncMetadataOutlet"]
c:I[59665,[],"ViewportBoundary"]
e:I[59665,[],"MetadataBoundary"]
10:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/0458d6941a120cde.css","style"]
0:{"P":null,"b":"8CSEQRRrJyhjI8sSOwcIy","p":"","c":["","blog","engineering","middleware","%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/middleware/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/0458d6941a120cde.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8","children":[["$","div",null,{"className":"flex justify-center space-x-6 md:order-2","children":[["$","$L5",null,{"href":"/about","className":"text-gray-600 hover:text-gray-800","children":"关于"}],["$","$L5",null,{"href":"/blog","className":"text-gray-600 hover:text-gray-800","children":"博客"}],["$","$L5",null,{"href":"/contact","className":"text-gray-600 hover:text-gray-800","children":"联系"}]]}],["$","div",null,{"className":"mt-8 md:order-1 md:mt-0","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-600","children":"© 2024 Skyfalling Blog. All rights reserved."}]}]]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/middleware/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","W0v1Sa9J8VG7x4-PHg2Ukv",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Le",null,{"children":"$Lf"}]]}],false]],"m":"$undefined","G":["$10","$undefined"],"s":false,"S":true}
11:"$Sreact.suspense"
12:I[74911,[],"AsyncMetadata"]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
19:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
f:["$","div",null,{"hidden":true,"children":["$","$11",null,{"fallback":null,"children":["$","$L12",null,{"promise":"$@13"}]}]}]
15:T4fc0,<p>你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。</p>
<p>另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) 
and name in(sql
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;)
)
</code></pre>
<p>缩略下印如下：</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004,...) 
and name in(
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,...)
)
</code></pre>
<p>既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -&gt; ORM -&gt; DataSource  -&gt; Connection -&gt; Driver -&gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -&gt; DataSource  -&gt; Connection -&gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从<strong>DataSource  -&gt; Connection -&gt; Driver</strong>三个环节进行入手：</p>
<h3><strong>一、SQL Profile监控</strong></h3>
<h4><strong>1、驱动层监控</strong></h4>
<p>如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：</p>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;logger=Slf4JLogger&amp;profileSQL=true
</code></pre>
<p>基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。</p>
<h4><strong>2、连接层监控</strong></h4>
<p>如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如<a href="https://p6spy.readthedocs.io/en/latest/">P6Spy</a>、<a href="https://github.com/arthurblake/log4jdbc">log4jdbc</a> 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：</p>
<ul>
<li>pyspy</li>
</ul>
<pre><code class="language-properties">jdbc:p6spy:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-properties">jdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<h4><strong>3、数据源层监控</strong></h4>
<p>可以通过对DataSource进行代理实现SQL监控</p>
<ul>
<li>P6Spy：</li>
</ul>
<pre><code class="language-java">@Bean
@Primary
public DataSource spyDataSource(@Autowired DataSource dataSource) {
  // wrap a datasource using P6SpyDataSource
  return new P6DataSource(dataSource);
}
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-java">public DataSource spyDataSource(DataSource dataSource) {
    // wrap the provided dataSource
  return new DataSource() {
    @Override
    public Connection getConnection() throws SQLException {
      // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection());
    }
      
    @Override
    public Connection getConnection(String username, String password) throws SQLException {
       // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection(username, password));
     }
      //...
  };
}
</code></pre>
<p>上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。</p>
<p>第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。</p>
<p>第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。</p>
<p>排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。</p>
<pre><code class="language-java">public interface DataSourceConfig extends HasBizDef {

    /**
     * 数据源名称，必须与KDB申请时填写的一致
     */String bizName();

    /**
     * 获取当前可用区单库只读的JdbcTemplate
     */
    default NamedParameterJdbcTemplate read() {
        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), &quot;read&quot;);
    }   

    /**
     * 获取当前可用区单库读写的JdbcTemplate
     */
    default NamedParameterJdbcTemplate write() {
        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), &quot;write&quot;);
    }	
  //....
}
</code></pre>
<p>DefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:</p>
<pre><code class="language-kotlin">enum class AdDataSources(
    private val bizDef: BizDef,
    private val forTest: AdDataSources? = null,
    private val usingNewZk: Boolean = false
) : DataSourceConfig{
    adFansTopProfileDashboardTest,
    adFansTopProfileDashboard,
    adChargeTest,
    adCharge,
    adChargeReadOnly,
    adDspReadOnlyTest,
    adDspReadOnly;
    public open fun bizName(): String {
        return bizDef.bizName
    }
}
</code></pre>
<p>如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？</p>
<p>具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：</p>
<pre><code class="language-java">public static ListenableDataSource&lt;Failover&lt;Instance&gt;&gt; create(Instance i) {
   //...
   try {
       return supplyWithRetry(
        DATA_SOURCE_BUILD_RETRY,
        DATA_SOURCE_BUILD_RETRY_DELAY,
        () -&gt; new ListenableDataSource&lt;&gt;(
              bizName, 
              new HikariDataSource(config), ds -&gt; i.toString(), i),
              DataSourceFactory::needRetry);
                               
  } catch (Throwable e) {/**/}
}
</code></pre>
<p>由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?</p>
<h3><strong>二、动态修改加载类</strong></h3>
<p>成本最低的方式就是直接修改这段代码，将其中&#x7684;<em>&#x6E;ew HikariDataSource(config)</em>&#x4FEE;改&#x6210;<em>&#x6E;ew P6DataSource(new HikariDataSource(config))，</em>&#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？</p>
<p>首先我们来分析一下，有哪些手段可以修改Java字节码？</p>
<ul>
<li>方案一、编译时修改，需要开发maven插件</li>
</ul>
<p>（不使用maven插件的同学咋办？）</p>
<ul>
<li>方案二、加载时修改，重写类加载器</li>
</ul>
<p>需要在代码中指定特定的类加载器，用有一定的侵入式</p>
<ul>
<li>方案三、运行时修改，使用JavaAgent</li>
</ul>
<p>需要修改应用启动参数，运维成本有点高</p>
<p>首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。</p>
<p><em>下面是对动态启动Java Agent技术的解释</em></p>
<blockquote>
<p>Note that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.</p>
</blockquote>
<blockquote>
<p>See <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description">the java.lang.instrument package documentation</a>…</p>
</blockquote>
<blockquote>
<p>Getting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. <a href="https://stackoverflow.com/a/19912148/2711488">This answer</a> demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.</p>
</blockquote>
<blockquote>
<p>However, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.</p>
</blockquote>
<blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/questions/56787777/?noredirect=1&lq=1#comment100160373_56787777">this comment</a>, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.</p>
</blockquote>
<ul>
<li>字节码工具对比</li>
</ul>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png" alt="图片"></p>
<ul>
<li>使用bytebuddy修改字节码</li>
</ul>
<p>在实现代码之前，我们回过头来再看一下快手的数据源生成：</p>
<pre><code class="language-java">new ListenableDataSource&lt;&gt;(bizName, new HikariDataSource(config), ds -&gt; i.toString());
</code></pre>
<p>这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：</p>
<pre><code class="language-java">public class DelegatingDataSource implements DataSource {
   //...
  public DelegatingDataSource(DataSource targetDataSource) {
    this.setTargetDataSource(targetDataSource);
   }

  public void setTargetDataSource(@Nullable DataSource targetDataSource) {
      this.targetDataSource = targetDataSource;
  }
  //...
}
</code></pre>
<p>因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
        this.targetDataSource = new P6DataSource(targetDataSource;
}
</code></pre>
<p>那么具体如何修改字节码呢？这里是<a href="https://bytebuddy.net/#/tutorial">官方文档</a>，原理我们不做赘述，直接介绍实现了。实现方式有三种：</p>
<h4><strong>1、类文件替换</strong></h4>
<p>假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：</p>
<pre><code class="language-java">new ByteBuddy()
  .redefine(NewDelegatingDataSource.class)
  .name(DelegatingDataSource.class.getName())
  .make()
  .load(Thread.currentThread().getContextClassLoader(), 
        ClassReloadingStrategy.fromInstalledAgent());
</code></pre>
<h4><strong>2、操作字节码：</strong></h4>
<pre><code class="language-java">new ByteBuddy()
    .redefine(DelegatingDataSource.class)
    //重写DelegatingDataSource#setTargetDataSource方法
    .method(named(&quot;setTargetDataSource&quot;))
    .intercept(MyImplementation.INSTANCE)
    .make()
    .load(Thread.currentThread().getContextClassLoader(),
          ClassReloadingStrategy.fromInstalledAgent());

enum MyImplementation implements Implementation {

INSTANCE; // singleton

  @Override
  public InstrumentedType prepare(InstrumentedType instrumentedType) {
  return instrumentedType;
  }
  
  @Override
  public ByteCodeAppender appender(Target implementationTarget) {
  return MyAppender.INSTANCE;
  }
  
}
//字节码定义
enum MyAppender implements ByteCodeAppender {

INSTANCE; // singleton

@Override
public Size apply(MethodVisitor methodVisitor,
        Implementation.Context implementationContext,
        MethodDescription instrumentedMethod) {
  Label label0 = new Label();
  methodVisitor.visitLabel(label0);
  methodVisitor.visitLineNumber(70, label0);
  methodVisitor.visitVarInsn(ALOAD, 0);
  methodVisitor.visitTypeInsn(NEW, &quot;com/p6spy/engine/spy/P6DataSource&quot;);
  methodVisitor.visitInsn(DUP);
  methodVisitor.visitVarInsn(ALOAD, 1);
  methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;com/p6spy/engine/spy/P6DataSource&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljavax/sql/DataSource;)V&quot;, false);
  methodVisitor.visitFieldInsn(PUTFIELD, &quot;org/springframework/jdbc/datasource/DelegatingDataSource&quot;, &quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;);
  Label label1 = new Label();
  methodVisitor.visitLabel(label1);
  methodVisitor.visitLineNumber(71, label1);
  methodVisitor.visitInsn(RETURN);
  Label label2 = new Label();
  methodVisitor.visitLabel(label2);
  methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;&quot;, null, label0, label2, 0);
  methodVisitor.visitLocalVariable(&quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;, null, label0, label2, 1);
  methodVisitor.visitMaxs(4, 2);
  return new Size(4, 2);
  }
}
</code></pre>
<p>上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？</p>
<p>我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9" alt="图片"></p>
<h4><strong>3、利用byte-buddy的Advice</strong></h4>
<pre><code class="language-java"> public static void redefine() {
   new ByteBuddy()
     .redefine(DelegatingDataSource.class)
     .visit(Advice.to(Decorator.class)
            .on(ElementMatchers.named(&quot;setTargetDataSource&quot;)))
     .make()
     .load(Thread.currentThread().getContextClassLoader(),
           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();
 }

static class Decorator {

  //在方法开始插入代码
  @Advice.OnMethodEnter
    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {
    dataSource = new P6DataSource(dataSource);
  }
}
</code></pre>
<p>byte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
  //插入的代码
  targetDataSource = new P6DataSource(targetDataSource);
  this.targetDataSource = targetDataSource;
}
</code></pre>
<p>注：</p>
<ol>
<li>动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。</li>
<li>使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。</li>
</ol>
<h3><strong>三、自动生效</strong></h3>
<p>前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.kuaishou.ad&lt;/groupId&gt;
  &lt;artifactId&gt;sqllog-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;制品库查询最新版&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。</p>
<pre><code class="language-java">private static String[] getConfigurations(File file) {
  @EnableAutoConfiguration
  class NoScan {
    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载
  }
  FileClassLoader classLoader = new FileClassLoader(file);
  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();
  selector.setBeanClassLoader(classLoader);
  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));
  selector.setEnvironment(new StandardEnvironment());
  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));
  return configurations;
}
</code></pre>
<h3><strong>四、SQL打印效果</strong></h3>
<p>sqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44" alt=""></p>
<p>SQL的打印内容分为三部分：</p>
<p>第一行，显示执行时间、耗时、SQL操作、数据库连接等信息</p>
<p>第二行，显示参数化SQL</p>
<p>第三行，显示绑定参数后的实际执行的SQL</p>
<p>通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。</p>
17:T59f6,<h1>Git 常用命令速查手册</h1>
<blockquote>
<p>本文按使用场景组织，覆盖日常开发中最常用的 Git 操作。每条命令附带简要说明，部分附有使用示例。</p>
</blockquote>
<hr>
<h2>1. 配置</h2>
<pre><code class="language-bash"># 查看当前配置
git config --list

# 设置用户信息（全局）
git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;your@email.com&quot;

# 仅对当前仓库设置（去掉 --global）
git config user.name &quot;Your Name&quot;

# 设置默认编辑器
git config --global core.editor &quot;vim&quot;

# 设置默认分支名
git config --global init.defaultBranch main

# 配置命令别名
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.lg &quot;log --oneline --graph --all&quot;
</code></pre>
<hr>
<h2>2. 仓库初始化与克隆</h2>
<pre><code class="language-bash"># 初始化新仓库
git init

# 克隆远程仓库
git clone &lt;url&gt;

# 克隆指定分支
git clone -b &lt;branch&gt; &lt;url&gt;

# 浅克隆（只拉最近 1 次提交，适合大仓库）
git clone --depth 1 &lt;url&gt;

# 克隆并指定本地目录名
git clone &lt;url&gt; my-project
</code></pre>
<hr>
<h2>3. 文件追踪与暂存</h2>
<pre><code class="language-bash"># 查看工作区状态
git status

# 简洁模式
git status -s

# 添加文件到暂存区
git add &lt;file&gt;
git add .                    # 当前目录所有变更
git add -A                   # 整个仓库所有变更
git add -p                   # 交互式选择要暂存的代码块

# 取消暂存（保留工作区修改）
git restore --staged &lt;file&gt;
git reset HEAD &lt;file&gt;        # 旧写法，效果相同

# 丢弃工作区修改（危险操作，不可恢复）
git restore &lt;file&gt;
git checkout -- &lt;file&gt;       # 旧写法
</code></pre>
<h3>取消跟踪已版本控制的文件</h3>
<pre><code class="language-bash"># 不再追踪文件改动（文件保留在仓库中，但本地修改不再显示为 dirty）
git update-index --assume-unchanged &lt;filePath&gt;

# 恢复追踪
git update-index --no-assume-unchanged &lt;filePath&gt;

# 查看所有被 assume-unchanged 的文件
git ls-files -v | grep &#39;^h&#39;

# 从版本控制中删除文件（但保留本地文件）
git rm --cached &lt;filePath&gt;

# 从版本控制中删除文件夹
git rm -r -f --cached &lt;dirPath&gt;
</code></pre>
<blockquote>
<p><strong><code>--assume-unchanged</code> vs <code>--skip-worktree</code></strong>：两者都能让 Git 忽略本地修改，但语义不同。<code>--assume-unchanged</code> 是性能优化提示（告诉 Git &quot;这个文件不会变&quot;），<code>--skip-worktree</code> 是明确的意图声明（&quot;我故意修改了这个文件，但不想提交&quot;）。对于本地配置文件的修改，推荐使用 <code>--skip-worktree</code>。</p>
</blockquote>
<pre><code class="language-bash">git update-index --skip-worktree &lt;filePath&gt;
git update-index --no-skip-worktree &lt;filePath&gt;
git ls-files -v | grep &#39;^S&#39;    # 查看所有 skip-worktree 文件
</code></pre>
<hr>
<h2>4. 提交</h2>
<pre><code class="language-bash"># 提交暂存区内容
git commit -m &quot;commit message&quot;

# 添加并提交所有已跟踪文件的修改（不含新文件）
git commit -am &quot;commit message&quot;

# 修改最近一次提交的信息（未推送到远程时使用）
git commit --amend -m &quot;new message&quot;

# 修改最近一次提交，追加文件但不改消息
git commit --amend --no-edit

# 创建空提交（可用于触发 CI）
git commit --allow-empty -m &quot;trigger build&quot;
</code></pre>
<hr>
<h2>5. 分支管理</h2>
<pre><code class="language-bash"># 查看本地分支
git branch

# 查看所有分支（含远程）
git branch -a

# 查看分支及最后一次提交
git branch -v

# 创建分支
git branch &lt;name&gt;

# 创建并切换
git checkout -b &lt;name&gt;
git switch -c &lt;name&gt;         # 推荐新写法

# 切换分支
git checkout &lt;name&gt;
git switch &lt;name&gt;            # 推荐新写法

# 重命名当前分支
git branch -m &lt;new-name&gt;

# 删除本地分支（已合并）
git branch -d &lt;name&gt;

# 强制删除本地分支（未合并也删）
git branch -D &lt;name&gt;

# 删除远程分支
git push origin --delete &lt;name&gt;

# 查看已合并到当前分支的分支
git branch --merged

# 查看未合并到当前分支的分支
git branch --no-merged
</code></pre>
<hr>
<h2>6. 合并与变基</h2>
<pre><code class="language-bash"># 合并指定分支到当前分支
git merge &lt;branch&gt;

# 合并时不使用 fast-forward（保留合并提交记录）
git merge --no-ff &lt;branch&gt;

# 只生成一个合并提交（压缩对方所有提交）
git merge --squash &lt;branch&gt;

# 变基（将当前分支的提交移到目标分支的最新提交之后）
git rebase &lt;branch&gt;

# 交互式变基（修改/合并/删除/排序最近 N 次提交）
git rebase -i HEAD~N

# 变基冲突后继续 / 跳过 / 终止
git rebase --continue
git rebase --skip
git rebase --abort

# 合并冲突后终止合并
git merge --abort
</code></pre>
<h3>Cherry-pick</h3>
<pre><code class="language-bash"># 将某个提交应用到当前分支
git cherry-pick &lt;commit-hash&gt;

# 连续多个提交
git cherry-pick &lt;hash1&gt; &lt;hash2&gt;

# 只暂存不提交
git cherry-pick &lt;hash&gt; --no-commit
</code></pre>
<hr>
<h2>7. 远程协作</h2>
<pre><code class="language-bash"># 查看远程仓库
git remote -v

# 添加远程仓库
git remote add origin &lt;url&gt;

# 修改远程仓库地址
git remote set-url origin &lt;new-url&gt;

# 拉取远程更新（不合并）
git fetch
git fetch --all              # 拉取所有远程
git fetch --prune            # 同时清理已删除的远程分支引用

# 拉取并合并（= fetch + merge）
git pull

# 拉取并变基（= fetch + rebase，保持线性历史）
git pull --rebase

# 推送
git push
git push origin &lt;branch&gt;

# 首次推送并建立追踪关系
git push -u origin &lt;branch&gt;

# 强制推送（覆盖远程历史，团队协作慎用）
git push --force

# 安全的强制推送（远程有新提交时会拒绝）
git push --force-with-lease

# 推送所有分支
git push --all

# 推送所有标签
git push --tags
</code></pre>
<hr>
<h2>8. 暂存工作区（Stash）</h2>
<pre><code class="language-bash"># 暂存当前工作区和暂存区的修改
git stash

# 带描述信息
git stash save &quot;work in progress: feature X&quot;
git stash push -m &quot;description&quot;   # 推荐新写法

# 暂存时包含未跟踪的文件
git stash -u

# 暂存时包含所有文件（含 .gitignore 忽略的）
git stash -a

# 查看 stash 列表
git stash list

# 恢复最近的 stash（保留 stash 记录）
git stash apply

# 恢复并删除最近的 stash
git stash pop

# 恢复指定的 stash
git stash apply stash@{2}

# 删除指定 stash
git stash drop stash@{0}

# 清空所有 stash
git stash clear

# 查看某个 stash 的内容
git stash show -p stash@{0}
</code></pre>
<hr>
<h2>9. 日志与差异</h2>
<pre><code class="language-bash"># 查看提交日志
git log

# 简洁单行显示
git log --oneline

# 图形化显示分支合并历史
git log --oneline --graph --all

# 显示每次提交的文件变更统计
git log --stat

# 显示每次提交的具体修改
git log -p

# 最近 N 次提交
git log -n 5

# 按作者过滤
git log --author=&quot;name&quot;

# 按时间范围过滤
git log --since=&quot;2024-01-01&quot; --until=&quot;2024-06-30&quot;

# 按提交信息关键字搜索
git log --grep=&quot;fix bug&quot;

# 搜索某段代码的变更历史
git log -S &quot;functionName&quot;

# 查看某个文件的提交历史
git log -- &lt;file&gt;
git log --follow -- &lt;file&gt;   # 包含重命名前的历史
</code></pre>
<h3>差异对比</h3>
<pre><code class="language-bash"># 工作区 vs 暂存区
git diff

# 暂存区 vs 最新提交
git diff --staged
git diff --cached            # 同义

# 两个分支之间的差异
git diff &lt;branch1&gt;..&lt;branch2&gt;

# 两个提交之间的差异
git diff &lt;commit1&gt;..&lt;commit2&gt;

# 只看文件名列表
git diff --name-only

# 查看文件改动统计
git diff --stat
</code></pre>
<hr>
<h2>10. 撤销与回退</h2>
<pre><code class="language-bash"># 撤销工作区修改（未暂存）
git restore &lt;file&gt;

# 撤销暂存（保留工作区修改）
git restore --staged &lt;file&gt;

# 回退到某个提交（保留修改在工作区）
git reset --soft &lt;commit&gt;

# 回退到某个提交（保留修改在暂存区）
git reset --mixed &lt;commit&gt;     # 默认模式

# 回退到某个提交（丢弃所有修改，危险操作）
git reset --hard &lt;commit&gt;

# 回退最近 N 次提交
git reset --soft HEAD~N

# 创建一个新提交来撤销指定提交（安全的回退方式，不改写历史）
git revert &lt;commit&gt;

# 撤销多个连续提交
git revert &lt;older-commit&gt;..&lt;newer-commit&gt;

# 只修改工作区不自动提交
git revert --no-commit &lt;commit&gt;
</code></pre>
<blockquote>
<p><strong><code>reset</code> vs <code>revert</code></strong>：<code>reset</code> 改写提交历史（适合未推送的本地提交），<code>revert</code> 创建新提交来撤销（适合已推送的公共分支）。在多人协作的分支上，永远优先使用 <code>revert</code>。</p>
</blockquote>
<hr>
<h2>11. 标签</h2>
<pre><code class="language-bash"># 查看所有标签
git tag

# 按模式过滤
git tag -l &quot;v1.*&quot;

# 创建轻量标签
git tag &lt;tag-name&gt;

# 创建附注标签（推荐）
git tag -a &lt;tag-name&gt; -m &quot;description&quot;

# 给历史提交打标签
git tag -a &lt;tag-name&gt; &lt;commit-hash&gt;

# 查看标签详情
git show &lt;tag-name&gt;

# 推送单个标签到远程
git push origin &lt;tag-name&gt;

# 推送所有标签
git push origin --tags

# 删除本地标签
git tag -d &lt;tag-name&gt;

# 删除远程标签
git push origin --delete &lt;tag-name&gt;
</code></pre>
<hr>
<h2>12. 子模块</h2>
<pre><code class="language-bash"># 添加子模块
git submodule add &lt;url&gt; &lt;path&gt;

# 克隆含子模块的仓库
git clone --recurse-submodules &lt;url&gt;

# 已克隆后初始化子模块
git submodule init
git submodule update

# 一步到位
git submodule update --init --recursive

# 更新所有子模块到最新
git submodule update --remote

# 删除子模块
git submodule deinit &lt;path&gt;
git rm &lt;path&gt;
rm -rf .git/modules/&lt;path&gt;
</code></pre>
<hr>
<h2>13. Worktree（多工作目录）</h2>
<pre><code class="language-bash"># 为指定分支创建一个独立的工作目录（无需 stash 即可同时处理多个分支）
git worktree add &lt;path&gt; &lt;branch&gt;

# 创建新分支并建立 worktree
git worktree add -b &lt;new-branch&gt; &lt;path&gt;

# 查看所有 worktree
git worktree list

# 删除 worktree
git worktree remove &lt;path&gt;

# 清理无效的 worktree 引用
git worktree prune
</code></pre>
<hr>
<h2>14. 查找与定位</h2>
<pre><code class="language-bash"># 查找引入 bug 的提交（二分法）
git bisect start
git bisect bad                # 当前版本有 bug
git bisect good &lt;commit&gt;      # 某个已知正常的版本
# Git 自动切换到中间版本，测试后标记 good/bad，直到定位到具体提交
git bisect reset              # 结束 bisect

# 查看某行代码的最后修改人和提交
git blame &lt;file&gt;
git blame -L 10,20 &lt;file&gt;    # 只看第 10-20 行

# 在所有提交中搜索内容
git grep &quot;pattern&quot;
git grep &quot;pattern&quot; &lt;branch&gt;
</code></pre>
<hr>
<h2>15. 清理</h2>
<pre><code class="language-bash"># 预览将被清理的未跟踪文件
git clean -n

# 删除未跟踪的文件
git clean -f

# 删除未跟踪的文件和目录
git clean -fd

# 删除未跟踪的文件（含 .gitignore 忽略的文件）
git clean -fdx

# 垃圾回收（压缩历史，清理悬空对象）
git gc

# 清理远程已删除的分支引用
git remote prune origin
git fetch --prune             # 等价
</code></pre>
<hr>
<h2>16. 常见场景速查</h2>
<h3>撤销最近一次提交但保留代码</h3>
<pre><code class="language-bash">git reset --soft HEAD~1
</code></pre>
<h3>合并多次提交为一个</h3>
<pre><code class="language-bash">git rebase -i HEAD~3
# 编辑器中将后两个 pick 改为 squash (或 s)，保存退出
</code></pre>
<h3>从其他分支拿一个文件</h3>
<pre><code class="language-bash">git checkout &lt;branch&gt; -- &lt;file&gt;
git restore --source &lt;branch&gt; -- &lt;file&gt;   # 推荐新写法
</code></pre>
<h3>找回误删的分支或提交</h3>
<pre><code class="language-bash"># 查看所有引用变更记录（包括已删除的）
git reflog

# 基于 reflog 中的哈希恢复
git checkout -b recovered-branch &lt;hash&gt;
</code></pre>
<h3>修改历史提交的作者信息</h3>
<pre><code class="language-bash">git rebase -i &lt;commit&gt;^
# 将目标提交标记为 edit，保存退出
git commit --amend --author=&quot;Name &lt;email&gt;&quot; --no-edit
git rebase --continue
</code></pre>
<h3>统计代码贡献</h3>
<pre><code class="language-bash"># 按作者统计提交数
git shortlog -sn

# 统计某人的代码行数增删
git log --author=&quot;name&quot; --numstat --pretty=&quot;%H&quot; | awk &#39;NF==3 {add+=$1; del+=$2} END {print &quot;+&quot;add, &quot;-&quot;del}&#39;
</code></pre>
<h3>临时切到其他分支修 bug，不想 stash</h3>
<pre><code class="language-bash"># 用 worktree 在另一个目录打开 hotfix 分支，互不干扰
git worktree add ../hotfix-dir hotfix/issue-123

# 修完后删除
git worktree remove ../hotfix-dir
</code></pre>
<h3>只克隆仓库的某个子目录（Sparse Checkout）</h3>
<pre><code class="language-bash">git clone --filter=blob:none --sparse &lt;url&gt;
cd &lt;repo&gt;
git sparse-checkout set path/to/subdir
</code></pre>
<h3>把未提交的修改生成补丁发给别人</h3>
<pre><code class="language-bash"># 生成补丁文件
git diff &gt; my-changes.patch

# 对方应用补丁
git apply my-changes.patch
</code></pre>
<h3>把已提交的 commit 生成补丁</h3>
<pre><code class="language-bash"># 生成最近 3 次提交的补丁文件（每个提交一个 .patch 文件）
git format-patch -3

# 对方应用
git am *.patch
</code></pre>
<hr>
<h2>17. .gitignore</h2>
<pre><code class="language-bash"># .gitignore 文件常用模式

# 忽略所有 .log 文件
*.log

# 但保留 important.log
!important.log

# 忽略根目录下的 build 文件夹（不影响子目录中的 build）
/build/

# 忽略所有目录下的 node_modules
node_modules/

# 忽略所有 .env 文件（防止泄露密钥）
.env
.env.*

# 忽略 IDE 配置
.idea/
.vscode/
*.swp
*.swo
*~

# 忽略操作系统文件
.DS_Store
Thumbs.db
</code></pre>
<pre><code class="language-bash"># .gitignore 已经添加规则，但文件之前已被跟踪？需要先从缓存中移除
git rm --cached &lt;file&gt;
git commit -m &quot;stop tracking &lt;file&gt;&quot;

# 检查某个文件为什么被忽略
git check-ignore -v &lt;file&gt;

# 列出所有被忽略的文件
git status --ignored

# 全局 gitignore（对所有仓库生效）
git config --global core.excludesfile ~/.gitignore_global
</code></pre>
<hr>
<h2>18. Git Hooks</h2>
<p>Git Hooks 是在特定事件（提交、推送等）发生时自动执行的脚本，存放在 <code>.git/hooks/</code> 目录下。</p>
<h3>常用 Hook 类型</h3>
<table>
<thead>
<tr>
<th>Hook</th>
<th>触发时机</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>pre-commit</code></td>
<td><code>git commit</code> 执行前</td>
<td>代码格式检查、lint、单元测试</td>
</tr>
<tr>
<td><code>commit-msg</code></td>
<td>提交信息写入后</td>
<td>校验 commit message 格式</td>
</tr>
<tr>
<td><code>pre-push</code></td>
<td><code>git push</code> 执行前</td>
<td>运行测试、阻止推送到 main</td>
</tr>
<tr>
<td><code>post-merge</code></td>
<td><code>git merge</code> 完成后</td>
<td>自动安装依赖</td>
</tr>
<tr>
<td><code>pre-rebase</code></td>
<td><code>git rebase</code> 执行前</td>
<td>阻止对公共分支变基</td>
</tr>
<tr>
<td><code>post-checkout</code></td>
<td><code>git checkout</code> 完成后</td>
<td>环境初始化</td>
</tr>
</tbody></table>
<h3>示例：pre-commit 检查是否有 console.log</h3>
<pre><code class="language-bash">#!/bin/sh
# .git/hooks/pre-commit

if git diff --cached --name-only | grep -E &#39;\.(js|ts|tsx)$&#39; | xargs grep -l &#39;console\.log&#39; 2&gt;/dev/null; then
    echo &quot;Error: console.log found in staged files&quot;
    exit 1
fi
</code></pre>
<h3>使用 Husky 管理 Hooks（推荐）</h3>
<p><code>.git/hooks/</code> 不会被提交到仓库，团队共享不方便。<a href="https://typicode.github.io/husky/">Husky</a> 解决了这个问题：</p>
<pre><code class="language-bash"># 安装
npm install husky -D
npx husky init

# 添加 pre-commit hook
echo &quot;npm run lint&quot; &gt; .husky/pre-commit
</code></pre>
<hr>
<h2>19. Git LFS（大文件存储）</h2>
<p>Git 不擅长处理大文件（二进制、模型文件、设计稿等），Git LFS 用指针文件替代大文件，实际内容存储在单独的 LFS 服务器上。</p>
<pre><code class="language-bash"># 安装（macOS）
brew install git-lfs

# 在仓库中启用
git lfs install

# 追踪特定类型的大文件
git lfs track &quot;*.psd&quot;
git lfs track &quot;*.zip&quot;
git lfs track &quot;models/**&quot;

# 追踪规则保存在 .gitattributes 中，需要提交
git add .gitattributes
git commit -m &quot;track large files with LFS&quot;

# 后续正常 add/commit/push，LFS 文件会自动走 LFS 通道
git add large-file.psd
git commit -m &quot;add design file&quot;
git push

# 查看当前 LFS 追踪的文件模式
git lfs track

# 查看 LFS 管理的文件列表
git lfs ls-files

# 拉取所有 LFS 文件（克隆后可能需要）
git lfs pull
</code></pre>
<hr>
<h2>20. Git Archive（导出代码）</h2>
<pre><code class="language-bash"># 导出当前 HEAD 为 zip
git archive --format=zip HEAD -o project.zip

# 导出指定分支
git archive --format=tar.gz release/v1.0 -o release-v1.0.tar.gz

# 只导出某个子目录
git archive HEAD --prefix=src/ -- src/ -o src-only.zip

# 导出两个版本之间的差异文件
git diff --name-only v1.0 v2.0 | xargs git archive HEAD -o diff-files.zip --
</code></pre>
<hr>
<h2>21. 交互式变基详解</h2>
<p><code>git rebase -i</code> 是最强大的提交历史编辑工具，编辑器中每行一个提交，支持以下操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>pick</code></td>
<td><code>p</code></td>
<td>保留该提交（默认）</td>
</tr>
<tr>
<td><code>reword</code></td>
<td><code>r</code></td>
<td>保留提交但修改提交信息</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>e</code></td>
<td>暂停在该提交，允许修改内容</td>
</tr>
<tr>
<td><code>squash</code></td>
<td><code>s</code></td>
<td>合并到上一个提交，合并提交信息</td>
</tr>
<tr>
<td><code>fixup</code></td>
<td><code>f</code></td>
<td>合并到上一个提交，丢弃本条提交信息</td>
</tr>
<tr>
<td><code>drop</code></td>
<td><code>d</code></td>
<td>删除该提交</td>
</tr>
</tbody></table>
<h3>典型场景</h3>
<pre><code class="language-bash"># 合并最近 4 次提交为 1 个
git rebase -i HEAD~4
# 编辑器中：第一个保持 pick，其余改为 squash 或 fixup

# 调整提交顺序：直接在编辑器中拖动行的位置

# 拆分一个提交为多个
git rebase -i HEAD~3
# 将目标提交标记为 edit，保存退出
git reset HEAD~1              # 撤回提交但保留文件修改
git add file1 &amp;&amp; git commit -m &quot;part 1&quot;
git add file2 &amp;&amp; git commit -m &quot;part 2&quot;
git rebase --continue
</code></pre>
<hr>
<h2>22. 签名与验证</h2>
<pre><code class="language-bash"># 配置 GPG 签名
git config --global user.signingkey &lt;GPG-KEY-ID&gt;
git config --global commit.gpgsign true    # 默认对所有提交签名

# 签名提交
git commit -S -m &quot;signed commit&quot;

# 签名标签
git tag -s v1.0 -m &quot;signed release&quot;

# 验证提交签名
git log --show-signature

# 验证标签签名
git tag -v v1.0
</code></pre>
<hr>
<h2>23. 高级配置技巧</h2>
<pre><code class="language-bash"># 自动纠正拼写错误的命令（如 git stauts → git status）
git config --global help.autocorrect 10   # 1 秒后自动执行

# 启用 rerere（记住冲突解决方式，下次自动应用）
git config --global rerere.enabled true

# diff 时使用更好的算法（对函数移动更友好）
git config --global diff.algorithm histogram

# 全局忽略文件权限变更（在 macOS/Windows 上避免无意义的 diff）
git config --global core.fileMode false

# 设置 pull 默认使用 rebase（保持线性历史）
git config --global pull.rebase true

# 推送时自动设置上游分支
git config --global push.autoSetupRemote true

# 多行 commit message 使用 heredoc
git commit -m &quot;$(cat &lt;&lt;&#39;EOF&#39;
feat: add user authentication

- Add JWT token generation
- Add login/logout endpoints
- Add middleware for protected routes
EOF
)&quot;
</code></pre>
<hr>
<h2>24. 速查表</h2>
<table>
<thead>
<tr>
<th>想做什么</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看状态</td>
<td><code>git status</code></td>
</tr>
<tr>
<td>添加所有修改</td>
<td><code>git add -A</code></td>
</tr>
<tr>
<td>提交</td>
<td><code>git commit -m &quot;msg&quot;</code></td>
</tr>
<tr>
<td>拉取 + 变基</td>
<td><code>git pull --rebase</code></td>
</tr>
<tr>
<td>推送</td>
<td><code>git push</code></td>
</tr>
<tr>
<td>新建分支并切换</td>
<td><code>git switch -c feat/xxx</code></td>
</tr>
<tr>
<td>合并分支</td>
<td><code>git merge --no-ff feat/xxx</code></td>
</tr>
<tr>
<td>暂存工作区</td>
<td><code>git stash -u</code></td>
</tr>
<tr>
<td>恢复暂存</td>
<td><code>git stash pop</code></td>
</tr>
<tr>
<td>查看简洁日志</td>
<td><code>git log --oneline --graph</code></td>
</tr>
<tr>
<td>撤销最近提交</td>
<td><code>git reset --soft HEAD~1</code></td>
</tr>
<tr>
<td>安全回退已推送的提交</td>
<td><code>git revert &lt;hash&gt;</code></td>
</tr>
<tr>
<td>找回误删内容</td>
<td><code>git reflog</code></td>
</tr>
<tr>
<td>查看某行代码作者</td>
<td><code>git blame &lt;file&gt;</code></td>
</tr>
<tr>
<td>二分法查 bug</td>
<td><code>git bisect start</code></td>
</tr>
<tr>
<td>只拿某个提交</td>
<td><code>git cherry-pick &lt;hash&gt;</code></td>
</tr>
<tr>
<td>导出代码压缩包</td>
<td><code>git archive HEAD -o out.zip</code></td>
</tr>
</tbody></table>
18:T214d,<h2>一、AI 正在发生什么：从“更大”到“更能干”</h2>
<h3>1）大模型走向“世界建模”</h3>
<p>以 GPT 系列、Claude、Gemini、通义等为代表的通用模型，已从语言理解扩展到视觉、语音、视频与动作控制，形成“多模态 +<br>代理（agentic）”的新范式。斯坦福 HAI《AI Index 2025》指出：</p>
<ul>
<li><strong>性能跃升</strong>：2024 年模型在复杂推理与编程任务中的表现较 2023 年提升 50% 以上；SWE-bench 可解比例从 4.4% 提升至 71.7%。</li>
<li><strong>开源追平</strong>：开源与闭源模型性能差距从 8% 缩小至 2%，AI 正从“巨头独占”走向“开源共享”。</li>
<li><strong>成本坍缩</strong>：达到 GPT-3.5 水平的模型推理成本两年下降 280 倍。AI 的使用门槛正被迅速拉低。</li>
</ul>
<h3>2）科学计算的“AI 第一性”</h3>
<p>AlphaFold3、DeepMind 的 GNoME 以及 Earth-2 等项目，标志着 AI 已进入科学研究核心环节。AI<br>不再仅仅识别模式，而是参与规律发现。生物学、气候模拟、材料科学正经历“生成—推理—验证”范式革命。</p>
<h3>3）从“工具”到“基础设施”</h3>
<ul>
<li><strong>投资规模</strong>：2024 年全球 AI 私营投资超 1000 亿美元，其中生成式 AI 占比 30%。</li>
<li><strong>使用扩散</strong>：企业采用 AI 的比例已达 78%，其中 65% 经常性使用生成式 AI。</li>
<li><strong>现实落地</strong>：Waymo 每周执行 15 万次无人驾驶任务，AI 已成为社会运行基础的一部分。</li>
</ul>
<h2>二、为什么重要：效率红利、产业结构与科学范式</h2>
<h3>1）效率红利：从“人效提升”到“组织再造”</h3>
<p>多项研究显示生成式 AI 对知识工作者生产率提升 15%–40%。</p>
<ul>
<li>客服实验表明，新手员工在 AI 辅助下解决率提升 35%。</li>
<li>开发者使用代码助手后任务完成速度提升 25%。<br>这种提升不仅体现在个体效率，更在于组织结构的重塑：未来企业将从“分工协作”进化为“人机协作”。AI 成为企业内部“第二大脑”，承担分析、生成与验证任务。</li>
</ul>
<h3>2）产业结构：从“软件吞噬世界”到“智能重写行业”</h3>
<ul>
<li><strong>医疗</strong>：AI 影像识别准确率已超专家平均水平；药物研发周期可缩短 40%。</li>
<li><strong>制造</strong>：AI 驱动的质量检测与预测性维护提升生产良率 15%。</li>
<li><strong>金融</strong>：AI 在风险建模与客服中广泛部署，节省运营成本 30%。</li>
<li><strong>交通</strong>：智能调度与自动驾驶结合，城市拥堵时间下降 20%。</li>
</ul>
<p>AI 不再是“应用层创新”，而是推动整个产业链价值重新分配的“中枢技术”。</p>
<h3>3）科学范式：AI 成为“假设生成器”</h3>
<p>过去的科研范式是“假设—实验—验证”，AI 让科学进入“生成—推理—验证”阶段。它能从数据中发现潜在规律，提前模拟实验结果，再由人类科学家进行验证。AI<br>正成为科学家的共创者。</p>
<h2>三、挑战并非“副作用”，而是“主战场”</h2>
<h3>1）就业与能力结构的再平衡</h3>
<p>AI 替代的不是人，而是重复性脑力劳动。自动化趋势导致职业结构重塑：</p>
<ul>
<li>单一技能岗位萎缩；跨学科与创造型岗位上升。</li>
<li>教育体系需从“知识传授”转向“思维训练”与“人机协作能力培养”。<br>未来社会将形成“人机共生”的劳动力生态。</li>
</ul>
<h3>2）伦理与可靠性：从“黑箱能力”到“可验证智能”</h3>
<p>算法偏见、虚假内容（Deepfake）与隐私泄露成为公众焦虑源。伦理治理的核心是三点：</p>
<ol>
<li><strong>可解释性</strong>：模型需能说明其决策逻辑。</li>
<li><strong>公平性</strong>：避免因训练数据导致歧视。</li>
<li><strong>隐私保护</strong>：确保数据使用安全、可控、可追踪。</li>
</ol>
<p>AI 必须从“能用”迈向“可信”。负责任 AI（Responsible AI）将成为行业标准。</p>
<h3>3）技术安全与失控风险</h3>
<p>AI 的失真（hallucination）问题在决策系统中风险极高。自主代理（Agent）可能因目标偏差造成不可预期行为。<br>防范思路：</p>
<ul>
<li>训练阶段强化“人类反馈对齐（RLHF）”；</li>
<li>推理阶段嵌入安全策略与审计机制；</li>
<li>对外接口增加人类在环（Human-in-the-loop）。</li>
</ul>
<h2>四、如何落地：面向企业的 8 条实践路线</h2>
<ol>
<li><p><strong>用例优先，分层推进</strong>：</p>
<ul>
<li>增产层：客服、文案、数据整理等快速落地；</li>
<li>提质层：代码助手、策略优化、运维自动化；</li>
<li>创新层：Agent 工厂与自主决策系统。</li>
</ul>
</li>
<li><p><strong>三层模型栈设计</strong>：</p>
<ul>
<li>任务层：小模型 + 本地推理；</li>
<li>通用层：API 调用闭源大模型；</li>
<li>中间件层：记忆、RAG、工作流编排。</li>
</ul>
</li>
<li><p><strong>数据治理前置</strong>：统一数据契约、提示语标准化、评测数据资产化。</p>
</li>
<li><p><strong>安全与合规即设计约束</strong>：遵循隐私最小化与可追溯原则，将治理要求前置到架构设计。</p>
</li>
<li><p><strong>工程化评测体系</strong>：建立功能、安全、成本三维评测框架，持续 A/B 测试与安全红队化。</p>
</li>
<li><p><strong>Agent 权限与审计机制</strong>：限制外部调用权限，提供日志可追踪与回滚机制。</p>
</li>
<li><p><strong>组织与人才升级</strong>：新角色包括 AI 产品经理、数据提示工程师、RAI 审核官。跨职能小队成为创新主力。</p>
</li>
<li><p><strong>ROI 量化与节奏控制</strong>：</p>
<ul>
<li>短期衡量节省工时与质量提升；</li>
<li>中期衡量转化率与延迟优化；</li>
<li>长期关注新收入占比与边际成本下降。</li>
</ul>
</li>
</ol>
<h2>五、政策与社会：从原则到制度化共识</h2>
<p>AI 治理正从理念走向法规：</p>
<ul>
<li>**欧盟《AI 法案》**确立风险分级监管体系，高风险场景强制审查；2027 年前全面实施。</li>
<li><strong>美国 AI 行政令</strong>强调透明、安全与版权保护，但更新迭代频繁，治理仍在探索中。</li>
<li>**中国《生成式 AI 暂行办法》**聚焦安全、合规与社会责任，强化模型备案与输出审查。</li>
</ul>
<p>未来治理方向是 <strong>全球互认 + 本地差异化实施</strong>。企业合规体系需同时满足多法域要求。</p>
<h2>六、反常识与纠偏</h2>
<ol>
<li><strong>AI 提效不是万能药</strong>：若流程与组织不变，AI 只会加重管理负担。流程再造是关键。</li>
<li><strong>小模型 + 工具链更具性价比</strong>：多数结构化任务无需大模型；RAG + 检索即够用。</li>
<li><strong>安全是创新的前提</strong>：早期建立安全闸门反而能加快迭代，减少上线风险。</li>
</ol>
<h2>七、面向 2030 的三种情景</h2>
<ul>
<li><p><strong>A：智能官能化（Augmented Intelligence）</strong><br>小模型普及，AI 成为每个岗位的“副驾驶”。组织形态重构，人均产出翻倍。</p>
</li>
<li><p><strong>B：代理自治化（Agentic Automation）</strong><br>Agent 网络接管企业内部流程，人类负责规则与异常决策。对齐与审计成为关键能力。</p>
</li>
<li><p><strong>C：科学范式跃迁（AI-native Science）</strong><br>世界模型成为科学研究新实验室，药物与气候研究周期缩短数倍。AI 成为基础设施。</p>
</li>
</ul>
<p>现实将是 A→B→C 的递进演化。每个阶段都需新的治理模式与社会契约。</p>
<h2>八、结语：让 AI 成为“可复利的社会能力”</h2>
<p>AI 的未来，不是取代人类，而是<strong>重塑人类能力边界</strong>。<br>真正的关键，不在于模型多强，而在于我们能否：</p>
<ul>
<li>以真实问题驱动；</li>
<li>以安全和伦理兜底；</li>
<li>以工程化与制度化保证复利。</li>
</ul>
<p>当人类学会以“结构化理性”驾驭智能，AI 将从风口变成文明底座。<br>它既是工具，更是镜子——照见我们对智慧与秩序的共同追求。</p>
6:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-04-07","children":"2024年04月07日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"非侵入式SQL监控"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L5","技术实战",{"href":"/blog/tag/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"技术实战"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$11",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/tooling/Git常用命令","title":"Git 常用命令速查手册","description":"一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。","pubDate":"2024-04-05","tags":["Git","技术实战"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"insights/technology/人工智能的未来—机遇与挑战","title":"人工智能的未来：机遇、挑战与行动路线图","description":"过去十年，AI 从“可用”走向“有用”，从“模型演示”走向“生产系统”。2024—2025 年尤为关键：多模态大模型跃迁、开源权重追平、产业投资破纪录、治理规则成型。今天谈AI，不再只是技术叙事，而是战略、制度与社会协同的综合工程。","pubDate":"2025-1-29","tags":["人工智能","大语言模型","技术洞察"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"技术实战":{"prev":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":null}}}]}],["$","$L19",null,{}]]}]}]}]
9:null
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
b:{"metadata":[["$","title","0",{"children":"非侵入式SQL监控 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."}],["$","meta","2",{"property":"og:title","content":"非侵入式SQL监控"}],["$","meta","3",{"property":"og:description","content":"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-04-07"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"非侵入式SQL监控"}],["$","meta","9",{"name":"twitter:description","content":"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
13:{"metadata":"$b:metadata","error":null,"digest":"$undefined"}

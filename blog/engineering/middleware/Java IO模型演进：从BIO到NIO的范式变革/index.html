<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/7dd6b3ec14b0b1d8.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>Java I/O模型演进：从BIO到NIO的范式变革 - Skyfalling Blog</title><meta name="description" content="系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。"/><meta property="og:title" content="Java I/O模型演进：从BIO到NIO的范式变革"/><meta property="og:description" content="系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2022-04-18"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Java I/O模型演进：从BIO到NIO的范式变革"/><meta name="twitter:description" content="系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/middleware/page/1/">中间件</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2022-04-18">2022年04月18日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">Java I/O模型演进：从BIO到NIO的范式变革</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/NIO/page/1/">NIO</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/I%2FO/page/1/">I/O</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Netty/page/1/">Netty</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/page/1/">网络编程</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>Java I/O模型演进：从BIO到NIO的范式变革</h1>
<blockquote>
<p>Java I/O 体系经历了从 BIO 到 NIO 再到 AIO 的演进。这不仅仅是 API 的更替，更是从&quot;流式阻塞&quot;到&quot;缓冲区+事件驱动&quot;的编程范式变革。理解这一变革的底层逻辑，是构建高性能网络应用的基础。</p>
</blockquote>
<h2>一、传统 I/O（BIO）</h2>
<h3>1.1 流模型</h3>
<p>Java 传统 I/O 基于**流（Stream）**的抽象。数据像水流一样，从源端流向目的端，一次处理一个字节或一个字符。</p>
<p>流的分类体系：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>方向</td>
<td>InputStream / OutputStream</td>
<td>输入流 / 输出流</td>
</tr>
<tr>
<td>数据单位</td>
<td>字节流 / 字符流</td>
<td>二进制数据用字节流，文本数据用字符流</td>
</tr>
<tr>
<td>处理层级</td>
<td>节点流 / 处理流</td>
<td>节点流直连数据源，处理流包装节点流增加功能</td>
</tr>
</tbody></table>
<p>四个基础抽象类：</p>
<pre><code>字节流：InputStream  → FileInputStream, ByteArrayInputStream, ...
       OutputStream → FileOutputStream, ByteArrayOutputStream, ...

字符流：Reader → FileReader, InputStreamReader, BufferedReader, ...
       Writer → FileWriter, OutputStreamWriter, BufferedWriter, ...
</code></pre>
<h3>1.2 装饰器模式</h3>
<p>Java I/O 的设计大量使用<strong>装饰器模式（Decorator Pattern）</strong>——通过包装已有流来增加功能，而非通过继承。</p>
<pre><code class="language-java">// 裸的文件字节流 → 加缓冲 → 转字符流 → 加行读取
InputStream fis = new FileInputStream(&quot;data.txt&quot;);         // 节点流
InputStream bis = new BufferedInputStream(fis);             // +缓冲
Reader isr = new InputStreamReader(bis, &quot;UTF-8&quot;);           // +字节→字符转换
BufferedReader br = new BufferedReader(isr);                // +行读取

String line;
while ((line = br.readLine()) != null) {
    process(line);
}
</code></pre>
<p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 是字节流与字符流之间的<strong>桥接类</strong>，负责字符编码的转换。</p>
<h3>1.3 BIO 的网络模型</h3>
<p>BIO 的网络编程采用<strong>一连接一线程</strong>模型：</p>
<pre><code class="language-java">ServerSocket serverSocket = new ServerSocket(8080);
while (true) {
    Socket socket = serverSocket.accept();  // 阻塞等待连接
    new Thread(() -&gt; {
        InputStream in = socket.getInputStream();
        int data = in.read();  // 阻塞等待数据
        // 处理数据...
    }).start();
}
</code></pre>
<pre><code>客户端 1 ──→ 线程 1（阻塞读取）
客户端 2 ──→ 线程 2（阻塞读取）
客户端 3 ──→ 线程 3（阻塞读取）
...
客户端 N ──→ 线程 N（阻塞读取）
</code></pre>
<p><strong>BIO 的瓶颈</strong>：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>线程资源浪费</td>
<td>每个连接占用一个线程，大量连接 = 大量线程</td>
</tr>
<tr>
<td>线程上下文切换</td>
<td>线程数过多时，CPU 花费大量时间在线程切换上</td>
</tr>
<tr>
<td>不可扩展</td>
<td>受限于 OS 线程数上限，无法支撑万级连接</td>
</tr>
<tr>
<td>阻塞等待</td>
<td>线程在 <code>read()</code> 时阻塞，即使没有数据也占用线程</td>
</tr>
</tbody></table>
<p>当连接数达到数千级别时，BIO 模型基本无法满足性能要求。</p>
<h2>二、NIO 核心模型</h2>
<p>Java NIO（New I/O，JDK 1.4 引入）从根本上改变了 I/O 编程模型。其核心变革是：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>BIO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>数据操作对象</td>
<td>Stream（流）</td>
<td>Buffer（缓冲区）</td>
</tr>
<tr>
<td>数据读写方式</td>
<td>面向流，单向</td>
<td>面向缓冲区，通过 Channel 双向</td>
</tr>
<tr>
<td>阻塞模式</td>
<td>阻塞</td>
<td>支持非阻塞</td>
</tr>
<tr>
<td>多路复用</td>
<td>无</td>
<td>Selector（一个线程管理多个 Channel）</td>
</tr>
</tbody></table>
<h3>2.1 Buffer（缓冲区）</h3>
<p>Buffer 是 NIO 的数据容器。所有数据的读写都通过 Buffer 进行——Channel 读数据写入 Buffer，Channel 写数据从 Buffer 读取。</p>
<p><strong>核心属性</strong>：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>约束关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>capacity</strong></td>
<td>缓冲区总容量</td>
<td>创建后不可变</td>
</tr>
<tr>
<td><strong>position</strong></td>
<td>当前读/写位置</td>
<td>0 ≤ position ≤ limit</td>
</tr>
<tr>
<td><strong>limit</strong></td>
<td>可读/写的上限</td>
<td>position ≤ limit ≤ capacity</td>
</tr>
<tr>
<td><strong>mark</strong></td>
<td>标记位置，供 reset 回退</td>
<td>mark ≤ position</td>
</tr>
</tbody></table>
<p><strong>读写模式切换</strong>：</p>
<pre><code>写模式（初始状态）：
  position = 写入位置
  limit = capacity

    ┌─────────────────────────────────────┐
    │ data data data |                     │
    └─────────────────────────────────────┘
    0              pos                   cap/lim

调用 flip() 切换到读模式：
  limit = position（写了多少就能读多少）
  position = 0

    ┌─────────────────────────────────────┐
    │ data data data |                     │
    └─────────────────────────────────────┘
    0/pos          lim                   cap
</code></pre>
<p><strong>关键操作</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>position</th>
<th>limit</th>
</tr>
</thead>
<tbody><tr>
<td><code>flip()</code></td>
<td>写模式 → 读模式</td>
<td>→ 0</td>
<td>→ 原 position</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空缓冲区（不擦数据）</td>
<td>→ 0</td>
<td>→ capacity</td>
</tr>
<tr>
<td><code>compact()</code></td>
<td>压缩：未读数据移到头部</td>
<td>→ 剩余数据之后</td>
<td>→ capacity</td>
</tr>
<tr>
<td><code>rewind()</code></td>
<td>重新读取</td>
<td>→ 0</td>
<td>不变</td>
</tr>
<tr>
<td><code>mark()</code> / <code>reset()</code></td>
<td>标记 / 回退到标记位</td>
<td>reset 时 → mark</td>
<td>不变</td>
</tr>
</tbody></table>
<h3>2.2 Channel（通道）</h3>
<p>Channel 是 NIO 中数据传输的通道。与 Stream 的区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Stream</th>
<th>Channel</th>
</tr>
</thead>
<tbody><tr>
<td>方向</td>
<td>单向（InputStream 或 OutputStream）</td>
<td>双向（可读可写）</td>
</tr>
<tr>
<td>阻塞</td>
<td>始终阻塞</td>
<td>支持非阻塞模式</td>
</tr>
<tr>
<td>数据交互</td>
<td>直接读写字节/字符</td>
<td>必须通过 Buffer</td>
</tr>
<tr>
<td>零拷贝</td>
<td>不支持</td>
<td><code>transferTo()</code>/<code>transferFrom()</code></td>
</tr>
</tbody></table>
<p><strong>主要实现类</strong>：</p>
<table>
<thead>
<tr>
<th>Channel</th>
<th>用途</th>
<th>支持非阻塞</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileChannel</code></td>
<td>文件读写</td>
<td>否（文件 I/O 不支持非阻塞）</td>
</tr>
<tr>
<td><code>SocketChannel</code></td>
<td>TCP 客户端</td>
<td>是</td>
</tr>
<tr>
<td><code>ServerSocketChannel</code></td>
<td>TCP 服务端</td>
<td>是</td>
</tr>
<tr>
<td><code>DatagramChannel</code></td>
<td>UDP</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>Channel 间直接传输</strong>：</p>
<pre><code class="language-java">// 零拷贝：数据不经过用户空间，直接在内核中从源 Channel 传到目标 Channel
FileChannel source = new FileInputStream(&quot;source.dat&quot;).getChannel();
FileChannel target = new FileOutputStream(&quot;target.dat&quot;).getChannel();
source.transferTo(0, source.size(), target);
</code></pre>
<h3>2.3 Scatter / Gather</h3>
<p>NIO 支持将数据分散读取到多个 Buffer（Scatter）或从多个 Buffer 聚集写入一个 Channel（Gather）：</p>
<pre><code class="language-java">// Scatter Read：一次读取分散到多个 Buffer
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
channel.read(new ByteBuffer[]{header, body});
// 先填满 header，再填 body

// Gather Write：多个 Buffer 的数据聚集写入一个 Channel
channel.write(new ByteBuffer[]{header, body});
// 先写 header 中 position~limit 的数据，再写 body
</code></pre>
<p>适用场景：协议解析中 header 和 body 分开处理的场景。</p>
<h3>2.4 Selector（多路复用器）</h3>
<p>Selector 是 NIO 实现高并发的关键。它允许<strong>单个线程监控多个 Channel 的 I/O 事件</strong>，只有当 Channel 上有就绪事件时才进行处理。</p>
<p><strong>事件类型</strong>：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>SelectionKey 常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>连接就绪</td>
<td><code>OP_CONNECT</code></td>
<td>SocketChannel 完成连接</td>
</tr>
<tr>
<td>接收就绪</td>
<td><code>OP_ACCEPT</code></td>
<td>ServerSocketChannel 有新连接</td>
</tr>
<tr>
<td>读就绪</td>
<td><code>OP_READ</code></td>
<td>Channel 有数据可读</td>
</tr>
<tr>
<td>写就绪</td>
<td><code>OP_WRITE</code></td>
<td>Channel 可以写数据</td>
</tr>
</tbody></table>
<p><strong>Selector 工作流程</strong>：</p>
<pre><code class="language-java">Selector selector = Selector.open();

// 1. 注册 Channel 到 Selector
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.configureBlocking(false);
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

// 2. 事件循环
while (true) {
    selector.select();  // 阻塞直到有就绪事件
    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

    while (iter.hasNext()) {
        SelectionKey key = iter.next();

        if (key.isAcceptable()) {
            // 处理新连接
            SocketChannel client = serverChannel.accept();
            client.configureBlocking(false);
            client.register(selector, SelectionKey.OP_READ);
        } else if (key.isReadable()) {
            // 处理可读事件
            SocketChannel client = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            client.read(buffer);
            // 处理数据...
        }

        iter.remove();  // 必须手动移除已处理的 key
    }
}
</code></pre>
<p><strong>Selector 的本质</strong>：</p>
<p>在 Linux 上，<code>Selector.select()</code> 底层调用的是 <code>epoll</code>。epoll 是 Linux 内核提供的高性能 I/O 多路复用机制：</p>
<table>
<thead>
<tr>
<th>多路复用实现</th>
<th>时间复杂度</th>
<th>连接数限制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>select</code></td>
<td>O(n)</td>
<td>1024（FD_SETSIZE）</td>
<td>每次调用需拷贝全部 fd 集合</td>
</tr>
<tr>
<td><code>poll</code></td>
<td>O(n)</td>
<td>无限制</td>
<td>与 select 类似，但无 fd 数量限制</td>
</tr>
<tr>
<td><code>epoll</code></td>
<td>O(1)</td>
<td>无限制</td>
<td>事件驱动，仅返回就绪的 fd</td>
</tr>
</tbody></table>
<p>epoll 的高效源于<strong>事件回调机制</strong>：不再遍历所有 fd，而是内核在 fd 就绪时主动通知。</p>
<h2>三、NIO 网络模型 vs BIO 网络模型</h2>
<pre><code>BIO 模型（一连接一线程）：

  客户端 1 ──→ [线程 1] ──→ read() 阻塞等待
  客户端 2 ──→ [线程 2] ──→ read() 阻塞等待
  客户端 N ──→ [线程 N] ──→ read() 阻塞等待

  线程数 = 连接数（线性增长）


NIO 模型（Reactor / 多路复用）：

  客户端 1 ─┐
  客户端 2 ─┼─→ [Selector] ─→ [线程] ─→ 处理就绪事件
  客户端 N ─┘

  线程数 = 常量（1 个或少量线程处理所有连接）
</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>BIO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>线程模型</td>
<td>一连接一线程</td>
<td>一线程管理多连接</td>
</tr>
<tr>
<td>并发能力</td>
<td>受限于线程数（通常数千）</td>
<td>轻松支撑万级连接</td>
</tr>
<tr>
<td>CPU 利用率</td>
<td>线程大量时间在等待</td>
<td>仅在有事件时才处理</td>
</tr>
<tr>
<td>编程复杂度</td>
<td>简单直观</td>
<td>较高（状态机、Buffer 管理）</td>
</tr>
<tr>
<td>适用场景</td>
<td>连接数少、每个连接数据量大</td>
<td>连接数多、每个连接数据量小</td>
</tr>
</tbody></table>
<h2>四、Reactor 模式</h2>
<p>NIO 的 Selector 机制是 Reactor 模式的基础。Reactor 模式有三种经典变体：</p>
<h3>4.1 单 Reactor 单线程</h3>
<pre><code>所有 I/O 操作和业务处理在一个线程中完成：

  [Reactor 线程]
    → accept 新连接
    → read 数据
    → 处理业务
    → write 响应
</code></pre>
<p>优点：无线程切换开销。<br>缺点：无法利用多核，业务处理阻塞会导致其他连接无法响应。</p>
<h3>4.2 单 Reactor 多线程</h3>
<pre><code>Reactor 线程负责 I/O，业务处理分发到线程池：

  [Reactor 线程] → accept / read / write
        ↓ 分发
  [线程池] → 业务处理
</code></pre>
<p>优点：业务处理与 I/O 解耦。<br>缺点：单 Reactor 线程处理所有 I/O，高并发下可能成为瓶颈。</p>
<h3>4.3 主从 Reactor（Netty 采用的模型）</h3>
<pre><code>mainReactor 负责 accept，subReactor 负责 read/write：

  [mainReactor] → accept 新连接 → 分配给 subReactor
  [subReactor 1] → read / write（管理一部分连接）
  [subReactor 2] → read / write（管理一部分连接）
        ↓ 分发
  [业务线程池] → 业务处理
</code></pre>
<p>优点：accept 和 I/O 分离，多个 subReactor 可以利用多核，是高性能网络框架的标准模型。</p>
<p>Netty 的线程模型正是主从 Reactor 的实现：</p>
<table>
<thead>
<tr>
<th>Netty 概念</th>
<th>对应角色</th>
</tr>
</thead>
<tbody><tr>
<td><code>BossGroup</code></td>
<td>mainReactor（处理 accept）</td>
</tr>
<tr>
<td><code>WorkerGroup</code></td>
<td>subReactor（处理 read/write）</td>
</tr>
<tr>
<td><code>ChannelPipeline</code></td>
<td>I/O 事件的处理链</td>
</tr>
<tr>
<td><code>EventLoop</code></td>
<td>绑定到单线程的事件循环</td>
</tr>
</tbody></table>
<h2>五、NIO 的工程实践要点</h2>
<h3>5.1 Buffer 使用陷阱</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>忘记 <code>flip()</code></td>
<td>写完数据后直接读，position 在末尾导致读不到数据</td>
<td>读之前必须调用 <code>flip()</code></td>
</tr>
<tr>
<td><code>clear()</code> vs <code>compact()</code></td>
<td><code>clear()</code> 丢弃所有数据，<code>compact()</code> 保留未读数据</td>
<td>有未读数据时用 <code>compact()</code></td>
</tr>
<tr>
<td>半包/粘包</td>
<td>TCP 是流协议，一次读取可能不完整或包含多条消息</td>
<td>基于长度或分隔符的协议解析</td>
</tr>
</tbody></table>
<h3>5.2 Direct Buffer vs Heap Buffer</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>分配位置</th>
<th>分配速度</th>
<th>I/O 性能</th>
<th>GC 影响</th>
</tr>
</thead>
<tbody><tr>
<td>Heap Buffer</td>
<td>JVM 堆</td>
<td>快</td>
<td>需要一次额外拷贝</td>
<td>受 GC 管理</td>
</tr>
<tr>
<td>Direct Buffer</td>
<td>本地内存</td>
<td>慢</td>
<td>直接 I/O，减少拷贝</td>
<td>不受 GC 直接管理</td>
</tr>
</tbody></table>
<p><strong>使用建议</strong>：</p>
<ul>
<li>频繁分配/释放的小 Buffer → Heap Buffer</li>
<li>长期存活、用于 I/O 操作的大 Buffer → Direct Buffer</li>
<li>生产环境中使用 Direct Buffer 时需要注意内存泄漏（手动管理或使用池化机制）</li>
</ul>
<h3>5.3 Pipe：线程间通信</h3>
<p>NIO 提供了 <code>Pipe</code> 用于同一 JVM 内线程间的数据传输：</p>
<pre><code class="language-java">Pipe pipe = Pipe.open();

// 写线程
Pipe.SinkChannel sink = pipe.sink();
ByteBuffer buf = ByteBuffer.wrap(&quot;data&quot;.getBytes());
sink.write(buf);

// 读线程
Pipe.SourceChannel source = pipe.source();
ByteBuffer readBuf = ByteBuffer.allocate(1024);
source.read(readBuf);
</code></pre>
<h2>总结</h2>
<p>Java I/O 体系的演进反映了一个核心的架构思想：<strong>从同步阻塞到事件驱动，从资源换并发到复用换并发</strong>。</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>核心抽象</th>
<th>线程模型</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO</strong></td>
<td>Stream</td>
<td>一连接一线程</td>
<td>连接数少、数据量大（文件传输）</td>
</tr>
<tr>
<td><strong>NIO</strong></td>
<td>Channel + Buffer + Selector</td>
<td>多路复用</td>
<td>连接数多、数据量小（即时通讯、API 网关）</td>
</tr>
</tbody></table>
<p>关键认知：</p>
<ol>
<li><strong>NIO 不是比 BIO 快</strong>。在单连接大数据量传输场景下，BIO 的简单模型可能更高效</li>
<li><strong>NIO 的优势在于可扩展性</strong>。它能用极少的线程管理大量连接，这是 BIO 无法做到的</li>
<li><strong>生产环境不要裸写 NIO</strong>。直接使用 NIO API 编程极其复杂（半包处理、空轮询 bug、线程模型），应使用 Netty 等成熟框架</li>
</ol>
<blockquote>
<p>I/O 模型的选择不取决于哪个&quot;更先进&quot;，而取决于业务的连接模式和数据特征。理解底层模型的差异，才能做出正确的技术选型。</p>
</blockquote>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/7dd6b3ec14b0b1d8.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"kLuGQpYNrv7rzQ0jpQCVp\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"middleware\",\"Java%20IO%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8EBIO%E5%88%B0NIO%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8F%98%E9%9D%A9\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/middleware/Java%20IO%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8EBIO%E5%88%B0NIO%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8F%98%E9%9D%A9\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7dd6b3ec14b0b1d8.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/middleware/Java%20IO%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8EBIO%E5%88%B0NIO%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8F%98%E9%9D%A9\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"9S8HfmNqO92r0870832P2v\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n19:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T4726,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava I/O模型演进：从BIO到NIO的范式变革\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJava I/O 体系经历了从 BIO 到 NIO 再到 AIO 的演进。这不仅仅是 API 的更替，更是从\u0026quot;流式阻塞\u0026quot;到\u0026quot;缓冲区+事件驱动\u0026quot;的编程范式变革。理解这一变革的底层逻辑，是构建高性能网络应用的基础。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e一、传统 I/O（BIO）\u003c/h2\u003e\n\u003ch3\u003e1.1 流模型\u003c/h3\u003e\n\u003cp\u003eJava 传统 I/O 基于**流（Stream）**的抽象。数据像水流一样，从源端流向目的端，一次处理一个字节或一个字符。\u003c/p\u003e\n\u003cp\u003e流的分类体系：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003e分类\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e方向\u003c/td\u003e\n\u003ctd\u003eInputStream / OutputStream\u003c/td\u003e\n\u003ctd\u003e输入流 / 输出流\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据单位\u003c/td\u003e\n\u003ctd\u003e字节流 / 字符流\u003c/td\u003e\n\u003ctd\u003e二进制数据用字节流，文本数据用字符流\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e处理层级\u003c/td\u003e\n\u003ctd\u003e节点流 / 处理流\u003c/td\u003e\n\u003ctd\u003e节点流直连数据源，处理流包装节点流增加功能\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e四个基础抽象类：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e字节流：InputStream  → FileInputStream, ByteArrayInputStream, ...\n       OutputStream → FileOutputStream, ByteArrayOutputStream, ...\n\n字符流：Reader → FileReader, InputStreamReader, BufferedReader, ...\n       Writer → FileWriter, OutputStreamWriter, BufferedWriter, ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1.2 装饰器模式\u003c/h3\u003e\n\u003cp\u003eJava I/O 的设计大量使用\u003cstrong\u003e装饰器模式（Decorator Pattern）\u003c/strong\u003e——通过包装已有流来增加功能，而非通过继承。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 裸的文件字节流 → 加缓冲 → 转字符流 → 加行读取\nInputStream fis = new FileInputStream(\u0026quot;data.txt\u0026quot;);         // 节点流\nInputStream bis = new BufferedInputStream(fis);             // +缓冲\nReader isr = new InputStreamReader(bis, \u0026quot;UTF-8\u0026quot;);           // +字节→字符转换\nBufferedReader br = new BufferedReader(isr);                // +行读取\n\nString line;\nwhile ((line = br.readLine()) != null) {\n    process(line);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eInputStreamReader\u003c/code\u003e 和 \u003ccode\u003eOutputStreamWriter\u003c/code\u003e 是字节流与字符流之间的\u003cstrong\u003e桥接类\u003c/strong\u003e，负责字符编码的转换。\u003c/p\u003e\n\u003ch3\u003e1.3 BIO 的网络模型\u003c/h3\u003e\n\u003cp\u003eBIO 的网络编程采用\u003cstrong\u003e一连接一线程\u003c/strong\u003e模型：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eServerSocket serverSocket = new ServerSocket(8080);\nwhile (true) {\n    Socket socket = serverSocket.accept();  // 阻塞等待连接\n    new Thread(() -\u0026gt; {\n        InputStream in = socket.getInputStream();\n        int data = in.read();  // 阻塞等待数据\n        // 处理数据...\n    }).start();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e客户端 1 ──→ 线程 1（阻塞读取）\n客户端 2 ──→ 线程 2（阻塞读取）\n客户端 3 ──→ 线程 3（阻塞读取）\n...\n客户端 N ──→ 线程 N（阻塞读取）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBIO 的瓶颈\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e线程资源浪费\u003c/td\u003e\n\u003ctd\u003e每个连接占用一个线程，大量连接 = 大量线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程上下文切换\u003c/td\u003e\n\u003ctd\u003e线程数过多时，CPU 花费大量时间在线程切换上\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e不可扩展\u003c/td\u003e\n\u003ctd\u003e受限于 OS 线程数上限，无法支撑万级连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e阻塞等待\u003c/td\u003e\n\u003ctd\u003e线程在 \u003ccode\u003eread()\u003c/code\u003e 时阻塞，即使没有数据也占用线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当连接数达到数千级别时，BIO 模型基本无法满足性能要求。\u003c/p\u003e\n\u003ch2\u003e二、NIO 核心模型\u003c/h2\u003e\n\u003cp\u003eJava NIO（New I/O，JDK 1.4 引入）从根本上改变了 I/O 编程模型。其核心变革是：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003eBIO\u003c/th\u003e\n\u003cth\u003eNIO\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e数据操作对象\u003c/td\u003e\n\u003ctd\u003eStream（流）\u003c/td\u003e\n\u003ctd\u003eBuffer（缓冲区）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据读写方式\u003c/td\u003e\n\u003ctd\u003e面向流，单向\u003c/td\u003e\n\u003ctd\u003e面向缓冲区，通过 Channel 双向\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e阻塞模式\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e支持非阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多路复用\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eSelector（一个线程管理多个 Channel）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.1 Buffer（缓冲区）\u003c/h3\u003e\n\u003cp\u003eBuffer 是 NIO 的数据容器。所有数据的读写都通过 Buffer 进行——Channel 读数据写入 Buffer，Channel 写数据从 Buffer 读取。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e核心属性\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e约束关系\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003ecapacity\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e缓冲区总容量\u003c/td\u003e\n\u003ctd\u003e创建后不可变\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eposition\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前读/写位置\u003c/td\u003e\n\u003ctd\u003e0 ≤ position ≤ limit\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003elimit\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e可读/写的上限\u003c/td\u003e\n\u003ctd\u003eposition ≤ limit ≤ capacity\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003emark\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e标记位置，供 reset 回退\u003c/td\u003e\n\u003ctd\u003emark ≤ position\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e读写模式切换\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e写模式（初始状态）：\n  position = 写入位置\n  limit = capacity\n\n    ┌─────────────────────────────────────┐\n    │ data data data |                     │\n    └─────────────────────────────────────┘\n    0              pos                   cap/lim\n\n调用 flip() 切换到读模式：\n  limit = position（写了多少就能读多少）\n  position = 0\n\n    ┌─────────────────────────────────────┐\n    │ data data data |                     │\n    └─────────────────────────────────────┘\n    0/pos          lim                   cap\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e关键操作\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003cth\u003eposition\u003c/th\u003e\n\u003cth\u003elimit\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eflip()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e写模式 → 读模式\u003c/td\u003e\n\u003ctd\u003e→ 0\u003c/td\u003e\n\u003ctd\u003e→ 原 position\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eclear()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e清空缓冲区（不擦数据）\u003c/td\u003e\n\u003ctd\u003e→ 0\u003c/td\u003e\n\u003ctd\u003e→ capacity\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecompact()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e压缩：未读数据移到头部\u003c/td\u003e\n\u003ctd\u003e→ 剩余数据之后\u003c/td\u003e\n\u003ctd\u003e→ capacity\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003erewind()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e重新读取\u003c/td\u003e\n\u003ctd\u003e→ 0\u003c/td\u003e\n\u003ctd\u003e不变\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003emark()\u003c/code\u003e / \u003ccode\u003ereset()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e标记 / 回退到标记位\u003c/td\u003e\n\u003ctd\u003ereset 时 → mark\u003c/td\u003e\n\u003ctd\u003e不变\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.2 Channel（通道）\u003c/h3\u003e\n\u003cp\u003eChannel 是 NIO 中数据传输的通道。与 Stream 的区别：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003eStream\u003c/th\u003e\n\u003cth\u003eChannel\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e方向\u003c/td\u003e\n\u003ctd\u003e单向（InputStream 或 OutputStream）\u003c/td\u003e\n\u003ctd\u003e双向（可读可写）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e始终阻塞\u003c/td\u003e\n\u003ctd\u003e支持非阻塞模式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据交互\u003c/td\u003e\n\u003ctd\u003e直接读写字节/字符\u003c/td\u003e\n\u003ctd\u003e必须通过 Buffer\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e零拷贝\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003etransferTo()\u003c/code\u003e/\u003ccode\u003etransferFrom()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e主要实现类\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eChannel\u003c/th\u003e\n\u003cth\u003e用途\u003c/th\u003e\n\u003cth\u003e支持非阻塞\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eFileChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e文件读写\u003c/td\u003e\n\u003ctd\u003e否（文件 I/O 不支持非阻塞）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSocketChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTCP 客户端\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eServerSocketChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTCP 服务端\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eDatagramChannel\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eUDP\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eChannel 间直接传输\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 零拷贝：数据不经过用户空间，直接在内核中从源 Channel 传到目标 Channel\nFileChannel source = new FileInputStream(\u0026quot;source.dat\u0026quot;).getChannel();\nFileChannel target = new FileOutputStream(\u0026quot;target.dat\u0026quot;).getChannel();\nsource.transferTo(0, source.size(), target);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.3 Scatter / Gather\u003c/h3\u003e\n\u003cp\u003eNIO 支持将数据分散读取到多个 Buffer（Scatter）或从多个 Buffer 聚集写入一个 Channel（Gather）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Scatter Read：一次读取分散到多个 Buffer\nByteBuffer header = ByteBuffer.allocate(128);\nByteBuffer body   = ByteBuffer.allocate(1024);\nchannel.read(new ByteBuffer[]{header, body});\n// 先填满 header，再填 body\n\n// Gather Write：多个 Buffer 的数据聚集写入一个 Channel\nchannel.write(new ByteBuffer[]{header, body});\n// 先写 header 中 position~limit 的数据，再写 body\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e适用场景：协议解析中 header 和 body 分开处理的场景。\u003c/p\u003e\n\u003ch3\u003e2.4 Selector（多路复用器）\u003c/h3\u003e\n\u003cp\u003eSelector 是 NIO 实现高并发的关键。它允许\u003cstrong\u003e单个线程监控多个 Channel 的 I/O 事件\u003c/strong\u003e，只有当 Channel 上有就绪事件时才进行处理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e事件类型\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e事件\u003c/th\u003e\n\u003cth\u003eSelectionKey 常量\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e连接就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_CONNECT\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eSocketChannel 完成连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e接收就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_ACCEPT\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eServerSocketChannel 有新连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_READ\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eChannel 有数据可读\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写就绪\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOP_WRITE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eChannel 可以写数据\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eSelector 工作流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSelector selector = Selector.open();\n\n// 1. 注册 Channel 到 Selector\nServerSocketChannel serverChannel = ServerSocketChannel.open();\nserverChannel.configureBlocking(false);\nserverChannel.bind(new InetSocketAddress(8080));\nserverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n// 2. 事件循环\nwhile (true) {\n    selector.select();  // 阻塞直到有就绪事件\n    Set\u0026lt;SelectionKey\u0026gt; selectedKeys = selector.selectedKeys();\n    Iterator\u0026lt;SelectionKey\u0026gt; iter = selectedKeys.iterator();\n\n    while (iter.hasNext()) {\n        SelectionKey key = iter.next();\n\n        if (key.isAcceptable()) {\n            // 处理新连接\n            SocketChannel client = serverChannel.accept();\n            client.configureBlocking(false);\n            client.register(selector, SelectionKey.OP_READ);\n        } else if (key.isReadable()) {\n            // 处理可读事件\n            SocketChannel client = (SocketChannel) key.channel();\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            client.read(buffer);\n            // 处理数据...\n        }\n\n        iter.remove();  // 必须手动移除已处理的 key\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSelector 的本质\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 Linux 上，\u003ccode\u003eSelector.select()\u003c/code\u003e 底层调用的是 \u003ccode\u003eepoll\u003c/code\u003e。epoll 是 Linux 内核提供的高性能 I/O 多路复用机制：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e多路复用实现\u003c/th\u003e\n\u003cth\u003e时间复杂度\u003c/th\u003e\n\u003cth\u003e连接数限制\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eselect\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003e1024（FD_SETSIZE）\u003c/td\u003e\n\u003ctd\u003e每次调用需拷贝全部 fd 集合\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epoll\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eO(n)\u003c/td\u003e\n\u003ctd\u003e无限制\u003c/td\u003e\n\u003ctd\u003e与 select 类似，但无 fd 数量限制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eepoll\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eO(1)\u003c/td\u003e\n\u003ctd\u003e无限制\u003c/td\u003e\n\u003ctd\u003e事件驱动，仅返回就绪的 fd\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eepoll 的高效源于\u003cstrong\u003e事件回调机制\u003c/strong\u003e：不再遍历所有 fd，而是内核在 fd 就绪时主动通知。\u003c/p\u003e\n\u003ch2\u003e三、NIO 网络模型 vs BIO 网络模型\u003c/h2\u003e\n\u003cpre\u003e\u003ccode\u003eBIO 模型（一连接一线程）：\n\n  客户端 1 ──→ [线程 1] ──→ read() 阻塞等待\n  客户端 2 ──→ [线程 2] ──→ read() 阻塞等待\n  客户端 N ──→ [线程 N] ──→ read() 阻塞等待\n\n  线程数 = 连接数（线性增长）\n\n\nNIO 模型（Reactor / 多路复用）：\n\n  客户端 1 ─┐\n  客户端 2 ─┼─→ [Selector] ─→ [线程] ─→ 处理就绪事件\n  客户端 N ─┘\n\n  线程数 = 常量（1 个或少量线程处理所有连接）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003eBIO\u003c/th\u003e\n\u003cth\u003eNIO\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e线程模型\u003c/td\u003e\n\u003ctd\u003e一连接一线程\u003c/td\u003e\n\u003ctd\u003e一线程管理多连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e并发能力\u003c/td\u003e\n\u003ctd\u003e受限于线程数（通常数千）\u003c/td\u003e\n\u003ctd\u003e轻松支撑万级连接\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCPU 利用率\u003c/td\u003e\n\u003ctd\u003e线程大量时间在等待\u003c/td\u003e\n\u003ctd\u003e仅在有事件时才处理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e编程复杂度\u003c/td\u003e\n\u003ctd\u003e简单直观\u003c/td\u003e\n\u003ctd\u003e较高（状态机、Buffer 管理）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e适用场景\u003c/td\u003e\n\u003ctd\u003e连接数少、每个连接数据量大\u003c/td\u003e\n\u003ctd\u003e连接数多、每个连接数据量小\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e四、Reactor 模式\u003c/h2\u003e\n\u003cp\u003eNIO 的 Selector 机制是 Reactor 模式的基础。Reactor 模式有三种经典变体：\u003c/p\u003e\n\u003ch3\u003e4.1 单 Reactor 单线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e所有 I/O 操作和业务处理在一个线程中完成：\n\n  [Reactor 线程]\n    → accept 新连接\n    → read 数据\n    → 处理业务\n    → write 响应\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优点：无线程切换开销。\u003cbr\u003e缺点：无法利用多核，业务处理阻塞会导致其他连接无法响应。\u003c/p\u003e\n\u003ch3\u003e4.2 单 Reactor 多线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eReactor 线程负责 I/O，业务处理分发到线程池：\n\n  [Reactor 线程] → accept / read / write\n        ↓ 分发\n  [线程池] → 业务处理\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优点：业务处理与 I/O 解耦。\u003cbr\u003e缺点：单 Reactor 线程处理所有 I/O，高并发下可能成为瓶颈。\u003c/p\u003e\n\u003ch3\u003e4.3 主从 Reactor（Netty 采用的模型）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003emainReactor 负责 accept，subReactor 负责 read/write：\n\n  [mainReactor] → accept 新连接 → 分配给 subReactor\n  [subReactor 1] → read / write（管理一部分连接）\n  [subReactor 2] → read / write（管理一部分连接）\n        ↓ 分发\n  [业务线程池] → 业务处理\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e优点：accept 和 I/O 分离，多个 subReactor 可以利用多核，是高性能网络框架的标准模型。\u003c/p\u003e\n\u003cp\u003eNetty 的线程模型正是主从 Reactor 的实现：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eNetty 概念\u003c/th\u003e\n\u003cth\u003e对应角色\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eBossGroup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003emainReactor（处理 accept）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eWorkerGroup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003esubReactor（处理 read/write）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eChannelPipeline\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eI/O 事件的处理链\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eEventLoop\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e绑定到单线程的事件循环\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e五、NIO 的工程实践要点\u003c/h2\u003e\n\u003ch3\u003e5.1 Buffer 使用陷阱\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e解决方案\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e忘记 \u003ccode\u003eflip()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e写完数据后直接读，position 在末尾导致读不到数据\u003c/td\u003e\n\u003ctd\u003e读之前必须调用 \u003ccode\u003eflip()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eclear()\u003c/code\u003e vs \u003ccode\u003ecompact()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eclear()\u003c/code\u003e 丢弃所有数据，\u003ccode\u003ecompact()\u003c/code\u003e 保留未读数据\u003c/td\u003e\n\u003ctd\u003e有未读数据时用 \u003ccode\u003ecompact()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e半包/粘包\u003c/td\u003e\n\u003ctd\u003eTCP 是流协议，一次读取可能不完整或包含多条消息\u003c/td\u003e\n\u003ctd\u003e基于长度或分隔符的协议解析\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e5.2 Direct Buffer vs Heap Buffer\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e类型\u003c/th\u003e\n\u003cth\u003e分配位置\u003c/th\u003e\n\u003cth\u003e分配速度\u003c/th\u003e\n\u003cth\u003eI/O 性能\u003c/th\u003e\n\u003cth\u003eGC 影响\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eHeap Buffer\u003c/td\u003e\n\u003ctd\u003eJVM 堆\u003c/td\u003e\n\u003ctd\u003e快\u003c/td\u003e\n\u003ctd\u003e需要一次额外拷贝\u003c/td\u003e\n\u003ctd\u003e受 GC 管理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDirect Buffer\u003c/td\u003e\n\u003ctd\u003e本地内存\u003c/td\u003e\n\u003ctd\u003e慢\u003c/td\u003e\n\u003ctd\u003e直接 I/O，减少拷贝\u003c/td\u003e\n\u003ctd\u003e不受 GC 直接管理\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e使用建议\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e频繁分配/释放的小 Buffer → Heap Buffer\u003c/li\u003e\n\u003cli\u003e长期存活、用于 I/O 操作的大 Buffer → Direct Buffer\u003c/li\u003e\n\u003cli\u003e生产环境中使用 Direct Buffer 时需要注意内存泄漏（手动管理或使用池化机制）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e5.3 Pipe：线程间通信\u003c/h3\u003e\n\u003cp\u003eNIO 提供了 \u003ccode\u003ePipe\u003c/code\u003e 用于同一 JVM 内线程间的数据传输：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ePipe pipe = Pipe.open();\n\n// 写线程\nPipe.SinkChannel sink = pipe.sink();\nByteBuffer buf = ByteBuffer.wrap(\u0026quot;data\u0026quot;.getBytes());\nsink.write(buf);\n\n// 读线程\nPipe.SourceChannel source = pipe.source();\nByteBuffer readBuf = ByteBuffer.allocate(1024);\nsource.read(readBuf);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava I/O 体系的演进反映了一个核心的架构思想：\u003cstrong\u003e从同步阻塞到事件驱动，从资源换并发到复用换并发\u003c/strong\u003e。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模型\u003c/th\u003e\n\u003cth\u003e核心抽象\u003c/th\u003e\n\u003cth\u003e线程模型\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eBIO\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eStream\u003c/td\u003e\n\u003ctd\u003e一连接一线程\u003c/td\u003e\n\u003ctd\u003e连接数少、数据量大（文件传输）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eNIO\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eChannel + Buffer + Selector\u003c/td\u003e\n\u003ctd\u003e多路复用\u003c/td\u003e\n\u003ctd\u003e连接数多、数据量小（即时通讯、API 网关）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e关键认知：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eNIO 不是比 BIO 快\u003c/strong\u003e。在单连接大数据量传输场景下，BIO 的简单模型可能更高效\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNIO 的优势在于可扩展性\u003c/strong\u003e。它能用极少的线程管理大量连接，这是 BIO 无法做到的\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e生产环境不要裸写 NIO\u003c/strong\u003e。直接使用 NIO API 编程极其复杂（半包处理、空轮询 bug、线程模型），应使用 Netty 等成熟框架\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI/O 模型的选择不取决于哪个\u0026quot;更先进\u0026quot;，而取决于业务的连接模式和数据特征。理解底层模型的差异，才能做出正确的技术选型。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"17:T5439,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava并发编程：从内存模型到并发工具的设计哲学\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发编程的核心挑战不在于\u0026quot;如何让多个线程同时跑\u0026quot;，而在于\u0026quot;如何让多个线程正确地协作\u0026quot;。理解 Java 内存模型和并发工具的设计原理，是写出正确并发代码的前提。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e并发编程是 Java 工程师的核心能力之一。它涉及从硬件层面的缓存一致性，到语言层面的内存模型，再到 JUC 工具类的 API 设计，是一个纵深很大的知识领域。\u003c/p\u003e\n\u003cp\u003e本文将从底层原理出发，逐层构建 Java 并发编程的知识体系。\u003c/p\u003e\n\u003ch2\u003e一、硬件基础：CPU 缓存与一致性\u003c/h2\u003e\n\u003ch3\u003e1.1 为什么需要缓存\u003c/h3\u003e\n\u003cp\u003e现代 CPU 的运算速度远超主内存的读写速度（差距约 100 倍）。为了弥补这一差距，CPU 引入了多级缓存（L1/L2/L3 Cache）。每个核心拥有独立的 L1/L2 缓存，L3 缓存为所有核心共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCPU Core 0          CPU Core 1\n┌─────────┐        ┌─────────┐\n│ L1 Cache│        │ L1 Cache│\n│ L2 Cache│        │ L2 Cache│\n└────┬────┘        └────┬────┘\n     └────────┬─────────┘\n         L3 Cache（共享）\n              │\n         主内存（RAM）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缓存的引入解决了性能问题，但带来了新问题：\u003cstrong\u003e当多个核心各自缓存了同一块数据的副本，其中一个核心修改了数据，如何保证其他核心看到的是最新值？\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 MESI 缓存一致性协议\u003c/h3\u003e\n\u003cp\u003eMESI 是最广泛采用的缓存一致性协议，每个缓存行处于四种状态之一：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e状态\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e对主内存\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eM（Modified）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心修改了数据，与主内存不一致\u003c/td\u003e\n\u003ctd\u003e需要写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eE（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e当前核心独占数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eS（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e多个核心共享数据，与主内存一致\u003c/td\u003e\n\u003ctd\u003e无需写回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI（Invalid）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e缓存行无效\u003c/td\u003e\n\u003ctd\u003e需从主内存重新加载\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当 Core 0 修改了处于 S 状态的缓存行时：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCore 0 将缓存行状态改为 M\u003c/li\u003e\n\u003cli\u003e通过总线嗅探（Bus Snooping）通知其他核心\u003c/li\u003e\n\u003cli\u003e其他核心将对应缓存行标记为 I\u003c/li\u003e\n\u003cli\u003e其他核心下次读取该数据时，从 Core 0 的缓存或主内存重新加载\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e1.3 缓存行伪共享（False Sharing）\u003c/h3\u003e\n\u003cp\u003e缓存行是缓存操作的最小单位，大小通常为 \u003cstrong\u003e64 字节\u003c/strong\u003e。如果两个无关的变量恰好落在同一缓存行中，一个变量的修改会导致另一个变量的缓存行也失效——这就是伪共享。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 伪共享示例：head 和 tail 可能在同一缓存行\nclass Queue {\n    volatile long head;  // 生产者频繁修改\n    volatile long tail;  // 消费者频繁修改\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDoug Lea 在 \u003ccode\u003eLinkedTransferQueue\u003c/code\u003e 中的解决方案——填充字节使变量独占一个缓存行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// JDK 7 中的做法\nclass PaddedAtomicReference\u0026lt;T\u0026gt; extends AtomicReference\u0026lt;T\u0026gt; {\n    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;\n}\n\n// JDK 8+ 可以使用 @Contended 注解\n@sun.misc.Contended\nclass QueueNode {\n    volatile long value;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e二、Java 内存模型（JMM）\u003c/h2\u003e\n\u003ch3\u003e2.1 JMM 的抽象\u003c/h3\u003e\n\u003cp\u003eJava 内存模型（Java Memory Model）定义了\u003cstrong\u003e多线程如何通过共享内存进行通信\u003c/strong\u003e的规则。它并不描述具体的硬件实现，而是提供了一组抽象的可见性和有序性保证。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程 A 工作内存          线程 B 工作内存\n┌──────────────┐      ┌──────────────┐\n│  变量副本      │      │  变量副本      │\n└──────┬───────┘      └──────┬───────┘\n       │    save/load         │\n       └──────────┬───────────┘\n              主内存\n         ┌──────────────┐\n         │  共享变量      │\n         └──────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJMM 定义了 8 种内存交互操作：lock、unlock、read、load、use、assign、store、write。这些操作的组合规则保证了多线程程序的语义正确性。\u003c/p\u003e\n\u003ch3\u003e2.2 三大并发问题\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e问题\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e根源\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e可见性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程修改了变量，其他线程看不到最新值\u003c/td\u003e\n\u003ctd\u003eCPU 缓存导致各线程工作内存不一致\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e原子性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一组操作被中断导致中间状态暴露\u003c/td\u003e\n\u003ctd\u003e线程切换导致复合操作被打断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e有序性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e代码执行顺序与编写顺序不一致\u003c/td\u003e\n\u003ctd\u003e编译器优化、CPU 指令重排序\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e2.3 volatile 的语义与实现\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e 是 Java 中最轻量的同步机制，它提供两个保证：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e可见性\u003c/strong\u003e：对 volatile 变量的写操作对所有线程立即可见\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e有序性\u003c/strong\u003e：禁止指令重排序（通过内存屏障实现）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e但不保证原子性\u003c/strong\u003e：\u003ccode\u003evolatile int count; count++\u003c/code\u003e 并不是线程安全的，因为 \u003ccode\u003ecount++\u003c/code\u003e 是读-改-写三步操作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e硬件级实现\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e在 x86 架构上，对 volatile 变量的写操作会生成一条带 \u003cstrong\u003eLOCK 前缀\u003c/strong\u003e的指令。LOCK 前缀的作用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将当前处理器缓存行的数据写回主内存\u003c/li\u003e\n\u003cli\u003e使其他处理器中缓存该地址的缓存行失效（通过 MESI 协议）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e// JIT 编译后的汇编（x86）\n0x01a3de24: lock addl $0x0,(%esp)  // LOCK 前缀指令\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 P6 及更新的处理器上，LOCK 不再锁总线，而是\u003cstrong\u003e锁缓存行\u003c/strong\u003e（Cache Locking），性能开销远小于总线锁。\u003c/p\u003e\n\u003ch3\u003e2.4 happens-before 规则\u003c/h3\u003e\n\u003cp\u003eJMM 通过 \u003cstrong\u003ehappens-before\u003c/strong\u003e 关系定义了操作间的可见性保证。如果操作 A happens-before 操作 B，则 A 的结果对 B 可见。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e规则\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e程序顺序规则\u003c/td\u003e\n\u003ctd\u003e同一线程中的操作，前面的 happens-before 后面的\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003evolatile 规则\u003c/td\u003e\n\u003ctd\u003evolatile 写 happens-before 后续的 volatile 读\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁规则\u003c/td\u003e\n\u003ctd\u003eunlock happens-before 后续对同一锁的 lock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e传递性\u003c/td\u003e\n\u003ctd\u003e如果 A hb B，B hb C，则 A hb C\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程启动规则\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eThread.start()\u003c/code\u003e happens-before 该线程的每个动作\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e线程终止规则\u003c/td\u003e\n\u003ctd\u003e线程的所有动作 happens-before 其他线程检测到该线程终止\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e三、锁机制\u003c/h2\u003e\n\u003ch3\u003e3.1 synchronized vs Lock\u003c/h3\u003e\n\u003cp\u003eJava 提供两种锁机制：内置锁（\u003ccode\u003esynchronized\u003c/code\u003e）和显式锁（\u003ccode\u003ejava.util.concurrent.locks.Lock\u003c/code\u003e）。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003esynchronized\u003c/th\u003e\n\u003cth\u003eLock\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e实现层面\u003c/td\u003e\n\u003ctd\u003eJVM 内置（monitorenter/monitorexit）\u003c/td\u003e\n\u003ctd\u003eJava API 层（基于 AQS）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁获取\u003c/td\u003e\n\u003ctd\u003e阻塞式，不可中断\u003c/td\u003e\n\u003ctd\u003e支持非阻塞 \u003ccode\u003etryLock()\u003c/code\u003e、可中断 \u003ccode\u003elockInterruptibly()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁释放\u003c/td\u003e\n\u003ctd\u003e自动释放（退出同步块）\u003c/td\u003e\n\u003ctd\u003e必须在 \u003ccode\u003efinally\u003c/code\u003e 中手动 \u003ccode\u003eunlock()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e条件等待\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eObject.wait()/notify()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCondition.await()/signal()\u003c/code\u003e，支持多条件队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平性\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eReentrantLock(true)\u003c/code\u003e 支持公平锁\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e锁状态查询\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eisLocked()\u003c/code\u003e、\u003ccode\u003egetHoldCount()\u003c/code\u003e 等\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e选择原则\u003c/strong\u003e：优先使用 \u003ccode\u003esynchronized\u003c/code\u003e（JVM 持续优化，且不会忘记释放锁）；需要高级特性（超时、中断、多条件、公平性）时选择 \u003ccode\u003eLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e3.2 Condition：精确的线程协作\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCondition\u003c/code\u003e 是 \u003ccode\u003eLock\u003c/code\u003e 的配套组件，它替代了 \u003ccode\u003eObject.wait()/notify()\u003c/code\u003e 机制，最大的优势是\u003cstrong\u003e支持多个等待队列\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 使用 Object 的 wait/notify：只有一个等待队列，notifyAll 会唤醒所有线程\n// 使用 Condition：可以创建多个条件队列，signal 只唤醒特定队列中的线程\n\nReentrantLock lock = new ReentrantLock();\nCondition notFull  = lock.newCondition();  // 生产者等待队列\nCondition notEmpty = lock.newCondition();  // 消费者等待队列\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e有界缓冲区实现\u003c/strong\u003e（经典的生产者-消费者模型）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eclass BoundedBuffer\u0026lt;E\u0026gt; {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n    final Object[] items = new Object[100];\n    int putIndex, takeIndex, count;\n\n    public void put(E e) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();      // 缓冲区满，生产者等待\n            items[putIndex] = e;\n            if (++putIndex == items.length) putIndex = 0;\n            ++count;\n            notEmpty.signal();        // 通知消费者\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();     // 缓冲区空，消费者等待\n            E e = (E) items[takeIndex];\n            if (++takeIndex == items.length) takeIndex = 0;\n            --count;\n            notFull.signal();         // 通知生产者\n            return e;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意 \u003ccode\u003eawait()\u003c/code\u003e 必须在 \u003ccode\u003ewhile\u003c/code\u003e 循环中调用，以防止\u003cstrong\u003e虚假唤醒（Spurious Wakeup）\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e3.3 ReadWriteLock：读写分离\u003c/h3\u003e\n\u003cp\u003e当读操作远多于写操作时，使用排他锁会严重限制并发度。\u003ccode\u003eReadWriteLock\u003c/code\u003e 允许多个线程同时持有读锁，但写锁是排他的。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁状态\u003c/th\u003e\n\u003cth\u003e读锁请求\u003c/th\u003e\n\u003cth\u003e写锁请求\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e无锁\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003ctd\u003e允许\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读锁已持有\u003c/td\u003e\n\u003ctd\u003e允许（共享）\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写锁已持有\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003ctd\u003e阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e 的设计决策：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e写锁可降级为读锁\u003c/strong\u003e：持有写锁的线程可以再获取读锁，然后释放写锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e读锁不可升级为写锁\u003c/strong\u003e：防止死锁（多个读线程同时尝试升级会互相等待）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e支持公平/非公平模式\u003c/strong\u003e：非公平模式下，读锁可能\u0026quot;插队\u0026quot;导致写线程饥饿\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e四、JUC 并发工具类\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ejava.util.concurrent\u003c/code\u003e 包提供了一组高级同步工具，用于解决常见的线程协调问题。\u003c/p\u003e\n\u003ch3\u003e4.1 CountDownLatch：一次性倒计数门闩\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一个或多个线程等待其他线程完成一组操作后再继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCountDownLatch latch = new CountDownLatch(3);  // 计数器初始值 3\n\n// 工作线程\nexecutor.submit(() -\u0026gt; {\n    doTask();\n    latch.countDown();  // 计数器 -1\n});\n\n// 等待线程\nlatch.await();  // 阻塞直到计数器归零\n// 所有任务完成，继续执行\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e一次性\u003c/strong\u003e：计数器归零后无法重置\u003c/li\u003e\n\u003cli\u003e底层基于 AQS 的共享模式实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e典型场景\u003c/strong\u003e：服务启动时等待所有依赖组件初始化完成。\u003c/p\u003e\n\u003ch3\u003e4.2 CyclicBarrier：可重用的屏障\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：一组线程互相等待，直到所有线程都到达屏障点，然后同时继续执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCyclicBarrier barrier = new CyclicBarrier(3, () -\u0026gt; {\n    System.out.println(\u0026quot;所有线程到齐，开始下一阶段\u0026quot;);  // barrierAction\n});\n\n// 每个工作线程\nexecutor.submit(() -\u0026gt; {\n    doPhase1();\n    barrier.await();  // 等待其他线程\n    doPhase2();\n    barrier.await();  // 可以重复使用\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e可重用\u003c/strong\u003e：所有线程通过屏障后，计数器自动重置\u003c/li\u003e\n\u003cli\u003e支持 \u003cstrong\u003ebarrierAction\u003c/strong\u003e：所有线程到齐时执行的回调\u003c/li\u003e\n\u003cli\u003e如果某个线程等待超时或被中断，屏障进入 \u003cstrong\u003eBroken\u003c/strong\u003e 状态，所有等待线程收到 \u003ccode\u003eBrokenBarrierException\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.3 Semaphore：信号量\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e语义\u003c/strong\u003e：控制同时访问某个资源的线程数量。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSemaphore semaphore = new Semaphore(5);  // 最多 5 个并发\n\nexecutor.submit(() -\u0026gt; {\n    semaphore.acquire();    // 获取许可（可用许可 -1）\n    try {\n        accessResource();\n    } finally {\n        semaphore.release();  // 释放许可（可用许可 +1）\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e核心特征\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e支持\u003cstrong\u003e公平/非公平\u003c/strong\u003e模式\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etryAcquire()\u003c/code\u003e 提供非阻塞获取\u003c/li\u003e\n\u003cli\u003e许可数量可以动态增减（\u003ccode\u003erelease()\u003c/code\u003e 可以在未 \u003ccode\u003eacquire()\u003c/code\u003e 的情况下调用）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e4.4 三者对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e核心语义\u003c/th\u003e\n\u003cth\u003e是否可重用\u003c/th\u003e\n\u003cth\u003e计数方向\u003c/th\u003e\n\u003cth\u003e典型场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e一个线程等待 N 个线程\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e递减至 0\u003c/td\u003e\n\u003ctd\u003e主线程等待子任务完成\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCyclicBarrier\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eN 个线程互相等待\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e递增至 N\u003c/td\u003e\n\u003ctd\u003e多阶段并行计算\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e控制并发访问数量\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003ctd\u003e许可的获取与释放\u003c/td\u003e\n\u003ctd\u003e限流、资源池\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e五、生产者-消费者模式\u003c/h2\u003e\n\u003cp\u003e生产者-消费者是并发编程中最经典的协作模式。Java 提供了从底层到高层的多种实现方式。\u003c/p\u003e\n\u003ch3\u003e5.1 三种实现方式对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现方式\u003c/th\u003e\n\u003cth\u003e同步机制\u003c/th\u003e\n\u003cth\u003e通知粒度\u003c/th\u003e\n\u003cth\u003e复杂度\u003c/th\u003e\n\u003cth\u003e推荐度\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003esynchronized + wait/notify\u003c/td\u003e\n\u003ctd\u003e内置锁\u003c/td\u003e\n\u003ctd\u003e全量唤醒（notifyAll）\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e一般\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eLock + Condition\u003c/td\u003e\n\u003ctd\u003e显式锁\u003c/td\u003e\n\u003ctd\u003e精确唤醒（signal）\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBlockingQueue\u003c/td\u003e\n\u003ctd\u003e封装在队列内部\u003c/td\u003e\n\u003ctd\u003e内部自动处理\u003c/td\u003e\n\u003ctd\u003e最低\u003c/td\u003e\n\u003ctd\u003e最推荐\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e为什么 BlockingQueue 是最佳选择\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBlockingQueue\u003c/code\u003e 将同步、等待、通知的逻辑完全封装在 \u003ccode\u003eput()\u003c/code\u003e/\u003ccode\u003etake()\u003c/code\u003e 方法内部，调用方无需关心并发细节：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eBlockingQueue\u0026lt;Task\u0026gt; queue = new ArrayBlockingQueue\u0026lt;\u0026gt;(100);\n\n// 生产者\nqueue.put(task);   // 队列满时自动阻塞\n\n// 消费者\nTask task = queue.take();  // 队列空时自动阻塞\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5.2 BlockingQueue 的实现选型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e实现类\u003c/th\u003e\n\u003cth\u003e底层结构\u003c/th\u003e\n\u003cth\u003e是否有界\u003c/th\u003e\n\u003cth\u003e锁策略\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eArrayBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e数组\u003c/td\u003e\n\u003ctd\u003e有界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e通用场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e链表\u003c/td\u003e\n\u003ctd\u003e可选有界\u003c/td\u003e\n\u003ctd\u003e读写分离锁\u003c/td\u003e\n\u003ctd\u003e吞吐量要求高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSynchronousQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e无容量\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eCAS\u003c/td\u003e\n\u003ctd\u003e直接传递（线程池默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ePriorityBlockingQueue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e堆\u003c/td\u003e\n\u003ctd\u003e无界\u003c/td\u003e\n\u003ctd\u003e单锁\u003c/td\u003e\n\u003ctd\u003e优先级调度\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e六、线程池\u003c/h2\u003e\n\u003ch3\u003e6.1 ThreadPoolExecutor 核心参数\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ThreadPoolExecutor(\n    corePoolSize,      // 核心线程数\n    maximumPoolSize,   // 最大线程数\n    keepAliveTime,     // 非核心线程空闲存活时间\n    TimeUnit.SECONDS,\n    workQueue,         // 任务队列\n    threadFactory,     // 线程工厂\n    rejectedHandler    // 拒绝策略\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e任务提交流程\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e提交任务\n  → 当前线程数 \u0026lt; corePoolSize？        → 创建核心线程执行\n  → 任务队列未满？                      → 入队等待\n  → 当前线程数 \u0026lt; maximumPoolSize？      → 创建非核心线程执行\n  → 以上都不满足                        → 执行拒绝策略\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2 拒绝策略\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e策略\u003c/th\u003e\n\u003cth\u003e行为\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eAbortPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e抛出 \u003ccode\u003eRejectedExecutionException\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e默认策略，适合需要感知过载的场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCallerRunsPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e由提交线程自己执行任务\u003c/td\u003e\n\u003ctd\u003e反压效果，但可能导致提交线程阻塞\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e静默丢弃任务\u003c/td\u003e\n\u003ctd\u003e允许丢失的场景（如日志）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDiscardOldestPolicy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e丢弃队列中最旧的任务\u003c/td\u003e\n\u003ctd\u003e实时性要求高、可接受旧数据丢失\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e6.3 生产阻塞型线程池\u003c/h3\u003e\n\u003cp\u003e标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 使用 \u003ccode\u003eBlockingQueue.offer()\u003c/code\u003e（非阻塞）入队。队列满时不会阻塞提交线程，而是触发拒绝策略。\u003c/p\u003e\n\u003cp\u003e在某些场景下（如需要严格的背压机制），需要让提交线程在队列满时\u003cstrong\u003e阻塞等待\u003c/strong\u003e而非被拒绝。可通过自定义拒绝策略实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThreadPoolExecutor executor = new ThreadPoolExecutor(\n    coreSize, maxSize, 60, TimeUnit.SECONDS,\n    new LinkedBlockingQueue\u0026lt;\u0026gt;(capacity),\n    (runnable, pool) -\u0026gt; {\n        try {\n            // 队列满时，put() 会阻塞提交线程\n            pool.getQueue().put(runnable);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式的优势在于：复用 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 的线程管理能力，同时实现了生产者阻塞语义，避免了手工管理线程的复杂性。\u003c/p\u003e\n\u003ch3\u003e6.4 线程池配置最佳实践\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e任务类型\u003c/th\u003e\n\u003cth\u003e核心线程数建议\u003c/th\u003e\n\u003cth\u003e队列选择\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCPU 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu + 1\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e小容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eI/O 密集型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eN_cpu × 2\u003c/code\u003e 或更高\u003c/td\u003e\n\u003ctd\u003e较大容量有界队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e混合型\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e拆分为 CPU 池和 I/O 池\u003c/td\u003e\n\u003ctd\u003e各自独立配置\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e关键原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e永远不要使用无界队列\u003c/strong\u003e：\u003ccode\u003eExecutors.newFixedThreadPool()\u003c/code\u003e 默认使用无界的 \u003ccode\u003eLinkedBlockingQueue\u003c/code\u003e，可能导致 OOM\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e为线程池命名\u003c/strong\u003e：自定义 \u003ccode\u003eThreadFactory\u003c/code\u003e，给线程添加有意义的名称前缀，便于排查问题\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控队列深度\u003c/strong\u003e：线程池队列持续增长是系统过载的信号\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava 并发编程的知识体系可以沿着三个层次理解：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e硬件层\u003c/strong\u003e：CPU 缓存、MESI 协议、缓存行伪共享——这是并发问题的物理根源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模型层\u003c/strong\u003e：JMM、happens-before、volatile/synchronized 语义——这是 Java 对硬件差异的抽象屏蔽\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工具层\u003c/strong\u003e：Lock/Condition、CountDownLatch/CyclicBarrier/Semaphore、BlockingQueue、ThreadPoolExecutor——这是面向工程的并发编程基础设施\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e并发工具的选择不在于功能的强大，而在于语义的匹配。\u003ccode\u003esynchronized\u003c/code\u003e 足以解决大多数问题；\u003ccode\u003eBlockingQueue\u003c/code\u003e 比手动的 wait/notify 更安全；标准 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 比自定义线程管理更可靠。优先选择高层抽象，只在确有需要时才下沉到底层机制。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"18:T4347,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava字节码增强实战：从原理到ByteBuddy工程应用\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e字节码增强是 Java 生态中一项\u0026quot;隐藏\u0026quot;的核心技术。Spring AOP、Hibernate 延迟加载、Mockito 测试框架、SkyWalking 链路追踪——这些工具的底层都依赖字节码操作。理解这项技术，就理解了 Java 动态能力的基石。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e一、字节码增强技术全景\u003c/h2\u003e\n\u003ch3\u003e1.1 什么是字节码增强\u003c/h3\u003e\n\u003cp\u003eJava 源码经过 \u003ccode\u003ejavac\u003c/code\u003e 编译后生成 \u003ccode\u003e.class\u003c/code\u003e 字节码文件。字节码增强（Bytecode Enhancement / Instrumentation）是指在不修改源码的前提下，\u003cstrong\u003e通过直接操作字节码来改变类的行为\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e操作时机可以是：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e编译时：编译后修改 .class 文件\n加载时：通过 Java Agent 在 ClassLoader 加载类时修改字节码\n运行时：在程序运行过程中动态生成新类\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1.2 技术选型对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003e抽象层级\u003c/th\u003e\n\u003cth\u003e性能\u003c/th\u003e\n\u003cth\u003e学习成本\u003c/th\u003e\n\u003cth\u003e维护状态\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eASM\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e指令级（直接操作 JVM 指令）\u003c/td\u003e\n\u003ctd\u003e最高\u003c/td\u003e\n\u003ctd\u003e高（需了解字节码指令集）\u003c/td\u003e\n\u003ctd\u003e活跃\u003c/td\u003e\n\u003ctd\u003e极致性能要求、底层框架开发\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eJavassist\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e源码级（用字符串写 Java 代码）\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e维护中\u003c/td\u003e\n\u003ctd\u003e快速原型、简单场景\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003ecglib\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eAPI 级（基于 ASM 封装）\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e停止维护\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e历史遗留项目\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eByteBuddy\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eAPI 级（类型安全的 DSL）\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e中\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e活跃\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e新项目首选\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e关键决策因素\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJava 17+ 兼容性\u003c/strong\u003e：Java 17 引入强封装（Strong Encapsulation），cglib 依赖的 \u003ccode\u003esun.misc.Unsafe\u003c/code\u003e 和内部 API 被限制访问，导致 cglib 在现代 JDK 上\u003cstrong\u003e无法正常工作\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eByteBuddy 是 cglib 的官方替代方案\u003c/strong\u003e：Spring Framework 6 / Spring Boot 3 已将底层代理从 cglib 切换为 ByteBuddy\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eASM 适合框架开发者\u003c/strong\u003e：如果你在开发 APM 工具或编译器插件，ASM 的指令级控制是必要的；否则 ByteBuddy 的高层 API 更高效\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e1.3 动态代理的两种路径\u003c/h3\u003e\n\u003cp\u003eJava 标准库提供的 \u003ccode\u003ejava.lang.reflect.Proxy\u003c/code\u003e 只能代理接口。对于类的代理，需要字节码增强工具。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方式\u003c/th\u003e\n\u003cth\u003e原理\u003c/th\u003e\n\u003cth\u003e限制\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eJDK 动态代理\u003c/td\u003e\n\u003ctd\u003e运行时生成接口的实现类\u003c/td\u003e\n\u003ctd\u003e只能代理接口\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e字节码增强代理\u003c/td\u003e\n\u003ctd\u003e运行时生成目标类的子类\u003c/td\u003e\n\u003ctd\u003e无法代理 \u003ccode\u003efinal\u003c/code\u003e 类/方法\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e二、ByteBuddy 核心概念\u003c/h2\u003e\n\u003ch3\u003e2.1 三种类操作模式\u003c/h3\u003e\n\u003cp\u003eByteBuddy 提供三种操作已有类的方式：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e原方法处理\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSubclass\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esubclass()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留（继承）\u003c/td\u003e\n\u003ctd\u003e创建代理类、扩展功能\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRebase\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003erebase()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留（重命名为 private）\u003c/td\u003e\n\u003ctd\u003e修改类行为但保留原逻辑可调用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRedefine\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eredefine()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e丢弃\u003c/td\u003e\n\u003ctd\u003e完全替换方法实现\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Subclass：生成 Foo 的子类\nnew ByteBuddy()\n    .subclass(Foo.class)\n    .method(named(\u0026quot;bar\u0026quot;))\n    .intercept(FixedValue.value(\u0026quot;intercepted\u0026quot;))\n    .make();\n\n// Rebase：修改 Foo 的 bar 方法，原方法被重命名保留\nnew ByteBuddy()\n    .rebase(Foo.class)\n    .method(named(\u0026quot;bar\u0026quot;))\n    .intercept(MethodDelegation.to(Interceptor.class))\n    .make();\n\n// Redefine：直接替换 bar 方法，原实现丢失\nnew ByteBuddy()\n    .redefine(Foo.class)\n    .method(named(\u0026quot;bar\u0026quot;))\n    .intercept(FixedValue.value(\u0026quot;replaced\u0026quot;))\n    .make();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRebase vs Redefine 的关键区别\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003eRebase 会将原方法重命名为一个 private synthetic 方法（如 \u003ccode\u003ebar$original$xxx\u003c/code\u003e），拦截器中可以通过 \u003ccode\u003e@SuperCall\u003c/code\u003e 调用原始逻辑。Redefine 则彻底丢弃原方法实现。\u003c/p\u003e\n\u003ch3\u003e2.2 DynamicType 生命周期\u003c/h3\u003e\n\u003cp\u003eByteBuddy 生成的类经历两个阶段：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eUnloaded（未加载）\n  ↓  ClassLoadingStrategy\nLoaded（已加载）→ 可通过反射或直接调用使用\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e加载策略\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e策略\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e使用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eWRAPPER\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e创建新的 ClassLoader 包装加载\u003c/td\u003e\n\u003ctd\u003e默认策略，隔离性好\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCHILD_FIRST\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e子优先加载（打破双亲委派）\u003c/td\u003e\n\u003ctd\u003e需要覆盖已有类时\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eINJECTION\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e注入到已有 ClassLoader\u003c/td\u003e\n\u003ctd\u003e需要与目标类在同一 ClassLoader\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eClass\u0026lt;?\u0026gt; loaded = new ByteBuddy()\n    .subclass(Object.class)\n    .name(\u0026quot;com.example.Generated\u0026quot;)\n    .make()\n    .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n    .getLoaded();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2.3 方法匹配（ElementMatchers）\u003c/h3\u003e\n\u003cp\u003eByteBuddy 提供丰富的方法匹配器，用于精确选择需要拦截的方法：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 按名称匹配\nnamed(\u0026quot;toString\u0026quot;)\nnameContains(\u0026quot;get\u0026quot;)\nnameStartsWith(\u0026quot;set\u0026quot;)\n\n// 按返回类型\nreturns(String.class)\nreturns(TypeDescription.VOID)\n\n// 按修饰符\nisPublic()\nisAnnotatedWith(Override.class)\n\n// 组合匹配\nnamed(\u0026quot;execute\u0026quot;).and(returns(void.class))\nnamed(\u0026quot;get\u0026quot;).or(named(\u0026quot;set\u0026quot;))\nnot(named(\u0026quot;hashCode\u0026quot;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e三、方法拦截与委托\u003c/h2\u003e\n\u003cp\u003e方法拦截是 ByteBuddy 最核心的能力。\u003c/p\u003e\n\u003ch3\u003e3.1 FixedValue：返回固定值\u003c/h3\u003e\n\u003cp\u003e最简单的拦截方式，直接返回一个预设值：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .subclass(Foo.class)\n    .method(named(\u0026quot;getName\u0026quot;))\n    .intercept(FixedValue.value(\u0026quot;ByteBuddy\u0026quot;))\n    .make();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.2 MethodDelegation：方法委托\u003c/h3\u003e\n\u003cp\u003e将方法调用委托给一个拦截器类（或实例）。ByteBuddy 通过\u003cstrong\u003e注解\u003c/strong\u003e来定义参数绑定规则：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TimingInterceptor {\n    @RuntimeType\n    public static Object intercept(\n            @Origin Method method,        // 被拦截的原方法\n            @AllArguments Object[] args,   // 所有参数\n            @SuperCall Callable\u0026lt;?\u0026gt; zuper   // 原方法的调用\n    ) throws Exception {\n        long start = System.nanoTime();\n        try {\n            return zuper.call();  // 调用原方法\n        } finally {\n            long elapsed = System.nanoTime() - start;\n            System.out.println(method.getName() + \u0026quot; took \u0026quot; + elapsed + \u0026quot;ns\u0026quot;);\n        }\n    }\n}\n\n// 应用拦截器\nnew ByteBuddy()\n    .subclass(TargetService.class)\n    .method(isPublic())\n    .intercept(MethodDelegation.to(TimingInterceptor.class))\n    .make();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.3 参数绑定注解体系\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e注解\u003c/th\u003e\n\u003cth\u003e绑定内容\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@This\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e被代理对象实例\u003c/td\u003e\n\u003ctd\u003e类似 AOP 中的 \u003ccode\u003ethis\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@Super\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e父类类型的代理实例\u003c/td\u003e\n\u003ctd\u003e可调用父类方法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@Origin\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e被拦截的 \u003ccode\u003eMethod\u003c/code\u003e / \u003ccode\u003eConstructor\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e反射元信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@AllArguments\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e所有参数（Object[]）\u003c/td\u003e\n\u003ctd\u003e参数列表\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@Argument(n)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e第 n 个参数\u003c/td\u003e\n\u003ctd\u003e精确参数获取\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@SuperCall\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e原方法的 \u003ccode\u003eCallable\u003c/code\u003e/\u003ccode\u003eRunnable\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e调用原始逻辑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@RuntimeType\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e允许运行时类型转换\u003c/td\u003e\n\u003ctd\u003e标注在方法上，支持泛型返回值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@FieldValue(\u0026quot;name\u0026quot;)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e指定字段的值\u003c/td\u003e\n\u003ctd\u003e读取被代理对象的字段\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@Morph\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e可修改参数的原方法调用\u003c/td\u003e\n\u003ctd\u003e比 \u003ccode\u003e@SuperCall\u003c/code\u003e 更灵活\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@Empty\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e返回类型的默认值\u003c/td\u003e\n\u003ctd\u003e数值返回 0，对象返回 null\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@StubValue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e桩值\u003c/td\u003e\n\u003ctd\u003e类似 \u003ccode\u003e@Empty\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e@Morph\u003c/code\u003e 的使用场景\u003c/strong\u003e——需要修改参数再调用原方法时：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MorphInterceptor {\n    @RuntimeType\n    public static Object intercept(\n            @Morph MorphCallable zuper,\n            @AllArguments Object[] args\n    ) {\n        args[0] = ((String) args[0]).toUpperCase();  // 修改参数\n        return zuper.call(args);  // 用修改后的参数调用原方法\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用 \u003ccode\u003e@Morph\u003c/code\u003e 时需要安装绑定：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMethodDelegation.to(MorphInterceptor.class)\n    .appendParameterBinder(Morph.Binder.install(MorphCallable.class))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.4 构造函数拦截\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .subclass(Target.class)\n    .constructor(any())\n    .intercept(SuperMethodCall.INSTANCE.andThen(\n        MethodDelegation.to(ConstructorInterceptor.class)\n    ))\n    .make();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eSuperMethodCall.INSTANCE\u003c/code\u003e 确保先执行父类构造函数，\u003ccode\u003eandThen\u003c/code\u003e 链接后续的拦截逻辑。\u003c/p\u003e\n\u003ch2\u003e四、工程实践\u003c/h2\u003e\n\u003ch3\u003e4.1 Java Agent：加载时增强\u003c/h3\u003e\n\u003cp\u003eJava Agent 是 JVM 提供的在类加载时修改字节码的标准机制。ByteBuddy 提供了 \u003ccode\u003eAgentBuilder\u003c/code\u003e 简化 Agent 开发：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyAgent {\n    public static void premain(String args, Instrumentation inst) {\n        new AgentBuilder.Default()\n            .type(nameStartsWith(\u0026quot;com.example.service\u0026quot;))\n            .transform((builder, type, classLoader, module, domain) -\u0026gt;\n                builder.method(isPublic())\n                       .intercept(MethodDelegation.to(TimingInterceptor.class))\n            )\n            .installOn(inst);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgent 的打包需要在 \u003ccode\u003eMANIFEST.MF\u003c/code\u003e 中声明：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePremain-Class: com.example.MyAgent\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启动参数：\u003ccode\u003ejava -javaagent:my-agent.jar -jar app.jar\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e4.2 代理类缓存\u003c/h3\u003e\n\u003cp\u003eByteBuddy 每次调用 \u003ccode\u003emake()\u003c/code\u003e 都会生成一个新类。在高频创建代理的场景下，应使用 \u003ccode\u003eTypeCache\u003c/code\u003e 缓存已生成的类：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eTypeCache\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; cache = new TypeCache\u0026lt;\u0026gt;(TypeCache.Sort.SOFT);\n\nClass\u0026lt;?\u0026gt; proxyClass = cache.findOrInsert(\n    classLoader,\n    targetClass,\n    () -\u0026gt; new ByteBuddy()\n        .subclass(targetClass)\n        .method(isPublic())\n        .intercept(MethodDelegation.to(interceptor))\n        .make()\n        .load(classLoader)\n        .getLoaded()\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4.3 从 cglib 迁移到 ByteBuddy\u003c/h3\u003e\n\u003cp\u003eJava 17 的强封装机制导致 cglib 无法正常工作。以下是常见的迁移对照：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003ecglib 用法\u003c/th\u003e\n\u003cth\u003eByteBuddy 等价方案\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eEnhancer\u003c/code\u003e + \u003ccode\u003eMethodInterceptor\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esubclass()\u003c/code\u003e + \u003ccode\u003eMethodDelegation\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eBeanGenerator\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esubclass(Object.class)\u003c/code\u003e + \u003ccode\u003edefineField()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eBeanCopier\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003esubclass()\u003c/code\u003e + 自定义 copy 方法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eFixedValue\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eFixedValue.value()\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003ecglib 的代理创建\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eEnhancer enhancer = new Enhancer();\nenhancer.setSuperclass(TargetClass.class);\nenhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -\u0026gt; {\n    // 前置逻辑\n    Object result = proxy.invokeSuper(obj, args);\n    // 后置逻辑\n    return result;\n});\nTargetClass proxy = (TargetClass) enhancer.create();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eByteBuddy 的等价实现\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eClass\u0026lt;? extends TargetClass\u0026gt; proxyClass = new ByteBuddy()\n    .subclass(TargetClass.class)\n    .method(isPublic())\n    .intercept(MethodDelegation.to(new GeneralInterceptor()))\n    .make()\n    .load(TargetClass.class.getClassLoader())\n    .getLoaded();\n\nTargetClass proxy = proxyClass.getDeclaredConstructor().newInstance();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class GeneralInterceptor {\n    @RuntimeType\n    public Object intercept(\n            @This Object self,\n            @Origin Method method,\n            @AllArguments Object[] args,\n            @SuperMethod Method superMethod\n    ) throws Throwable {\n        // 前置逻辑\n        Object result = superMethod.invoke(self, args);\n        // 后置逻辑\n        return result;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4.4 运行时创建 Annotation 实例\u003c/h3\u003e\n\u003cp\u003e某些场景需要在运行时动态创建注解实例（如框架中需要将注解加入集合进行比较）。注解在 Java 中本质是接口，可以通过匿名类实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMyAnnotation annotation = new MyAnnotation() {\n    @Override\n    public String value() { return \u0026quot;dynamic\u0026quot;; }\n\n    @Override\n    public Class\u0026lt;? extends Annotation\u0026gt; annotationType() {\n        return MyAnnotation.class;\n    }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更健壮的方案是使用 \u003ccode\u003eProxy\u003c/code\u003e 动态代理：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMyAnnotation annotation = (MyAnnotation) Proxy.newProxyInstance(\n    MyAnnotation.class.getClassLoader(),\n    new Class[]{MyAnnotation.class},\n    (proxy, method, args) -\u0026gt; {\n        if (\u0026quot;value\u0026quot;.equals(method.getName())) return \u0026quot;dynamic\u0026quot;;\n        if (\u0026quot;annotationType\u0026quot;.equals(method.getName())) return MyAnnotation.class;\n        // equals/hashCode 需按 Annotation 规范实现\n        throw new UnsupportedOperationException(method.getName());\n    }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e五、编译时增强：Build Plugin\u003c/h2\u003e\n\u003cp\u003e除了运行时增强，ByteBuddy 还支持\u003cstrong\u003e编译时增强\u003c/strong\u003e——在 Maven/Gradle 构建阶段直接修改 .class 文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;plugin\u0026gt;\n    \u0026lt;groupId\u0026gt;net.bytebuddy\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;byte-buddy-maven-plugin\u0026lt;/artifactId\u0026gt;\n    \u0026lt;executions\u0026gt;\n        \u0026lt;execution\u0026gt;\n            \u0026lt;goals\u0026gt;\u0026lt;goal\u0026gt;transform\u0026lt;/goal\u0026gt;\u0026lt;/goals\u0026gt;\n        \u0026lt;/execution\u0026gt;\n    \u0026lt;/executions\u0026gt;\n    \u0026lt;configuration\u0026gt;\n        \u0026lt;transformations\u0026gt;\n            \u0026lt;transformation\u0026gt;\n                \u0026lt;plugin\u0026gt;com.example.MyBuildPlugin\u0026lt;/plugin\u0026gt;\n            \u0026lt;/transformation\u0026gt;\n        \u0026lt;/transformations\u0026gt;\n    \u0026lt;/configuration\u0026gt;\n\u0026lt;/plugin\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e编译时增强的优势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e无运行时开销\u003c/strong\u003e：类在编译时已被修改，运行时无需生成子类\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可以修改 final 类/方法\u003c/strong\u003e：因为是直接修改 .class 文件，不受子类化限制\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e启动速度更快\u003c/strong\u003e：省去了运行时字节码生成的耗时\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e字节码增强技术是 Java 生态中\u0026quot;不可见但无处不在\u0026quot;的基础能力。核心要点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e工具选型\u003c/strong\u003e：新项目首选 ByteBuddy，它是 cglib 的官方替代方案，与现代 JDK 完全兼容\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e三种模式\u003c/strong\u003e：\u003ccode\u003esubclass\u003c/code\u003e 用于代理，\u003ccode\u003erebase\u003c/code\u003e 用于保留原逻辑的增强，\u003ccode\u003eredefine\u003c/code\u003e 用于完全替换\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e注解驱动的委托机制\u003c/strong\u003e是 ByteBuddy 的核心设计——通过 \u003ccode\u003e@This\u003c/code\u003e、\u003ccode\u003e@Origin\u003c/code\u003e、\u003ccode\u003e@SuperCall\u003c/code\u003e 等注解声明式地绑定拦截器参数\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e工程层面\u003c/strong\u003e：生产环境务必使用 \u003ccode\u003eTypeCache\u003c/code\u003e 缓存代理类；优先考虑编译时增强以消除运行时开销\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e字节码增强不是\u0026quot;黑魔法\u0026quot;，而是 Java 类型系统的合理扩展。理解它，是从\u0026quot;使用框架\u0026quot;到\u0026quot;理解框架\u0026quot;的关键一步。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/middleware/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"中间件\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2022-04-18\",\"children\":\"2022年04月18日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"Java I/O模型演进：从BIO到NIO的范式变革\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}],[\"$\",\"$L13\",\"NIO\",{\"href\":\"/blog/tag/NIO/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"NIO\"}],[\"$\",\"$L13\",\"I/O\",{\"href\":\"/blog/tag/I%2FO/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"I/O\"}],[\"$\",\"$L13\",\"Netty\",{\"href\":\"/blog/tag/Netty/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Netty\"}],[\"$\",\"$L13\",\"网络编程\",{\"href\":\"/blog/tag/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"网络编程\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/middleware/Java并发编程：从内存模型到并发工具的设计哲学\",\"title\":\"Java并发编程：从内存模型到并发工具的设计哲学\",\"description\":\"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。\",\"pubDate\":\"2021-11-20\",\"tags\":[\"Java\",\"并发编程\",\"JMM\",\"JUC\",\"线程池\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/middleware/Java字节码增强实战：从原理到ByteBuddy工程应用\",\"title\":\"Java字节码增强实战：从原理到ByteBuddy工程应用\",\"description\":\"全面解析Java字节码增强技术体系，对比ASM、Javassist、cglib、ByteBuddy四大工具的定位与取舍，深入ByteBuddy的核心API——类创建、方法拦截、注解驱动委托，并结合Java Agent与cglib迁移等工程场景展开实战。\",\"pubDate\":\"2022-10-25\",\"tags\":[\"Java\",\"ByteBuddy\",\"字节码\",\"动态代理\",\"Java Agent\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"Java\":{\"prev\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"NIO\":{\"prev\":null,\"next\":null},\"I/O\":{\"prev\":null,\"next\":null},\"Netty\":{\"prev\":null,\"next\":null},\"网络编程\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L19\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Java I/O模型演进：从BIO到NIO的范式变革 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Java I/O模型演进：从BIO到NIO的范式变革\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2022-04-18\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Java I/O模型演进：从BIO到NIO的范式变革\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
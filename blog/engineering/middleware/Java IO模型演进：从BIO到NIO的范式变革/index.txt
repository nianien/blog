1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ab9f9bc568942ddd.css","style"]
0:{"P":null,"b":"CEV2RmJ4qYe381pMG-_gT","p":"","c":["","blog","engineering","middleware","Java%20IO%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8EBIO%E5%88%B0NIO%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8F%98%E9%9D%A9",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/middleware/Java%20IO%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8EBIO%E5%88%B0NIO%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8F%98%E9%9D%A9","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ab9f9bc568942ddd.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/middleware/Java%20IO%E6%A8%A1%E5%9E%8B%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%8EBIO%E5%88%B0NIO%E7%9A%84%E8%8C%83%E5%BC%8F%E5%8F%98%E9%9D%A9","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","DSAyUVimR_04aTOq9sBW-v",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
19:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T4726,<h1>Java I/O模型演进：从BIO到NIO的范式变革</h1>
<blockquote>
<p>Java I/O 体系经历了从 BIO 到 NIO 再到 AIO 的演进。这不仅仅是 API 的更替，更是从&quot;流式阻塞&quot;到&quot;缓冲区+事件驱动&quot;的编程范式变革。理解这一变革的底层逻辑，是构建高性能网络应用的基础。</p>
</blockquote>
<h2>一、传统 I/O（BIO）</h2>
<h3>1.1 流模型</h3>
<p>Java 传统 I/O 基于**流（Stream）**的抽象。数据像水流一样，从源端流向目的端，一次处理一个字节或一个字符。</p>
<p>流的分类体系：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>分类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>方向</td>
<td>InputStream / OutputStream</td>
<td>输入流 / 输出流</td>
</tr>
<tr>
<td>数据单位</td>
<td>字节流 / 字符流</td>
<td>二进制数据用字节流，文本数据用字符流</td>
</tr>
<tr>
<td>处理层级</td>
<td>节点流 / 处理流</td>
<td>节点流直连数据源，处理流包装节点流增加功能</td>
</tr>
</tbody></table>
<p>四个基础抽象类：</p>
<pre><code>字节流：InputStream  → FileInputStream, ByteArrayInputStream, ...
       OutputStream → FileOutputStream, ByteArrayOutputStream, ...

字符流：Reader → FileReader, InputStreamReader, BufferedReader, ...
       Writer → FileWriter, OutputStreamWriter, BufferedWriter, ...
</code></pre>
<h3>1.2 装饰器模式</h3>
<p>Java I/O 的设计大量使用<strong>装饰器模式（Decorator Pattern）</strong>——通过包装已有流来增加功能，而非通过继承。</p>
<pre><code class="language-java">// 裸的文件字节流 → 加缓冲 → 转字符流 → 加行读取
InputStream fis = new FileInputStream(&quot;data.txt&quot;);         // 节点流
InputStream bis = new BufferedInputStream(fis);             // +缓冲
Reader isr = new InputStreamReader(bis, &quot;UTF-8&quot;);           // +字节→字符转换
BufferedReader br = new BufferedReader(isr);                // +行读取

String line;
while ((line = br.readLine()) != null) {
    process(line);
}
</code></pre>
<p><code>InputStreamReader</code> 和 <code>OutputStreamWriter</code> 是字节流与字符流之间的<strong>桥接类</strong>，负责字符编码的转换。</p>
<h3>1.3 BIO 的网络模型</h3>
<p>BIO 的网络编程采用<strong>一连接一线程</strong>模型：</p>
<pre><code class="language-java">ServerSocket serverSocket = new ServerSocket(8080);
while (true) {
    Socket socket = serverSocket.accept();  // 阻塞等待连接
    new Thread(() -&gt; {
        InputStream in = socket.getInputStream();
        int data = in.read();  // 阻塞等待数据
        // 处理数据...
    }).start();
}
</code></pre>
<pre><code>客户端 1 ──→ 线程 1（阻塞读取）
客户端 2 ──→ 线程 2（阻塞读取）
客户端 3 ──→ 线程 3（阻塞读取）
...
客户端 N ──→ 线程 N（阻塞读取）
</code></pre>
<p><strong>BIO 的瓶颈</strong>：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>线程资源浪费</td>
<td>每个连接占用一个线程，大量连接 = 大量线程</td>
</tr>
<tr>
<td>线程上下文切换</td>
<td>线程数过多时，CPU 花费大量时间在线程切换上</td>
</tr>
<tr>
<td>不可扩展</td>
<td>受限于 OS 线程数上限，无法支撑万级连接</td>
</tr>
<tr>
<td>阻塞等待</td>
<td>线程在 <code>read()</code> 时阻塞，即使没有数据也占用线程</td>
</tr>
</tbody></table>
<p>当连接数达到数千级别时，BIO 模型基本无法满足性能要求。</p>
<h2>二、NIO 核心模型</h2>
<p>Java NIO（New I/O，JDK 1.4 引入）从根本上改变了 I/O 编程模型。其核心变革是：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>BIO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>数据操作对象</td>
<td>Stream（流）</td>
<td>Buffer（缓冲区）</td>
</tr>
<tr>
<td>数据读写方式</td>
<td>面向流，单向</td>
<td>面向缓冲区，通过 Channel 双向</td>
</tr>
<tr>
<td>阻塞模式</td>
<td>阻塞</td>
<td>支持非阻塞</td>
</tr>
<tr>
<td>多路复用</td>
<td>无</td>
<td>Selector（一个线程管理多个 Channel）</td>
</tr>
</tbody></table>
<h3>2.1 Buffer（缓冲区）</h3>
<p>Buffer 是 NIO 的数据容器。所有数据的读写都通过 Buffer 进行——Channel 读数据写入 Buffer，Channel 写数据从 Buffer 读取。</p>
<p><strong>核心属性</strong>：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>约束关系</th>
</tr>
</thead>
<tbody><tr>
<td><strong>capacity</strong></td>
<td>缓冲区总容量</td>
<td>创建后不可变</td>
</tr>
<tr>
<td><strong>position</strong></td>
<td>当前读/写位置</td>
<td>0 ≤ position ≤ limit</td>
</tr>
<tr>
<td><strong>limit</strong></td>
<td>可读/写的上限</td>
<td>position ≤ limit ≤ capacity</td>
</tr>
<tr>
<td><strong>mark</strong></td>
<td>标记位置，供 reset 回退</td>
<td>mark ≤ position</td>
</tr>
</tbody></table>
<p><strong>读写模式切换</strong>：</p>
<pre><code>写模式（初始状态）：
  position = 写入位置
  limit = capacity

    ┌─────────────────────────────────────┐
    │ data data data |                     │
    └─────────────────────────────────────┘
    0              pos                   cap/lim

调用 flip() 切换到读模式：
  limit = position（写了多少就能读多少）
  position = 0

    ┌─────────────────────────────────────┐
    │ data data data |                     │
    └─────────────────────────────────────┘
    0/pos          lim                   cap
</code></pre>
<p><strong>关键操作</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>position</th>
<th>limit</th>
</tr>
</thead>
<tbody><tr>
<td><code>flip()</code></td>
<td>写模式 → 读模式</td>
<td>→ 0</td>
<td>→ 原 position</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空缓冲区（不擦数据）</td>
<td>→ 0</td>
<td>→ capacity</td>
</tr>
<tr>
<td><code>compact()</code></td>
<td>压缩：未读数据移到头部</td>
<td>→ 剩余数据之后</td>
<td>→ capacity</td>
</tr>
<tr>
<td><code>rewind()</code></td>
<td>重新读取</td>
<td>→ 0</td>
<td>不变</td>
</tr>
<tr>
<td><code>mark()</code> / <code>reset()</code></td>
<td>标记 / 回退到标记位</td>
<td>reset 时 → mark</td>
<td>不变</td>
</tr>
</tbody></table>
<h3>2.2 Channel（通道）</h3>
<p>Channel 是 NIO 中数据传输的通道。与 Stream 的区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Stream</th>
<th>Channel</th>
</tr>
</thead>
<tbody><tr>
<td>方向</td>
<td>单向（InputStream 或 OutputStream）</td>
<td>双向（可读可写）</td>
</tr>
<tr>
<td>阻塞</td>
<td>始终阻塞</td>
<td>支持非阻塞模式</td>
</tr>
<tr>
<td>数据交互</td>
<td>直接读写字节/字符</td>
<td>必须通过 Buffer</td>
</tr>
<tr>
<td>零拷贝</td>
<td>不支持</td>
<td><code>transferTo()</code>/<code>transferFrom()</code></td>
</tr>
</tbody></table>
<p><strong>主要实现类</strong>：</p>
<table>
<thead>
<tr>
<th>Channel</th>
<th>用途</th>
<th>支持非阻塞</th>
</tr>
</thead>
<tbody><tr>
<td><code>FileChannel</code></td>
<td>文件读写</td>
<td>否（文件 I/O 不支持非阻塞）</td>
</tr>
<tr>
<td><code>SocketChannel</code></td>
<td>TCP 客户端</td>
<td>是</td>
</tr>
<tr>
<td><code>ServerSocketChannel</code></td>
<td>TCP 服务端</td>
<td>是</td>
</tr>
<tr>
<td><code>DatagramChannel</code></td>
<td>UDP</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>Channel 间直接传输</strong>：</p>
<pre><code class="language-java">// 零拷贝：数据不经过用户空间，直接在内核中从源 Channel 传到目标 Channel
FileChannel source = new FileInputStream(&quot;source.dat&quot;).getChannel();
FileChannel target = new FileOutputStream(&quot;target.dat&quot;).getChannel();
source.transferTo(0, source.size(), target);
</code></pre>
<h3>2.3 Scatter / Gather</h3>
<p>NIO 支持将数据分散读取到多个 Buffer（Scatter）或从多个 Buffer 聚集写入一个 Channel（Gather）：</p>
<pre><code class="language-java">// Scatter Read：一次读取分散到多个 Buffer
ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body   = ByteBuffer.allocate(1024);
channel.read(new ByteBuffer[]{header, body});
// 先填满 header，再填 body

// Gather Write：多个 Buffer 的数据聚集写入一个 Channel
channel.write(new ByteBuffer[]{header, body});
// 先写 header 中 position~limit 的数据，再写 body
</code></pre>
<p>适用场景：协议解析中 header 和 body 分开处理的场景。</p>
<h3>2.4 Selector（多路复用器）</h3>
<p>Selector 是 NIO 实现高并发的关键。它允许<strong>单个线程监控多个 Channel 的 I/O 事件</strong>，只有当 Channel 上有就绪事件时才进行处理。</p>
<p><strong>事件类型</strong>：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>SelectionKey 常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>连接就绪</td>
<td><code>OP_CONNECT</code></td>
<td>SocketChannel 完成连接</td>
</tr>
<tr>
<td>接收就绪</td>
<td><code>OP_ACCEPT</code></td>
<td>ServerSocketChannel 有新连接</td>
</tr>
<tr>
<td>读就绪</td>
<td><code>OP_READ</code></td>
<td>Channel 有数据可读</td>
</tr>
<tr>
<td>写就绪</td>
<td><code>OP_WRITE</code></td>
<td>Channel 可以写数据</td>
</tr>
</tbody></table>
<p><strong>Selector 工作流程</strong>：</p>
<pre><code class="language-java">Selector selector = Selector.open();

// 1. 注册 Channel 到 Selector
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.configureBlocking(false);
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

// 2. 事件循环
while (true) {
    selector.select();  // 阻塞直到有就绪事件
    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();
    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();

    while (iter.hasNext()) {
        SelectionKey key = iter.next();

        if (key.isAcceptable()) {
            // 处理新连接
            SocketChannel client = serverChannel.accept();
            client.configureBlocking(false);
            client.register(selector, SelectionKey.OP_READ);
        } else if (key.isReadable()) {
            // 处理可读事件
            SocketChannel client = (SocketChannel) key.channel();
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            client.read(buffer);
            // 处理数据...
        }

        iter.remove();  // 必须手动移除已处理的 key
    }
}
</code></pre>
<p><strong>Selector 的本质</strong>：</p>
<p>在 Linux 上，<code>Selector.select()</code> 底层调用的是 <code>epoll</code>。epoll 是 Linux 内核提供的高性能 I/O 多路复用机制：</p>
<table>
<thead>
<tr>
<th>多路复用实现</th>
<th>时间复杂度</th>
<th>连接数限制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>select</code></td>
<td>O(n)</td>
<td>1024（FD_SETSIZE）</td>
<td>每次调用需拷贝全部 fd 集合</td>
</tr>
<tr>
<td><code>poll</code></td>
<td>O(n)</td>
<td>无限制</td>
<td>与 select 类似，但无 fd 数量限制</td>
</tr>
<tr>
<td><code>epoll</code></td>
<td>O(1)</td>
<td>无限制</td>
<td>事件驱动，仅返回就绪的 fd</td>
</tr>
</tbody></table>
<p>epoll 的高效源于<strong>事件回调机制</strong>：不再遍历所有 fd，而是内核在 fd 就绪时主动通知。</p>
<h2>三、NIO 网络模型 vs BIO 网络模型</h2>
<pre><code>BIO 模型（一连接一线程）：

  客户端 1 ──→ [线程 1] ──→ read() 阻塞等待
  客户端 2 ──→ [线程 2] ──→ read() 阻塞等待
  客户端 N ──→ [线程 N] ──→ read() 阻塞等待

  线程数 = 连接数（线性增长）


NIO 模型（Reactor / 多路复用）：

  客户端 1 ─┐
  客户端 2 ─┼─→ [Selector] ─→ [线程] ─→ 处理就绪事件
  客户端 N ─┘

  线程数 = 常量（1 个或少量线程处理所有连接）
</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>BIO</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>线程模型</td>
<td>一连接一线程</td>
<td>一线程管理多连接</td>
</tr>
<tr>
<td>并发能力</td>
<td>受限于线程数（通常数千）</td>
<td>轻松支撑万级连接</td>
</tr>
<tr>
<td>CPU 利用率</td>
<td>线程大量时间在等待</td>
<td>仅在有事件时才处理</td>
</tr>
<tr>
<td>编程复杂度</td>
<td>简单直观</td>
<td>较高（状态机、Buffer 管理）</td>
</tr>
<tr>
<td>适用场景</td>
<td>连接数少、每个连接数据量大</td>
<td>连接数多、每个连接数据量小</td>
</tr>
</tbody></table>
<h2>四、Reactor 模式</h2>
<p>NIO 的 Selector 机制是 Reactor 模式的基础。Reactor 模式有三种经典变体：</p>
<h3>4.1 单 Reactor 单线程</h3>
<pre><code>所有 I/O 操作和业务处理在一个线程中完成：

  [Reactor 线程]
    → accept 新连接
    → read 数据
    → 处理业务
    → write 响应
</code></pre>
<p>优点：无线程切换开销。<br>缺点：无法利用多核，业务处理阻塞会导致其他连接无法响应。</p>
<h3>4.2 单 Reactor 多线程</h3>
<pre><code>Reactor 线程负责 I/O，业务处理分发到线程池：

  [Reactor 线程] → accept / read / write
        ↓ 分发
  [线程池] → 业务处理
</code></pre>
<p>优点：业务处理与 I/O 解耦。<br>缺点：单 Reactor 线程处理所有 I/O，高并发下可能成为瓶颈。</p>
<h3>4.3 主从 Reactor（Netty 采用的模型）</h3>
<pre><code>mainReactor 负责 accept，subReactor 负责 read/write：

  [mainReactor] → accept 新连接 → 分配给 subReactor
  [subReactor 1] → read / write（管理一部分连接）
  [subReactor 2] → read / write（管理一部分连接）
        ↓ 分发
  [业务线程池] → 业务处理
</code></pre>
<p>优点：accept 和 I/O 分离，多个 subReactor 可以利用多核，是高性能网络框架的标准模型。</p>
<p>Netty 的线程模型正是主从 Reactor 的实现：</p>
<table>
<thead>
<tr>
<th>Netty 概念</th>
<th>对应角色</th>
</tr>
</thead>
<tbody><tr>
<td><code>BossGroup</code></td>
<td>mainReactor（处理 accept）</td>
</tr>
<tr>
<td><code>WorkerGroup</code></td>
<td>subReactor（处理 read/write）</td>
</tr>
<tr>
<td><code>ChannelPipeline</code></td>
<td>I/O 事件的处理链</td>
</tr>
<tr>
<td><code>EventLoop</code></td>
<td>绑定到单线程的事件循环</td>
</tr>
</tbody></table>
<h2>五、NIO 的工程实践要点</h2>
<h3>5.1 Buffer 使用陷阱</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>忘记 <code>flip()</code></td>
<td>写完数据后直接读，position 在末尾导致读不到数据</td>
<td>读之前必须调用 <code>flip()</code></td>
</tr>
<tr>
<td><code>clear()</code> vs <code>compact()</code></td>
<td><code>clear()</code> 丢弃所有数据，<code>compact()</code> 保留未读数据</td>
<td>有未读数据时用 <code>compact()</code></td>
</tr>
<tr>
<td>半包/粘包</td>
<td>TCP 是流协议，一次读取可能不完整或包含多条消息</td>
<td>基于长度或分隔符的协议解析</td>
</tr>
</tbody></table>
<h3>5.2 Direct Buffer vs Heap Buffer</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>分配位置</th>
<th>分配速度</th>
<th>I/O 性能</th>
<th>GC 影响</th>
</tr>
</thead>
<tbody><tr>
<td>Heap Buffer</td>
<td>JVM 堆</td>
<td>快</td>
<td>需要一次额外拷贝</td>
<td>受 GC 管理</td>
</tr>
<tr>
<td>Direct Buffer</td>
<td>本地内存</td>
<td>慢</td>
<td>直接 I/O，减少拷贝</td>
<td>不受 GC 直接管理</td>
</tr>
</tbody></table>
<p><strong>使用建议</strong>：</p>
<ul>
<li>频繁分配/释放的小 Buffer → Heap Buffer</li>
<li>长期存活、用于 I/O 操作的大 Buffer → Direct Buffer</li>
<li>生产环境中使用 Direct Buffer 时需要注意内存泄漏（手动管理或使用池化机制）</li>
</ul>
<h3>5.3 Pipe：线程间通信</h3>
<p>NIO 提供了 <code>Pipe</code> 用于同一 JVM 内线程间的数据传输：</p>
<pre><code class="language-java">Pipe pipe = Pipe.open();

// 写线程
Pipe.SinkChannel sink = pipe.sink();
ByteBuffer buf = ByteBuffer.wrap(&quot;data&quot;.getBytes());
sink.write(buf);

// 读线程
Pipe.SourceChannel source = pipe.source();
ByteBuffer readBuf = ByteBuffer.allocate(1024);
source.read(readBuf);
</code></pre>
<h2>总结</h2>
<p>Java I/O 体系的演进反映了一个核心的架构思想：<strong>从同步阻塞到事件驱动，从资源换并发到复用换并发</strong>。</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>核心抽象</th>
<th>线程模型</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BIO</strong></td>
<td>Stream</td>
<td>一连接一线程</td>
<td>连接数少、数据量大（文件传输）</td>
</tr>
<tr>
<td><strong>NIO</strong></td>
<td>Channel + Buffer + Selector</td>
<td>多路复用</td>
<td>连接数多、数据量小（即时通讯、API 网关）</td>
</tr>
</tbody></table>
<p>关键认知：</p>
<ol>
<li><strong>NIO 不是比 BIO 快</strong>。在单连接大数据量传输场景下，BIO 的简单模型可能更高效</li>
<li><strong>NIO 的优势在于可扩展性</strong>。它能用极少的线程管理大量连接，这是 BIO 无法做到的</li>
<li><strong>生产环境不要裸写 NIO</strong>。直接使用 NIO API 编程极其复杂（半包处理、空轮询 bug、线程模型），应使用 Netty 等成熟框架</li>
</ol>
<blockquote>
<p>I/O 模型的选择不取决于哪个&quot;更先进&quot;，而取决于业务的连接模式和数据特征。理解底层模型的差异，才能做出正确的技术选型。</p>
</blockquote>
17:T5439,<h1>Java并发编程：从内存模型到并发工具的设计哲学</h1>
<blockquote>
<p>并发编程的核心挑战不在于&quot;如何让多个线程同时跑&quot;，而在于&quot;如何让多个线程正确地协作&quot;。理解 Java 内存模型和并发工具的设计原理，是写出正确并发代码的前提。</p>
</blockquote>
<p>并发编程是 Java 工程师的核心能力之一。它涉及从硬件层面的缓存一致性，到语言层面的内存模型，再到 JUC 工具类的 API 设计，是一个纵深很大的知识领域。</p>
<p>本文将从底层原理出发，逐层构建 Java 并发编程的知识体系。</p>
<h2>一、硬件基础：CPU 缓存与一致性</h2>
<h3>1.1 为什么需要缓存</h3>
<p>现代 CPU 的运算速度远超主内存的读写速度（差距约 100 倍）。为了弥补这一差距，CPU 引入了多级缓存（L1/L2/L3 Cache）。每个核心拥有独立的 L1/L2 缓存，L3 缓存为所有核心共享。</p>
<pre><code>CPU Core 0          CPU Core 1
┌─────────┐        ┌─────────┐
│ L1 Cache│        │ L1 Cache│
│ L2 Cache│        │ L2 Cache│
└────┬────┘        └────┬────┘
     └────────┬─────────┘
         L3 Cache（共享）
              │
         主内存（RAM）
</code></pre>
<p>缓存的引入解决了性能问题，但带来了新问题：<strong>当多个核心各自缓存了同一块数据的副本，其中一个核心修改了数据，如何保证其他核心看到的是最新值？</strong></p>
<h3>1.2 MESI 缓存一致性协议</h3>
<p>MESI 是最广泛采用的缓存一致性协议，每个缓存行处于四种状态之一：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
<th>对主内存</th>
</tr>
</thead>
<tbody><tr>
<td><strong>M（Modified）</strong></td>
<td>当前核心修改了数据，与主内存不一致</td>
<td>需要写回</td>
</tr>
<tr>
<td><strong>E（Exclusive）</strong></td>
<td>当前核心独占数据，与主内存一致</td>
<td>无需写回</td>
</tr>
<tr>
<td><strong>S（Shared）</strong></td>
<td>多个核心共享数据，与主内存一致</td>
<td>无需写回</td>
</tr>
<tr>
<td><strong>I（Invalid）</strong></td>
<td>缓存行无效</td>
<td>需从主内存重新加载</td>
</tr>
</tbody></table>
<p>当 Core 0 修改了处于 S 状态的缓存行时：</p>
<ol>
<li>Core 0 将缓存行状态改为 M</li>
<li>通过总线嗅探（Bus Snooping）通知其他核心</li>
<li>其他核心将对应缓存行标记为 I</li>
<li>其他核心下次读取该数据时，从 Core 0 的缓存或主内存重新加载</li>
</ol>
<h3>1.3 缓存行伪共享（False Sharing）</h3>
<p>缓存行是缓存操作的最小单位，大小通常为 <strong>64 字节</strong>。如果两个无关的变量恰好落在同一缓存行中，一个变量的修改会导致另一个变量的缓存行也失效——这就是伪共享。</p>
<pre><code class="language-java">// 伪共享示例：head 和 tail 可能在同一缓存行
class Queue {
    volatile long head;  // 生产者频繁修改
    volatile long tail;  // 消费者频繁修改
}
</code></pre>
<p>Doug Lea 在 <code>LinkedTransferQueue</code> 中的解决方案——填充字节使变量独占一个缓存行：</p>
<pre><code class="language-java">// JDK 7 中的做法
class PaddedAtomicReference&lt;T&gt; extends AtomicReference&lt;T&gt; {
    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;
}

// JDK 8+ 可以使用 @Contended 注解
@sun.misc.Contended
class QueueNode {
    volatile long value;
}
</code></pre>
<h2>二、Java 内存模型（JMM）</h2>
<h3>2.1 JMM 的抽象</h3>
<p>Java 内存模型（Java Memory Model）定义了<strong>多线程如何通过共享内存进行通信</strong>的规则。它并不描述具体的硬件实现，而是提供了一组抽象的可见性和有序性保证。</p>
<pre><code>线程 A 工作内存          线程 B 工作内存
┌──────────────┐      ┌──────────────┐
│  变量副本      │      │  变量副本      │
└──────┬───────┘      └──────┬───────┘
       │    save/load         │
       └──────────┬───────────┘
              主内存
         ┌──────────────┐
         │  共享变量      │
         └──────────────┘
</code></pre>
<p>JMM 定义了 8 种内存交互操作：lock、unlock、read、load、use、assign、store、write。这些操作的组合规则保证了多线程程序的语义正确性。</p>
<h3>2.2 三大并发问题</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>根源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可见性</strong></td>
<td>一个线程修改了变量，其他线程看不到最新值</td>
<td>CPU 缓存导致各线程工作内存不一致</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td>一组操作被中断导致中间状态暴露</td>
<td>线程切换导致复合操作被打断</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>代码执行顺序与编写顺序不一致</td>
<td>编译器优化、CPU 指令重排序</td>
</tr>
</tbody></table>
<h3>2.3 volatile 的语义与实现</h3>
<p><code>volatile</code> 是 Java 中最轻量的同步机制，它提供两个保证：</p>
<ol>
<li><strong>可见性</strong>：对 volatile 变量的写操作对所有线程立即可见</li>
<li><strong>有序性</strong>：禁止指令重排序（通过内存屏障实现）</li>
</ol>
<p><strong>但不保证原子性</strong>：<code>volatile int count; count++</code> 并不是线程安全的，因为 <code>count++</code> 是读-改-写三步操作。</p>
<p><strong>硬件级实现</strong>：</p>
<p>在 x86 架构上，对 volatile 变量的写操作会生成一条带 <strong>LOCK 前缀</strong>的指令。LOCK 前缀的作用：</p>
<ol>
<li>将当前处理器缓存行的数据写回主内存</li>
<li>使其他处理器中缓存该地址的缓存行失效（通过 MESI 协议）</li>
</ol>
<pre><code>// JIT 编译后的汇编（x86）
0x01a3de24: lock addl $0x0,(%esp)  // LOCK 前缀指令
</code></pre>
<p>在 P6 及更新的处理器上，LOCK 不再锁总线，而是<strong>锁缓存行</strong>（Cache Locking），性能开销远小于总线锁。</p>
<h3>2.4 happens-before 规则</h3>
<p>JMM 通过 <strong>happens-before</strong> 关系定义了操作间的可见性保证。如果操作 A happens-before 操作 B，则 A 的结果对 B 可见。</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>程序顺序规则</td>
<td>同一线程中的操作，前面的 happens-before 后面的</td>
</tr>
<tr>
<td>volatile 规则</td>
<td>volatile 写 happens-before 后续的 volatile 读</td>
</tr>
<tr>
<td>锁规则</td>
<td>unlock happens-before 后续对同一锁的 lock</td>
</tr>
<tr>
<td>传递性</td>
<td>如果 A hb B，B hb C，则 A hb C</td>
</tr>
<tr>
<td>线程启动规则</td>
<td><code>Thread.start()</code> happens-before 该线程的每个动作</td>
</tr>
<tr>
<td>线程终止规则</td>
<td>线程的所有动作 happens-before 其他线程检测到该线程终止</td>
</tr>
</tbody></table>
<h2>三、锁机制</h2>
<h3>3.1 synchronized vs Lock</h3>
<p>Java 提供两种锁机制：内置锁（<code>synchronized</code>）和显式锁（<code>java.util.concurrent.locks.Lock</code>）。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>实现层面</td>
<td>JVM 内置（monitorenter/monitorexit）</td>
<td>Java API 层（基于 AQS）</td>
</tr>
<tr>
<td>锁获取</td>
<td>阻塞式，不可中断</td>
<td>支持非阻塞 <code>tryLock()</code>、可中断 <code>lockInterruptibly()</code></td>
</tr>
<tr>
<td>锁释放</td>
<td>自动释放（退出同步块）</td>
<td>必须在 <code>finally</code> 中手动 <code>unlock()</code></td>
</tr>
<tr>
<td>条件等待</td>
<td><code>Object.wait()/notify()</code></td>
<td><code>Condition.await()/signal()</code>，支持多条件队列</td>
</tr>
<tr>
<td>公平性</td>
<td>不支持</td>
<td><code>ReentrantLock(true)</code> 支持公平锁</td>
</tr>
<tr>
<td>锁状态查询</td>
<td>不支持</td>
<td><code>isLocked()</code>、<code>getHoldCount()</code> 等</td>
</tr>
</tbody></table>
<p><strong>选择原则</strong>：优先使用 <code>synchronized</code>（JVM 持续优化，且不会忘记释放锁）；需要高级特性（超时、中断、多条件、公平性）时选择 <code>Lock</code>。</p>
<h3>3.2 Condition：精确的线程协作</h3>
<p><code>Condition</code> 是 <code>Lock</code> 的配套组件，它替代了 <code>Object.wait()/notify()</code> 机制，最大的优势是<strong>支持多个等待队列</strong>。</p>
<pre><code class="language-java">// 使用 Object 的 wait/notify：只有一个等待队列，notifyAll 会唤醒所有线程
// 使用 Condition：可以创建多个条件队列，signal 只唤醒特定队列中的线程

ReentrantLock lock = new ReentrantLock();
Condition notFull  = lock.newCondition();  // 生产者等待队列
Condition notEmpty = lock.newCondition();  // 消费者等待队列
</code></pre>
<p><strong>有界缓冲区实现</strong>（经典的生产者-消费者模型）：</p>
<pre><code class="language-java">class BoundedBuffer&lt;E&gt; {
    final Lock lock = new ReentrantLock();
    final Condition notFull  = lock.newCondition();
    final Condition notEmpty = lock.newCondition();
    final Object[] items = new Object[100];
    int putIndex, takeIndex, count;

    public void put(E e) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await();      // 缓冲区满，生产者等待
            items[putIndex] = e;
            if (++putIndex == items.length) putIndex = 0;
            ++count;
            notEmpty.signal();        // 通知消费者
        } finally {
            lock.unlock();
        }
    }

    public E take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();     // 缓冲区空，消费者等待
            E e = (E) items[takeIndex];
            if (++takeIndex == items.length) takeIndex = 0;
            --count;
            notFull.signal();         // 通知生产者
            return e;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
<p>注意 <code>await()</code> 必须在 <code>while</code> 循环中调用，以防止<strong>虚假唤醒（Spurious Wakeup）</strong>。</p>
<h3>3.3 ReadWriteLock：读写分离</h3>
<p>当读操作远多于写操作时，使用排他锁会严重限制并发度。<code>ReadWriteLock</code> 允许多个线程同时持有读锁，但写锁是排他的。</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>读锁请求</th>
<th>写锁请求</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>读锁已持有</td>
<td>允许（共享）</td>
<td>阻塞</td>
</tr>
<tr>
<td>写锁已持有</td>
<td>阻塞</td>
<td>阻塞</td>
</tr>
</tbody></table>
<p><code>ReentrantReadWriteLock</code> 的设计决策：</p>
<ul>
<li><strong>写锁可降级为读锁</strong>：持有写锁的线程可以再获取读锁，然后释放写锁</li>
<li><strong>读锁不可升级为写锁</strong>：防止死锁（多个读线程同时尝试升级会互相等待）</li>
<li><strong>支持公平/非公平模式</strong>：非公平模式下，读锁可能&quot;插队&quot;导致写线程饥饿</li>
</ul>
<h2>四、JUC 并发工具类</h2>
<p><code>java.util.concurrent</code> 包提供了一组高级同步工具，用于解决常见的线程协调问题。</p>
<h3>4.1 CountDownLatch：一次性倒计数门闩</h3>
<p><strong>语义</strong>：一个或多个线程等待其他线程完成一组操作后再继续执行。</p>
<pre><code class="language-java">CountDownLatch latch = new CountDownLatch(3);  // 计数器初始值 3

// 工作线程
executor.submit(() -&gt; {
    doTask();
    latch.countDown();  // 计数器 -1
});

// 等待线程
latch.await();  // 阻塞直到计数器归零
// 所有任务完成，继续执行
</code></pre>
<p><strong>核心特征</strong>：</p>
<ul>
<li><strong>一次性</strong>：计数器归零后无法重置</li>
<li>底层基于 AQS 的共享模式实现</li>
</ul>
<p><strong>典型场景</strong>：服务启动时等待所有依赖组件初始化完成。</p>
<h3>4.2 CyclicBarrier：可重用的屏障</h3>
<p><strong>语义</strong>：一组线程互相等待，直到所有线程都到达屏障点，然后同时继续执行。</p>
<pre><code class="language-java">CyclicBarrier barrier = new CyclicBarrier(3, () -&gt; {
    System.out.println(&quot;所有线程到齐，开始下一阶段&quot;);  // barrierAction
});

// 每个工作线程
executor.submit(() -&gt; {
    doPhase1();
    barrier.await();  // 等待其他线程
    doPhase2();
    barrier.await();  // 可以重复使用
});
</code></pre>
<p><strong>核心特征</strong>：</p>
<ul>
<li><strong>可重用</strong>：所有线程通过屏障后，计数器自动重置</li>
<li>支持 <strong>barrierAction</strong>：所有线程到齐时执行的回调</li>
<li>如果某个线程等待超时或被中断，屏障进入 <strong>Broken</strong> 状态，所有等待线程收到 <code>BrokenBarrierException</code></li>
</ul>
<h3>4.3 Semaphore：信号量</h3>
<p><strong>语义</strong>：控制同时访问某个资源的线程数量。</p>
<pre><code class="language-java">Semaphore semaphore = new Semaphore(5);  // 最多 5 个并发

executor.submit(() -&gt; {
    semaphore.acquire();    // 获取许可（可用许可 -1）
    try {
        accessResource();
    } finally {
        semaphore.release();  // 释放许可（可用许可 +1）
    }
});
</code></pre>
<p><strong>核心特征</strong>：</p>
<ul>
<li>支持<strong>公平/非公平</strong>模式</li>
<li><code>tryAcquire()</code> 提供非阻塞获取</li>
<li>许可数量可以动态增减（<code>release()</code> 可以在未 <code>acquire()</code> 的情况下调用）</li>
</ul>
<h3>4.4 三者对比</h3>
<table>
<thead>
<tr>
<th>工具</th>
<th>核心语义</th>
<th>是否可重用</th>
<th>计数方向</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CountDownLatch</strong></td>
<td>一个线程等待 N 个线程</td>
<td>否</td>
<td>递减至 0</td>
<td>主线程等待子任务完成</td>
</tr>
<tr>
<td><strong>CyclicBarrier</strong></td>
<td>N 个线程互相等待</td>
<td>是</td>
<td>递增至 N</td>
<td>多阶段并行计算</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>控制并发访问数量</td>
<td>-</td>
<td>许可的获取与释放</td>
<td>限流、资源池</td>
</tr>
</tbody></table>
<h2>五、生产者-消费者模式</h2>
<p>生产者-消费者是并发编程中最经典的协作模式。Java 提供了从底层到高层的多种实现方式。</p>
<h3>5.1 三种实现方式对比</h3>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>同步机制</th>
<th>通知粒度</th>
<th>复杂度</th>
<th>推荐度</th>
</tr>
</thead>
<tbody><tr>
<td>synchronized + wait/notify</td>
<td>内置锁</td>
<td>全量唤醒（notifyAll）</td>
<td>低</td>
<td>一般</td>
</tr>
<tr>
<td>Lock + Condition</td>
<td>显式锁</td>
<td>精确唤醒（signal）</td>
<td>中</td>
<td>推荐</td>
</tr>
<tr>
<td>BlockingQueue</td>
<td>封装在队列内部</td>
<td>内部自动处理</td>
<td>最低</td>
<td>最推荐</td>
</tr>
</tbody></table>
<p><strong>为什么 BlockingQueue 是最佳选择</strong>：</p>
<p><code>BlockingQueue</code> 将同步、等待、通知的逻辑完全封装在 <code>put()</code>/<code>take()</code> 方法内部，调用方无需关心并发细节：</p>
<pre><code class="language-java">BlockingQueue&lt;Task&gt; queue = new ArrayBlockingQueue&lt;&gt;(100);

// 生产者
queue.put(task);   // 队列满时自动阻塞

// 消费者
Task task = queue.take();  // 队列空时自动阻塞
</code></pre>
<h3>5.2 BlockingQueue 的实现选型</h3>
<table>
<thead>
<tr>
<th>实现类</th>
<th>底层结构</th>
<th>是否有界</th>
<th>锁策略</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>ArrayBlockingQueue</code></td>
<td>数组</td>
<td>有界</td>
<td>单锁</td>
<td>通用场景</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>链表</td>
<td>可选有界</td>
<td>读写分离锁</td>
<td>吞吐量要求高</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>无容量</td>
<td>无</td>
<td>CAS</td>
<td>直接传递（线程池默认）</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>堆</td>
<td>无界</td>
<td>单锁</td>
<td>优先级调度</td>
</tr>
</tbody></table>
<h2>六、线程池</h2>
<h3>6.1 ThreadPoolExecutor 核心参数</h3>
<pre><code class="language-java">new ThreadPoolExecutor(
    corePoolSize,      // 核心线程数
    maximumPoolSize,   // 最大线程数
    keepAliveTime,     // 非核心线程空闲存活时间
    TimeUnit.SECONDS,
    workQueue,         // 任务队列
    threadFactory,     // 线程工厂
    rejectedHandler    // 拒绝策略
);
</code></pre>
<p><strong>任务提交流程</strong>：</p>
<pre><code>提交任务
  → 当前线程数 &lt; corePoolSize？        → 创建核心线程执行
  → 任务队列未满？                      → 入队等待
  → 当前线程数 &lt; maximumPoolSize？      → 创建非核心线程执行
  → 以上都不满足                        → 执行拒绝策略
</code></pre>
<h3>6.2 拒绝策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>行为</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AbortPolicy</strong></td>
<td>抛出 <code>RejectedExecutionException</code></td>
<td>默认策略，适合需要感知过载的场景</td>
</tr>
<tr>
<td><strong>CallerRunsPolicy</strong></td>
<td>由提交线程自己执行任务</td>
<td>反压效果，但可能导致提交线程阻塞</td>
</tr>
<tr>
<td><strong>DiscardPolicy</strong></td>
<td>静默丢弃任务</td>
<td>允许丢失的场景（如日志）</td>
</tr>
<tr>
<td><strong>DiscardOldestPolicy</strong></td>
<td>丢弃队列中最旧的任务</td>
<td>实时性要求高、可接受旧数据丢失</td>
</tr>
</tbody></table>
<h3>6.3 生产阻塞型线程池</h3>
<p>标准 <code>ThreadPoolExecutor</code> 使用 <code>BlockingQueue.offer()</code>（非阻塞）入队。队列满时不会阻塞提交线程，而是触发拒绝策略。</p>
<p>在某些场景下（如需要严格的背压机制），需要让提交线程在队列满时<strong>阻塞等待</strong>而非被拒绝。可通过自定义拒绝策略实现：</p>
<pre><code class="language-java">ThreadPoolExecutor executor = new ThreadPoolExecutor(
    coreSize, maxSize, 60, TimeUnit.SECONDS,
    new LinkedBlockingQueue&lt;&gt;(capacity),
    (runnable, pool) -&gt; {
        try {
            // 队列满时，put() 会阻塞提交线程
            pool.getQueue().put(runnable);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
);
</code></pre>
<p>这种方式的优势在于：复用 <code>ThreadPoolExecutor</code> 的线程管理能力，同时实现了生产者阻塞语义，避免了手工管理线程的复杂性。</p>
<h3>6.4 线程池配置最佳实践</h3>
<table>
<thead>
<tr>
<th>任务类型</th>
<th>核心线程数建议</th>
<th>队列选择</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPU 密集型</strong></td>
<td><code>N_cpu + 1</code></td>
<td>小容量有界队列</td>
</tr>
<tr>
<td><strong>I/O 密集型</strong></td>
<td><code>N_cpu × 2</code> 或更高</td>
<td>较大容量有界队列</td>
</tr>
<tr>
<td><strong>混合型</strong></td>
<td>拆分为 CPU 池和 I/O 池</td>
<td>各自独立配置</td>
</tr>
</tbody></table>
<p>关键原则：</p>
<ul>
<li><strong>永远不要使用无界队列</strong>：<code>Executors.newFixedThreadPool()</code> 默认使用无界的 <code>LinkedBlockingQueue</code>，可能导致 OOM</li>
<li><strong>为线程池命名</strong>：自定义 <code>ThreadFactory</code>，给线程添加有意义的名称前缀，便于排查问题</li>
<li><strong>监控队列深度</strong>：线程池队列持续增长是系统过载的信号</li>
</ul>
<h2>总结</h2>
<p>Java 并发编程的知识体系可以沿着三个层次理解：</p>
<ol>
<li><strong>硬件层</strong>：CPU 缓存、MESI 协议、缓存行伪共享——这是并发问题的物理根源</li>
<li><strong>模型层</strong>：JMM、happens-before、volatile/synchronized 语义——这是 Java 对硬件差异的抽象屏蔽</li>
<li><strong>工具层</strong>：Lock/Condition、CountDownLatch/CyclicBarrier/Semaphore、BlockingQueue、ThreadPoolExecutor——这是面向工程的并发编程基础设施</li>
</ol>
<blockquote>
<p>并发工具的选择不在于功能的强大，而在于语义的匹配。<code>synchronized</code> 足以解决大多数问题；<code>BlockingQueue</code> 比手动的 wait/notify 更安全；标准 <code>ThreadPoolExecutor</code> 比自定义线程管理更可靠。优先选择高层抽象，只在确有需要时才下沉到底层机制。</p>
</blockquote>
18:T4347,<h1>Java字节码增强实战：从原理到ByteBuddy工程应用</h1>
<blockquote>
<p>字节码增强是 Java 生态中一项&quot;隐藏&quot;的核心技术。Spring AOP、Hibernate 延迟加载、Mockito 测试框架、SkyWalking 链路追踪——这些工具的底层都依赖字节码操作。理解这项技术，就理解了 Java 动态能力的基石。</p>
</blockquote>
<h2>一、字节码增强技术全景</h2>
<h3>1.1 什么是字节码增强</h3>
<p>Java 源码经过 <code>javac</code> 编译后生成 <code>.class</code> 字节码文件。字节码增强（Bytecode Enhancement / Instrumentation）是指在不修改源码的前提下，<strong>通过直接操作字节码来改变类的行为</strong>。</p>
<p>操作时机可以是：</p>
<pre><code>编译时：编译后修改 .class 文件
加载时：通过 Java Agent 在 ClassLoader 加载类时修改字节码
运行时：在程序运行过程中动态生成新类
</code></pre>
<h3>1.2 技术选型对比</h3>
<table>
<thead>
<tr>
<th>工具</th>
<th>抽象层级</th>
<th>性能</th>
<th>学习成本</th>
<th>维护状态</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ASM</strong></td>
<td>指令级（直接操作 JVM 指令）</td>
<td>最高</td>
<td>高（需了解字节码指令集）</td>
<td>活跃</td>
<td>极致性能要求、底层框架开发</td>
</tr>
<tr>
<td><strong>Javassist</strong></td>
<td>源码级（用字符串写 Java 代码）</td>
<td>中</td>
<td>低</td>
<td>维护中</td>
<td>快速原型、简单场景</td>
</tr>
<tr>
<td><strong>cglib</strong></td>
<td>API 级（基于 ASM 封装）</td>
<td>高</td>
<td>中</td>
<td><strong>停止维护</strong></td>
<td>历史遗留项目</td>
</tr>
<tr>
<td><strong>ByteBuddy</strong></td>
<td>API 级（类型安全的 DSL）</td>
<td>高</td>
<td>中</td>
<td><strong>活跃</strong></td>
<td>新项目首选</td>
</tr>
</tbody></table>
<p><strong>关键决策因素</strong>：</p>
<ul>
<li><strong>Java 17+ 兼容性</strong>：Java 17 引入强封装（Strong Encapsulation），cglib 依赖的 <code>sun.misc.Unsafe</code> 和内部 API 被限制访问，导致 cglib 在现代 JDK 上<strong>无法正常工作</strong></li>
<li><strong>ByteBuddy 是 cglib 的官方替代方案</strong>：Spring Framework 6 / Spring Boot 3 已将底层代理从 cglib 切换为 ByteBuddy</li>
<li><strong>ASM 适合框架开发者</strong>：如果你在开发 APM 工具或编译器插件，ASM 的指令级控制是必要的；否则 ByteBuddy 的高层 API 更高效</li>
</ul>
<h3>1.3 动态代理的两种路径</h3>
<p>Java 标准库提供的 <code>java.lang.reflect.Proxy</code> 只能代理接口。对于类的代理，需要字节码增强工具。</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>原理</th>
<th>限制</th>
</tr>
</thead>
<tbody><tr>
<td>JDK 动态代理</td>
<td>运行时生成接口的实现类</td>
<td>只能代理接口</td>
</tr>
<tr>
<td>字节码增强代理</td>
<td>运行时生成目标类的子类</td>
<td>无法代理 <code>final</code> 类/方法</td>
</tr>
</tbody></table>
<h2>二、ByteBuddy 核心概念</h2>
<h3>2.1 三种类操作模式</h3>
<p>ByteBuddy 提供三种操作已有类的方式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>方法</th>
<th>原方法处理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Subclass</strong></td>
<td><code>subclass()</code></td>
<td>保留（继承）</td>
<td>创建代理类、扩展功能</td>
</tr>
<tr>
<td><strong>Rebase</strong></td>
<td><code>rebase()</code></td>
<td>保留（重命名为 private）</td>
<td>修改类行为但保留原逻辑可调用</td>
</tr>
<tr>
<td><strong>Redefine</strong></td>
<td><code>redefine()</code></td>
<td>丢弃</td>
<td>完全替换方法实现</td>
</tr>
</tbody></table>
<pre><code class="language-java">// Subclass：生成 Foo 的子类
new ByteBuddy()
    .subclass(Foo.class)
    .method(named(&quot;bar&quot;))
    .intercept(FixedValue.value(&quot;intercepted&quot;))
    .make();

// Rebase：修改 Foo 的 bar 方法，原方法被重命名保留
new ByteBuddy()
    .rebase(Foo.class)
    .method(named(&quot;bar&quot;))
    .intercept(MethodDelegation.to(Interceptor.class))
    .make();

// Redefine：直接替换 bar 方法，原实现丢失
new ByteBuddy()
    .redefine(Foo.class)
    .method(named(&quot;bar&quot;))
    .intercept(FixedValue.value(&quot;replaced&quot;))
    .make();
</code></pre>
<p><strong>Rebase vs Redefine 的关键区别</strong>：</p>
<p>Rebase 会将原方法重命名为一个 private synthetic 方法（如 <code>bar$original$xxx</code>），拦截器中可以通过 <code>@SuperCall</code> 调用原始逻辑。Redefine 则彻底丢弃原方法实现。</p>
<h3>2.2 DynamicType 生命周期</h3>
<p>ByteBuddy 生成的类经历两个阶段：</p>
<pre><code>Unloaded（未加载）
  ↓  ClassLoadingStrategy
Loaded（已加载）→ 可通过反射或直接调用使用
</code></pre>
<p><strong>加载策略</strong>：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>WRAPPER</code></td>
<td>创建新的 ClassLoader 包装加载</td>
<td>默认策略，隔离性好</td>
</tr>
<tr>
<td><code>CHILD_FIRST</code></td>
<td>子优先加载（打破双亲委派）</td>
<td>需要覆盖已有类时</td>
</tr>
<tr>
<td><code>INJECTION</code></td>
<td>注入到已有 ClassLoader</td>
<td>需要与目标类在同一 ClassLoader</td>
</tr>
</tbody></table>
<pre><code class="language-java">Class&lt;?&gt; loaded = new ByteBuddy()
    .subclass(Object.class)
    .name(&quot;com.example.Generated&quot;)
    .make()
    .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)
    .getLoaded();
</code></pre>
<h3>2.3 方法匹配（ElementMatchers）</h3>
<p>ByteBuddy 提供丰富的方法匹配器，用于精确选择需要拦截的方法：</p>
<pre><code class="language-java">// 按名称匹配
named(&quot;toString&quot;)
nameContains(&quot;get&quot;)
nameStartsWith(&quot;set&quot;)

// 按返回类型
returns(String.class)
returns(TypeDescription.VOID)

// 按修饰符
isPublic()
isAnnotatedWith(Override.class)

// 组合匹配
named(&quot;execute&quot;).and(returns(void.class))
named(&quot;get&quot;).or(named(&quot;set&quot;))
not(named(&quot;hashCode&quot;))
</code></pre>
<h2>三、方法拦截与委托</h2>
<p>方法拦截是 ByteBuddy 最核心的能力。</p>
<h3>3.1 FixedValue：返回固定值</h3>
<p>最简单的拦截方式，直接返回一个预设值：</p>
<pre><code class="language-java">new ByteBuddy()
    .subclass(Foo.class)
    .method(named(&quot;getName&quot;))
    .intercept(FixedValue.value(&quot;ByteBuddy&quot;))
    .make();
</code></pre>
<h3>3.2 MethodDelegation：方法委托</h3>
<p>将方法调用委托给一个拦截器类（或实例）。ByteBuddy 通过<strong>注解</strong>来定义参数绑定规则：</p>
<pre><code class="language-java">public class TimingInterceptor {
    @RuntimeType
    public static Object intercept(
            @Origin Method method,        // 被拦截的原方法
            @AllArguments Object[] args,   // 所有参数
            @SuperCall Callable&lt;?&gt; zuper   // 原方法的调用
    ) throws Exception {
        long start = System.nanoTime();
        try {
            return zuper.call();  // 调用原方法
        } finally {
            long elapsed = System.nanoTime() - start;
            System.out.println(method.getName() + &quot; took &quot; + elapsed + &quot;ns&quot;);
        }
    }
}

// 应用拦截器
new ByteBuddy()
    .subclass(TargetService.class)
    .method(isPublic())
    .intercept(MethodDelegation.to(TimingInterceptor.class))
    .make();
</code></pre>
<h3>3.3 参数绑定注解体系</h3>
<table>
<thead>
<tr>
<th>注解</th>
<th>绑定内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@This</code></td>
<td>被代理对象实例</td>
<td>类似 AOP 中的 <code>this</code></td>
</tr>
<tr>
<td><code>@Super</code></td>
<td>父类类型的代理实例</td>
<td>可调用父类方法</td>
</tr>
<tr>
<td><code>@Origin</code></td>
<td>被拦截的 <code>Method</code> / <code>Constructor</code></td>
<td>反射元信息</td>
</tr>
<tr>
<td><code>@AllArguments</code></td>
<td>所有参数（Object[]）</td>
<td>参数列表</td>
</tr>
<tr>
<td><code>@Argument(n)</code></td>
<td>第 n 个参数</td>
<td>精确参数获取</td>
</tr>
<tr>
<td><code>@SuperCall</code></td>
<td>原方法的 <code>Callable</code>/<code>Runnable</code></td>
<td>调用原始逻辑</td>
</tr>
<tr>
<td><code>@RuntimeType</code></td>
<td>允许运行时类型转换</td>
<td>标注在方法上，支持泛型返回值</td>
</tr>
<tr>
<td><code>@FieldValue(&quot;name&quot;)</code></td>
<td>指定字段的值</td>
<td>读取被代理对象的字段</td>
</tr>
<tr>
<td><code>@Morph</code></td>
<td>可修改参数的原方法调用</td>
<td>比 <code>@SuperCall</code> 更灵活</td>
</tr>
<tr>
<td><code>@Empty</code></td>
<td>返回类型的默认值</td>
<td>数值返回 0，对象返回 null</td>
</tr>
<tr>
<td><code>@StubValue</code></td>
<td>桩值</td>
<td>类似 <code>@Empty</code></td>
</tr>
</tbody></table>
<p><strong><code>@Morph</code> 的使用场景</strong>——需要修改参数再调用原方法时：</p>
<pre><code class="language-java">public class MorphInterceptor {
    @RuntimeType
    public static Object intercept(
            @Morph MorphCallable zuper,
            @AllArguments Object[] args
    ) {
        args[0] = ((String) args[0]).toUpperCase();  // 修改参数
        return zuper.call(args);  // 用修改后的参数调用原方法
    }
}
</code></pre>
<p>使用 <code>@Morph</code> 时需要安装绑定：</p>
<pre><code class="language-java">MethodDelegation.to(MorphInterceptor.class)
    .appendParameterBinder(Morph.Binder.install(MorphCallable.class))
</code></pre>
<h3>3.4 构造函数拦截</h3>
<pre><code class="language-java">new ByteBuddy()
    .subclass(Target.class)
    .constructor(any())
    .intercept(SuperMethodCall.INSTANCE.andThen(
        MethodDelegation.to(ConstructorInterceptor.class)
    ))
    .make();
</code></pre>
<p><code>SuperMethodCall.INSTANCE</code> 确保先执行父类构造函数，<code>andThen</code> 链接后续的拦截逻辑。</p>
<h2>四、工程实践</h2>
<h3>4.1 Java Agent：加载时增强</h3>
<p>Java Agent 是 JVM 提供的在类加载时修改字节码的标准机制。ByteBuddy 提供了 <code>AgentBuilder</code> 简化 Agent 开发：</p>
<pre><code class="language-java">public class MyAgent {
    public static void premain(String args, Instrumentation inst) {
        new AgentBuilder.Default()
            .type(nameStartsWith(&quot;com.example.service&quot;))
            .transform((builder, type, classLoader, module, domain) -&gt;
                builder.method(isPublic())
                       .intercept(MethodDelegation.to(TimingInterceptor.class))
            )
            .installOn(inst);
    }
}
</code></pre>
<p>Agent 的打包需要在 <code>MANIFEST.MF</code> 中声明：</p>
<pre><code>Premain-Class: com.example.MyAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
</code></pre>
<p>启动参数：<code>java -javaagent:my-agent.jar -jar app.jar</code></p>
<h3>4.2 代理类缓存</h3>
<p>ByteBuddy 每次调用 <code>make()</code> 都会生成一个新类。在高频创建代理的场景下，应使用 <code>TypeCache</code> 缓存已生成的类：</p>
<pre><code class="language-java">TypeCache&lt;Class&lt;?&gt;&gt; cache = new TypeCache&lt;&gt;(TypeCache.Sort.SOFT);

Class&lt;?&gt; proxyClass = cache.findOrInsert(
    classLoader,
    targetClass,
    () -&gt; new ByteBuddy()
        .subclass(targetClass)
        .method(isPublic())
        .intercept(MethodDelegation.to(interceptor))
        .make()
        .load(classLoader)
        .getLoaded()
);
</code></pre>
<h3>4.3 从 cglib 迁移到 ByteBuddy</h3>
<p>Java 17 的强封装机制导致 cglib 无法正常工作。以下是常见的迁移对照：</p>
<table>
<thead>
<tr>
<th>cglib 用法</th>
<th>ByteBuddy 等价方案</th>
</tr>
</thead>
<tbody><tr>
<td><code>Enhancer</code> + <code>MethodInterceptor</code></td>
<td><code>subclass()</code> + <code>MethodDelegation</code></td>
</tr>
<tr>
<td><code>BeanGenerator</code></td>
<td><code>subclass(Object.class)</code> + <code>defineField()</code></td>
</tr>
<tr>
<td><code>BeanCopier</code></td>
<td><code>subclass()</code> + 自定义 copy 方法</td>
</tr>
<tr>
<td><code>FixedValue</code></td>
<td><code>FixedValue.value()</code></td>
</tr>
</tbody></table>
<p><strong>cglib 的代理创建</strong>：</p>
<pre><code class="language-java">Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(TargetClass.class);
enhancer.setCallback((MethodInterceptor) (obj, method, args, proxy) -&gt; {
    // 前置逻辑
    Object result = proxy.invokeSuper(obj, args);
    // 后置逻辑
    return result;
});
TargetClass proxy = (TargetClass) enhancer.create();
</code></pre>
<p><strong>ByteBuddy 的等价实现</strong>：</p>
<pre><code class="language-java">Class&lt;? extends TargetClass&gt; proxyClass = new ByteBuddy()
    .subclass(TargetClass.class)
    .method(isPublic())
    .intercept(MethodDelegation.to(new GeneralInterceptor()))
    .make()
    .load(TargetClass.class.getClassLoader())
    .getLoaded();

TargetClass proxy = proxyClass.getDeclaredConstructor().newInstance();
</code></pre>
<pre><code class="language-java">public class GeneralInterceptor {
    @RuntimeType
    public Object intercept(
            @This Object self,
            @Origin Method method,
            @AllArguments Object[] args,
            @SuperMethod Method superMethod
    ) throws Throwable {
        // 前置逻辑
        Object result = superMethod.invoke(self, args);
        // 后置逻辑
        return result;
    }
}
</code></pre>
<h3>4.4 运行时创建 Annotation 实例</h3>
<p>某些场景需要在运行时动态创建注解实例（如框架中需要将注解加入集合进行比较）。注解在 Java 中本质是接口，可以通过匿名类实现：</p>
<pre><code class="language-java">MyAnnotation annotation = new MyAnnotation() {
    @Override
    public String value() { return &quot;dynamic&quot;; }

    @Override
    public Class&lt;? extends Annotation&gt; annotationType() {
        return MyAnnotation.class;
    }
};
</code></pre>
<p>更健壮的方案是使用 <code>Proxy</code> 动态代理：</p>
<pre><code class="language-java">MyAnnotation annotation = (MyAnnotation) Proxy.newProxyInstance(
    MyAnnotation.class.getClassLoader(),
    new Class[]{MyAnnotation.class},
    (proxy, method, args) -&gt; {
        if (&quot;value&quot;.equals(method.getName())) return &quot;dynamic&quot;;
        if (&quot;annotationType&quot;.equals(method.getName())) return MyAnnotation.class;
        // equals/hashCode 需按 Annotation 规范实现
        throw new UnsupportedOperationException(method.getName());
    }
);
</code></pre>
<h2>五、编译时增强：Build Plugin</h2>
<p>除了运行时增强，ByteBuddy 还支持<strong>编译时增强</strong>——在 Maven/Gradle 构建阶段直接修改 .class 文件：</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;
    &lt;artifactId&gt;byte-buddy-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;&lt;goal&gt;transform&lt;/goal&gt;&lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;transformations&gt;
            &lt;transformation&gt;
                &lt;plugin&gt;com.example.MyBuildPlugin&lt;/plugin&gt;
            &lt;/transformation&gt;
        &lt;/transformations&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>
<p>编译时增强的优势：</p>
<ul>
<li><strong>无运行时开销</strong>：类在编译时已被修改，运行时无需生成子类</li>
<li><strong>可以修改 final 类/方法</strong>：因为是直接修改 .class 文件，不受子类化限制</li>
<li><strong>启动速度更快</strong>：省去了运行时字节码生成的耗时</li>
</ul>
<h2>总结</h2>
<p>字节码增强技术是 Java 生态中&quot;不可见但无处不在&quot;的基础能力。核心要点：</p>
<ol>
<li><strong>工具选型</strong>：新项目首选 ByteBuddy，它是 cglib 的官方替代方案，与现代 JDK 完全兼容</li>
<li><strong>三种模式</strong>：<code>subclass</code> 用于代理，<code>rebase</code> 用于保留原逻辑的增强，<code>redefine</code> 用于完全替换</li>
<li><strong>注解驱动的委托机制</strong>是 ByteBuddy 的核心设计——通过 <code>@This</code>、<code>@Origin</code>、<code>@SuperCall</code> 等注解声明式地绑定拦截器参数</li>
<li><strong>工程层面</strong>：生产环境务必使用 <code>TypeCache</code> 缓存代理类；优先考虑编译时增强以消除运行时开销</li>
</ol>
<blockquote>
<p>字节码增强不是&quot;黑魔法&quot;，而是 Java 类型系统的合理扩展。理解它，是从&quot;使用框架&quot;到&quot;理解框架&quot;的关键一步。</p>
</blockquote>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/middleware/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"中间件"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2022-04-18","children":"2022年04月18日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"Java I/O模型演进：从BIO到NIO的范式变革"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","Java",{"href":"/blog/tag/Java/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Java"}],["$","$L13","NIO",{"href":"/blog/tag/NIO/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"NIO"}],["$","$L13","I/O",{"href":"/blog/tag/I%2FO/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"I/O"}],["$","$L13","Netty",{"href":"/blog/tag/Netty/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Netty"}],["$","$L13","网络编程",{"href":"/blog/tag/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"网络编程"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/middleware/Java并发编程：从内存模型到并发工具的设计哲学","title":"Java并发编程：从内存模型到并发工具的设计哲学","description":"从CPU缓存一致性协议到Java内存模型，从volatile的硬件级实现到Lock/Condition的协作机制，从JUC并发工具类到线程池的高级用法，系统构建Java并发编程的知识体系。","pubDate":"2021-11-20","tags":["Java","并发编程","JMM","JUC","线程池"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/middleware/Java字节码增强实战：从原理到ByteBuddy工程应用","title":"Java字节码增强实战：从原理到ByteBuddy工程应用","description":"全面解析Java字节码增强技术体系，对比ASM、Javassist、cglib、ByteBuddy四大工具的定位与取舍，深入ByteBuddy的核心API——类创建、方法拦截、注解驱动委托，并结合Java Agent与cglib迁移等工程场景展开实战。","pubDate":"2022-10-25","tags":["Java","ByteBuddy","字节码","动态代理","Java Agent"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"Java":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next"},"NIO":{"prev":null,"next":null},"I/O":{"prev":null,"next":null},"Netty":{"prev":null,"next":null},"网络编程":{"prev":null,"next":null}}}]}],["$","$L19",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"Java I/O模型演进：从BIO到NIO的范式变革 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。"}],["$","meta","2",{"property":"og:title","content":"Java I/O模型演进：从BIO到NIO的范式变革"}],["$","meta","3",{"property":"og:description","content":"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2022-04-18"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"Java I/O模型演进：从BIO到NIO的范式变革"}],["$","meta","9",{"name":"twitter:description","content":"系统梳理Java I/O体系的演进脉络，从传统BIO的流式模型到NIO的缓冲区+通道+多路复用模型，深入分析Channel、Buffer、Selector的设计原理与协作机制，理解I/O模型变革背后的系统级思考。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

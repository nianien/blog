<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/a2b4a60000c93b46.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-51baccc14cf1da9e.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>Mousika 规则引擎：让规则可编排、可执行、可解释 - Skyfalling Blog</title><meta name="description" content="本文基于 Mousika 规则引擎平台，系统解析其如何通过 DSL 编排与 JS 求值分层、四棵同构树贯穿全链路、万物皆 UDF 的统一抽象，实现规则从可视化配置到动态执行再到归因分析的完整闭环。适合对业务规则引擎、DSL 设计、动态规则平台感兴趣的工程师阅读。"/><meta property="og:title" content="Mousika 规则引擎：让规则可编排、可执行、可解释"/><meta property="og:description" content="本文基于 Mousika 规则引擎平台，系统解析其如何通过 DSL 编排与 JS 求值分层、四棵同构树贯穿全链路、万物皆 UDF 的统一抽象，实现规则从可视化配置到动态执行再到归因分析的完整闭环。适合对业务规则引擎、DSL 设计、动态规则平台感兴趣的工程师阅读。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2026-2-17"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Mousika 规则引擎：让规则可编排、可执行、可解释"/><meta name="twitter:description" content="本文基于 Mousika 规则引擎平台，系统解析其如何通过 DSL 编排与 JS 求值分层、四棵同构树贯穿全链路、万物皆 UDF 的统一抽象，实现规则从可视化配置到动态执行再到归因分析的完整闭环。适合对业务规则引擎、DSL 设计、动态规则平台感兴趣的工程师阅读。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2026-2-17">2026年02月17日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">Mousika 规则引擎：让规则可编排、可执行、可解释</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/page/1/">规则引擎</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/DSL/page/1/">DSL</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E6%8E%92/page/1/">可视化编排</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>Mousika 规则引擎：让规则可编排、可执行、可解释</h1>
<blockquote>
<p>在大规模业务系统中，业务规则的变更频率远高于代码发布节奏。投放策略、风控拦截条件、流量分配逻辑——这些规则如果硬编码在业务代码中，每次调整都意味着一次发版。</p>
<p>Mousika 是一个面向复杂业务场景的规则引擎平台，它的核心目标是：<strong>让业务规则的变更脱离代码发布周期，通过配置化实现秒级生效</strong>。</p>
<p>本文基于 Mousika 的实际代码，拆解它是如何让规则<strong>可编排</strong>（可视化流程图 → AST）、<strong>可执行</strong>（DSL 编排 + JS 求值分层、UDF 万物皆函数）、<strong>可解释</strong>（四棵同构树驱动全链路归因）的。</p>
</blockquote>
<h3>阅读指南</h3>
<ul>
<li><strong>了解整体架构与设计理念</strong>：阅读第 1–3 章（约 5 分钟）</li>
<li><strong>深入 AST 解析与执行引擎原理</strong>：重点阅读第 4、5 章（约 20 分钟）</li>
<li><strong>UDF 扩展与事件驱动</strong>：第 6、7 章（约 8 分钟）</li>
<li><strong>执行结果与可解释性</strong>：第 8 章（约 5 分钟）</li>
<li><strong>平台能力：可视化编排、动态调试与归因分析</strong>：第 9 章（约 10 分钟）</li>
<li><strong>设计权衡与工程总结</strong>：第 10 章（约 5 分钟）</li>
</ul>
<hr>
<h2>1. 为什么需要规则引擎</h2>
<h3>1.1 业务规则与代码的矛盾</h3>
<p>在实际业务系统中，典型的业务规则如：</p>
<ul>
<li>&quot;代理商 A 旗下客户不允许跨开户操作&quot;</li>
<li>&quot;广告主行业为游戏且日预算低于 1 万时，走人工审核&quot;</li>
<li>&quot;购票人为残疾人时半价，满足特定条件时免费，否则全价&quot;</li>
</ul>
<p>这些规则有三个共同特征：<strong>变更频繁、逻辑复杂、影响面大</strong>。如果硬编码在业务代码中，每次变更都需要经历 开发→测试→上线 的完整周期。</p>
<h3>1.2 规则引擎的核心价值</h3>
<p>规则引擎解决的本质问题是<strong>规则与代码的解耦</strong>：</p>
<pre><code>┌──────────────────────────────────────────────────────────────┐
│                       传统方式                                │
│  业务规则 ──嵌入──→ 业务代码 ──编译──→ 发布 ──部署──→ 生效     │
│                     (变更 = 发版)                             │
└──────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────┐
│                       规则引擎方式                             │
│  业务规则 ──配置──→ 规则平台 ──推送──→ 引擎热加载 ──→ 秒级生效  │
│  业务代码 ──调用──→ 引擎 SDK ──提交 Fact──→ 获取结果            │
│                     (规则变更 ≠ 发版)                          │
└──────────────────────────────────────────────────────────────┘
</code></pre>
<p>Mousika 在此基础上进一步解决了几个工程问题：</p>
<ul>
<li><strong>如何表达复杂的规则编排逻辑</strong>（条件分支、并行、串行、范围匹配）</li>
<li><strong>如何在运行时安全地热更新规则</strong>（MQ 通知 + 定时兜底）</li>
<li><strong>如何让规则执行结果可解释</strong>（树形结果 + 动态描述）</li>
<li><strong>如何扩展规则的能力边界</strong>（UDF 机制 + 插件化 JAR 加载）</li>
</ul>
<hr>
<h2>2. 整体架构</h2>
<h3>2.1 模块全景</h3>
<p>Mousika 采用多模块 Maven 工程组织，各模块职责明确：</p>
<pre><code>mousika/
├── mousika-core              # 规则引擎内核：解析、执行、结果分析
├── mousika-udf-sdk           # UDF 定义 SDK：注解、函数接口
├── mousika-udf               # 内置系统 UDF（场景调用、RPC 调用等）
├── mousika-runtime-base      # 运行时公共组件：监听器、转换器、ES 写入
├── mousika-rpc               # 中心化 RPC 服务（gRPC/Krpc）
├── mousika-brms              # 规则管理平台后端（Web UI）
├── mousika-sdk               # 业务方调用 SDK（Fact 定义 + RPC 接口）
├── mousika-local-runtime-sdk # 去中心化本地运行时 SDK
├── mousika-consumer          # Kafka 消费者（执行结果对比验证）
└── mousika-test-sdk          # 测试 SDK
</code></pre>
<p>核心依赖栈：<strong>ANTLR4</strong>（规则语法解析）、<strong>Nashorn</strong>（JS 表达式执行）、<strong>ByteBuddy</strong>（动态类生成）、<strong>Krpc/gRPC</strong>（RPC 通信）、<strong>jOOQ</strong>（数据库访问）、<strong>Kafka/RocketMQ</strong>（消息驱动）。</p>
<h3>2.2 分层架构</h3>
<p>从数据流视角，Mousika 的架构分为四层，每一层都有明确的职责边界：</p>
<pre><code>┌─────────────────────────────────────────────────────┐
│                   接入层（SDK / RPC）                  │
│   业务方通过 SDK 提交 Fact 对象 + 场景 Key             │
│   RPC 模式: gRPC/Krpc 远程调用                        │
│   SDK 模式: 进程内直接调用                             │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                   编排层（Suite / Scene）               │
│   RuleSuite: 全局单例，持有所有 Scene                   │
│   RuleScene: 业务场景 → 活跃规则集 + 候选规则集（灰度）  │
│   职责: 场景路由、规则集版本管理、灰度验证                │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                   执行层（Evaluator / AST）             │
│   NodeBuilder: ANTLR4 解析规则表达式 → AST 节点树       │
│   RuleEvaluator: Visitor 模式遍历 AST                  │
│   RuleContextImpl: 执行上下文 + 缓存 + 事件分发          │
│   职责: 规则编排逻辑的解释执行                           │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                   引擎层（RuleEngine / UDF）            │
│   Nashorn ScriptEngine: 执行单条 JS 表达式              │
│   UdfContainer: UDF 注册 + ByteBuddy 动态编译           │
│   Bindings: $ = Fact, $$ = Context, UDF 函数           │
│   职责: 单条规则的表达式求值                             │
└─────────────────────────────────────────────────────┘
</code></pre>
<p><strong>为什么分四层而不是两层？</strong> 关键的设计洞察在于：规则的&quot;编排&quot;和&quot;求值&quot;是两个不同性质的问题。编排（AST 层）处理的是节点之间的逻辑关系（与或非、条件分支、串并行），这是一个树遍历问题；求值（引擎层）处理的是单条规则表达式的计算，这是一个脚本执行问题。将两者分离，使得编排逻辑可以用类型安全的 Java AST 实现，而求值逻辑可以利用 JS 引擎的灵活性——各取所长。</p>
<h3>2.3 双模部署</h3>
<p>Mousika 支持两种部署模式，业务方根据延迟敏感度和运维复杂度选型：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>实现模块</th>
<th>规则加载方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>中心化 RPC</strong></td>
<td><code>mousika-rpc</code></td>
<td>从数据库直接加载（<code>RuleLoaderServiceImpl</code>）</td>
<td>统一部署，规则集中管理，有网络开销</td>
</tr>
<tr>
<td><strong>去中心化 SDK</strong></td>
<td><code>mousika-local-runtime-sdk</code></td>
<td>从中心服务拉取（<code>DecentralizedRuleLoaderServiceImpl</code>）</td>
<td>引擎嵌入业务进程，零网络延迟</td>
</tr>
</tbody></table>
<p>两种模式共享同一个 <code>mousika-core</code> 内核。去中心化模式的核心权衡是：<strong>用内存换延迟，用复杂度换自主性</strong>——每个业务进程持有一份规则副本，消除了 RPC 调用开销，但需要自行处理规则同步和版本一致性。</p>
<hr>
<h2>3. 核心概念模型</h2>
<p>在深入实现之前，先厘清 Mousika 的核心领域概念及其关系：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RuleSuite</strong></td>
<td><code>RuleSuite</code></td>
<td>规则套件，顶层容器。持有 <code>RuleEvaluator</code> 和所有 <code>RuleScene</code>。全局单例（<code>volatile</code> + 引用替换实现热更新）</td>
</tr>
<tr>
<td><strong>RuleScene</strong></td>
<td><code>RuleScene</code></td>
<td>规则场景，一个业务场景对应一个 Scene（如&quot;广告审核&quot;&quot;客户分配&quot;）。包含活跃规则集 + 候选规则集</td>
</tr>
<tr>
<td><strong>RuleConfig</strong></td>
<td><code>RuleConfig</code></td>
<td>规则集配置，包含表达式字符串和解析后的 <code>RuleNode</code> AST</td>
</tr>
<tr>
<td><strong>RuleDefinition</strong></td>
<td><code>RuleDefinition</code></td>
<td>单条规则定义：规则 ID + JS 表达式 + 通过/未通过描述文案 + 类型标识</td>
</tr>
<tr>
<td><strong>RuleNode</strong></td>
<td><code>RuleNode</code></td>
<td>规则 AST 节点接口，9 种具体节点类型</td>
</tr>
<tr>
<td><strong>RuleContext</strong></td>
<td><code>RuleContextImpl</code></td>
<td>执行上下文，同时是 Visitor、缓存和跨规则状态容器</td>
</tr>
<tr>
<td><strong>UDF</strong></td>
<td><code>@Udf</code> + <code>Functions.*</code></td>
<td>用户自定义函数，通过注解或动态 JAR 注册</td>
</tr>
<tr>
<td><strong>Fact</strong></td>
<td>业务 POJO</td>
<td>业务方提交的待匹配数据对象，在 JS 引擎中绑定为 <code>$</code></td>
</tr>
</tbody></table>
<p>它们之间的关系构成了两棵树——<strong>配置树</strong>和<strong>执行树</strong>：</p>
<pre><code>配置树（静态结构）                          执行树（运行时构建）

RuleSuite (单例)                          NodeResult
  ├── RuleEvaluator                         ├── expr: &quot;1269-&gt;((1242||1243)?...)&quot;
  │     └── RuleEngine                      ├── matched: true/false
  │           ├── sourceScripts             └── details: [RuleResult]
  │           │   {ruleId → JS expr}              ├── RuleResult (1269)
  │           ├── compiledScripts                 │     ├── matched: true
  │           │   {expr → CompiledScript}         │     └── desc: &quot;获取购票人详情&quot;
  │           └── UdfContainer                    └── RuleResult (1242||1243)
  │                 {namespace → UDF tree}              ├── matched: true
  └── scenes                                          └── subRules: [...]
        {sceneKey → RuleScene}
              ├── activeRule: RuleConfig
              │     └── ruleNode: RuleNode (AST)
              └── candidateRules: [RuleConfig]
</code></pre>
<hr>
<h2>4. 规则表达式与 AST 解析</h2>
<h3>4.1 DSL 设计：为什么不直接用 JS</h3>
<p>一个自然的问题是：既然底层已经用了 Nashorn JS 引擎，为什么不直接让用户写 JS？</p>
<p>答案是 <strong>关注点分离</strong>。用户需要表达的是规则之间的编排关系（&quot;先执行 A，如果通过再执行 B 和 C&quot;），而不是通用编程逻辑。Mousika 设计了一套领域专用语言（DSL），专门用于规则编排：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>语义</th>
<th>节点类型</th>
<th>执行语义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>AndNode</code></td>
<td><strong>短路求值</strong>：任一子节点为 false 立即返回，不再执行后续节点</td>
</tr>
<tr>
<td><code>||</code></td>
<td>逻辑或</td>
<td><code>OrNode</code></td>
<td><strong>短路求值</strong>：任一子节点为 true 立即返回</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>NotNode</code></td>
<td>对子节点结果取反</td>
</tr>
<tr>
<td><code>?:</code></td>
<td>条件分支</td>
<td><code>CaseNode</code></td>
<td><strong>惰性求值</strong>：只执行匹配的分支，未执行分支返回 <code>NaResult</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>串行执行</td>
<td><code>SerNode</code></td>
<td><strong>全量执行</strong>：按顺序执行所有子节点，取最后一个节点的结果</td>
</tr>
<tr>
<td><code>=&gt;</code></td>
<td>并行执行</td>
<td><code>ParNode</code></td>
<td><strong>并发执行</strong>：线程池并发，任一为 true 则整体为 true</td>
</tr>
<tr>
<td><code>limit(l,h,...)</code></td>
<td>范围匹配</td>
<td><code>LimitNode</code></td>
<td>匹配命中数在 <code>[l, h]</code> 区间内为 true</td>
</tr>
<tr>
<td><code>()</code></td>
<td>分组</td>
<td>—</td>
<td>改变优先级</td>
</tr>
</tbody></table>
<p>这套 DSL 与 JS 的关系是：<strong>DSL 负责&quot;编排&quot;（哪些规则按什么逻辑组合），JS 负责&quot;求值&quot;（单条规则怎么计算）</strong>。两者在不同抽象层次工作。</p>
<p>一条实际的规则表达式：</p>
<pre><code>1269-&gt;((1242||1243)?1246:(1241?1244:1245))
</code></pre>
<p>在配置平台上渲染为可视化流程图，运营人员通过拖拽节点和连线即可生成这种表达式——他们不需要理解语法。</p>
<h3>4.2 ANTLR4 解析流程</h3>
<p>规则表达式的解析由 <code>NodeBuilder</code> 驱动，内部使用 ANTLR4 完成从文本到 AST 的转换。ANTLR4 是业界成熟的 parser generator，Mousika 选择它而非手写 Recursive Descent Parser 的原因是：语法可能随业务演化（如后来添加了 <code>limit</code> 和 <code>=&gt;</code> 操作符），ANTLR4 的 grammar 文件易于扩展。</p>
<p>解析分为四步：</p>
<pre><code>                 ┌────────────────────────────────────────────────────────────┐
                 │                   ANTLR4 解析流程                          │
                 │                                                          │
  输入字符串 ─────→  RuleLexer ──→ Token 流 ──→ RuleParser ──→ ParseTree     │
  &quot;1&amp;&amp;2?3:4&quot;     │   (词法分析)     [ID, &amp;&amp;,    (语法分析)      (语法树)       │
                 │                  ID, ?, ...]                             │
                 └──────────────────────────────┬───────────────────────────┘
                                                │
                 ┌──────────────────────────────▼───────────────────────────┐
                 │              DefaultRuleVisitor (ANTLR4 Visitor)         │
                 │                                                          │
                 │  visitOr()   → OrNode          visitPar()  → ParNode     │
                 │  visitAnd()  → AndNode         visitSer()  → SerNode     │
                 │  visitNot()  → NotNode         visitLimit()→ LimitNode   │
                 │  visitIf()   → CaseNode        visitId()   → ExprNode    │
                 └──────────────────────────────┬───────────────────────────┘
                                                │
                                                ▼
                                        RuleNode AST (可执行)
</code></pre>
<p><code>NodeBuilder</code> 对解析结果做了<strong>缓存</strong>（<code>ConcurrentHashMap</code>），同一表达式只解析一次：</p>
<pre><code class="language-java">public static RuleNode build(String expr) {
    return nodeCache.computeIfAbsent(expr, ruleExpr -&gt; {
        long begin = System.currentTimeMillis();
        try {
            RuleNode node = Antlr4Parser.parse(ruleExpr, defaultGenerator);
            ListenerProvider.DEFAULT.onParse(
                new RuleEvent(EventType.PARSE_SUCCEED, ruleExpr, node, cost));
            return node;
        } catch (Exception e) {
            ListenerProvider.DEFAULT.onParse(
                new RuleEvent(EventType.PARSE_FAIL, ruleExpr, e, cost));
            throw new RuleParseException(ruleExpr, &quot;rule parse failed:&quot; + ruleExpr, e);
        }
    });
}
</code></pre>
<h3>4.3 复合规则的递归解析与环检测</h3>
<p>普通规则的叶子节点（<code>ExprNode</code>）直接引用一个规则 ID。但 Mousika 还支持<strong>复合规则</strong>（<code>useType=2</code>）——一条规则的表达式本身是另一个规则集的编排。这意味着解析时需要递归展开。</p>
<p><code>NodeGenerator</code> 处理了这个递归，并通过 <strong>Stack 做环检测</strong>，防止 A → B → A 的循环依赖：</p>
<pre><code class="language-java">static NodeGenerator create(Map&lt;String, String&gt; compositeRules) {
    return new NodeGenerator() {
        private RuleNode parseRecursively(String expr, Stack&lt;String&gt; resolved) {
            if (compositeRules.containsKey(expr)) {
                resolved.push(expr);  // 入栈：标记正在解析
                try {
                    return new CompositeNode(expr,
                        NodeParser.parse(compositeRules.get(expr), s -&gt; {
                            if (resolved.contains(s)) {
                                throw new IllegalStateException(
                                    &quot;circular dependency between [&quot; + expr + &quot;] and [&quot; + s + &quot;]&quot;);
                            }
                            return parseRecursively(s, resolved);  // 递归展开
                        }));
                } finally {
                    resolved.pop();   // 出栈：回溯
                }
            }
            return new ExprNode(expr);  // 叶子节点
        }
    };
}
</code></pre>
<p>这本质上是一个<strong>带回溯的深度优先搜索</strong>：<code>Stack&lt;String&gt; resolved</code> 维护当前解析路径，如果即将解析的节点已经在路径上，说明存在环依赖，立即抛出异常。<code>finally</code> 块确保回溯时正确出栈，不会影响同层的其他分支解析。</p>
<h3>4.4 AST 节点的设计哲学</h3>
<p>所有节点实现 <code>RuleNode</code> 接口，核心方法只有三个：</p>
<pre><code class="language-java">public interface RuleNode {
    EvalResult eval(RuleContext context);  // 执行
    String expr();                          // 表达式序列化
    NodeType ruleNodeType();                // 类型标识

    // Builder 风格的 default 方法，支持链式组合
    default RuleNode and(RuleNode node)  { return new AndNode(this, node); }
    default RuleNode or(RuleNode node)   { return new OrNode(this, node); }
    default RuleNode not()               { return new NotNode(this); }
    default RuleNode next(RuleNode node) { return new SerNode(this, node); }
}
</code></pre>
<p>这个设计有两个值得注意的地方：</p>
<p><strong>1) Interpreter 模式</strong>：每个节点自己负责自己的执行逻辑（<code>eval</code> 方法），而不是由一个集中的解释器遍历 AST。这使得添加新节点类型只需要实现接口，不需要修改任何已有代码（符合开闭原则）。</p>
<p><strong>2) Builder 风格的 default 方法</strong>：<code>and()</code> / <code>or()</code> / <code>next()</code> 直接在接口层提供，使得 AST 可以通过编程方式动态构建，而不仅限于从表达式解析生成：</p>
<pre><code class="language-java">// 编程方式构建 AST，等价于表达式 &quot;(A &amp;&amp; B) || C&quot;
RuleNode tree = ruleA.and(ruleB).or(ruleC);
</code></pre>
<h4>短路求值的实现</h4>
<p><code>AndNode</code> 的短路求值实现非常简洁——遍历子节点，一旦遇到 false 立即返回：</p>
<pre><code class="language-java">public EvalResult eval(RuleContext context) {
    for (RuleNode node : nodes) {
        if (!context.visit(node).isMatched()) {
            return new EvalResult(expr(), false, ruleNodeType());
        }
    }
    return new EvalResult(expr(), true, ruleNodeType());
}
</code></pre>
<p>注意调用的是 <code>context.visit(node)</code> 而非 <code>node.eval(context)</code>——这个间接层是关键，它使得 <code>DefaultNodeVisitor</code> 有机会在每次节点执行时记录执行树（详见 5.4 节），实现了执行逻辑与追踪逻辑的分离。</p>
<h4>CaseNode：三态返回</h4>
<p><code>CaseNode</code> 是最能体现 Mousika 表达力的节点。传统的三元运算符只有 true/false 两种结果，但 Mousika 的 <code>CaseNode</code> 引入了第三种状态——<code>NaResult</code>（Not Applicable）：</p>
<pre><code class="language-java">public EvalResult eval(RuleContext context) {
    EvalResult result = null;
    boolean succeed = context.visit(condition).isMatched();
    if (succeed) {
        if (trueCase != null) result = context.visit(trueCase);
    } else {
        if (falseCase != null) result = context.visit(falseCase);
    }
    return result != null
        ? new EvalResult(expr(), result.getResult(), result.isMatched(), ruleNodeType())
        : new EvalResult(expr(), NaResult.DEFAULT, ruleNodeType());
}
</code></pre>
<p>当分支为 <code>null</code> 时返回 <code>NaResult</code>——表示&quot;该分支未被执行&quot;。这在结果分析中至关重要：它允许下游精确区分&quot;规则执行失败&quot;和&quot;规则根本未被评估&quot;。</p>
<h4>SerNode 与 ParNode：两种执行语义</h4>
<p><code>SerNode</code>（串行）和 <code>ParNode</code>（并行）是 Mousika 特有的控制流节点：</p>
<ul>
<li><strong>SerNode</strong>（<code>-&gt;</code>）：按顺序执行所有子节点，<strong>取最后一个节点的结果</strong>。前面的节点视为&quot;前置动作&quot;——它们的执行结果不影响最终判定，但它们可以通过 <code>$$</code>（上下文 Map）为后续节点准备数据。</li>
</ul>
<pre><code class="language-java">// SerNode.eval() — 全量执行，取最后一个结果
public EvalResult eval(RuleContext context) {
    List&lt;EvalResult&gt; results = nodes.stream()
        .filter(e -&gt; !e.expr().equals(&quot;nop&quot;))
        .map(context::visit)
        .collect(Collectors.toList());
    EvalResult result = results.get(results.size() - 1);
    return new EvalResult(expr(), result.getResult(), result.isMatched(), ruleNodeType());
}
</code></pre>
<ul>
<li><strong>ParNode</strong>（<code>=&gt;</code>）：将子节点提交到线程池并发执行，结果聚合策略是<strong>任一为 true 则整体为 true</strong>。</li>
</ul>
<pre><code class="language-java">// ParNode.eval() — 并发执行 + ThreadLocal 上下文迁移
public EvalResult eval(RuleContext context) {
    RuleContextImpl ruleContext = (RuleContextImpl) context;
    ThreadLocal&lt;EvalNode&gt; currentEval = ruleContext.getCurrentEval();
    EvalNode stashEvalNode = currentEval.get();  // 暂存主线程的执行节点

    Vector&lt;EvalResult&gt; vector = new Vector&lt;&gt;();
    CountDownLatch latch = new CountDownLatch(nodes.size());

    for (RuleNode node : nodes) {
        executor.execute(() -&gt; {
            try {
                EvalNode root = new EvalNode(null, ruleNodeType());
                currentEval.set(root);  // 每个线程独立的执行树根节点
                EvalResult result = context.visit(node);
                stashEvalNode.getChildren().addAll(root.getChildren());  // 合并回主线程
                vector.add(result);
            } finally {
                currentEval.set(null);
                latch.countDown();
            }
        });
    }
    currentEval.set(stashEvalNode);  // 恢复主线程上下文
    latch.await(timeout, TimeUnit.MILLISECONDS);
    // ...
}
</code></pre>
<p><code>ParNode</code> 中最复杂的部分是 <strong>ThreadLocal 上下文的迁移</strong>。<code>DefaultNodeVisitor</code> 使用 <code>ThreadLocal&lt;EvalNode&gt;</code> 追踪当前执行位置，在并行场景下，每个工作线程需要创建独立的执行树根节点，完成后再将子节点合并回主线程的执行树。这里使用 <code>Vector</code>（线程安全）收集结果，<code>EvalNode.children</code> 也使用 <code>Vector</code> 以保证并发写入安全。</p>
<h4>LimitNode：范围匹配</h4>
<p><code>LimitNode</code> 表达的语义是&quot;N 个规则中命中了 M 个，M 是否在 [low, high] 范围内&quot;：</p>
<pre><code class="language-java">public EvalResult eval(RuleContext context) {
    int hit = 0;
    for (RuleNode node : nodes) {
        EvalResult eval = node.eval(context);
        if (eval.isMatched()) hit++;
        if (high &gt; 0 &amp;&amp; hit &gt; high) break;  // 提前终止：已超上限
    }
    return new EvalResult(expr(), result.getResult(),
        hit &gt;= low &amp;&amp; (high &lt; 0 || hit &lt;= high), ruleNodeType());
}
</code></pre>
<p><code>high = -1</code> 表示无上限。这个节点实现了类似 &quot;至少满足 2 个条件中的 1 个&quot; 或 &quot;恰好满足 3 个条件中的 2 个&quot; 这样的投票逻辑，为业务规则提供了灵活的组合能力。</p>
<hr>
<h2>5. 执行引擎</h2>
<h3>5.1 RuleEngine：JS 脚本编译与缓存</h3>
<p><code>RuleEngine</code> 是单条规则的执行核心，基于 <strong>Nashorn JavaScript 引擎</strong>。选择 JS 引擎而非自研表达式求值器的原因是：JS 天然支持属性链访问（<code>$.advertiser.industry</code>）、运算符、字符串操作等，省去了大量的解析和执行逻辑开发。</p>
<pre><code class="language-java">public class RuleEngine {
    private ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);
    private Map&lt;String, String&gt; sourceScripts = new ConcurrentHashMap&lt;&gt;();         // 源脚本
    private Map&lt;String, CompiledScript&gt; compiledScripts = new ConcurrentHashMap&lt;&gt;(); // 编译缓存
    private UdfContainer udfContainer = new UdfContainer(engine);

    // 初始化时注册内置规则
    {
        this.register(new RuleDefinition(&quot;true&quot;, &quot;true&quot;, &quot;SUCCESS&quot;));
        this.register(new RuleDefinition(&quot;false&quot;, &quot;false&quot;, &quot;FAILED&quot;));
        this.register(new RuleDefinition(&quot;null&quot;,
            &quot;Java.type(&#39;&quot; + NaResult.class.getName() + &quot;&#39;).DEFAULT&quot;, &quot;NOP&quot;));
        this.register(new RuleDefinition(&quot;nop&quot;,
            &quot;Java.type(&#39;&quot; + NaResult.class.getName() + &quot;&#39;).DEFAULT&quot;, &quot;NOP&quot;));
    }
}
</code></pre>
<p>几个关键的设计细节：</p>
<p><strong>1) 预编译 + 缓存</strong>：JS 表达式通过 <code>Compilable.compile()</code> 预编译为 <code>CompiledScript</code>，后续执行直接调用 <code>compiledScript.eval(bindings)</code>。编译结果按表达式文本做 key 缓存，避免重复解析。</p>
<pre><code class="language-java">private CompiledScript compile(String expression, boolean cache) {
    CompiledScript compiled = compiledScripts.get(expression);
    if (compiled == null) {
        compiled = ((Compilable) engine).compile(expression);
        if (cache) compiledScripts.put(expression, compiled);
    }
    return compiled;
}
</code></pre>
<p><strong>2) Bindings 隔离</strong>：每次执行都创建独立的 <code>Bindings</code>，避免线程间状态污染。三种绑定注入：</p>
<pre><code class="language-java">private Object doEval(CompiledScript script, Object root, Object context) {
    Bindings bindings = engine.createBindings();
    bindings.putAll(udfContainer.compileUdf());  // UDF 函数（命名空间对象）
    bindings.put(&quot;$&quot;, root);                      // Fact 数据对象
    bindings.put(&quot;$$&quot;, context);                   // 执行上下文 Map
    Object result = script.eval(bindings);
    return ScriptUtils.convertIntoJavaObject(result);  // JS 对象 → Java 对象
}
</code></pre>
<p><strong>3) 内置规则</strong>：<code>true</code>、<code>false</code>、<code>null</code>、<code>nop</code> 是预注册的规则 ID。<code>null</code> 和 <code>nop</code> 返回 <code>NaResult.DEFAULT</code>（通过 Nashorn 的 <code>Java.type()</code> 引用 Java 类），用于在 CaseNode 中表示&quot;不执行&quot;。</p>
<h3>5.2 规则描述的动态插值</h3>
<p>每条规则可以配置两个描述文案（分别对应通过/不通过时展示），支持 <code>{$.field}</code> 语法引用 Fact 对象字段。<code>evalRuleDesc()</code> 方法通过正则替换将模板转换为 JS 字符串拼接表达式，然后复用 JS 引擎执行：</p>
<pre><code class="language-java">public String evalRuleDesc(String ruleId, Boolean match, Object root, Object context) {
    // 选择对应的描述模板
    String originDesc = match ? explainPair.getRight() : explainPair.getLeft();

    // 正则替换: {$.agentId} → &quot;+$.agentId+&quot;
    // 最终拼接为 JS 字符串表达式: &quot;代理商【&quot;+$.agentId+&quot;】不允许跨开&quot;
    originDesc = &quot;\&quot;&quot; + originDesc.replaceAll(&quot;\\{(\\$+\\..+?)\\}&quot;, &quot;\\\&quot;+$1+\\\&quot;&quot;) + &quot;\&quot;&quot;;
    return (String) evalExpr(originDesc, root, context);
}
</code></pre>
<p>这个设计的巧妙之处在于<strong>复用了 JS 引擎的求值能力</strong>来做模板渲染——不需要引入额外的模板引擎，<code>$</code> 绑定在 Bindings 中天然可用。</p>
<h3>5.3 RuleContextImpl：三位一体的执行上下文</h3>
<p><code>RuleContextImpl</code> 是整个执行流程的核心协调者。它的类定义本身就揭示了它的多重身份：</p>
<pre><code class="language-java">public class RuleContextImpl extends LinkedHashMap&lt;String, Object&gt; implements RuleContext
</code></pre>
<p><strong>继承 <code>LinkedHashMap</code></strong>：自身就是上下文 Map，以 <code>$$</code> 的身份暴露给 JS 引擎。规则执行过程中可以通过 <code>$$.put(&quot;key&quot;, value)</code> 在规则之间传递状态——这是 <code>SerNode</code>（串行节点）能够实现&quot;前置动作准备数据，后续规则使用数据&quot;模式的基础。</p>
<p><strong>实现 <code>RuleContext</code></strong>：同时承担 Visitor 协调和规则执行两个职责：</p>
<pre><code class="language-java">// 规则执行：带缓存的幂等执行
public EvalResult eval(String ruleId) {
    return evalCache.computeIfAbsent(ruleId, this::doEval);
}

// Visitor 协调：委托给 DefaultNodeVisitor，同时维护 currentRule
public EvalResult visit(RuleNode node) {
    if (node instanceof ExprNode) {
        this.currentRule.set(node.expr());  // 追踪当前执行的规则 ID
    }
    return visitor.visit(node);
}
</code></pre>
<p><code>evalCache</code> 使用 <code>ConcurrentSkipListMap</code> 实现——有序且线程安全。当同一个规则 ID 在 AST 中被多个分支引用时，只会执行一次，后续直接返回缓存结果。这不仅是性能优化，更保证了<strong>规则执行的幂等性</strong>。</p>
<h3>5.4 DefaultNodeVisitor：执行树的构建</h3>
<p><code>DefaultNodeVisitor</code> 在每次 <code>visit()</code> 调用时构建一棵与 AST 平行的<strong>执行树</strong>（<code>EvalNode</code> 树）。这棵树记录了&quot;实际执行了哪些节点，每个节点的结果是什么&quot;——这是结果可解释性的基础。</p>
<pre><code class="language-java">public EvalResult visit(RuleNode node) {
    EvalNode evalNode = new EvalNode(node.expr(), node.ruleNodeType());
    boolean isExprNode = node.getClass() == ExprNode.class;

    currentEval.get().getChildren().add(evalNode);  // 挂到父节点下

    if (!isExprNode) {
        evalNode.setParent(currentEval.get());
        currentEval.set(evalNode);   // 进入子树
    }

    EvalResult result = node.eval(ruleContext);  // 实际执行

    if (!isExprNode) {
        // 缓存复合节点的结果
        ((RuleContextImpl) ruleContext).getEvalCache().put(node.expr(), result);
        currentEval.set(currentEval.get().getParent());  // 回溯到父节点
    }
    return result;
}
</code></pre>
<p><strong>区分 ExprNode 和复合节点</strong>是这段代码的关键：<code>ExprNode</code>（叶子节点）直接挂到当前节点下作为子节点；复合节点（And/Or/Case 等）则需要&quot;进入&quot;——将 <code>currentEval</code> 指向自己，这样它的子节点会被正确地挂到它下面。执行完成后&quot;回溯&quot;到父节点。这本质上是一个<strong>基于 ThreadLocal 的栈帧模拟</strong>，用来在扁平的 <code>visit()</code> 调用序列中重建树形结构。</p>
<h3>5.5 规则类型与决策表</h3>
<p>Mousika 通过 <code>RuleDefinition.useType</code> 支持三种规则类型：</p>
<table>
<thead>
<tr>
<th>useType</th>
<th>类型</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>普通规则</td>
<td>JS 表达式直接注册到 <code>RuleEngine</code></td>
</tr>
<tr>
<td>1</td>
<td>决策表</td>
<td><strong>转换为 UDF</strong> → 注册为动态函数 → 修改表达式为 <code>udf($)</code></td>
</tr>
<tr>
<td>2</td>
<td>复合规则</td>
<td>规则表达式引用其他规则集 → <strong>递归解析</strong>为 <code>CompositeNode</code></td>
</tr>
</tbody></table>
<p>决策表的处理体现了 Mousika 的统一抽象能力——不引入新的执行机制，而是将决策表转换为 UDF，复用已有的引擎：</p>
<pre><code class="language-java">case 1: // 决策表
    String udf = &quot;udf_rule_table_$&quot; + ruleDefinition.getRuleId();
    // 将决策表 JSON 配置转换为 RuleTableUdf 函数
    udfDefinitions.add(new UdfDefinition(udf,
        RuleTableUdf.fromJson(ruleDefinition.getExpression())));
    // 修改规则表达式为 UDF 调用
    ruleDefinition.setExpression(udf + &quot;($)&quot;);
    break;
</code></pre>
<p><code>RuleTableUdf</code> 接收 Fact 对象，遍历表格的每一行，检查所有列条件是否匹配——本质上是一个 <strong>多维度 AND 匹配器</strong>。</p>
<hr>
<h2>6. UDF 扩展机制</h2>
<p>UDF（User Defined Function）是 Mousika 的能力扩展基座。决策表、外部 RPC 调用、跨场景规则引用——这些看似不同的功能，全部通过 UDF 机制统一实现。</p>
<h3>6.1 函数式接口体系</h3>
<p><code>mousika-udf-sdk</code> 定义了 <code>Functions</code> 类，包含 <code>Function0</code> 到 <code>Function22</code> 共 23 个函数式接口（对应 0 到 22 个参数），覆盖了所有可能的 UDF 签名：</p>
<pre><code class="language-java">@Udf(value = &quot;eval&quot;, group = &quot;sys.scene&quot;)
@Component
public class EvalSceneUdf implements Functions.Function3&lt;String, Object, Map&gt; {
    public Object apply(String sceneKey, Object target, Map context) {
        return RuleSuite.get().evalScene(sceneKey, target, context);
    }
}
</code></pre>
<h3>6.2 UdfDelegate：反射代理与自动类型转换</h3>
<p>JS 引擎调用 Java UDF 时，参数类型是 JS 对象（Nashorn 的内部类型），需要转换为 Java 类型。<code>UdfDelegate</code> 通过<strong>反射 + JSON 序列化</strong>实现了透明的类型桥接：</p>
<pre><code class="language-java">public Object apply(Object... params) {
    // 1. 按参数个数查找匹配的 apply 方法（排除 bridge 方法）
    Method method = Reflections.getMethods(udf.getClass(),
        m -&gt; m.getName().equals(&quot;apply&quot;)
            &amp;&amp; m.getParameterCount() == params.length
            &amp;&amp; !m.isBridge()
    ).stream().findFirst().orElseThrow(...);

    // 2. 逐参数做类型转换：JS Object → JSON String → Java Type
    Object[] casts = Reflections.convert(params,
        method.getGenericParameterTypes(), converter);

    // 3. 反射调用
    return Reflections.invoke(method, udf, casts);
}
</code></pre>
<p>类型转换器的策略是：先尝试将 JS 对象转为 Java 对象（<code>ScriptUtils.convertIntoJavaObject</code>），如果类型不匹配，则序列化为 JSON 字符串再反序列化为目标类型。这种 <strong>JSON 作为中间格式</strong> 的做法虽然有性能开销，但保证了 JS 与 Java 之间几乎任意类型都能互通。</p>
<h3>6.3 UdfContainer：ByteBuddy 动态类生成</h3>
<p>UDF 在 JS 引擎中以属性链方式访问（如 <code>sys.scene.eval(...)</code>），但 Nashorn 的 <code>Bindings</code> 只支持扁平的 key-value。<code>UdfContainer</code> 需要将嵌套的 UDF 注册表（<code>Map&lt;String, Map&lt;String, Object&gt;&gt;</code>）转换为嵌套的 Java 对象。</p>
<p>它使用 <strong>ByteBuddy 在运行时动态生成 Java 类</strong>：</p>
<pre><code class="language-java">private static Object compileUdf(String name, Object udf) {
    if (!(udf instanceof HashMap)) return udf;

    Map&lt;String, Object&gt; udfMap = (Map&lt;String, Object&gt;) udf;
    // ByteBuddy 动态生成一个类，为每个 key 创建一个 public 字段
    Builder&lt;Object&gt; subclass = new ByteBuddy()
        .subclass(Object.class)
        .name(name);
    for (Entry&lt;String, Object&gt; entry : udfMap.entrySet()) {
        subclass = subclass.defineField(entry.getKey(), Object.class, Visibility.PUBLIC);
    }
    // 实例化并赋值（递归处理嵌套命名空间）
    Object instance = subclass.make()
        .load(Thread.currentThread().getContextClassLoader())
        .getLoaded().newInstance();
    for (Entry&lt;String, Object&gt; entry : udfMap.entrySet()) {
        instance.getClass().getField(entry.getKey())
            .set(instance, compileUdf(name + &quot;$&quot; + capitalize(entry.getKey()), entry.getValue()));
    }
    return instance;
}
</code></pre>
<p>对于 <code>sys.scene.eval</code> 这样的三层命名空间，ByteBuddy 会生成如下类层次：</p>
<pre><code>UDF$Sys            (class, field: scene)
  └── UDF$Sys$Scene    (class, field: eval)
        └── UdfDelegate  (实际的函数代理对象)
</code></pre>
<p>Nashorn 引擎通过属性访问 <code>sys.scene.eval(...)</code> 时，会依次访问 <code>UDF$Sys</code> 实例的 <code>scene</code> 字段 → <code>UDF$Sys$Scene</code> 实例的 <code>eval</code> 字段 → 得到 <code>UdfDelegate</code> → 调用其 <code>apply()</code> 方法。整个过程对 JS 表达式编写者完全透明。</p>
<h3>6.4 动态 JAR 加载：插件化 UDF</h3>
<p><code>SpringUdfLoader</code> 支持在运行时从外部加载 JAR 文件，实现插件化的 UDF 扩展：</p>
<pre><code class="language-java">protected void loadBeans(File file) {
    // 1. 创建隔离的 ClassLoader
    ClassLoader classLoader = new URLClassLoader(
        new URL[]{classPathToURL(file.getAbsolutePath())}, originClassLoader);

    // 2. 创建独立的 Spring 容器（父容器为主应用容器）
    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(...);
    context.setClassLoader(classLoader);
    context.setParent(originContext);

    // 3. 扫描自动配置类（读取 META-INF/spring.factories）
    String[] configurations = getConfigurations(classLoader);
    for (String config : configurations) {
        context.register(classLoader.loadClass(config));
    }

    // 4. 刷新容器，完成 Bean 初始化
    context.refresh();
    this.fileOfContext.put(file, context);
}
</code></pre>
<p>这里的关键设计是<strong>容器隔离 + 父子关系</strong>：每个 JAR 有独立的 <code>ClassLoader</code> 和 <code>ApplicationContext</code>，但以主应用容器为父容器——这意味着 JAR 中的 UDF 可以注入主应用的 Bean（如 RPC 客户端），但不会污染主应用的 Bean 空间。</p>
<p>卸载时（<code>unloadBeans</code>）需要做 <strong>Spring 缓存清理</strong>：关闭子容器、清理 <code>AbstractAutoProxyCreator</code> 的代理缓存、清理 Krpc 的引用缓存、清理 gRPC transport。这些清理工作是防止 ClassLoader 泄漏的关键——如果不清理，被卸载的类仍会被缓存引用，导致 ClassLoader 无法被 GC。</p>
<hr>
<h2>7. 事件驱动体系</h2>
<p>Mousika 的事件体系覆盖了规则生命周期的三个阶段：<strong>解析时、执行时、变更时</strong>。</p>
<h3>7.1 引擎内事件：观察者模式</h3>
<p><code>RuleEvent</code> 是引擎内部的轻量事件对象：</p>
<pre><code class="language-java">public class RuleEvent {
    private EventType eventType;  // PARSE_SUCCEED / PARSE_FAIL / EVAL_SUCCEED / EVAL_FAIL
    private String ruleExpr;      // 规则表达式或规则 ID
    private Object data;          // 成功时为 EvalResult / RuleNode，失败时为 Exception
    private long cost;            // 耗时（毫秒）
}
</code></pre>
<p><code>ListenerProvider</code> 实现了经典的<strong>观察者模式</strong>——它自身既是 <code>RuleListener</code>，也是监听器注册中心。所有引擎内事件通过 <code>ListenerProvider.DEFAULT</code>（全局静态单例）扇出到所有注册的监听器。</p>
<p>事件触发的时机精确定义在两个位置：</p>
<table>
<thead>
<tr>
<th>触发位置</th>
<th>事件类型</th>
<th>设计意图</th>
</tr>
</thead>
<tbody><tr>
<td><code>NodeBuilder.build()</code></td>
<td><code>PARSE_SUCCEED</code> / <code>PARSE_FAIL</code></td>
<td>监控规则表达式的解析成功率和耗时</td>
</tr>
<tr>
<td><code>RuleContextImpl.doEval()</code></td>
<td><code>EVAL_SUCCEED</code> / <code>EVAL_FAIL</code></td>
<td>监控每条规则的执行成功率、耗时和异常</td>
</tr>
</tbody></table>
<h3>7.2 内置监听器</h3>
<p><strong>RuleEvalLogListener</strong>：日志和错误监控的基础。<code>EVAL_FAIL</code> 和 <code>PARSE_FAIL</code> 时上报 <code>ad.mousika.rule.error</code> 指标，便于配置报警。</p>
<p><strong>RuleEvalElapsedListener</strong>：性能监控的基础。记录每条规则的执行耗时，按 pass / fail / error 三种状态分维度上报 <code>ad.mousika.rule.elapsed</code> 指标。当某条规则突然变慢（比如依赖的外部服务超时），可以通过这个指标快速定位。</p>
<h3>7.3 规则变更事件（MQ 驱动热加载）</h3>
<p>规则热加载是 Mousika 的核心能力之一。变更通知通过 <strong>RocketMQ 广播</strong>推送：</p>
<pre><code>BRMS 保存规则
    │
    ▼
发布消息到 ad_infra_mousika_rule_info_notify_topic（广播模式）
    │
    ▼
AbstractNotifyConsumer 接收通知
    │  提取变更的 sceneKey，放入内部队列
    ▼
定时调度器批量处理队列中的变更
    │
    ▼
RuleLoader.loadSuite()
    │  从数据库 / 中心服务重新加载所有规则
    ▼
new RuleSuite(definitions, udfs, scenes)
    │  构造新的 RuleSuite 实例
    ▼
RuleSuite.current = newSuite  (volatile 引用替换)
</code></pre>
<p>热加载的线程安全依赖两个机制：</p>
<ol>
<li><p><strong><code>volatile</code> 引用替换</strong>：<code>RuleSuite.current</code> 是 <code>volatile</code> 的，新实例构造完成后直接替换引用。正在执行的请求仍持有旧实例的引用（Java GC 的引用计数保证旧实例不会被提前回收），新请求使用新实例。这是一种<strong>无锁的 Copy-on-Write</strong> 策略。</p>
</li>
<li><p><strong>双重保障</strong>：MQ 通知实现秒级生效，<code>RuleSuiteRefreshTask</code> 每 5 分钟定时全量刷新作为兜底——防止 MQ 消息丢失或消费失败导致的规则不一致。</p>
</li>
</ol>
<h3>7.4 执行审计事件（Kafka + ES）</h3>
<p>在中心化 RPC 模式下，每次规则执行的完整上下文会<strong>异步写入 Kafka</strong>（Topic: <code>ad_mousika_eval_info_topic</code>）。这条数据链支撑了三个下游场景：</p>
<pre><code>规则执行
    │
    ├──→ Kafka (ad_mousika_eval_info_topic)
    │         │
    │         ├──→ EvalCompareService (灰度对比)
    │         │    对比 activeRule 和 candidateRule 的执行结果差异
    │         │    发现不一致时生成验证报告
    │         │
    │         └──→ 数据分析平台 (离线分析)
    │
    └──→ ElasticSearch (实时写入)
              │
              └──→ BRMS 在线调试
                   输入 Fact JSON → 查看执行详情 → 定位规则问题
</code></pre>
<p>灰度验证的机制是：每个 <code>RuleScene</code> 除了 <code>activeRule</code>（线上生效的规则集），还可以挂载 <code>candidateRules</code>（候选规则集）。执行时，活跃规则集在主线程执行返回结果，候选规则集在独立线程池异步执行，两组结果写入 Kafka 后由 <code>EvalCompareService</code> 对比——这使得规则变更可以在不影响线上的前提下提前验证。</p>
<hr>
<h2>8. 执行结果与可解释性</h2>
<h3>8.1 结果类型层次</h3>
<p>规则引擎不仅要给出&quot;通过/不通过&quot;的结论，还要能解释<strong>为什么</strong>。Mousika 的结果体系是一棵与 AST 对应的结果树：</p>
<pre><code>NodeResult                          -- 规则集执行结果
  ├── expr: String                  -- 完整规则集表达式
  ├── nodeType: NodeType            -- 根节点类型
  ├── result: Object                -- 原始返回值
  └── details: List&lt;RuleResult&gt;     -- 详细结果树
        └── RuleResult              -- 单条规则结果
              ├── expr: String      -- 规则 ID
              ├── result: Object    -- JS 引擎返回的原始值
              ├── matched: boolean  -- 匹配结果
              ├── desc: String      -- 动态描述（如 &quot;广告主 张三 行业不合规&quot;）
              ├── nodeType          -- 节点类型
              └── subRules: List&lt;RuleResult&gt;  -- 子规则结果（递归）
</code></pre>
<h3>8.2 布尔类型转换策略</h3>
<p>JS 引擎的返回值类型不确定，Mousika 通过 <code>EvalResult.parseBoolean()</code> 做智能转换：</p>
<pre><code class="language-java">private boolean parseBoolean(Object res) {
    if (res == null)             return false;
    if (res instanceof Boolean)  return (Boolean) res;
    if (res instanceof Number)   return ((Number) res).floatValue() &gt; 0;
    if (res instanceof String)   return ((String) res).toLowerCase().matches(&quot;yes|true|1&quot;);
    if (res instanceof UdfPredicate) return ((UdfPredicate) res).test();
    return res != null;  // 非 null 对象默认为 true
}
</code></pre>
<p><code>UdfPredicate</code> 接口是一个扩展点——UDF 可以返回一个实现了 <code>UdfPredicate</code> 的对象，通过自定义的 <code>test()</code> 方法决定布尔语义。这允许 UDF 返回&quot;富结果&quot;（携带额外数据），同时仍能作为布尔条件参与 AST 的逻辑判断。</p>
<h3>8.3 描述动态插值的实现原理</h3>
<p>规则描述支持 <code>{$.field}</code> 语法引用 Fact 字段。<code>evalRuleDesc()</code> 通过正则替换将模板转换为 JS 字符串拼接表达式，然后复用 JS 引擎求值：</p>
<pre><code>输入模板:  &quot;代理商【{$.agentId}】不允许【{$.customerId}】跨开&quot;
正则替换:  &quot;代理商【&quot;+$.agentId+&quot;】不允许【&quot;+$.customerId+&quot;】跨开&quot;
JS 求值:   &quot;代理商【10086】不允许【20001】跨开&quot;
</code></pre>
<p>这个设计复用了引擎已有的 JS 执行能力，零额外依赖。</p>
<hr>
<h2>9. 平台能力：可视化编排、动态调试与归因分析</h2>
<p>规则引擎的核心能力在于执行，但一个能<strong>落地生产</strong>的规则平台，还需要回答三个问题：运营人员如何配置规则？配置错了怎么验证？线上规则命中异常时如何定位原因？Mousika 的 BRMS（Business Rule Management System）平台围绕这三个问题，构建了可视化编排、动态调试和归因分析三大前端能力。</p>
<h3>9.1 可视化规则编排：从流程图到 AST</h3>
<p>运营人员不写代码，他们需要的是&quot;画流程图&quot;——在画布上拖拽节点、连接边线，所见即所得。Mousika 的 BRMS 提供了三代 UI 编排方案，逐步演进：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>实现类</th>
<th>UI 形态</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>v1.0 规则树</td>
<td><code>TreeNode</code></td>
<td>树形嵌套面板</td>
<td>简单条件分支（if-else 嵌套）</td>
</tr>
<tr>
<td>v2.0 流程图</td>
<td><code>GraphNode</code></td>
<td>有向图（节点 + 有向边）</td>
<td>复杂条件链（多级分支 + 环检测）</td>
</tr>
<tr>
<td>v3.0 流程图</td>
<td><code>GraphNodeV2</code></td>
<td>结构化流程图（语义化节点类型）</td>
<td>全场景覆盖（串/并行网关、排他分支、复合条件）</td>
</tr>
</tbody></table>
<h4>核心设计：UI 节点到 AST 节点的双向映射</h4>
<p>三代方案共享同一个核心接口 <code>UiConfig</code>——前后端传输协议：</p>
<pre><code class="language-java">public interface UiConfig {
    RuleNode toRule();           // UI 配置 → 引擎可执行的 AST
    void valid();                // 配置合法性校验
    Set&lt;Long&gt; collectRuleIds();  // 收集引用的规则 ID 集合
}
</code></pre>
<p>这个接口是<strong>整个平台能力的锚点</strong>：无论前端用什么形态展示规则（树、图、画布），后端只关心一件事——它能否转换为合法的 <code>RuleNode</code> AST。</p>
<h4>v3.0 流程图的节点类型体系</h4>
<p><code>GraphNodeV2</code> 是当前主力方案，它定义了 9 种语义化节点类型，每种节点对应一种 AST 结构：</p>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│                   GraphNodeV2 节点类型体系                        │
│                                                                  │
│  start (EntryNode)          ── 流程入口，委托给子节点              │
│  condition (ConditionNode)  ── 条件分支 → CaseNode               │
│  action (ActionNode)        ── 动作执行 → ExprNode / SerNode     │
│  and (LogicAndNode)         ── 逻辑与 → AndNode                  │
│  or (LogicOrNode)           ── 逻辑或 → OrNode                   │
│  serial (SerialGatewayNode) ── 串行网关 → SerNode                │
│  parallel (ParallelGatewayNode) ── 并行网关 → ParNode            │
│  exclusive (ExclusiveNode)  ── 排他网关 → 嵌套 CaseNode 链        │
│  complexCondition (ComplexConditionNode) ── 复合条件（And/Or 组合）│
└──────────────────────────────────────────────────────────────────┘
</code></pre>
<p>每种 UI 节点通过 <code>toRule()</code> 方法递归生成对应的 AST 节点。以 <code>ConditionNode</code> 为例：</p>
<pre><code class="language-java">public RuleNode toRule() {
    ExprNode exprNode = new ExprNode(String.valueOf(ruleId));
    RuleNode ruleNode = negative ? new NotNode(exprNode) : exprNode;

    // 无出度分支 → 纯条件节点
    if (getTrueCase() == null &amp;&amp; getFalseCase() == null) {
        return ruleNode;
    }
    // 有分支 → CaseNode（条件 + true 分支 + false 分支）
    return new CaseNode(ruleNode, getTrueCase().toRule(),
            getFalseCase() == null ? null : getFalseCase().toRule());
}
</code></pre>
<p><code>ExclusiveNode</code>（排他网关）的转换最为巧妙——它将多个互斥条件分支<strong>从后向前折叠</strong>为嵌套的 <code>CaseNode</code> 链：</p>
<pre><code class="language-java">// ExclusiveNode.toRule() — 排他网关的递归折叠
// 输入: [条件A → 动作1, 条件B → 动作2, 条件C → 动作3] + 默认动作D
// 输出: A ? 动作1 : (B ? 动作2 : (C ? 动作3 : D))

while (CollectionUtils.isNotEmpty(ruleNodes)) {
    CaseNode lastCaseNode = (CaseNode) ruleNodes.removeLast();
    if (isHandleLastCondition &amp;&amp; defaultNode != null) {
        caseNode = new CaseNode(lastCaseNode.getCondition(),
            lastCaseNode.getTrueCase(), defaultNode.toRule());
        isHandleLastCondition = false;
    } else {
        caseNode = new CaseNode(lastCaseNode.getCondition(),
            lastCaseNode.getTrueCase(), caseNode);
    }
}
</code></pre>
<p>这意味着运营人员在画布上看到的是&quot;排他网关&quot;（类似 BPMN 中的 XOR Gateway），但引擎实际执行的是嵌套的三元表达式——<strong>视觉语义与执行语义的分离</strong>。</p>
<h4>JSON 双向序列化与草稿机制</h4>
<p><code>GraphNodeV2</code> 通过 Jackson 的 <code>@JsonTypeInfo</code> + <code>@JsonTypeIdResolver</code> 实现多态 JSON 序列化。每个节点携带 <code>nodeType</code> 字段用于反序列化时的类型路由，前后端通过同一份 JSON 结构进行数据交换。</p>
<pre><code class="language-java">@JsonTypeInfo(use = Id.CUSTOM, property = &quot;nodeType&quot;)
@JsonTypeIdResolver(GraphNodeV2NodeTypeResolver.class)
public interface Node {
    String getNodeType();
    RuleNode toRule();
    List&lt;Long&gt; ruleIdList();
}
</code></pre>
<p><code>GraphNodeV2</code> 还支持<strong>草稿模式</strong>（<code>isDraft = true</code>）：运营人员可以保存未完成的流程图配置而不触发 AST 转换和校验——这对于复杂规则集的渐进式编排至关重要。同时，<code>feUiConfig</code> 字段存储前端画布的布局信息（节点坐标、连线路径等），确保再次打开时视觉布局不丢失。</p>
<h4>v2.0 流程图：有向图 + 环检测</h4>
<p><code>GraphNode</code>（v2.0）采用经典的有向图模型——节点列表 + 有向边列表：</p>
<pre><code class="language-java">public class GraphNode implements UiConfig {
    private Map&lt;String, Node&gt; nodeMap;           // 节点集合
    private Map&lt;String, List&lt;Edge&gt;&gt; outComingEdgeMap; // 出边映射

    public RuleNode toRule() {
        String firstNodeId = outComingEdgeMap.get(startNodeId).get(0).getTarget().getId();
        return toRule(firstNodeId, outComingEdgeMap, nodeMap);  // 递归遍历有向图生成 AST
    }
}
</code></pre>
<p><code>valid()</code> 方法执行三项校验：<strong>单入口检查</strong>（确保只有一个起始节点）、<strong>条件完整性检查</strong>（每个条件节点必须有两条出边）、<strong>环路检测</strong>（DFS + 回溯，防止循环依赖导致执行死循环）。</p>
<h3>9.2 动态调试：实时验证规则逻辑</h3>
<p>规则配置完成后，运营人员需要在发布前验证逻辑正确性。Mousika 提供了两层调试能力：</p>
<h4>在线调试（规则集级别）</h4>
<p><code>RuleDebugController</code> 暴露 <code>/api/brms/rule/debug/call</code> 接口，接受 Fact JSON 和规则集 ID / 规则表达式，<strong>直接调用引擎 RPC 服务</strong>执行并返回完整结果：</p>
<pre><code class="language-java">public String call(CallParam param) {
    String ruleExpr = param.getExpr();
    if (debugType == DebugTypeEnum.RULE_SET) {
        // 从数据库读取规则集配置
        RuleSetRecord record = ruleSetDao.queryById(Long.parseLong(param.getExpr()));
        ruleExpr = record.getConfig();
    }
    // 构造 gRPC 请求，调用引擎 evalByRuleExpr
    RuleExprRequest request = RuleExprRequest.newBuilder()
        .setRuleExpr(ruleExpr).setRawFact(param.getRequest()).build();
    EvalResponse response = ruleEngineService.evalByRuleExpr(request);
    return ObjectMapperUtils.toJSON(response);
}
</code></pre>
<p>调试支持两种粒度：<strong>单条规则</strong>（<code>DebugTypeEnum.RULE</code>）和<strong>规则集</strong>（<code>DebugTypeEnum.RULE_SET</code>）。规则集调试时，先从数据库读取完整的规则集表达式，再提交给引擎执行——确保调试结果与线上一致。</p>
<h4>实时表达式调试（未保存的规则）</h4>
<p><code>/api/brms/rule/debug/execRuleExpr</code> 接口支持对<strong>尚未保存</strong>的规则表达式进行实时调试——运营人员在编辑器中修改了 JS 表达式后，无需保存即可立即验证：</p>
<pre><code class="language-java">public String exeRuleExpr(ExeParam exeParam) {
    RuleEngine ruleEngine = new RuleEngine();  // 独立引擎实例，不影响线上
    Object result = ruleEngine.evalExpr(
        exeParam.getRuleExpr(),
        ObjectMapperUtils.fromJson(exeParam.getRequest()),
        new Object()
    );
    return Objects.isNull(result) ? &quot;&quot; : ObjectMapperUtils.toJSON(result);
}
</code></pre>
<p>注意这里创建了一个全新的 <code>RuleEngine</code> 实例——与线上引擎完全隔离，避免调试数据污染生产环境。</p>
<h4>智能参数模板生成</h4>
<p>调试的痛点之一是构造测试入参。<code>genRequestModel()</code> 方法自动分析规则集引用的所有变量（通过正则 <code>\$[.a-zA-Z_0-9]+</code> 提取），并生成一个带默认值的 JSON 模板：</p>
<pre><code class="language-java">// 1. 从规则集中收集所有规则 ID
// 2. 查询规则定义，提取 JS 表达式中的变量引用（如 $.advertiser.industry）
// 3. 按路径层级构建嵌套 JSON 结构
// 4. 通过 Protobuf 反射自动填充默认值

private Object computeDefaultValue(String variablePath) {
    RuleEngine ruleEngine = new RuleEngine();
    for (Object message : pbInstances) {
        Object o = ruleEngine.evalExpr(variablePath, message, new Object());
        if (o != null) return o;
    }
    return &quot;&quot;;  // 兜底空字符串
}
</code></pre>
<p>Mousika 通过类路径扫描加载所有 Protobuf Message 类，构造默认实例，然后用 JS 引擎实际执行变量路径来获取默认值类型——这比静态类型推断更准确，因为它<strong>直接复用了引擎的求值逻辑</strong>。</p>
<h4>测试用例与执行路径断言</h4>
<p>BRMS 还支持创建持久化的<strong>测试用例</strong>（<code>RuleSetTestCaseDetail</code>），每个用例包含：</p>
<pre><code class="language-java">public class RuleSetTestCaseDetail {
    private String buildSceneConfig;          // 场景构建配置
    private String buildSceneValue;           // 场景参数值
    private String buildRequestParam;         // Fact 入参
    private String expectedExecutionPath;     // 期望执行路径
}
</code></pre>
<p><code>expectedExecutionPath</code> 是核心字段——它记录了<strong>期望的规则执行路径</strong>（如 <code>1269-&gt;1242-&gt;1246</code>），在回归测试时，系统会将实际执行路径与期望路径对比，发现不一致则标记测试失败。这使得规则变更的影响范围可以通过自动化测试提前发现。</p>
<h3>9.3 归因分析：从&quot;不通过&quot;到&quot;为什么不通过&quot;</h3>
<p>规则引擎最常见的运营诉求是：&quot;这条数据为什么被拦截了？&quot;Mousika 的归因分析体系基于<strong>执行树到结果树的转换</strong>，提供从宏观到微观的逐层下钻能力。</p>
<h4>执行树 → 结果树的转换</h4>
<p>第 5.4 节介绍了 <code>DefaultNodeVisitor</code> 在执行过程中构建的 <code>EvalNode</code> 执行树。<code>RuleContextImpl</code> 将这棵执行树<strong>转换为面向展示的 <code>RuleResult</code> 结果树</strong>：</p>
<pre><code class="language-java">private RuleResult transform(EvalNode node) {
    String expr = node.getExpr();
    EvalResult result = evalCache.get(expr);
    // 动态插值生成人类可读的描述文案
    RuleResult ruleResult = new RuleResult(result, evalDesc(expr), node.getNodeType());
    // 递归转换子节点
    for (EvalNode subNode : node.getChildren()) {
        ruleResult.getSubRules().add(transform(subNode));
    }
    return ruleResult;
}
</code></pre>
<p>转换过程做了两件关键的事：</p>
<ol>
<li><strong>关联 evalCache</strong>：从缓存中取出每个节点的实际执行结果（<code>EvalResult</code>），包括原始返回值和布尔判定</li>
<li><strong>动态描述插值</strong>：调用 <code>evalDesc()</code> 将规则描述模板中的 <code>{$.field}</code> 替换为实际的 Fact 字段值，生成如 &quot;广告主【张三】行业【游戏】不合规&quot; 这样的人类可读文案</li>
</ol>
<p>最终的 <code>NodeResult</code> 是一棵<strong>与 AST 同构的结果树</strong>，每个节点都携带了表达式、执行结果、动态描述和子节点列表。</p>
<h4>深度遍历：叶子节点的扁平化视图</h4>
<p>对于需要快速定位具体命中/未命中规则的场景，<code>getEvalResults()</code> 提供了执行树的扁平化视图——只展示叶子节点（<code>ExprNode</code>），跳过中间的编排节点：</p>
<pre><code class="language-java">private void deepTraverse(List&lt;EvalNode&gt; evalNodes, List&lt;NodeResult&gt; nodeResults) {
    for (EvalNode evalNode : evalNodes) {
        if (evalNode.getChildren().size() == 0) {
            // 叶子节点：直接构造 NodeResult
            EvalResult evalResult = evalCache.get(evalNode.getExpr());
            if (Objects.isNull(evalResult)) continue;  // 跳过未完成执行的节点
            RuleResult ruleResult = new RuleResult(evalResult, evalDesc(expr), ...);
            nodeResults.add(new NodeResult(ruleResult.getExpr(), ...));
        } else {
            // 非叶子节点：递归向下
            deepTraverse(evalNode.getChildren(), nodeResults);
        }
    }
}
</code></pre>
<p>这为前端提供了两种展示模式：<strong>树形归因</strong>（完整的决策路径）和<strong>列表归因</strong>（直接看哪些具体规则通过/未通过）。</p>
<h4>验证对比：多规则集横向分析</h4>
<p><code>ValidationDetail</code> 支持<strong>同一份 Fact 数据在多个规则集上的横向对比</strong>：</p>
<pre><code class="language-java">public class ValidationDetail {
    private String bizPrimaryKey;                     // 业务主键
    private List&lt;ValidationResult&gt; validationResults; // 多个规则集的执行结果

    public static class ValidationResult {
        private long ruleSetId;  // 规则集 ID
        private String result;   // 执行结果
        private String desc;     // 结果描述
    }
}
</code></pre>
<p>运营人员可以选择多个规则集版本（如&quot;当前线上版本&quot;和&quot;待发布版本&quot;），对同一批业务数据进行批量验证，对比结果差异。结果支持<strong>导出 Excel</strong>——<code>toExcelRow()</code> 方法将每条数据的多规则集结果格式化为表格行，便于线下分析和审批。</p>
<p>这与第 7 章介绍的灰度验证机制（<code>candidateRules</code>）形成互补：灰度验证是<strong>线上流量的自动对比</strong>，验证对比是<strong>指定数据的手动对比</strong>——两者共同保障了规则变更的安全性。</p>
<h3>9.4 执行路径渲染：从 EvalNode 到可视化</h3>
<p>执行路径渲染将规则的实际执行过程&quot;叠加&quot;到规则编排的流程图上，让运营人员直观地看到&quot;数据在规则图中走了哪条路&quot;。</p>
<p>其技术链路是：</p>
<pre><code>Fact 数据 ──→ 引擎执行 ──→ EvalNode 执行树 ──→ NodeResult 结果树
                                                    │
    ┌───────────────────────────────────────────────┘
    │
    ▼
前端流程图 ──→ 遍历结果树 ──→ 标记每个节点的状态（通过/未通过/未执行）
              │
              ├── 通过的节点：绿色高亮
              ├── 未通过的节点：红色高亮
              ├── 未执行的分支（NaResult）：灰色
              └── 点击节点 → 展开规则描述 + 原始返回值
</code></pre>
<p>关键是 <code>NaResult</code> 的设计价值在这里得到了充分体现：传统的 true/false 二态无法区分&quot;规则执行结果为 false&quot;和&quot;规则因条件分支未被评估&quot;。<code>CaseNode</code> 引入的三态返回使得前端可以精确地将未执行的分支渲染为灰色（Not Applicable），而非误导性地标记为&quot;未通过&quot;。</p>
<h4>完整的数据流闭环</h4>
<p>从数据写入到归因展示，完整的数据流形成了一个闭环：</p>
<pre><code>┌────────────────────────────────────────────────────────────────────┐
│                         数据流闭环                                  │
│                                                                    │
│  配置阶段:  画布编排 ──→ GraphNodeV2 JSON ──→ toRule() ──→ AST     │
│                                                                    │
│  执行阶段:  Fact + AST ──→ DefaultNodeVisitor ──→ EvalNode 执行树   │
│            │                                       │               │
│            └── evalCache（幂等缓存）                └── RuleResult  │
│                                                         结果树     │
│                                                         │          │
│  展示阶段:  结果树 ──→ 叠加到流程图 ──→ 路径高亮 + 节点描述          │
│            │                                                       │
│            ├── 树形归因（递归展开完整决策路径）                       │
│            ├── 列表归因（叶子节点扁平化）                            │
│            └── 横向对比（多版本验证 + Excel 导出）                   │
└────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>这个闭环的核心设计原则是<strong>同构映射</strong>：配置时的 UI 节点、执行时的 AST 节点、追踪时的 EvalNode、展示时的 RuleResult——四棵树结构一一对应。正是这种同构性，使得从&quot;画规则&quot;到&quot;看结果&quot;的全链路可以自然贯通，而不需要在任何环节做复杂的结构转换。</p>
<hr>
<h2>10. 设计权衡与工程总结</h2>
<h3>10.1 关键设计决策</h3>
<table>
<thead>
<tr>
<th>决策</th>
<th>选择</th>
<th>权衡</th>
</tr>
</thead>
<tbody><tr>
<td>规则表达式执行</td>
<td><strong>AST + JS 引擎分层</strong></td>
<td>AST 保证编排逻辑的类型安全和可控性；JS 引擎提供单条规则求值的灵活性。代价是 Nashorn 在 JDK 11+ 被标记 deprecated</td>
</tr>
<tr>
<td>UDF 注册表 → JS 可访问对象</td>
<td><strong>ByteBuddy 动态生成类</strong></td>
<td>让 JS 能以 <code>sys.scene.eval()</code> 的属性链方式调用 UDF。代价是动态生成类增加了调试复杂度和 Metaspace 占用</td>
</tr>
<tr>
<td>规则热加载</td>
<td><strong>volatile 引用替换（Copy-on-Write）</strong></td>
<td>无锁、无停顿。代价是短暂的内存双份（新旧 RuleSuite 共存直到旧实例被 GC）</td>
</tr>
<tr>
<td>执行结果追踪</td>
<td><strong>ThreadLocal + 栈帧模拟</strong></td>
<td>不侵入 AST 节点的执行逻辑。代价是 ParNode 中需要手动处理 ThreadLocal 迁移</td>
</tr>
<tr>
<td>类型转换</td>
<td><strong>JSON 作为中间格式</strong></td>
<td>JS ↔ Java 几乎任意类型可互通。代价是序列化/反序列化的性能开销</td>
</tr>
<tr>
<td>插件 JAR 卸载</td>
<td><strong>显式清理 Spring 缓存</strong></td>
<td>防止 ClassLoader 泄漏。代价是需要知道 Spring / Krpc 内部的缓存字段（反射访问私有字段）</td>
</tr>
</tbody></table>
<h3>10.2 架构模式总结</h3>
<p>回顾整个 Mousika 的设计，可以提炼出几个核心的架构模式：</p>
<ol>
<li><p><strong>DSL + Interpreter 模式</strong>：规则编排语言通过 ANTLR4 解析为 AST，每个节点自解释执行。扩展新操作符只需添加新的 <code>RuleNode</code> 实现。</p>
</li>
<li><p><strong>Visitor 模式（变体）</strong>：执行时通过 <code>context.visit(node)</code> 间接调用，而非直接 <code>node.eval(context)</code>。这个间接层让 <code>DefaultNodeVisitor</code> 可以在不修改节点代码的前提下记录执行树。</p>
</li>
<li><p><strong>观察者模式</strong>：<code>ListenerProvider</code> 聚合所有 <code>RuleListener</code>，引擎在关键路径上触发事件。可观测性（监控、日志、审计）全部通过事件驱动实现，不侵入核心执行逻辑。</p>
</li>
<li><p><strong>Copy-on-Write</strong>：<code>RuleSuite</code> 的热加载通过构造新实例 + <code>volatile</code> 引用替换实现，正在执行的请求不受影响。</p>
</li>
<li><p><strong>统一抽象</strong>：决策表、复合规则、外部 RPC 调用——所有扩展功能都被归约到 UDF 机制，引擎内核始终只处理&quot;JS 表达式求值&quot;这一件事。</p>
</li>
</ol>
<p>这些模式共同构成了一个<strong>稳定内核 + 灵活扩展</strong>的架构——引擎核心代码量不大（<code>mousika-core</code> 约 30 个类），但通过 UDF、事件监听器、规则热加载的扩展点，支撑起了整个业务体系的规则管理需求。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-600 hover:text-gray-800" href="/about/">关于</a><a class="text-gray-600 hover:text-gray-800" href="/blog/">博客</a><a class="text-gray-600 hover:text-gray-800" href="/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-600">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-51baccc14cf1da9e.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n5:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[59665,[],\"MetadataBoundary\"]\n10:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/a2b4a60000c93b46.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"u1TxinqMv1nGhkHv-C9Es\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"domain\",\"Mousika%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%EF%BC%9A%E8%AE%A9%E8%A7%84%E5%88%99%E5%8F%AF%E7%BC%96%E6%8E%92%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E3%80%81%E5%8F%AF%E8%A7%A3%E9%87%8A\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/domain/Mousika%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%EF%BC%9A%E8%AE%A9%E8%A7%84%E5%88%99%E5%8F%AF%E7%BC%96%E6%8E%92%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E3%80%81%E5%8F%AF%E8%A7%A3%E9%87%8A\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/a2b4a60000c93b46.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-600\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/domain/Mousika%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%EF%BC%9A%E8%AE%A9%E8%A7%84%E5%88%99%E5%8F%AF%E7%BC%96%E6%8E%92%E3%80%81%E5%8F%AF%E6%89%A7%E8%A1%8C%E3%80%81%E5%8F%AF%E8%A7%A3%E9%87%8A\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"KsnmkcpMDKu3YKE0JF3UQv\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[74911,[],\"AsyncMetadata\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n18:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n15:T11c47,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eMousika 规则引擎：让规则可编排、可执行、可解释\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在大规模业务系统中，业务规则的变更频率远高于代码发布节奏。投放策略、风控拦截条件、流量分配逻辑——这些规则如果硬编码在业务代码中，每次调整都意味着一次发版。\u003c/p\u003e\n\u003cp\u003eMousika 是一个面向复杂业务场景的规则引擎平台，它的核心目标是：\u003cstrong\u003e让业务规则的变更脱离代码发布周期，通过配置化实现秒级生效\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e本文基于 Mousika 的实际代码，拆解它是如何让规则\u003cstrong\u003e可编排\u003c/strong\u003e（可视化流程图 → AST）、\u003cstrong\u003e可执行\u003c/strong\u003e（DSL 编排 + JS 求值分层、UDF 万物皆函数）、\u003cstrong\u003e可解释\u003c/strong\u003e（四棵同构树驱动全链路归因）的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e阅读指南\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e了解整体架构与设计理念\u003c/strong\u003e：阅读第 1–3 章（约 5 分钟）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e深入 AST 解析与执行引擎原理\u003c/strong\u003e：重点阅读第 4、5 章（约 20 分钟）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUDF 扩展与事件驱动\u003c/strong\u003e：第 6、7 章（约 8 分钟）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e执行结果与可解释性\u003c/strong\u003e：第 8 章（约 5 分钟）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e平台能力：可视化编排、动态调试与归因分析\u003c/strong\u003e：第 9 章（约 10 分钟）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e设计权衡与工程总结\u003c/strong\u003e：第 10 章（约 5 分钟）\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e1. 为什么需要规则引擎\u003c/h2\u003e\n\u003ch3\u003e1.1 业务规则与代码的矛盾\u003c/h3\u003e\n\u003cp\u003e在实际业务系统中，典型的业务规则如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u0026quot;代理商 A 旗下客户不允许跨开户操作\u0026quot;\u003c/li\u003e\n\u003cli\u003e\u0026quot;广告主行业为游戏且日预算低于 1 万时，走人工审核\u0026quot;\u003c/li\u003e\n\u003cli\u003e\u0026quot;购票人为残疾人时半价，满足特定条件时免费，否则全价\u0026quot;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些规则有三个共同特征：\u003cstrong\u003e变更频繁、逻辑复杂、影响面大\u003c/strong\u003e。如果硬编码在业务代码中，每次变更都需要经历 开发→测试→上线 的完整周期。\u003c/p\u003e\n\u003ch3\u003e1.2 规则引擎的核心价值\u003c/h3\u003e\n\u003cp\u003e规则引擎解决的本质问题是\u003cstrong\u003e规则与代码的解耦\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌──────────────────────────────────────────────────────────────┐\n│                       传统方式                                │\n│  业务规则 ──嵌入──→ 业务代码 ──编译──→ 发布 ──部署──→ 生效     │\n│                     (变更 = 发版)                             │\n└──────────────────────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────────────────────┐\n│                       规则引擎方式                             │\n│  业务规则 ──配置──→ 规则平台 ──推送──→ 引擎热加载 ──→ 秒级生效  │\n│  业务代码 ──调用──→ 引擎 SDK ──提交 Fact──→ 获取结果            │\n│                     (规则变更 ≠ 发版)                          │\n└──────────────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMousika 在此基础上进一步解决了几个工程问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e如何表达复杂的规则编排逻辑\u003c/strong\u003e（条件分支、并行、串行、范围匹配）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如何在运行时安全地热更新规则\u003c/strong\u003e（MQ 通知 + 定时兜底）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如何让规则执行结果可解释\u003c/strong\u003e（树形结果 + 动态描述）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e如何扩展规则的能力边界\u003c/strong\u003e（UDF 机制 + 插件化 JAR 加载）\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 整体架构\u003c/h2\u003e\n\u003ch3\u003e2.1 模块全景\u003c/h3\u003e\n\u003cp\u003eMousika 采用多模块 Maven 工程组织，各模块职责明确：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emousika/\n├── mousika-core              # 规则引擎内核：解析、执行、结果分析\n├── mousika-udf-sdk           # UDF 定义 SDK：注解、函数接口\n├── mousika-udf               # 内置系统 UDF（场景调用、RPC 调用等）\n├── mousika-runtime-base      # 运行时公共组件：监听器、转换器、ES 写入\n├── mousika-rpc               # 中心化 RPC 服务（gRPC/Krpc）\n├── mousika-brms              # 规则管理平台后端（Web UI）\n├── mousika-sdk               # 业务方调用 SDK（Fact 定义 + RPC 接口）\n├── mousika-local-runtime-sdk # 去中心化本地运行时 SDK\n├── mousika-consumer          # Kafka 消费者（执行结果对比验证）\n└── mousika-test-sdk          # 测试 SDK\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e核心依赖栈：\u003cstrong\u003eANTLR4\u003c/strong\u003e（规则语法解析）、\u003cstrong\u003eNashorn\u003c/strong\u003e（JS 表达式执行）、\u003cstrong\u003eByteBuddy\u003c/strong\u003e（动态类生成）、\u003cstrong\u003eKrpc/gRPC\u003c/strong\u003e（RPC 通信）、\u003cstrong\u003ejOOQ\u003c/strong\u003e（数据库访问）、\u003cstrong\u003eKafka/RocketMQ\u003c/strong\u003e（消息驱动）。\u003c/p\u003e\n\u003ch3\u003e2.2 分层架构\u003c/h3\u003e\n\u003cp\u003e从数据流视角，Mousika 的架构分为四层，每一层都有明确的职责边界：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌─────────────────────────────────────────────────────┐\n│                   接入层（SDK / RPC）                  │\n│   业务方通过 SDK 提交 Fact 对象 + 场景 Key             │\n│   RPC 模式: gRPC/Krpc 远程调用                        │\n│   SDK 模式: 进程内直接调用                             │\n└──────────────────────┬──────────────────────────────┘\n                       │\n┌──────────────────────▼──────────────────────────────┐\n│                   编排层（Suite / Scene）               │\n│   RuleSuite: 全局单例，持有所有 Scene                   │\n│   RuleScene: 业务场景 → 活跃规则集 + 候选规则集（灰度）  │\n│   职责: 场景路由、规则集版本管理、灰度验证                │\n└──────────────────────┬──────────────────────────────┘\n                       │\n┌──────────────────────▼──────────────────────────────┐\n│                   执行层（Evaluator / AST）             │\n│   NodeBuilder: ANTLR4 解析规则表达式 → AST 节点树       │\n│   RuleEvaluator: Visitor 模式遍历 AST                  │\n│   RuleContextImpl: 执行上下文 + 缓存 + 事件分发          │\n│   职责: 规则编排逻辑的解释执行                           │\n└──────────────────────┬──────────────────────────────┘\n                       │\n┌──────────────────────▼──────────────────────────────┐\n│                   引擎层（RuleEngine / UDF）            │\n│   Nashorn ScriptEngine: 执行单条 JS 表达式              │\n│   UdfContainer: UDF 注册 + ByteBuddy 动态编译           │\n│   Bindings: $ = Fact, $$ = Context, UDF 函数           │\n│   职责: 单条规则的表达式求值                             │\n└─────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e为什么分四层而不是两层？\u003c/strong\u003e 关键的设计洞察在于：规则的\u0026quot;编排\u0026quot;和\u0026quot;求值\u0026quot;是两个不同性质的问题。编排（AST 层）处理的是节点之间的逻辑关系（与或非、条件分支、串并行），这是一个树遍历问题；求值（引擎层）处理的是单条规则表达式的计算，这是一个脚本执行问题。将两者分离，使得编排逻辑可以用类型安全的 Java AST 实现，而求值逻辑可以利用 JS 引擎的灵活性——各取所长。\u003c/p\u003e\n\u003ch3\u003e2.3 双模部署\u003c/h3\u003e\n\u003cp\u003eMousika 支持两种部署模式，业务方根据延迟敏感度和运维复杂度选型：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e实现模块\u003c/th\u003e\n\u003cth\u003e规则加载方式\u003c/th\u003e\n\u003cth\u003e特点\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e中心化 RPC\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003emousika-rpc\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e从数据库直接加载（\u003ccode\u003eRuleLoaderServiceImpl\u003c/code\u003e）\u003c/td\u003e\n\u003ctd\u003e统一部署，规则集中管理，有网络开销\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e去中心化 SDK\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003emousika-local-runtime-sdk\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e从中心服务拉取（\u003ccode\u003eDecentralizedRuleLoaderServiceImpl\u003c/code\u003e）\u003c/td\u003e\n\u003ctd\u003e引擎嵌入业务进程，零网络延迟\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e两种模式共享同一个 \u003ccode\u003emousika-core\u003c/code\u003e 内核。去中心化模式的核心权衡是：\u003cstrong\u003e用内存换延迟，用复杂度换自主性\u003c/strong\u003e——每个业务进程持有一份规则副本，消除了 RPC 调用开销，但需要自行处理规则同步和版本一致性。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 核心概念模型\u003c/h2\u003e\n\u003cp\u003e在深入实现之前，先厘清 Mousika 的核心领域概念及其关系：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e概念\u003c/th\u003e\n\u003cth\u003e类\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRuleSuite\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eRuleSuite\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e规则套件，顶层容器。持有 \u003ccode\u003eRuleEvaluator\u003c/code\u003e 和所有 \u003ccode\u003eRuleScene\u003c/code\u003e。全局单例（\u003ccode\u003evolatile\u003c/code\u003e + 引用替换实现热更新）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRuleScene\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eRuleScene\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e规则场景，一个业务场景对应一个 Scene（如\u0026quot;广告审核\u0026quot;\u0026quot;客户分配\u0026quot;）。包含活跃规则集 + 候选规则集\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRuleConfig\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eRuleConfig\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e规则集配置，包含表达式字符串和解析后的 \u003ccode\u003eRuleNode\u003c/code\u003e AST\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRuleDefinition\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eRuleDefinition\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e单条规则定义：规则 ID + JS 表达式 + 通过/未通过描述文案 + 类型标识\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRuleNode\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eRuleNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e规则 AST 节点接口，9 种具体节点类型\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRuleContext\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eRuleContextImpl\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e执行上下文，同时是 Visitor、缓存和跨规则状态容器\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eUDF\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e@Udf\u003c/code\u003e + \u003ccode\u003eFunctions.*\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e用户自定义函数，通过注解或动态 JAR 注册\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eFact\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e业务 POJO\u003c/td\u003e\n\u003ctd\u003e业务方提交的待匹配数据对象，在 JS 引擎中绑定为 \u003ccode\u003e$\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e它们之间的关系构成了两棵树——\u003cstrong\u003e配置树\u003c/strong\u003e和\u003cstrong\u003e执行树\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e配置树（静态结构）                          执行树（运行时构建）\n\nRuleSuite (单例)                          NodeResult\n  ├── RuleEvaluator                         ├── expr: \u0026quot;1269-\u0026gt;((1242||1243)?...)\u0026quot;\n  │     └── RuleEngine                      ├── matched: true/false\n  │           ├── sourceScripts             └── details: [RuleResult]\n  │           │   {ruleId → JS expr}              ├── RuleResult (1269)\n  │           ├── compiledScripts                 │     ├── matched: true\n  │           │   {expr → CompiledScript}         │     └── desc: \u0026quot;获取购票人详情\u0026quot;\n  │           └── UdfContainer                    └── RuleResult (1242||1243)\n  │                 {namespace → UDF tree}              ├── matched: true\n  └── scenes                                          └── subRules: [...]\n        {sceneKey → RuleScene}\n              ├── activeRule: RuleConfig\n              │     └── ruleNode: RuleNode (AST)\n              └── candidateRules: [RuleConfig]\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e4. 规则表达式与 AST 解析\u003c/h2\u003e\n\u003ch3\u003e4.1 DSL 设计：为什么不直接用 JS\u003c/h3\u003e\n\u003cp\u003e一个自然的问题是：既然底层已经用了 Nashorn JS 引擎，为什么不直接让用户写 JS？\u003c/p\u003e\n\u003cp\u003e答案是 \u003cstrong\u003e关注点分离\u003c/strong\u003e。用户需要表达的是规则之间的编排关系（\u0026quot;先执行 A，如果通过再执行 B 和 C\u0026quot;），而不是通用编程逻辑。Mousika 设计了一套领域专用语言（DSL），专门用于规则编排：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e操作符\u003c/th\u003e\n\u003cth\u003e语义\u003c/th\u003e\n\u003cth\u003e节点类型\u003c/th\u003e\n\u003cth\u003e执行语义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e逻辑与\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAndNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e短路求值\u003c/strong\u003e：任一子节点为 false 立即返回，不再执行后续节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e||\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e逻辑或\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eOrNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e短路求值\u003c/strong\u003e：任一子节点为 true 立即返回\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e!\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e逻辑非\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eNotNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e对子节点结果取反\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e?:\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e条件分支\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCaseNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e惰性求值\u003c/strong\u003e：只执行匹配的分支，未执行分支返回 \u003ccode\u003eNaResult\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e串行执行\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eSerNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e全量执行\u003c/strong\u003e：按顺序执行所有子节点，取最后一个节点的结果\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e=\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e并行执行\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eParNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e并发执行\u003c/strong\u003e：线程池并发，任一为 true 则整体为 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003elimit(l,h,...)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e范围匹配\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eLimitNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e匹配命中数在 \u003ccode\u003e[l, h]\u003c/code\u003e 区间内为 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e分组\u003c/td\u003e\n\u003ctd\u003e—\u003c/td\u003e\n\u003ctd\u003e改变优先级\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这套 DSL 与 JS 的关系是：\u003cstrong\u003eDSL 负责\u0026quot;编排\u0026quot;（哪些规则按什么逻辑组合），JS 负责\u0026quot;求值\u0026quot;（单条规则怎么计算）\u003c/strong\u003e。两者在不同抽象层次工作。\u003c/p\u003e\n\u003cp\u003e一条实际的规则表达式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1269-\u0026gt;((1242||1243)?1246:(1241?1244:1245))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在配置平台上渲染为可视化流程图，运营人员通过拖拽节点和连线即可生成这种表达式——他们不需要理解语法。\u003c/p\u003e\n\u003ch3\u003e4.2 ANTLR4 解析流程\u003c/h3\u003e\n\u003cp\u003e规则表达式的解析由 \u003ccode\u003eNodeBuilder\u003c/code\u003e 驱动，内部使用 ANTLR4 完成从文本到 AST 的转换。ANTLR4 是业界成熟的 parser generator，Mousika 选择它而非手写 Recursive Descent Parser 的原因是：语法可能随业务演化（如后来添加了 \u003ccode\u003elimit\u003c/code\u003e 和 \u003ccode\u003e=\u0026gt;\u003c/code\u003e 操作符），ANTLR4 的 grammar 文件易于扩展。\u003c/p\u003e\n\u003cp\u003e解析分为四步：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e                 ┌────────────────────────────────────────────────────────────┐\n                 │                   ANTLR4 解析流程                          │\n                 │                                                          │\n  输入字符串 ─────→  RuleLexer ──→ Token 流 ──→ RuleParser ──→ ParseTree     │\n  \u0026quot;1\u0026amp;\u0026amp;2?3:4\u0026quot;     │   (词法分析)     [ID, \u0026amp;\u0026amp;,    (语法分析)      (语法树)       │\n                 │                  ID, ?, ...]                             │\n                 └──────────────────────────────┬───────────────────────────┘\n                                                │\n                 ┌──────────────────────────────▼───────────────────────────┐\n                 │              DefaultRuleVisitor (ANTLR4 Visitor)         │\n                 │                                                          │\n                 │  visitOr()   → OrNode          visitPar()  → ParNode     │\n                 │  visitAnd()  → AndNode         visitSer()  → SerNode     │\n                 │  visitNot()  → NotNode         visitLimit()→ LimitNode   │\n                 │  visitIf()   → CaseNode        visitId()   → ExprNode    │\n                 └──────────────────────────────┬───────────────────────────┘\n                                                │\n                                                ▼\n                                        RuleNode AST (可执行)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eNodeBuilder\u003c/code\u003e 对解析结果做了\u003cstrong\u003e缓存\u003c/strong\u003e（\u003ccode\u003eConcurrentHashMap\u003c/code\u003e），同一表达式只解析一次：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static RuleNode build(String expr) {\n    return nodeCache.computeIfAbsent(expr, ruleExpr -\u0026gt; {\n        long begin = System.currentTimeMillis();\n        try {\n            RuleNode node = Antlr4Parser.parse(ruleExpr, defaultGenerator);\n            ListenerProvider.DEFAULT.onParse(\n                new RuleEvent(EventType.PARSE_SUCCEED, ruleExpr, node, cost));\n            return node;\n        } catch (Exception e) {\n            ListenerProvider.DEFAULT.onParse(\n                new RuleEvent(EventType.PARSE_FAIL, ruleExpr, e, cost));\n            throw new RuleParseException(ruleExpr, \u0026quot;rule parse failed:\u0026quot; + ruleExpr, e);\n        }\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4.3 复合规则的递归解析与环检测\u003c/h3\u003e\n\u003cp\u003e普通规则的叶子节点（\u003ccode\u003eExprNode\u003c/code\u003e）直接引用一个规则 ID。但 Mousika 还支持\u003cstrong\u003e复合规则\u003c/strong\u003e（\u003ccode\u003euseType=2\u003c/code\u003e）——一条规则的表达式本身是另一个规则集的编排。这意味着解析时需要递归展开。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNodeGenerator\u003c/code\u003e 处理了这个递归，并通过 \u003cstrong\u003eStack 做环检测\u003c/strong\u003e，防止 A → B → A 的循环依赖：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003estatic NodeGenerator create(Map\u0026lt;String, String\u0026gt; compositeRules) {\n    return new NodeGenerator() {\n        private RuleNode parseRecursively(String expr, Stack\u0026lt;String\u0026gt; resolved) {\n            if (compositeRules.containsKey(expr)) {\n                resolved.push(expr);  // 入栈：标记正在解析\n                try {\n                    return new CompositeNode(expr,\n                        NodeParser.parse(compositeRules.get(expr), s -\u0026gt; {\n                            if (resolved.contains(s)) {\n                                throw new IllegalStateException(\n                                    \u0026quot;circular dependency between [\u0026quot; + expr + \u0026quot;] and [\u0026quot; + s + \u0026quot;]\u0026quot;);\n                            }\n                            return parseRecursively(s, resolved);  // 递归展开\n                        }));\n                } finally {\n                    resolved.pop();   // 出栈：回溯\n                }\n            }\n            return new ExprNode(expr);  // 叶子节点\n        }\n    };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这本质上是一个\u003cstrong\u003e带回溯的深度优先搜索\u003c/strong\u003e：\u003ccode\u003eStack\u0026lt;String\u0026gt; resolved\u003c/code\u003e 维护当前解析路径，如果即将解析的节点已经在路径上，说明存在环依赖，立即抛出异常。\u003ccode\u003efinally\u003c/code\u003e 块确保回溯时正确出栈，不会影响同层的其他分支解析。\u003c/p\u003e\n\u003ch3\u003e4.4 AST 节点的设计哲学\u003c/h3\u003e\n\u003cp\u003e所有节点实现 \u003ccode\u003eRuleNode\u003c/code\u003e 接口，核心方法只有三个：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface RuleNode {\n    EvalResult eval(RuleContext context);  // 执行\n    String expr();                          // 表达式序列化\n    NodeType ruleNodeType();                // 类型标识\n\n    // Builder 风格的 default 方法，支持链式组合\n    default RuleNode and(RuleNode node)  { return new AndNode(this, node); }\n    default RuleNode or(RuleNode node)   { return new OrNode(this, node); }\n    default RuleNode not()               { return new NotNode(this); }\n    default RuleNode next(RuleNode node) { return new SerNode(this, node); }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个设计有两个值得注意的地方：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1) Interpreter 模式\u003c/strong\u003e：每个节点自己负责自己的执行逻辑（\u003ccode\u003eeval\u003c/code\u003e 方法），而不是由一个集中的解释器遍历 AST。这使得添加新节点类型只需要实现接口，不需要修改任何已有代码（符合开闭原则）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2) Builder 风格的 default 方法\u003c/strong\u003e：\u003ccode\u003eand()\u003c/code\u003e / \u003ccode\u003eor()\u003c/code\u003e / \u003ccode\u003enext()\u003c/code\u003e 直接在接口层提供，使得 AST 可以通过编程方式动态构建，而不仅限于从表达式解析生成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 编程方式构建 AST，等价于表达式 \u0026quot;(A \u0026amp;\u0026amp; B) || C\u0026quot;\nRuleNode tree = ruleA.and(ruleB).or(ruleC);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e短路求值的实现\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eAndNode\u003c/code\u003e 的短路求值实现非常简洁——遍历子节点，一旦遇到 false 立即返回：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic EvalResult eval(RuleContext context) {\n    for (RuleNode node : nodes) {\n        if (!context.visit(node).isMatched()) {\n            return new EvalResult(expr(), false, ruleNodeType());\n        }\n    }\n    return new EvalResult(expr(), true, ruleNodeType());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意调用的是 \u003ccode\u003econtext.visit(node)\u003c/code\u003e 而非 \u003ccode\u003enode.eval(context)\u003c/code\u003e——这个间接层是关键，它使得 \u003ccode\u003eDefaultNodeVisitor\u003c/code\u003e 有机会在每次节点执行时记录执行树（详见 5.4 节），实现了执行逻辑与追踪逻辑的分离。\u003c/p\u003e\n\u003ch4\u003eCaseNode：三态返回\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eCaseNode\u003c/code\u003e 是最能体现 Mousika 表达力的节点。传统的三元运算符只有 true/false 两种结果，但 Mousika 的 \u003ccode\u003eCaseNode\u003c/code\u003e 引入了第三种状态——\u003ccode\u003eNaResult\u003c/code\u003e（Not Applicable）：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic EvalResult eval(RuleContext context) {\n    EvalResult result = null;\n    boolean succeed = context.visit(condition).isMatched();\n    if (succeed) {\n        if (trueCase != null) result = context.visit(trueCase);\n    } else {\n        if (falseCase != null) result = context.visit(falseCase);\n    }\n    return result != null\n        ? new EvalResult(expr(), result.getResult(), result.isMatched(), ruleNodeType())\n        : new EvalResult(expr(), NaResult.DEFAULT, ruleNodeType());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当分支为 \u003ccode\u003enull\u003c/code\u003e 时返回 \u003ccode\u003eNaResult\u003c/code\u003e——表示\u0026quot;该分支未被执行\u0026quot;。这在结果分析中至关重要：它允许下游精确区分\u0026quot;规则执行失败\u0026quot;和\u0026quot;规则根本未被评估\u0026quot;。\u003c/p\u003e\n\u003ch4\u003eSerNode 与 ParNode：两种执行语义\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eSerNode\u003c/code\u003e（串行）和 \u003ccode\u003eParNode\u003c/code\u003e（并行）是 Mousika 特有的控制流节点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSerNode\u003c/strong\u003e（\u003ccode\u003e-\u0026gt;\u003c/code\u003e）：按顺序执行所有子节点，\u003cstrong\u003e取最后一个节点的结果\u003c/strong\u003e。前面的节点视为\u0026quot;前置动作\u0026quot;——它们的执行结果不影响最终判定，但它们可以通过 \u003ccode\u003e$$\u003c/code\u003e（上下文 Map）为后续节点准备数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// SerNode.eval() — 全量执行，取最后一个结果\npublic EvalResult eval(RuleContext context) {\n    List\u0026lt;EvalResult\u0026gt; results = nodes.stream()\n        .filter(e -\u0026gt; !e.expr().equals(\u0026quot;nop\u0026quot;))\n        .map(context::visit)\n        .collect(Collectors.toList());\n    EvalResult result = results.get(results.size() - 1);\n    return new EvalResult(expr(), result.getResult(), result.isMatched(), ruleNodeType());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eParNode\u003c/strong\u003e（\u003ccode\u003e=\u0026gt;\u003c/code\u003e）：将子节点提交到线程池并发执行，结果聚合策略是\u003cstrong\u003e任一为 true 则整体为 true\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ParNode.eval() — 并发执行 + ThreadLocal 上下文迁移\npublic EvalResult eval(RuleContext context) {\n    RuleContextImpl ruleContext = (RuleContextImpl) context;\n    ThreadLocal\u0026lt;EvalNode\u0026gt; currentEval = ruleContext.getCurrentEval();\n    EvalNode stashEvalNode = currentEval.get();  // 暂存主线程的执行节点\n\n    Vector\u0026lt;EvalResult\u0026gt; vector = new Vector\u0026lt;\u0026gt;();\n    CountDownLatch latch = new CountDownLatch(nodes.size());\n\n    for (RuleNode node : nodes) {\n        executor.execute(() -\u0026gt; {\n            try {\n                EvalNode root = new EvalNode(null, ruleNodeType());\n                currentEval.set(root);  // 每个线程独立的执行树根节点\n                EvalResult result = context.visit(node);\n                stashEvalNode.getChildren().addAll(root.getChildren());  // 合并回主线程\n                vector.add(result);\n            } finally {\n                currentEval.set(null);\n                latch.countDown();\n            }\n        });\n    }\n    currentEval.set(stashEvalNode);  // 恢复主线程上下文\n    latch.await(timeout, TimeUnit.MILLISECONDS);\n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eParNode\u003c/code\u003e 中最复杂的部分是 \u003cstrong\u003eThreadLocal 上下文的迁移\u003c/strong\u003e。\u003ccode\u003eDefaultNodeVisitor\u003c/code\u003e 使用 \u003ccode\u003eThreadLocal\u0026lt;EvalNode\u0026gt;\u003c/code\u003e 追踪当前执行位置，在并行场景下，每个工作线程需要创建独立的执行树根节点，完成后再将子节点合并回主线程的执行树。这里使用 \u003ccode\u003eVector\u003c/code\u003e（线程安全）收集结果，\u003ccode\u003eEvalNode.children\u003c/code\u003e 也使用 \u003ccode\u003eVector\u003c/code\u003e 以保证并发写入安全。\u003c/p\u003e\n\u003ch4\u003eLimitNode：范围匹配\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eLimitNode\u003c/code\u003e 表达的语义是\u0026quot;N 个规则中命中了 M 个，M 是否在 [low, high] 范围内\u0026quot;：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic EvalResult eval(RuleContext context) {\n    int hit = 0;\n    for (RuleNode node : nodes) {\n        EvalResult eval = node.eval(context);\n        if (eval.isMatched()) hit++;\n        if (high \u0026gt; 0 \u0026amp;\u0026amp; hit \u0026gt; high) break;  // 提前终止：已超上限\n    }\n    return new EvalResult(expr(), result.getResult(),\n        hit \u0026gt;= low \u0026amp;\u0026amp; (high \u0026lt; 0 || hit \u0026lt;= high), ruleNodeType());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ehigh = -1\u003c/code\u003e 表示无上限。这个节点实现了类似 \u0026quot;至少满足 2 个条件中的 1 个\u0026quot; 或 \u0026quot;恰好满足 3 个条件中的 2 个\u0026quot; 这样的投票逻辑，为业务规则提供了灵活的组合能力。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e5. 执行引擎\u003c/h2\u003e\n\u003ch3\u003e5.1 RuleEngine：JS 脚本编译与缓存\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eRuleEngine\u003c/code\u003e 是单条规则的执行核心，基于 \u003cstrong\u003eNashorn JavaScript 引擎\u003c/strong\u003e。选择 JS 引擎而非自研表达式求值器的原因是：JS 天然支持属性链访问（\u003ccode\u003e$.advertiser.industry\u003c/code\u003e）、运算符、字符串操作等，省去了大量的解析和执行逻辑开发。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RuleEngine {\n    private ScriptEngine engine = new ScriptEngineManager().getEngineByName(\u0026quot;JavaScript\u0026quot;);\n    private Map\u0026lt;String, String\u0026gt; sourceScripts = new ConcurrentHashMap\u0026lt;\u0026gt;();         // 源脚本\n    private Map\u0026lt;String, CompiledScript\u0026gt; compiledScripts = new ConcurrentHashMap\u0026lt;\u0026gt;(); // 编译缓存\n    private UdfContainer udfContainer = new UdfContainer(engine);\n\n    // 初始化时注册内置规则\n    {\n        this.register(new RuleDefinition(\u0026quot;true\u0026quot;, \u0026quot;true\u0026quot;, \u0026quot;SUCCESS\u0026quot;));\n        this.register(new RuleDefinition(\u0026quot;false\u0026quot;, \u0026quot;false\u0026quot;, \u0026quot;FAILED\u0026quot;));\n        this.register(new RuleDefinition(\u0026quot;null\u0026quot;,\n            \u0026quot;Java.type(\u0026#39;\u0026quot; + NaResult.class.getName() + \u0026quot;\u0026#39;).DEFAULT\u0026quot;, \u0026quot;NOP\u0026quot;));\n        this.register(new RuleDefinition(\u0026quot;nop\u0026quot;,\n            \u0026quot;Java.type(\u0026#39;\u0026quot; + NaResult.class.getName() + \u0026quot;\u0026#39;).DEFAULT\u0026quot;, \u0026quot;NOP\u0026quot;));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e几个关键的设计细节：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1) 预编译 + 缓存\u003c/strong\u003e：JS 表达式通过 \u003ccode\u003eCompilable.compile()\u003c/code\u003e 预编译为 \u003ccode\u003eCompiledScript\u003c/code\u003e，后续执行直接调用 \u003ccode\u003ecompiledScript.eval(bindings)\u003c/code\u003e。编译结果按表达式文本做 key 缓存，避免重复解析。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate CompiledScript compile(String expression, boolean cache) {\n    CompiledScript compiled = compiledScripts.get(expression);\n    if (compiled == null) {\n        compiled = ((Compilable) engine).compile(expression);\n        if (cache) compiledScripts.put(expression, compiled);\n    }\n    return compiled;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2) Bindings 隔离\u003c/strong\u003e：每次执行都创建独立的 \u003ccode\u003eBindings\u003c/code\u003e，避免线程间状态污染。三种绑定注入：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Object doEval(CompiledScript script, Object root, Object context) {\n    Bindings bindings = engine.createBindings();\n    bindings.putAll(udfContainer.compileUdf());  // UDF 函数（命名空间对象）\n    bindings.put(\u0026quot;$\u0026quot;, root);                      // Fact 数据对象\n    bindings.put(\u0026quot;$$\u0026quot;, context);                   // 执行上下文 Map\n    Object result = script.eval(bindings);\n    return ScriptUtils.convertIntoJavaObject(result);  // JS 对象 → Java 对象\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3) 内置规则\u003c/strong\u003e：\u003ccode\u003etrue\u003c/code\u003e、\u003ccode\u003efalse\u003c/code\u003e、\u003ccode\u003enull\u003c/code\u003e、\u003ccode\u003enop\u003c/code\u003e 是预注册的规则 ID。\u003ccode\u003enull\u003c/code\u003e 和 \u003ccode\u003enop\u003c/code\u003e 返回 \u003ccode\u003eNaResult.DEFAULT\u003c/code\u003e（通过 Nashorn 的 \u003ccode\u003eJava.type()\u003c/code\u003e 引用 Java 类），用于在 CaseNode 中表示\u0026quot;不执行\u0026quot;。\u003c/p\u003e\n\u003ch3\u003e5.2 规则描述的动态插值\u003c/h3\u003e\n\u003cp\u003e每条规则可以配置两个描述文案（分别对应通过/不通过时展示），支持 \u003ccode\u003e{$.field}\u003c/code\u003e 语法引用 Fact 对象字段。\u003ccode\u003eevalRuleDesc()\u003c/code\u003e 方法通过正则替换将模板转换为 JS 字符串拼接表达式，然后复用 JS 引擎执行：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String evalRuleDesc(String ruleId, Boolean match, Object root, Object context) {\n    // 选择对应的描述模板\n    String originDesc = match ? explainPair.getRight() : explainPair.getLeft();\n\n    // 正则替换: {$.agentId} → \u0026quot;+$.agentId+\u0026quot;\n    // 最终拼接为 JS 字符串表达式: \u0026quot;代理商【\u0026quot;+$.agentId+\u0026quot;】不允许跨开\u0026quot;\n    originDesc = \u0026quot;\\\u0026quot;\u0026quot; + originDesc.replaceAll(\u0026quot;\\\\{(\\\\$+\\\\..+?)\\\\}\u0026quot;, \u0026quot;\\\\\\\u0026quot;+$1+\\\\\\\u0026quot;\u0026quot;) + \u0026quot;\\\u0026quot;\u0026quot;;\n    return (String) evalExpr(originDesc, root, context);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个设计的巧妙之处在于\u003cstrong\u003e复用了 JS 引擎的求值能力\u003c/strong\u003e来做模板渲染——不需要引入额外的模板引擎，\u003ccode\u003e$\u003c/code\u003e 绑定在 Bindings 中天然可用。\u003c/p\u003e\n\u003ch3\u003e5.3 RuleContextImpl：三位一体的执行上下文\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eRuleContextImpl\u003c/code\u003e 是整个执行流程的核心协调者。它的类定义本身就揭示了它的多重身份：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RuleContextImpl extends LinkedHashMap\u0026lt;String, Object\u0026gt; implements RuleContext\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e继承 \u003ccode\u003eLinkedHashMap\u003c/code\u003e\u003c/strong\u003e：自身就是上下文 Map，以 \u003ccode\u003e$$\u003c/code\u003e 的身份暴露给 JS 引擎。规则执行过程中可以通过 \u003ccode\u003e$$.put(\u0026quot;key\u0026quot;, value)\u003c/code\u003e 在规则之间传递状态——这是 \u003ccode\u003eSerNode\u003c/code\u003e（串行节点）能够实现\u0026quot;前置动作准备数据，后续规则使用数据\u0026quot;模式的基础。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e实现 \u003ccode\u003eRuleContext\u003c/code\u003e\u003c/strong\u003e：同时承担 Visitor 协调和规则执行两个职责：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 规则执行：带缓存的幂等执行\npublic EvalResult eval(String ruleId) {\n    return evalCache.computeIfAbsent(ruleId, this::doEval);\n}\n\n// Visitor 协调：委托给 DefaultNodeVisitor，同时维护 currentRule\npublic EvalResult visit(RuleNode node) {\n    if (node instanceof ExprNode) {\n        this.currentRule.set(node.expr());  // 追踪当前执行的规则 ID\n    }\n    return visitor.visit(node);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eevalCache\u003c/code\u003e 使用 \u003ccode\u003eConcurrentSkipListMap\u003c/code\u003e 实现——有序且线程安全。当同一个规则 ID 在 AST 中被多个分支引用时，只会执行一次，后续直接返回缓存结果。这不仅是性能优化，更保证了\u003cstrong\u003e规则执行的幂等性\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e5.4 DefaultNodeVisitor：执行树的构建\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eDefaultNodeVisitor\u003c/code\u003e 在每次 \u003ccode\u003evisit()\u003c/code\u003e 调用时构建一棵与 AST 平行的\u003cstrong\u003e执行树\u003c/strong\u003e（\u003ccode\u003eEvalNode\u003c/code\u003e 树）。这棵树记录了\u0026quot;实际执行了哪些节点，每个节点的结果是什么\u0026quot;——这是结果可解释性的基础。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic EvalResult visit(RuleNode node) {\n    EvalNode evalNode = new EvalNode(node.expr(), node.ruleNodeType());\n    boolean isExprNode = node.getClass() == ExprNode.class;\n\n    currentEval.get().getChildren().add(evalNode);  // 挂到父节点下\n\n    if (!isExprNode) {\n        evalNode.setParent(currentEval.get());\n        currentEval.set(evalNode);   // 进入子树\n    }\n\n    EvalResult result = node.eval(ruleContext);  // 实际执行\n\n    if (!isExprNode) {\n        // 缓存复合节点的结果\n        ((RuleContextImpl) ruleContext).getEvalCache().put(node.expr(), result);\n        currentEval.set(currentEval.get().getParent());  // 回溯到父节点\n    }\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e区分 ExprNode 和复合节点\u003c/strong\u003e是这段代码的关键：\u003ccode\u003eExprNode\u003c/code\u003e（叶子节点）直接挂到当前节点下作为子节点；复合节点（And/Or/Case 等）则需要\u0026quot;进入\u0026quot;——将 \u003ccode\u003ecurrentEval\u003c/code\u003e 指向自己，这样它的子节点会被正确地挂到它下面。执行完成后\u0026quot;回溯\u0026quot;到父节点。这本质上是一个\u003cstrong\u003e基于 ThreadLocal 的栈帧模拟\u003c/strong\u003e，用来在扁平的 \u003ccode\u003evisit()\u003c/code\u003e 调用序列中重建树形结构。\u003c/p\u003e\n\u003ch3\u003e5.5 规则类型与决策表\u003c/h3\u003e\n\u003cp\u003eMousika 通过 \u003ccode\u003eRuleDefinition.useType\u003c/code\u003e 支持三种规则类型：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003euseType\u003c/th\u003e\n\u003cth\u003e类型\u003c/th\u003e\n\u003cth\u003e处理方式\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e普通规则\u003c/td\u003e\n\u003ctd\u003eJS 表达式直接注册到 \u003ccode\u003eRuleEngine\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e决策表\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e转换为 UDF\u003c/strong\u003e → 注册为动态函数 → 修改表达式为 \u003ccode\u003eudf($)\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e复合规则\u003c/td\u003e\n\u003ctd\u003e规则表达式引用其他规则集 → \u003cstrong\u003e递归解析\u003c/strong\u003e为 \u003ccode\u003eCompositeNode\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e决策表的处理体现了 Mousika 的统一抽象能力——不引入新的执行机制，而是将决策表转换为 UDF，复用已有的引擎：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ecase 1: // 决策表\n    String udf = \u0026quot;udf_rule_table_$\u0026quot; + ruleDefinition.getRuleId();\n    // 将决策表 JSON 配置转换为 RuleTableUdf 函数\n    udfDefinitions.add(new UdfDefinition(udf,\n        RuleTableUdf.fromJson(ruleDefinition.getExpression())));\n    // 修改规则表达式为 UDF 调用\n    ruleDefinition.setExpression(udf + \u0026quot;($)\u0026quot;);\n    break;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eRuleTableUdf\u003c/code\u003e 接收 Fact 对象，遍历表格的每一行，检查所有列条件是否匹配——本质上是一个 \u003cstrong\u003e多维度 AND 匹配器\u003c/strong\u003e。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e6. UDF 扩展机制\u003c/h2\u003e\n\u003cp\u003eUDF（User Defined Function）是 Mousika 的能力扩展基座。决策表、外部 RPC 调用、跨场景规则引用——这些看似不同的功能，全部通过 UDF 机制统一实现。\u003c/p\u003e\n\u003ch3\u003e6.1 函数式接口体系\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003emousika-udf-sdk\u003c/code\u003e 定义了 \u003ccode\u003eFunctions\u003c/code\u003e 类，包含 \u003ccode\u003eFunction0\u003c/code\u003e 到 \u003ccode\u003eFunction22\u003c/code\u003e 共 23 个函数式接口（对应 0 到 22 个参数），覆盖了所有可能的 UDF 签名：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Udf(value = \u0026quot;eval\u0026quot;, group = \u0026quot;sys.scene\u0026quot;)\n@Component\npublic class EvalSceneUdf implements Functions.Function3\u0026lt;String, Object, Map\u0026gt; {\n    public Object apply(String sceneKey, Object target, Map context) {\n        return RuleSuite.get().evalScene(sceneKey, target, context);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6.2 UdfDelegate：反射代理与自动类型转换\u003c/h3\u003e\n\u003cp\u003eJS 引擎调用 Java UDF 时，参数类型是 JS 对象（Nashorn 的内部类型），需要转换为 Java 类型。\u003ccode\u003eUdfDelegate\u003c/code\u003e 通过\u003cstrong\u003e反射 + JSON 序列化\u003c/strong\u003e实现了透明的类型桥接：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object apply(Object... params) {\n    // 1. 按参数个数查找匹配的 apply 方法（排除 bridge 方法）\n    Method method = Reflections.getMethods(udf.getClass(),\n        m -\u0026gt; m.getName().equals(\u0026quot;apply\u0026quot;)\n            \u0026amp;\u0026amp; m.getParameterCount() == params.length\n            \u0026amp;\u0026amp; !m.isBridge()\n    ).stream().findFirst().orElseThrow(...);\n\n    // 2. 逐参数做类型转换：JS Object → JSON String → Java Type\n    Object[] casts = Reflections.convert(params,\n        method.getGenericParameterTypes(), converter);\n\n    // 3. 反射调用\n    return Reflections.invoke(method, udf, casts);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类型转换器的策略是：先尝试将 JS 对象转为 Java 对象（\u003ccode\u003eScriptUtils.convertIntoJavaObject\u003c/code\u003e），如果类型不匹配，则序列化为 JSON 字符串再反序列化为目标类型。这种 \u003cstrong\u003eJSON 作为中间格式\u003c/strong\u003e 的做法虽然有性能开销，但保证了 JS 与 Java 之间几乎任意类型都能互通。\u003c/p\u003e\n\u003ch3\u003e6.3 UdfContainer：ByteBuddy 动态类生成\u003c/h3\u003e\n\u003cp\u003eUDF 在 JS 引擎中以属性链方式访问（如 \u003ccode\u003esys.scene.eval(...)\u003c/code\u003e），但 Nashorn 的 \u003ccode\u003eBindings\u003c/code\u003e 只支持扁平的 key-value。\u003ccode\u003eUdfContainer\u003c/code\u003e 需要将嵌套的 UDF 注册表（\u003ccode\u003eMap\u0026lt;String, Map\u0026lt;String, Object\u0026gt;\u0026gt;\u003c/code\u003e）转换为嵌套的 Java 对象。\u003c/p\u003e\n\u003cp\u003e它使用 \u003cstrong\u003eByteBuddy 在运行时动态生成 Java 类\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static Object compileUdf(String name, Object udf) {\n    if (!(udf instanceof HashMap)) return udf;\n\n    Map\u0026lt;String, Object\u0026gt; udfMap = (Map\u0026lt;String, Object\u0026gt;) udf;\n    // ByteBuddy 动态生成一个类，为每个 key 创建一个 public 字段\n    Builder\u0026lt;Object\u0026gt; subclass = new ByteBuddy()\n        .subclass(Object.class)\n        .name(name);\n    for (Entry\u0026lt;String, Object\u0026gt; entry : udfMap.entrySet()) {\n        subclass = subclass.defineField(entry.getKey(), Object.class, Visibility.PUBLIC);\n    }\n    // 实例化并赋值（递归处理嵌套命名空间）\n    Object instance = subclass.make()\n        .load(Thread.currentThread().getContextClassLoader())\n        .getLoaded().newInstance();\n    for (Entry\u0026lt;String, Object\u0026gt; entry : udfMap.entrySet()) {\n        instance.getClass().getField(entry.getKey())\n            .set(instance, compileUdf(name + \u0026quot;$\u0026quot; + capitalize(entry.getKey()), entry.getValue()));\n    }\n    return instance;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于 \u003ccode\u003esys.scene.eval\u003c/code\u003e 这样的三层命名空间，ByteBuddy 会生成如下类层次：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eUDF$Sys            (class, field: scene)\n  └── UDF$Sys$Scene    (class, field: eval)\n        └── UdfDelegate  (实际的函数代理对象)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNashorn 引擎通过属性访问 \u003ccode\u003esys.scene.eval(...)\u003c/code\u003e 时，会依次访问 \u003ccode\u003eUDF$Sys\u003c/code\u003e 实例的 \u003ccode\u003escene\u003c/code\u003e 字段 → \u003ccode\u003eUDF$Sys$Scene\u003c/code\u003e 实例的 \u003ccode\u003eeval\u003c/code\u003e 字段 → 得到 \u003ccode\u003eUdfDelegate\u003c/code\u003e → 调用其 \u003ccode\u003eapply()\u003c/code\u003e 方法。整个过程对 JS 表达式编写者完全透明。\u003c/p\u003e\n\u003ch3\u003e6.4 动态 JAR 加载：插件化 UDF\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSpringUdfLoader\u003c/code\u003e 支持在运行时从外部加载 JAR 文件，实现插件化的 UDF 扩展：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected void loadBeans(File file) {\n    // 1. 创建隔离的 ClassLoader\n    ClassLoader classLoader = new URLClassLoader(\n        new URL[]{classPathToURL(file.getAbsolutePath())}, originClassLoader);\n\n    // 2. 创建独立的 Spring 容器（父容器为主应用容器）\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(...);\n    context.setClassLoader(classLoader);\n    context.setParent(originContext);\n\n    // 3. 扫描自动配置类（读取 META-INF/spring.factories）\n    String[] configurations = getConfigurations(classLoader);\n    for (String config : configurations) {\n        context.register(classLoader.loadClass(config));\n    }\n\n    // 4. 刷新容器，完成 Bean 初始化\n    context.refresh();\n    this.fileOfContext.put(file, context);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里的关键设计是\u003cstrong\u003e容器隔离 + 父子关系\u003c/strong\u003e：每个 JAR 有独立的 \u003ccode\u003eClassLoader\u003c/code\u003e 和 \u003ccode\u003eApplicationContext\u003c/code\u003e，但以主应用容器为父容器——这意味着 JAR 中的 UDF 可以注入主应用的 Bean（如 RPC 客户端），但不会污染主应用的 Bean 空间。\u003c/p\u003e\n\u003cp\u003e卸载时（\u003ccode\u003eunloadBeans\u003c/code\u003e）需要做 \u003cstrong\u003eSpring 缓存清理\u003c/strong\u003e：关闭子容器、清理 \u003ccode\u003eAbstractAutoProxyCreator\u003c/code\u003e 的代理缓存、清理 Krpc 的引用缓存、清理 gRPC transport。这些清理工作是防止 ClassLoader 泄漏的关键——如果不清理，被卸载的类仍会被缓存引用，导致 ClassLoader 无法被 GC。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e7. 事件驱动体系\u003c/h2\u003e\n\u003cp\u003eMousika 的事件体系覆盖了规则生命周期的三个阶段：\u003cstrong\u003e解析时、执行时、变更时\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e7.1 引擎内事件：观察者模式\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eRuleEvent\u003c/code\u003e 是引擎内部的轻量事件对象：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RuleEvent {\n    private EventType eventType;  // PARSE_SUCCEED / PARSE_FAIL / EVAL_SUCCEED / EVAL_FAIL\n    private String ruleExpr;      // 规则表达式或规则 ID\n    private Object data;          // 成功时为 EvalResult / RuleNode，失败时为 Exception\n    private long cost;            // 耗时（毫秒）\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eListenerProvider\u003c/code\u003e 实现了经典的\u003cstrong\u003e观察者模式\u003c/strong\u003e——它自身既是 \u003ccode\u003eRuleListener\u003c/code\u003e，也是监听器注册中心。所有引擎内事件通过 \u003ccode\u003eListenerProvider.DEFAULT\u003c/code\u003e（全局静态单例）扇出到所有注册的监听器。\u003c/p\u003e\n\u003cp\u003e事件触发的时机精确定义在两个位置：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e触发位置\u003c/th\u003e\n\u003cth\u003e事件类型\u003c/th\u003e\n\u003cth\u003e设计意图\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eNodeBuilder.build()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ePARSE_SUCCEED\u003c/code\u003e / \u003ccode\u003ePARSE_FAIL\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e监控规则表达式的解析成功率和耗时\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eRuleContextImpl.doEval()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eEVAL_SUCCEED\u003c/code\u003e / \u003ccode\u003eEVAL_FAIL\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e监控每条规则的执行成功率、耗时和异常\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e7.2 内置监听器\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRuleEvalLogListener\u003c/strong\u003e：日志和错误监控的基础。\u003ccode\u003eEVAL_FAIL\u003c/code\u003e 和 \u003ccode\u003ePARSE_FAIL\u003c/code\u003e 时上报 \u003ccode\u003ead.mousika.rule.error\u003c/code\u003e 指标，便于配置报警。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRuleEvalElapsedListener\u003c/strong\u003e：性能监控的基础。记录每条规则的执行耗时，按 pass / fail / error 三种状态分维度上报 \u003ccode\u003ead.mousika.rule.elapsed\u003c/code\u003e 指标。当某条规则突然变慢（比如依赖的外部服务超时），可以通过这个指标快速定位。\u003c/p\u003e\n\u003ch3\u003e7.3 规则变更事件（MQ 驱动热加载）\u003c/h3\u003e\n\u003cp\u003e规则热加载是 Mousika 的核心能力之一。变更通知通过 \u003cstrong\u003eRocketMQ 广播\u003c/strong\u003e推送：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eBRMS 保存规则\n    │\n    ▼\n发布消息到 ad_infra_mousika_rule_info_notify_topic（广播模式）\n    │\n    ▼\nAbstractNotifyConsumer 接收通知\n    │  提取变更的 sceneKey，放入内部队列\n    ▼\n定时调度器批量处理队列中的变更\n    │\n    ▼\nRuleLoader.loadSuite()\n    │  从数据库 / 中心服务重新加载所有规则\n    ▼\nnew RuleSuite(definitions, udfs, scenes)\n    │  构造新的 RuleSuite 实例\n    ▼\nRuleSuite.current = newSuite  (volatile 引用替换)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e热加载的线程安全依赖两个机制：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003evolatile\u003c/code\u003e 引用替换\u003c/strong\u003e：\u003ccode\u003eRuleSuite.current\u003c/code\u003e 是 \u003ccode\u003evolatile\u003c/code\u003e 的，新实例构造完成后直接替换引用。正在执行的请求仍持有旧实例的引用（Java GC 的引用计数保证旧实例不会被提前回收），新请求使用新实例。这是一种\u003cstrong\u003e无锁的 Copy-on-Write\u003c/strong\u003e 策略。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e双重保障\u003c/strong\u003e：MQ 通知实现秒级生效，\u003ccode\u003eRuleSuiteRefreshTask\u003c/code\u003e 每 5 分钟定时全量刷新作为兜底——防止 MQ 消息丢失或消费失败导致的规则不一致。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e7.4 执行审计事件（Kafka + ES）\u003c/h3\u003e\n\u003cp\u003e在中心化 RPC 模式下，每次规则执行的完整上下文会\u003cstrong\u003e异步写入 Kafka\u003c/strong\u003e（Topic: \u003ccode\u003ead_mousika_eval_info_topic\u003c/code\u003e）。这条数据链支撑了三个下游场景：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e规则执行\n    │\n    ├──→ Kafka (ad_mousika_eval_info_topic)\n    │         │\n    │         ├──→ EvalCompareService (灰度对比)\n    │         │    对比 activeRule 和 candidateRule 的执行结果差异\n    │         │    发现不一致时生成验证报告\n    │         │\n    │         └──→ 数据分析平台 (离线分析)\n    │\n    └──→ ElasticSearch (实时写入)\n              │\n              └──→ BRMS 在线调试\n                   输入 Fact JSON → 查看执行详情 → 定位规则问题\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e灰度验证的机制是：每个 \u003ccode\u003eRuleScene\u003c/code\u003e 除了 \u003ccode\u003eactiveRule\u003c/code\u003e（线上生效的规则集），还可以挂载 \u003ccode\u003ecandidateRules\u003c/code\u003e（候选规则集）。执行时，活跃规则集在主线程执行返回结果，候选规则集在独立线程池异步执行，两组结果写入 Kafka 后由 \u003ccode\u003eEvalCompareService\u003c/code\u003e 对比——这使得规则变更可以在不影响线上的前提下提前验证。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 执行结果与可解释性\u003c/h2\u003e\n\u003ch3\u003e8.1 结果类型层次\u003c/h3\u003e\n\u003cp\u003e规则引擎不仅要给出\u0026quot;通过/不通过\u0026quot;的结论，还要能解释\u003cstrong\u003e为什么\u003c/strong\u003e。Mousika 的结果体系是一棵与 AST 对应的结果树：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNodeResult                          -- 规则集执行结果\n  ├── expr: String                  -- 完整规则集表达式\n  ├── nodeType: NodeType            -- 根节点类型\n  ├── result: Object                -- 原始返回值\n  └── details: List\u0026lt;RuleResult\u0026gt;     -- 详细结果树\n        └── RuleResult              -- 单条规则结果\n              ├── expr: String      -- 规则 ID\n              ├── result: Object    -- JS 引擎返回的原始值\n              ├── matched: boolean  -- 匹配结果\n              ├── desc: String      -- 动态描述（如 \u0026quot;广告主 张三 行业不合规\u0026quot;）\n              ├── nodeType          -- 节点类型\n              └── subRules: List\u0026lt;RuleResult\u0026gt;  -- 子规则结果（递归）\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e8.2 布尔类型转换策略\u003c/h3\u003e\n\u003cp\u003eJS 引擎的返回值类型不确定，Mousika 通过 \u003ccode\u003eEvalResult.parseBoolean()\u003c/code\u003e 做智能转换：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate boolean parseBoolean(Object res) {\n    if (res == null)             return false;\n    if (res instanceof Boolean)  return (Boolean) res;\n    if (res instanceof Number)   return ((Number) res).floatValue() \u0026gt; 0;\n    if (res instanceof String)   return ((String) res).toLowerCase().matches(\u0026quot;yes|true|1\u0026quot;);\n    if (res instanceof UdfPredicate) return ((UdfPredicate) res).test();\n    return res != null;  // 非 null 对象默认为 true\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eUdfPredicate\u003c/code\u003e 接口是一个扩展点——UDF 可以返回一个实现了 \u003ccode\u003eUdfPredicate\u003c/code\u003e 的对象，通过自定义的 \u003ccode\u003etest()\u003c/code\u003e 方法决定布尔语义。这允许 UDF 返回\u0026quot;富结果\u0026quot;（携带额外数据），同时仍能作为布尔条件参与 AST 的逻辑判断。\u003c/p\u003e\n\u003ch3\u003e8.3 描述动态插值的实现原理\u003c/h3\u003e\n\u003cp\u003e规则描述支持 \u003ccode\u003e{$.field}\u003c/code\u003e 语法引用 Fact 字段。\u003ccode\u003eevalRuleDesc()\u003c/code\u003e 通过正则替换将模板转换为 JS 字符串拼接表达式，然后复用 JS 引擎求值：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e输入模板:  \u0026quot;代理商【{$.agentId}】不允许【{$.customerId}】跨开\u0026quot;\n正则替换:  \u0026quot;代理商【\u0026quot;+$.agentId+\u0026quot;】不允许【\u0026quot;+$.customerId+\u0026quot;】跨开\u0026quot;\nJS 求值:   \u0026quot;代理商【10086】不允许【20001】跨开\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个设计复用了引擎已有的 JS 执行能力，零额外依赖。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e9. 平台能力：可视化编排、动态调试与归因分析\u003c/h2\u003e\n\u003cp\u003e规则引擎的核心能力在于执行，但一个能\u003cstrong\u003e落地生产\u003c/strong\u003e的规则平台，还需要回答三个问题：运营人员如何配置规则？配置错了怎么验证？线上规则命中异常时如何定位原因？Mousika 的 BRMS（Business Rule Management System）平台围绕这三个问题，构建了可视化编排、动态调试和归因分析三大前端能力。\u003c/p\u003e\n\u003ch3\u003e9.1 可视化规则编排：从流程图到 AST\u003c/h3\u003e\n\u003cp\u003e运营人员不写代码，他们需要的是\u0026quot;画流程图\u0026quot;——在画布上拖拽节点、连接边线，所见即所得。Mousika 的 BRMS 提供了三代 UI 编排方案，逐步演进：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e版本\u003c/th\u003e\n\u003cth\u003e实现类\u003c/th\u003e\n\u003cth\u003eUI 形态\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003ev1.0 规则树\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eTreeNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e树形嵌套面板\u003c/td\u003e\n\u003ctd\u003e简单条件分支（if-else 嵌套）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ev2.0 流程图\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eGraphNode\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e有向图（节点 + 有向边）\u003c/td\u003e\n\u003ctd\u003e复杂条件链（多级分支 + 环检测）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ev3.0 流程图\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eGraphNodeV2\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e结构化流程图（语义化节点类型）\u003c/td\u003e\n\u003ctd\u003e全场景覆盖（串/并行网关、排他分支、复合条件）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4\u003e核心设计：UI 节点到 AST 节点的双向映射\u003c/h4\u003e\n\u003cp\u003e三代方案共享同一个核心接口 \u003ccode\u003eUiConfig\u003c/code\u003e——前后端传输协议：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface UiConfig {\n    RuleNode toRule();           // UI 配置 → 引擎可执行的 AST\n    void valid();                // 配置合法性校验\n    Set\u0026lt;Long\u0026gt; collectRuleIds();  // 收集引用的规则 ID 集合\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个接口是\u003cstrong\u003e整个平台能力的锚点\u003c/strong\u003e：无论前端用什么形态展示规则（树、图、画布），后端只关心一件事——它能否转换为合法的 \u003ccode\u003eRuleNode\u003c/code\u003e AST。\u003c/p\u003e\n\u003ch4\u003ev3.0 流程图的节点类型体系\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eGraphNodeV2\u003c/code\u003e 是当前主力方案，它定义了 9 种语义化节点类型，每种节点对应一种 AST 结构：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌──────────────────────────────────────────────────────────────────┐\n│                   GraphNodeV2 节点类型体系                        │\n│                                                                  │\n│  start (EntryNode)          ── 流程入口，委托给子节点              │\n│  condition (ConditionNode)  ── 条件分支 → CaseNode               │\n│  action (ActionNode)        ── 动作执行 → ExprNode / SerNode     │\n│  and (LogicAndNode)         ── 逻辑与 → AndNode                  │\n│  or (LogicOrNode)           ── 逻辑或 → OrNode                   │\n│  serial (SerialGatewayNode) ── 串行网关 → SerNode                │\n│  parallel (ParallelGatewayNode) ── 并行网关 → ParNode            │\n│  exclusive (ExclusiveNode)  ── 排他网关 → 嵌套 CaseNode 链        │\n│  complexCondition (ComplexConditionNode) ── 复合条件（And/Or 组合）│\n└──────────────────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e每种 UI 节点通过 \u003ccode\u003etoRule()\u003c/code\u003e 方法递归生成对应的 AST 节点。以 \u003ccode\u003eConditionNode\u003c/code\u003e 为例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic RuleNode toRule() {\n    ExprNode exprNode = new ExprNode(String.valueOf(ruleId));\n    RuleNode ruleNode = negative ? new NotNode(exprNode) : exprNode;\n\n    // 无出度分支 → 纯条件节点\n    if (getTrueCase() == null \u0026amp;\u0026amp; getFalseCase() == null) {\n        return ruleNode;\n    }\n    // 有分支 → CaseNode（条件 + true 分支 + false 分支）\n    return new CaseNode(ruleNode, getTrueCase().toRule(),\n            getFalseCase() == null ? null : getFalseCase().toRule());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eExclusiveNode\u003c/code\u003e（排他网关）的转换最为巧妙——它将多个互斥条件分支\u003cstrong\u003e从后向前折叠\u003c/strong\u003e为嵌套的 \u003ccode\u003eCaseNode\u003c/code\u003e 链：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ExclusiveNode.toRule() — 排他网关的递归折叠\n// 输入: [条件A → 动作1, 条件B → 动作2, 条件C → 动作3] + 默认动作D\n// 输出: A ? 动作1 : (B ? 动作2 : (C ? 动作3 : D))\n\nwhile (CollectionUtils.isNotEmpty(ruleNodes)) {\n    CaseNode lastCaseNode = (CaseNode) ruleNodes.removeLast();\n    if (isHandleLastCondition \u0026amp;\u0026amp; defaultNode != null) {\n        caseNode = new CaseNode(lastCaseNode.getCondition(),\n            lastCaseNode.getTrueCase(), defaultNode.toRule());\n        isHandleLastCondition = false;\n    } else {\n        caseNode = new CaseNode(lastCaseNode.getCondition(),\n            lastCaseNode.getTrueCase(), caseNode);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这意味着运营人员在画布上看到的是\u0026quot;排他网关\u0026quot;（类似 BPMN 中的 XOR Gateway），但引擎实际执行的是嵌套的三元表达式——\u003cstrong\u003e视觉语义与执行语义的分离\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003eJSON 双向序列化与草稿机制\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eGraphNodeV2\u003c/code\u003e 通过 Jackson 的 \u003ccode\u003e@JsonTypeInfo\u003c/code\u003e + \u003ccode\u003e@JsonTypeIdResolver\u003c/code\u003e 实现多态 JSON 序列化。每个节点携带 \u003ccode\u003enodeType\u003c/code\u003e 字段用于反序列化时的类型路由，前后端通过同一份 JSON 结构进行数据交换。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@JsonTypeInfo(use = Id.CUSTOM, property = \u0026quot;nodeType\u0026quot;)\n@JsonTypeIdResolver(GraphNodeV2NodeTypeResolver.class)\npublic interface Node {\n    String getNodeType();\n    RuleNode toRule();\n    List\u0026lt;Long\u0026gt; ruleIdList();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eGraphNodeV2\u003c/code\u003e 还支持\u003cstrong\u003e草稿模式\u003c/strong\u003e（\u003ccode\u003eisDraft = true\u003c/code\u003e）：运营人员可以保存未完成的流程图配置而不触发 AST 转换和校验——这对于复杂规则集的渐进式编排至关重要。同时，\u003ccode\u003efeUiConfig\u003c/code\u003e 字段存储前端画布的布局信息（节点坐标、连线路径等），确保再次打开时视觉布局不丢失。\u003c/p\u003e\n\u003ch4\u003ev2.0 流程图：有向图 + 环检测\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eGraphNode\u003c/code\u003e（v2.0）采用经典的有向图模型——节点列表 + 有向边列表：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class GraphNode implements UiConfig {\n    private Map\u0026lt;String, Node\u0026gt; nodeMap;           // 节点集合\n    private Map\u0026lt;String, List\u0026lt;Edge\u0026gt;\u0026gt; outComingEdgeMap; // 出边映射\n\n    public RuleNode toRule() {\n        String firstNodeId = outComingEdgeMap.get(startNodeId).get(0).getTarget().getId();\n        return toRule(firstNodeId, outComingEdgeMap, nodeMap);  // 递归遍历有向图生成 AST\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003evalid()\u003c/code\u003e 方法执行三项校验：\u003cstrong\u003e单入口检查\u003c/strong\u003e（确保只有一个起始节点）、\u003cstrong\u003e条件完整性检查\u003c/strong\u003e（每个条件节点必须有两条出边）、\u003cstrong\u003e环路检测\u003c/strong\u003e（DFS + 回溯，防止循环依赖导致执行死循环）。\u003c/p\u003e\n\u003ch3\u003e9.2 动态调试：实时验证规则逻辑\u003c/h3\u003e\n\u003cp\u003e规则配置完成后，运营人员需要在发布前验证逻辑正确性。Mousika 提供了两层调试能力：\u003c/p\u003e\n\u003ch4\u003e在线调试（规则集级别）\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eRuleDebugController\u003c/code\u003e 暴露 \u003ccode\u003e/api/brms/rule/debug/call\u003c/code\u003e 接口，接受 Fact JSON 和规则集 ID / 规则表达式，\u003cstrong\u003e直接调用引擎 RPC 服务\u003c/strong\u003e执行并返回完整结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String call(CallParam param) {\n    String ruleExpr = param.getExpr();\n    if (debugType == DebugTypeEnum.RULE_SET) {\n        // 从数据库读取规则集配置\n        RuleSetRecord record = ruleSetDao.queryById(Long.parseLong(param.getExpr()));\n        ruleExpr = record.getConfig();\n    }\n    // 构造 gRPC 请求，调用引擎 evalByRuleExpr\n    RuleExprRequest request = RuleExprRequest.newBuilder()\n        .setRuleExpr(ruleExpr).setRawFact(param.getRequest()).build();\n    EvalResponse response = ruleEngineService.evalByRuleExpr(request);\n    return ObjectMapperUtils.toJSON(response);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e调试支持两种粒度：\u003cstrong\u003e单条规则\u003c/strong\u003e（\u003ccode\u003eDebugTypeEnum.RULE\u003c/code\u003e）和\u003cstrong\u003e规则集\u003c/strong\u003e（\u003ccode\u003eDebugTypeEnum.RULE_SET\u003c/code\u003e）。规则集调试时，先从数据库读取完整的规则集表达式，再提交给引擎执行——确保调试结果与线上一致。\u003c/p\u003e\n\u003ch4\u003e实时表达式调试（未保存的规则）\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003e/api/brms/rule/debug/execRuleExpr\u003c/code\u003e 接口支持对\u003cstrong\u003e尚未保存\u003c/strong\u003e的规则表达式进行实时调试——运营人员在编辑器中修改了 JS 表达式后，无需保存即可立即验证：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String exeRuleExpr(ExeParam exeParam) {\n    RuleEngine ruleEngine = new RuleEngine();  // 独立引擎实例，不影响线上\n    Object result = ruleEngine.evalExpr(\n        exeParam.getRuleExpr(),\n        ObjectMapperUtils.fromJson(exeParam.getRequest()),\n        new Object()\n    );\n    return Objects.isNull(result) ? \u0026quot;\u0026quot; : ObjectMapperUtils.toJSON(result);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意这里创建了一个全新的 \u003ccode\u003eRuleEngine\u003c/code\u003e 实例——与线上引擎完全隔离，避免调试数据污染生产环境。\u003c/p\u003e\n\u003ch4\u003e智能参数模板生成\u003c/h4\u003e\n\u003cp\u003e调试的痛点之一是构造测试入参。\u003ccode\u003egenRequestModel()\u003c/code\u003e 方法自动分析规则集引用的所有变量（通过正则 \u003ccode\u003e\\$[.a-zA-Z_0-9]+\u003c/code\u003e 提取），并生成一个带默认值的 JSON 模板：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 1. 从规则集中收集所有规则 ID\n// 2. 查询规则定义，提取 JS 表达式中的变量引用（如 $.advertiser.industry）\n// 3. 按路径层级构建嵌套 JSON 结构\n// 4. 通过 Protobuf 反射自动填充默认值\n\nprivate Object computeDefaultValue(String variablePath) {\n    RuleEngine ruleEngine = new RuleEngine();\n    for (Object message : pbInstances) {\n        Object o = ruleEngine.evalExpr(variablePath, message, new Object());\n        if (o != null) return o;\n    }\n    return \u0026quot;\u0026quot;;  // 兜底空字符串\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMousika 通过类路径扫描加载所有 Protobuf Message 类，构造默认实例，然后用 JS 引擎实际执行变量路径来获取默认值类型——这比静态类型推断更准确，因为它\u003cstrong\u003e直接复用了引擎的求值逻辑\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003e测试用例与执行路径断言\u003c/h4\u003e\n\u003cp\u003eBRMS 还支持创建持久化的\u003cstrong\u003e测试用例\u003c/strong\u003e（\u003ccode\u003eRuleSetTestCaseDetail\u003c/code\u003e），每个用例包含：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class RuleSetTestCaseDetail {\n    private String buildSceneConfig;          // 场景构建配置\n    private String buildSceneValue;           // 场景参数值\n    private String buildRequestParam;         // Fact 入参\n    private String expectedExecutionPath;     // 期望执行路径\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eexpectedExecutionPath\u003c/code\u003e 是核心字段——它记录了\u003cstrong\u003e期望的规则执行路径\u003c/strong\u003e（如 \u003ccode\u003e1269-\u0026gt;1242-\u0026gt;1246\u003c/code\u003e），在回归测试时，系统会将实际执行路径与期望路径对比，发现不一致则标记测试失败。这使得规则变更的影响范围可以通过自动化测试提前发现。\u003c/p\u003e\n\u003ch3\u003e9.3 归因分析：从\u0026quot;不通过\u0026quot;到\u0026quot;为什么不通过\u0026quot;\u003c/h3\u003e\n\u003cp\u003e规则引擎最常见的运营诉求是：\u0026quot;这条数据为什么被拦截了？\u0026quot;Mousika 的归因分析体系基于\u003cstrong\u003e执行树到结果树的转换\u003c/strong\u003e，提供从宏观到微观的逐层下钻能力。\u003c/p\u003e\n\u003ch4\u003e执行树 → 结果树的转换\u003c/h4\u003e\n\u003cp\u003e第 5.4 节介绍了 \u003ccode\u003eDefaultNodeVisitor\u003c/code\u003e 在执行过程中构建的 \u003ccode\u003eEvalNode\u003c/code\u003e 执行树。\u003ccode\u003eRuleContextImpl\u003c/code\u003e 将这棵执行树\u003cstrong\u003e转换为面向展示的 \u003ccode\u003eRuleResult\u003c/code\u003e 结果树\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate RuleResult transform(EvalNode node) {\n    String expr = node.getExpr();\n    EvalResult result = evalCache.get(expr);\n    // 动态插值生成人类可读的描述文案\n    RuleResult ruleResult = new RuleResult(result, evalDesc(expr), node.getNodeType());\n    // 递归转换子节点\n    for (EvalNode subNode : node.getChildren()) {\n        ruleResult.getSubRules().add(transform(subNode));\n    }\n    return ruleResult;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e转换过程做了两件关键的事：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e关联 evalCache\u003c/strong\u003e：从缓存中取出每个节点的实际执行结果（\u003ccode\u003eEvalResult\u003c/code\u003e），包括原始返回值和布尔判定\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e动态描述插值\u003c/strong\u003e：调用 \u003ccode\u003eevalDesc()\u003c/code\u003e 将规则描述模板中的 \u003ccode\u003e{$.field}\u003c/code\u003e 替换为实际的 Fact 字段值，生成如 \u0026quot;广告主【张三】行业【游戏】不合规\u0026quot; 这样的人类可读文案\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e最终的 \u003ccode\u003eNodeResult\u003c/code\u003e 是一棵\u003cstrong\u003e与 AST 同构的结果树\u003c/strong\u003e，每个节点都携带了表达式、执行结果、动态描述和子节点列表。\u003c/p\u003e\n\u003ch4\u003e深度遍历：叶子节点的扁平化视图\u003c/h4\u003e\n\u003cp\u003e对于需要快速定位具体命中/未命中规则的场景，\u003ccode\u003egetEvalResults()\u003c/code\u003e 提供了执行树的扁平化视图——只展示叶子节点（\u003ccode\u003eExprNode\u003c/code\u003e），跳过中间的编排节点：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void deepTraverse(List\u0026lt;EvalNode\u0026gt; evalNodes, List\u0026lt;NodeResult\u0026gt; nodeResults) {\n    for (EvalNode evalNode : evalNodes) {\n        if (evalNode.getChildren().size() == 0) {\n            // 叶子节点：直接构造 NodeResult\n            EvalResult evalResult = evalCache.get(evalNode.getExpr());\n            if (Objects.isNull(evalResult)) continue;  // 跳过未完成执行的节点\n            RuleResult ruleResult = new RuleResult(evalResult, evalDesc(expr), ...);\n            nodeResults.add(new NodeResult(ruleResult.getExpr(), ...));\n        } else {\n            // 非叶子节点：递归向下\n            deepTraverse(evalNode.getChildren(), nodeResults);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这为前端提供了两种展示模式：\u003cstrong\u003e树形归因\u003c/strong\u003e（完整的决策路径）和\u003cstrong\u003e列表归因\u003c/strong\u003e（直接看哪些具体规则通过/未通过）。\u003c/p\u003e\n\u003ch4\u003e验证对比：多规则集横向分析\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eValidationDetail\u003c/code\u003e 支持\u003cstrong\u003e同一份 Fact 数据在多个规则集上的横向对比\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ValidationDetail {\n    private String bizPrimaryKey;                     // 业务主键\n    private List\u0026lt;ValidationResult\u0026gt; validationResults; // 多个规则集的执行结果\n\n    public static class ValidationResult {\n        private long ruleSetId;  // 规则集 ID\n        private String result;   // 执行结果\n        private String desc;     // 结果描述\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运营人员可以选择多个规则集版本（如\u0026quot;当前线上版本\u0026quot;和\u0026quot;待发布版本\u0026quot;），对同一批业务数据进行批量验证，对比结果差异。结果支持\u003cstrong\u003e导出 Excel\u003c/strong\u003e——\u003ccode\u003etoExcelRow()\u003c/code\u003e 方法将每条数据的多规则集结果格式化为表格行，便于线下分析和审批。\u003c/p\u003e\n\u003cp\u003e这与第 7 章介绍的灰度验证机制（\u003ccode\u003ecandidateRules\u003c/code\u003e）形成互补：灰度验证是\u003cstrong\u003e线上流量的自动对比\u003c/strong\u003e，验证对比是\u003cstrong\u003e指定数据的手动对比\u003c/strong\u003e——两者共同保障了规则变更的安全性。\u003c/p\u003e\n\u003ch3\u003e9.4 执行路径渲染：从 EvalNode 到可视化\u003c/h3\u003e\n\u003cp\u003e执行路径渲染将规则的实际执行过程\u0026quot;叠加\u0026quot;到规则编排的流程图上，让运营人员直观地看到\u0026quot;数据在规则图中走了哪条路\u0026quot;。\u003c/p\u003e\n\u003cp\u003e其技术链路是：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFact 数据 ──→ 引擎执行 ──→ EvalNode 执行树 ──→ NodeResult 结果树\n                                                    │\n    ┌───────────────────────────────────────────────┘\n    │\n    ▼\n前端流程图 ──→ 遍历结果树 ──→ 标记每个节点的状态（通过/未通过/未执行）\n              │\n              ├── 通过的节点：绿色高亮\n              ├── 未通过的节点：红色高亮\n              ├── 未执行的分支（NaResult）：灰色\n              └── 点击节点 → 展开规则描述 + 原始返回值\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e关键是 \u003ccode\u003eNaResult\u003c/code\u003e 的设计价值在这里得到了充分体现：传统的 true/false 二态无法区分\u0026quot;规则执行结果为 false\u0026quot;和\u0026quot;规则因条件分支未被评估\u0026quot;。\u003ccode\u003eCaseNode\u003c/code\u003e 引入的三态返回使得前端可以精确地将未执行的分支渲染为灰色（Not Applicable），而非误导性地标记为\u0026quot;未通过\u0026quot;。\u003c/p\u003e\n\u003ch4\u003e完整的数据流闭环\u003c/h4\u003e\n\u003cp\u003e从数据写入到归因展示，完整的数据流形成了一个闭环：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌────────────────────────────────────────────────────────────────────┐\n│                         数据流闭环                                  │\n│                                                                    │\n│  配置阶段:  画布编排 ──→ GraphNodeV2 JSON ──→ toRule() ──→ AST     │\n│                                                                    │\n│  执行阶段:  Fact + AST ──→ DefaultNodeVisitor ──→ EvalNode 执行树   │\n│            │                                       │               │\n│            └── evalCache（幂等缓存）                └── RuleResult  │\n│                                                         结果树     │\n│                                                         │          │\n│  展示阶段:  结果树 ──→ 叠加到流程图 ──→ 路径高亮 + 节点描述          │\n│            │                                                       │\n│            ├── 树形归因（递归展开完整决策路径）                       │\n│            ├── 列表归因（叶子节点扁平化）                            │\n│            └── 横向对比（多版本验证 + Excel 导出）                   │\n└────────────────────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这个闭环的核心设计原则是\u003cstrong\u003e同构映射\u003c/strong\u003e：配置时的 UI 节点、执行时的 AST 节点、追踪时的 EvalNode、展示时的 RuleResult——四棵树结构一一对应。正是这种同构性，使得从\u0026quot;画规则\u0026quot;到\u0026quot;看结果\u0026quot;的全链路可以自然贯通，而不需要在任何环节做复杂的结构转换。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e10. 设计权衡与工程总结\u003c/h2\u003e\n\u003ch3\u003e10.1 关键设计决策\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e决策\u003c/th\u003e\n\u003cth\u003e选择\u003c/th\u003e\n\u003cth\u003e权衡\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e规则表达式执行\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eAST + JS 引擎分层\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eAST 保证编排逻辑的类型安全和可控性；JS 引擎提供单条规则求值的灵活性。代价是 Nashorn 在 JDK 11+ 被标记 deprecated\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eUDF 注册表 → JS 可访问对象\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eByteBuddy 动态生成类\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e让 JS 能以 \u003ccode\u003esys.scene.eval()\u003c/code\u003e 的属性链方式调用 UDF。代价是动态生成类增加了调试复杂度和 Metaspace 占用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e规则热加载\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003evolatile 引用替换（Copy-on-Write）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e无锁、无停顿。代价是短暂的内存双份（新旧 RuleSuite 共存直到旧实例被 GC）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e执行结果追踪\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eThreadLocal + 栈帧模拟\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e不侵入 AST 节点的执行逻辑。代价是 ParNode 中需要手动处理 ThreadLocal 迁移\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e类型转换\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eJSON 作为中间格式\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eJS ↔ Java 几乎任意类型可互通。代价是序列化/反序列化的性能开销\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e插件 JAR 卸载\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003e显式清理 Spring 缓存\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e防止 ClassLoader 泄漏。代价是需要知道 Spring / Krpc 内部的缓存字段（反射访问私有字段）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e10.2 架构模式总结\u003c/h3\u003e\n\u003cp\u003e回顾整个 Mousika 的设计，可以提炼出几个核心的架构模式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eDSL + Interpreter 模式\u003c/strong\u003e：规则编排语言通过 ANTLR4 解析为 AST，每个节点自解释执行。扩展新操作符只需添加新的 \u003ccode\u003eRuleNode\u003c/code\u003e 实现。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eVisitor 模式（变体）\u003c/strong\u003e：执行时通过 \u003ccode\u003econtext.visit(node)\u003c/code\u003e 间接调用，而非直接 \u003ccode\u003enode.eval(context)\u003c/code\u003e。这个间接层让 \u003ccode\u003eDefaultNodeVisitor\u003c/code\u003e 可以在不修改节点代码的前提下记录执行树。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e观察者模式\u003c/strong\u003e：\u003ccode\u003eListenerProvider\u003c/code\u003e 聚合所有 \u003ccode\u003eRuleListener\u003c/code\u003e，引擎在关键路径上触发事件。可观测性（监控、日志、审计）全部通过事件驱动实现，不侵入核心执行逻辑。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eCopy-on-Write\u003c/strong\u003e：\u003ccode\u003eRuleSuite\u003c/code\u003e 的热加载通过构造新实例 + \u003ccode\u003evolatile\u003c/code\u003e 引用替换实现，正在执行的请求不受影响。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e统一抽象\u003c/strong\u003e：决策表、复合规则、外部 RPC 调用——所有扩展功能都被归约到 UDF 机制，引擎内核始终只处理\u0026quot;JS 表达式求值\u0026quot;这一件事。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些模式共同构成了一个\u003cstrong\u003e稳定内核 + 灵活扩展\u003c/strong\u003e的架构——引擎核心代码量不大（\u003ccode\u003emousika-core\u003c/code\u003e 约 30 个类），但通过 UDF、事件监听器、规则热加载的扩展点，支撑起了整个业务体系的规则管理需求。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T5098,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eAI 编程的生产落地：从代码生成到安全发布的工程实践\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAI 编程工具正在快速改变开发者的工作方式——但\u0026quot;写得快\u0026quot;和\u0026quot;上得稳\u0026quot;是两件事。\u003c/p\u003e\n\u003cp\u003e本文不讨论如何用好 Copilot 或 Claude Code，而是聚焦一个更关键的工程问题：\u003cstrong\u003e当团队大规模使用 AI 编程后，我们需要哪些机制来确保产出的代码能安全地跑在生产环境中？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e文中所有方案均可直接落地为仓库配置与团队规约，不依赖特定语言或框架。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e1. 问题定义：AI 代码的不确定性从哪里来\u003c/h2\u003e\n\u003cp\u003eAI 生成代码与人类手写代码最大的区别不是质量——而是\u003cstrong\u003e可预测性\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e人类工程师写代码时，即使出了 bug，通常能解释\u0026quot;为什么这么写\u0026quot;。AI 生成的代码则不然：它可能在 99% 的 case 下完全正确，但在边界条件下以你意想不到的方式失败。更关键的是，AI 不理解你的系统全貌——它看到的是局部上下文，给出的是局部最优解。\u003c/p\u003e\n\u003cp\u003e具体来说，AI 代码的不确定性集中在以下维度：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e不确定性类型\u003c/th\u003e\n\u003cth\u003e典型表现\u003c/th\u003e\n\u003cth\u003e危害等级\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e行为不确定\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e对边界输入的处理不一致，缺少防御性逻辑\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e依赖不确定\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e引入陌生 / 过时 / 有漏洞的第三方库\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e安全不确定\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eSQL 拼接、命令注入、敏感信息硬编码\u003c/td\u003e\n\u003ctd\u003e极高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e性能不确定\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e无界循环、全量加载、缺少分页和超时\u003c/td\u003e\n\u003ctd\u003e中-高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e语义不确定\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e代码\u0026quot;看起来对\u0026quot;但不符合业务契约\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e核心认知：AI 写代码很快，但它不理解你的系统。\u003c/strong\u003e 管控的重点不是\u0026quot;AI 能不能写\u0026quot;，而是围绕生成、合并、发布三个阶段建立完整的工程防线。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 全链路管控：三道防线\u003c/h2\u003e\n\u003cp\u003e我们把 AI 代码从生成到上线的管控分为三道防线，覆盖代码生命周期的每一个关键节点：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e┌──────────────────┐     ┌──────────────────┐     ┌──────────────────┐\n│    第一道防线      │     │    第二道防线      │     │    第三道防线      │\n│    生成约束        │ ──→ │    合并门禁        │ ──→ │    发布管控        │\n│                  │     │                  │     │                  │\n│ · AI 代码标识     │     │ · PR 模板强制填写  │     │ · Feature Flag    │\n│ · 契约先行        │     │ · CI 自动 Gate    │     │ · Canary 渐进放量  │\n│ · 禁止清单        │     │ · 危险模式扫描     │     │ · 自动回滚机制     │\n│ · Tests-First    │     │ · 两段式 Review   │     │ · 可操作回滚方案   │\n└──────────────────┘     └──────────────────┘     └──────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e三道防线层层递进、互为补充。\u003cstrong\u003e第一道防线减少问题的产生，第二道防线拦截问题的流入，第三道防线控制问题的影响面。\u003c/strong\u003e 单独任何一道都不够，组合在一起才能形成闭环。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 第一道防线：生成环节的编程规范\u003c/h2\u003e\n\u003cp\u003e生成环节的目标不是\u0026quot;让 AI 别犯错\u0026quot;（这做不到），而是\u003cstrong\u003e通过规范和约束，大幅降低 AI 产出不合格代码的概率\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e3.1 AI 代码的定义与标识\u003c/h3\u003e\n\u003cp\u003e团队首先需要明确什么算\u0026quot;AI 代码\u0026quot;，以及如何对它做差异化管理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e标准：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e任何由 AI 生成或大幅修改（\u0026gt;30 行或 \u0026gt;10% 文件变更）的代码，必须标识为 \u003ccode\u003eAI-assisted\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e涉及\u003cstrong\u003e鉴权 / 权限 / 资金 / 数据删除 / 加密 / 合规 / 基础设施\u003c/strong\u003e的改动：AI 只能辅助，必须由负责人手写或逐行审核\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e落地方式：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePR 标题使用 \u003ccode\u003e[AI]\u003c/code\u003e 前缀，或添加 \u003ccode\u003eai-assisted\u003c/code\u003e label\u003c/li\u003e\n\u003cli\u003ePR 描述必须包含：prompt 摘要 + 风险点 + 测试证据 + 回滚方案\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这不是行政负担，而是让团队对 AI 代码保持\u003cstrong\u003e显式的风险意识\u003c/strong\u003e——一条没有标识的 AI PR 滑入主干，出了问题你连排查方向都没有。\u003c/p\u003e\n\u003ch3\u003e3.2 契约先行：先定接口再写实现\u003c/h3\u003e\n\u003cp\u003eAI 最容易\u0026quot;翻车\u0026quot;的场景是：你让它\u0026quot;实现一个功能\u0026quot;，它直接输出一大段代码，但没人约定过输入输出规格。它给的实现可能完全\u0026quot;合理\u0026quot;，但和上下游系统对不上。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e标准：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e先写契约再写实现\u003c/strong\u003e：函数签名、输入/输出 schema、错误码、幂等语义、超时/重试策略\u003c/li\u003e\n\u003cli\u003e对外 API 必须有：\u003ccode\u003erequest_id\u003c/code\u003e / \u003ccode\u003etrace_id\u003c/code\u003e 透传，错误结构统一\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e落地方式：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 AI 提示词模板中强制要求按如下顺序输出：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eContract → Tests → Implementation → Risks\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e即使不做严格 TDD，也必须做到 \u003cstrong\u003eTests-First\u003c/strong\u003e——先写测试用例定义预期行为，再让 AI 补实现。这样 AI 生成的代码天然就有验收标准，而不是\u0026quot;看起来能跑就行\u0026quot;。\u003c/p\u003e\n\u003cp\u003e一个实际的提示词模板片段：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-text\"\u003e请为以下需求生成代码。严格按照如下顺序输出：\n\n1. 函数签名与契约：入参类型、返回类型、错误码定义、幂等语义\n2. 测试用例：至少覆盖正常路径、边界输入、错误路径\n3. 实现代码\n4. 风险声明：该实现的已知局限、可能的边界问题\n\n需求：...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.3 禁止清单：AI 最常见的翻车点\u003c/h3\u003e\n\u003cp\u003e经验表明，AI 生成代码中有一些\u003cstrong\u003e反复出现的危险模式\u003c/strong\u003e。把它们明确写进团队规约的禁止清单，比事后 Review 发现要高效得多。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e禁止项\u003c/th\u003e\n\u003cth\u003e原因\u003c/th\u003e\n\u003cth\u003e检测手段\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e外部请求无 \u003ccode\u003etimeout\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e线程/协程泄漏，级联故障\u003c/td\u003e\n\u003ctd\u003elint 规则 + CI 扫描\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e捕获异常后静默吞掉（\u003ccode\u003eexcept: pass\u003c/code\u003e）\u003c/td\u003e\n\u003ctd\u003e故障不可观测，排查时间翻倍\u003c/td\u003e\n\u003ctd\u003e自定义 lint\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSQL / 命令 / 模板字符串拼接\u003c/td\u003e\n\u003ctd\u003e注入风险\u003c/td\u003e\n\u003ctd\u003eSAST 扫描\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e无界循环 / 无分页 / 全量读入内存\u003c/td\u003e\n\u003ctd\u003eOOM、CPU 打满\u003c/td\u003e\n\u003ctd\u003eCode Review\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e引入未审批的陌生依赖\u003c/td\u003e\n\u003ctd\u003e供应链攻击、License 合规\u003c/td\u003e\n\u003ctd\u003e依赖白名单 + SCA\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e硬编码密钥、Token、连接字符串\u003c/td\u003e\n\u003ctd\u003e凭证泄漏\u003c/td\u003e\n\u003ctd\u003eSecret 扫描\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e关键思路：每次 AI 犯过的错，都应该变成禁止清单上的一条新规则。\u003c/strong\u003e 禁止清单不是静态文档，而是一个随团队经验持续增长的\u0026quot;抗体库\u0026quot;。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e4. 第二道防线：合并门禁\u003c/h2\u003e\n\u003cp\u003e第一道防线靠规范和自觉，第二道防线靠\u003cstrong\u003e自动化机制\u003c/strong\u003e——让不合格的代码根本无法合入主干。\u003c/p\u003e\n\u003ch3\u003e4.1 PR 模板：结构化的信息收集\u003c/h3\u003e\n\u003cp\u003ePR 模板的目的不是增加官僚流程，而是强制提交者\u003cstrong\u003e提前思考该想的问题\u003c/strong\u003e。存为 \u003ccode\u003e.github/pull_request_template.md\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-markdown\"\u003e## Change Type\n- [ ] AI-assisted (generated or heavily modified)\n- [ ] Human-written\n\n## Summary\nWhat changed? (1-3 bullets)\n\n## Contract / Behavior\n- API / Function contract:\n- Error behavior:\n- Idempotency / retries / timeouts:\n- Backward compatibility:\n\n## Risk Assessment\n- Highest risk area:\n- Data correctness risk:\n- Security risk:\n- Performance risk:\n\n## Test Evidence\n- Unit tests:\n- Integration tests:\n- Manual test steps (if any):\n- Benchmarks (if relevant):\n\n## Observability\n- Metrics added/updated:\n- Logs/trace updates:\n- Alert / rollback thresholds:\n\n## Rollback Plan\nHow to rollback safely? (flag / revert / DB migration rollback etc.)\n\n## AI Prompt Summary (required if AI-assisted)\n- Tool/model:\n- Prompt outline (no secrets):\n- Known limitations / TODO:\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4.2 CI Gate：最小必备检查\u003c/h3\u003e\n\u003cp\u003e以下是 merge 前必须通过的自动化检查，优先级从高到低：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e优先级\u003c/th\u003e\n\u003cth\u003e检查项\u003c/th\u003e\n\u003cth\u003e拦截目标\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eP0\u003c/td\u003e\n\u003ctd\u003eformat / lint / typecheck\u003c/td\u003e\n\u003ctd\u003e基本代码质量\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP0\u003c/td\u003e\n\u003ctd\u003e单元测试（含边界和错误路径）\u003c/td\u003e\n\u003ctd\u003e行为正确性\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP0\u003c/td\u003e\n\u003ctd\u003eSecret 扫描\u003c/td\u003e\n\u003ctd\u003e凭证泄漏\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP1\u003c/td\u003e\n\u003ctd\u003e依赖漏洞扫描（SCA）\u003c/td\u003e\n\u003ctd\u003e供应链安全\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP1\u003c/td\u003e\n\u003ctd\u003e自定义危险模式扫描\u003c/td\u003e\n\u003ctd\u003eAI 高频翻车点\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP2\u003c/td\u003e\n\u003ctd\u003e集成测试\u003c/td\u003e\n\u003ctd\u003e端到端行为\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eGitHub Actions 示例（通用骨架）：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003ename: CI\non:\n  pull_request:\n  push:\n    branches: [main]\n\njobs:\n  build-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      # ---- 以 Python 为例，按你的语言替换 ----\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \u0026quot;3.11\u0026quot;\n\n      - run: pip install -r requirements.txt\n      - run: pip install ruff mypy pytest\n\n      - name: Lint\n        run: ruff check .\n\n      - name: Type check\n        run: mypy .\n\n      - name: Unit tests\n        run: pytest -q\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: TruffleHog (secret scan)\n        uses: trufflesecurity/trufflehog@v3\n        with:\n          path: .\n          base: ${{ github.event.pull_request.base.sha || \u0026#39;HEAD~1\u0026#39; }}\n          head: ${{ github.sha }}\n\n      - name: OSV Scanner (dependency scan)\n        uses: google/osv-scanner-action@v1\n        with:\n          scan-args: |-\n            -r .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJava/Gradle 项目替换为 \u003ccode\u003e./gradlew test\u003c/code\u003e + SpotBugs/ErrorProne；Go 项目用 \u003ccode\u003ego vet\u003c/code\u003e + \u003ccode\u003egolangci-lint\u003c/code\u003e + \u003ccode\u003egovulncheck\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e4.3 自定义危险模式扫描\u003c/h3\u003e\n\u003cp\u003e通用 lint 工具覆盖不了所有 AI 翻车场景。针对第 3.3 节的禁止清单，编写轻量脚本实现自动检测：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e示例：禁止无 timeout 的 HTTP 请求\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# scripts/ci/ban_no_timeout.sh\nset -euo pipefail\nif rg -n \u0026#39;requests\\.(get|post|put|delete|patch)\\(\u0026#39; . \\\n   --glob \u0026#39;*.py\u0026#39; | rg -v \u0026#39;timeout=\u0026#39;; then\n  echo \u0026quot;ERROR: requests call without timeout=\u0026quot;\n  exit 1\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e示例：禁止静默吞异常\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# scripts/ci/ban_silent_except.sh\nset -euo pipefail\nif rg -n \u0026#39;except.*:\u0026#39; . --glob \u0026#39;*.py\u0026#39; -A 1 | rg \u0026#39;^\\s+pass$\u0026#39;; then\n  echo \u0026quot;ERROR: bare \u0026#39;except: pass\u0026#39; detected\u0026quot;\n  exit 1\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 CI 中加一步即可生效：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e- name: Custom safety checks\n  run: |\n    bash scripts/ci/ban_no_timeout.sh\n    bash scripts/ci/ban_silent_except.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这些规则的核心价值在于：\u003cstrong\u003e把团队踩过的坑编码成自动化检查，让同样的错误不会第二次进入主干。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e4.4 Code Review：两段式审查\u003c/h3\u003e\n\u003cp\u003e自动化能拦住模式化的问题，但\u003cstrong\u003e语义层面的错误只有人能发现\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e标准：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAI-assisted PR：必须 \u003cstrong\u003e2 人 review\u003c/strong\u003e，其中至少 1 人是系统 owner\u003c/li\u003e\n\u003cli\u003eReview 重点不是代码风格，而是四个核心维度：\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003e关注点\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e契约完整性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e输入输出是否符合预期？接口是否向后兼容？\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e错误处理\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e异常路径是否完备？重试和幂等是否正确？\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e资源边界\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e内存、连接数、并发是否有上限？timeout 是否合理？\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e安全性\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e输入校验是否充分？是否存在注入点？日志是否泄漏敏感信息？\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e落地方式：\u003c/strong\u003e GitHub CODEOWNERS + Branch Protection Rules，确保 AI-assisted PR 必须经过 review 才能 merge。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e5. 第三道防线：发布管控\u003c/h2\u003e\n\u003cp\u003e代码合入主干不等于上线。考虑到 AI 代码的不确定性，发布环节需要更精细的控制。\u003c/p\u003e\n\u003ch3\u003e5.1 Feature Flag + Canary 放量\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e标准：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAI-assisted 功能必须走 Feature Flag，\u003cstrong\u003e默认关闭\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eCanary 放量梯度：\u003cstrong\u003e1% → 10% → 50% → 100%\u003c/strong\u003e，每一步必须满足 SLO 才能继续\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFlag 不需要复杂的配置中心——起步阶段用环境变量或简单的配置文件就够了。关键是确保每个 AI-assisted 功能都有一个\u003cstrong\u003e独立的开关\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e5.2 自动回滚\u003c/h3\u003e\n\u003cp\u003e放量过程中，以下任一条件触发时应自动回滚：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e指标\u003c/th\u003e\n\u003cth\u003e触发条件\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e错误率\u003c/td\u003e\n\u003ctd\u003e超过基线 X%（按业务定义）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP95 延迟\u003c/td\u003e\n\u003ctd\u003e超过阈值 Y ms\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e关键业务指标\u003c/td\u003e\n\u003ctd\u003e跌破历史基线\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e5.3 回滚方案必须\u0026quot;可操作\u0026quot;\u003c/h3\u003e\n\u003cp\u003e\u0026quot;回滚到上一个版本\u0026quot;不是回滚方案——它缺少具体操作步骤和预期恢复时间。可操作的回滚方案需要明确：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e回滚方式\u003c/th\u003e\n\u003cth\u003e适用场景\u003c/th\u003e\n\u003cth\u003e恢复时间\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e关闭 Feature Flag\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e纯逻辑变更，无状态影响\u003c/td\u003e\n\u003ctd\u003e秒级\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eGit revert + 重新部署\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e没有 Flag 覆盖的变更\u003c/td\u003e\n\u003ctd\u003e分钟级\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e蓝绿切换\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e基础设施变更\u003c/td\u003e\n\u003ctd\u003e分钟级\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eDB 回滚脚本\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e涉及 schema 或数据迁移\u003c/td\u003e\n\u003ctd\u003e视数据量而定\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e每个 PR 的 Rollback Plan 字段必须写清楚选择哪种方式、具体步骤是什么。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003e6. 特殊场景：Pipeline 类系统的额外规则\u003c/h2\u003e\n\u003cp\u003e如果你的系统包含增量执行、缓存、fingerprint 等机制（如数据流水线、构建系统、AI 推理管线），上述三道防线之外还需要两条铁律。\u003c/p\u003e\n\u003cp\u003e这类系统的核心风险是：\u003cstrong\u003e逻辑变了，但缓存没失效，修改后的代码根本不会被执行。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e6.1 逻辑版本化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e标准：\u003c/strong\u003e 任何影响处理阶段输出语义的改动（算法、处理逻辑、默认行为），必须 bump \u003ccode\u003ephase.version\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e落地方式：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass TranslationPhase(Phase):\n    VERSION = \u0026quot;2026-02-15.1\u0026quot;  # 语义变更时必须 bump\n\n    def should_run(self, manifest):\n        return (\n            self.VERSION != manifest.get(\u0026quot;translation_version\u0026quot;)\n            or self.input_changed(manifest)\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunner 在执行前比较版本号——不同则强制重跑并更新 manifest。\u003c/p\u003e\n\u003ch3\u003e6.2 配置指纹闭环\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e标准：\u003c/strong\u003e 任何影响输出的配置变更（模型版本、参数调整等）必须参与 \u003ccode\u003econfig_fingerprint\u003c/code\u003e 计算。严禁\u0026quot;配置变了但缓存不失效\u0026quot;。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e落地方式：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef config_fingerprint(phase_name: str, config: dict) -\u0026gt; str:\n    \u0026quot;\u0026quot;\u0026quot;对阶段生效配置做稳定序列化后取 hash\u0026quot;\u0026quot;\u0026quot;\n    effective = get_effective_config(phase_name, config)\n    serialized = json.dumps(effective, sort_keys=True)\n    return hashlib.sha256(serialized.encode()).hexdigest()[:16]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e要点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e维护 phase → config_keys \u003cstrong\u003e白名单\u003c/strong\u003e，只有白名单内的 key 参与 fingerprint\u003c/li\u003e\n\u003cli\u003eGlobal config 与 phase override 合并后再序列化\u003c/li\u003e\n\u003cli\u003efingerprint 作为缓存 key 的一部分\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003e7. 落地路线图：从最小集到完整体系\u003c/h2\u003e\n\u003cp\u003e如果团队资源有限，按以下优先级分阶段落地：\u003c/p\u003e\n\u003ch3\u003e第一阶段：本周可完成\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e产物\u003c/th\u003e\n\u003cth\u003e内容\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003ePR 模板\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.github/pull_request_template.md\u003c/code\u003e，强制填写 AI 标识、风险、测试证据、回滚方案\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCI 基础 Gate\u003c/td\u003e\n\u003ctd\u003elint / typecheck / unit test + secret scan + dependency scan\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e团队约定\u003c/td\u003e\n\u003ctd\u003eAI-assisted PR 必须打 label，敏感模块禁止 AI 直接提交\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e第二阶段：两周内完成\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e产物\u003c/th\u003e\n\u003cth\u003e内容\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e自定义扫描脚本\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003escripts/ci/*\u003c/code\u003e——timeout、吞异常、SQL 拼接等危险模式检测\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eReview 机制\u003c/td\u003e\n\u003ctd\u003eCODEOWNERS + Branch Protection，AI PR 必须 2 人 review\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e提示词模板\u003c/td\u003e\n\u003ctd\u003e团队共享的 Contract → Tests → Implementation → Risks 模板\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e第三阶段：一个月内完成\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e产物\u003c/th\u003e\n\u003cth\u003e内容\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eFeature Flag 框架\u003c/td\u003e\n\u003ctd\u003eAI-assisted 功能默认关闭，支持渐进放量\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCanary + 自动回滚\u003c/td\u003e\n\u003ctd\u003e放量梯度 + SLO 监控 + 自动回滚阈值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e编程规约文档\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003edocs/AI_CODING_STANDARD.md\u003c/code\u003e，包含标准、禁止清单、流程，配合团队培训\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePipeline 专项\u003c/td\u003e\n\u003ctd\u003ephase.version 机制 + config_fingerprint 闭环（如适用）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e仓库产物清单\u003c/h3\u003e\n\u003cp\u003e最终需要在仓库中维护以下文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003erepo/\n├── docs/\n│   └── AI_CODING_STANDARD.md      # 编程规约：标准 / 禁止清单 / 流程\n├── .github/\n│   ├── pull_request_template.md    # PR 必填模板\n│   ├── CODEOWNERS                  # 模块责任人定义\n│   └── workflows/\n│       └── ci.yml                  # CI Gate 自动检查\n└── scripts/\n    └── ci/\n        ├── ban_no_timeout.sh       # 禁止无 timeout 请求\n        ├── ban_silent_except.sh    # 禁止静默吞异常\n        └── ...                     # 更多团队积累的规则\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 总结\u003c/h2\u003e\n\u003cp\u003eAI 编程工具的生产力价值毋庸置疑。但**\u0026quot;让 AI 写代码\u0026quot;和\u0026quot;让 AI 代码上生产\u0026quot;之间，需要一整套工程机制来填补**。\u003c/p\u003e\n\u003cp\u003e这套机制的核心逻辑：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e生成时约束\u003c/strong\u003e：通过契约先行、Tests-First 和禁止清单，从源头降低不合格代码的产出概率\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e合并时拦截\u003c/strong\u003e：通过 CI Gate、危险模式扫描和结构化 Review，让不合格代码无法进入主干\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e发布时兜底\u003c/strong\u003e：通过 Feature Flag、Canary 放量和自动回滚，即使有漏网之鱼也能快速止损\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eAI 不确定性的本质是：你无法在生成阶段消灭所有风险。\u003c/strong\u003e 所以答案不是\u0026quot;写更好的 prompt\u0026quot;，而是\u0026quot;建更好的工程防线\u0026quot;。\u003c/p\u003e\n\u003cp\u003e把每一次 AI 犯的错编码成一条自动规则，让防线随经验一起生长——这才是与 AI 协作编程的可持续方式。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2026-2-17\",\"children\":\"2026年02月17日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"Mousika 规则引擎：让规则可编排、可执行、可解释\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L5\",\"规则引擎\",{\"href\":\"/blog/tag/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"规则引擎\"}],[\"$\",\"$L5\",\"DSL\",{\"href\":\"/blog/tag/DSL/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"DSL\"}],[\"$\",\"$L5\",\"可视化编排\",{\"href\":\"/blog/tag/%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E6%8E%92/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"可视化编排\"}],[\"$\",\"$L5\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$11\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/infrastructure/AI编程的生产落地：从代码生成到安全发布的工程实践\",\"title\":\"AI 编程的生产落地：从代码生成到安全发布的工程实践\",\"description\":\"本文面向工程团队负责人与一线开发者，系统梳理 AI 辅助编程从提示词设计、代码生成、质量门禁到生产发布的全链路管控方案。核心命题是：如何建立一套工程机制，让 AI 生成的代码能够安全、可控地跑在生产环境中。\",\"pubDate\":\"2026-2-15\",\"tags\":[\"AI 编程\",\"工程实践\",\"DevOps\",\"代码质量\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":null},\"tagNav\":{\"规则引擎\":{\"prev\":null,\"next\":null},\"DSL\":{\"prev\":null,\"next\":null},\"可视化编排\":{\"prev\":null,\"next\":null},\"Java\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L18\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Mousika 规则引擎：让规则可编排、可执行、可解释 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"本文基于 Mousika 规则引擎平台，系统解析其如何通过 DSL 编排与 JS 求值分层、四棵同构树贯穿全链路、万物皆 UDF 的统一抽象，实现规则从可视化配置到动态执行再到归因分析的完整闭环。适合对业务规则引擎、DSL 设计、动态规则平台感兴趣的工程师阅读。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Mousika 规则引擎：让规则可编排、可执行、可解释\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"本文基于 Mousika 规则引擎平台，系统解析其如何通过 DSL 编排与 JS 求值分层、四棵同构树贯穿全链路、万物皆 UDF 的统一抽象，实现规则从可视化配置到动态执行再到归因分析的完整闭环。适合对业务规则引擎、DSL 设计、动态规则平台感兴趣的工程师阅读。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2026-2-17\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Mousika 规则引擎：让规则可编排、可执行、可解释\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"本文基于 Mousika 规则引擎平台，系统解析其如何通过 DSL 编排与 JS 求值分层、四棵同构树贯穿全链路、万物皆 UDF 的统一抽象，实现规则从可视化配置到动态执行再到归因分析的完整闭环。适合对业务规则引擎、DSL 设计、动态规则平台感兴趣的工程师阅读。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ab9f9bc568942ddd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>用户系统设计——三户模型及三层身份模型 - Skyfalling Blog</title><meta name="description" content="三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建..."/><meta property="og:title" content="用户系统设计——三户模型及三层身份模型"/><meta property="og:description" content="三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建..."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-03-01"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="用户系统设计——三户模型及三层身份模型"/><meta name="twitter:description" content="三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建..."/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/domain/page/1/">领域建模</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-03-01">2024年03月01日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">用户系统设计——三户模型及三层身份模型</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84/page/1/">业务架构</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/page/1/">用户系统</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B/page/1/">三户模型</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>用户系统设计:三户模型&amp;三层身份模型</h1>
<h3>三户模型</h3>
<p>三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建立用户和账户。这三个是相互关联的实体，这种关联只是一个归属和映射的关系，而三个实体本身是相互独立的，分别是体现完全不同的几个域的信息，<strong>客户</strong>是体现了<strong>社会域</strong>的信息，<strong>用户</strong>体现了<strong>业务域</strong>的信息，<strong>账户</strong>体现的是<strong>资金域</strong>的信息。</p>
<ul>
<li>客户（customer）：是指客户（自然人、公司、集团公司）的基本资料信息。例如自然人的姓名、手机号、身份证、邮箱地址等等；公司的五证一照、行业、联系人、网站地址、通讯地址等等。如无特指，一般客户指个人客户。</li>
<li>用户（user）：指客户在系统的登录账号信息，包括账号、密码、人员权限、角色等等。对应的，法人客户在系统中注册后，被称之为商户。</li>
<li>账户（account）：指客户在系统的虚拟账户，主要与交易记账相关。</li>
</ul>
<p><img src="https://www.biaodianfu.com/wp-content/uploads/2020/09/customer-user-account.png" alt=""></p>
<p>以电信业务为例：</p>
<ul>
<li>客户：人</li>
<li>用户：电信产品的实例表现</li>
<li>账户：付费的账号</li>
</ul>
<p>假设张三是中国典电信的一个客户，张三办理了一个手机SIM卡和一个宽带业务。其中手机SIM卡和宽带业务分别作为一个用户存在（电信产品实例）。下面还有一个账户的概念，账户是用户进行付费的。一般情况，一个用户只有一个账户，以上例为例，张三有一个账户，为手机号和宽带付费。当然，有的人可能存在多个账户，例如手机号是一个账户，宽带是是一个账户。</p>
<p>总结一下，一个客户（张三）可以有多个用户（一个手机号和一个宽带业务），但一个用户只能归属于一个客户。一个客户可以用多个账户，但一个账户也只能归属于一个客户。账户和用户的关系比较复杂，一般情况，一个账户可以给多个用户付费，但也允许，一个用户的不同费用由多个账户付费，所以账户和用户之间是多对多的关系。</p>
<h4>客户</h4>
<p>客户是一个社会化的概念，一个自然人或一个法人就称之为一个客户，法人客户既可以是一个企业，也可以是与这个企业、集团相关的自然人客户，可以称之为一个集团客户组。</p>
<p>客户可分为个人客户，企业客户。一个客户可以包含多个用户，客户通过唯一的客户标识来确定。客户描述一个客户的自然属性，客户可以和用户一一对应，也可以和用户一对多。<strong>即使不使用业务，也可能存在客户</strong>，因为客户是自然存在的。客户信息包含客户名，地址，邮政编码，性别，年龄，职业，证件号码等等信息，是自然存在的信息。</p>
<p><strong>个人客户</strong></p>
<p>在互联网系统中，一般是用户先注册，先有用户，然后补充客户身份信息。也就是客户身份信息是在运行过程中逐步完善的。在电信体系或银行体系，客户的主键通常是证件号（如身份证），将所有相同的证件视为同一客户。在互联网行业通常是将手机号识别为主键（<strong>注意：手机号有注销、更换等问题</strong>），这里面就有一个关键业务，既然相同证件的证件号或手机号会识别成一个客户，当相同的证件号或手机号进入系统时，系统是如何处理的？当然是合成一个了，这个过程叫做客户归并，即：将客户合成同一个客户号的过程，我们称为归并。归并是有风险的，所以需要一些<strong>鉴权手段</strong>来处理。</p>
<p>在互联网应用中，一个系统中的生命周期如下：</p>
<p><img src="https://www.biaodianfu.com/wp-content/uploads/2020/09/customer.png" alt=""></p>
<p>正常的互联网站点一般只有正常和禁入2种状态，银行业可能还会包含冻结和止付状态（以司法协查为例，某个客户被协查以致账户冻结，需要冻结该客户下所有资金账户，这些账户都被止付）。</p>
<p>注意在这个流程中<strong>没有销户的状态</strong>。 这是为了<strong>支持历史业务的处理</strong>，客户一般不做销户。 此外这个流程和支付账户的流程比较类似，这是为了方便在客户层面做账户控制。</p>
<p><strong>存在问题，用户手机号更换带来的身份识别不能解决。</strong></p>
<p><strong>企业客户</strong></p>
<p>企业客户相对个人客户来说比较复杂点，但三户模型仍然适用。企业客户是一个组织，其账户必然是组织授权内部人员去操作。但是这个操作人，同个人客户一样，只是系统的使用者，即用户。企业的资金比较大，并且有严格的业务流程，所以在系统使用上，一般是多个用户操作一个或多个资金账户。这种关系本身来说，也是一种授权关系，企业授权相应的用户来操作特定的资金账户，只不过为了管理方便，可以引入角色管理机制来实现。对于支付公司来说，企业客户通常都是发展商户过程中产生的。企业客户的识别同个人客户识别也是一样的，通过企业证件来统一识别。相同的企业证件号归并到同一个企业客户下面。建立企业客户的好处在于：</p>
<ul>
<li>有些企业本身只开通了企业服务业务，而不开通商户服务</li>
<li>一个企业可以开通多个商户，企业客户是这些多个商户的统计口径</li>
</ul>
<h4>用户</h4>
<p>用户是在产品基础上产生的实体。如果说一个客户使用了多个产品，那么一个客户就会对应好几个用户（即产品）。</p>
<p><strong>个体用户</strong></p>
<p>用户与资金账户之间我们可以抽象出一种授权关系，凡是授权用户，都可以操作资金账户，当然，这种授权包括客户自己的用户。用户的建立比较简单，一般自助注册后就可以生成用户实体了。</p>
<p>用户的生命周期如下：</p>
<p><img src="https://www.biaodianfu.com/wp-content/uploads/2020/09/user.png" alt=""></p>
<p>如果用户想要销户，收到销户申请后，不能直接销户，客户是通过用户来进行资金账户的管理与操作的，所以，此时有个确认过程，要求各业务系统确认此用户下的所有账户是否可以销户，如果没有问题，先销资金账户，当用户下的所有资金账户都销户完毕，再销用户，用户销户完成后，会释放出此用户占用的资源，如注册手机号。</p>
<p>在互联网环境比较多的场景是用户更新手机号，用户更新手机号的时候涉及到的两个手机号都需要验证。需要注意的是， 更新手机号需要涉及到更新客户ID。</p>
<p>用户除了生命周期状态外，还有一个管理状态，比如锁定，从现实模型中来说，这个是不应该放在用户层面的而是放在账户层面上的，但互联网模式下，一个用户有多个资金账户，为了用户体验，把这些放在了用户层面上了，就如同支付密码放在用户层面上一样。</p>
<p><strong>商户</strong></p>
<p>商户是企业客户的一个业务影子，或是看成资金账户分组的一个手段。商户是客户一个外围业务，如果把它看成用户平级层面也是可以的，即：此商户所有业务产生的资金进入到一个分类资金账户里。不论怎么说，一个企业不论开多少个商户，每个商户又开通多少个资金账户，都改变不了资金账户的归属关系，它是现实客户这个实体的。</p>
<h4>账户</h4>
<p>账户的概念起源于金融业，只是一个客户存放资金的实体，目的是为选择的产品付费。一个客户可以拥有一个账户也可以拥有多个账户，账户上的资金可以为客户本人的用户付费，也可以为其他客户的用户付费，这种付费关系需要一个付费规则进行关联。</p>
<p>既然账户关系到付费规则，必然会引出账单的概念。一般来首先要生成用户账单，账单应该归属于用户。</p>
<p>账单分为两级，客户账单和用户账单：</p>
<ul>
<li>客户账单是根据用户账单按照规则进行简单的算术加和得到的。</li>
<li>用户账单可以进一步细分为账单项，账单项是为客户打印账单提供清晰明了的消费明细。</li>
</ul>
<p>账单应当归属于用户，为客户提供的账单应当以产品为单元来生成账单，一般的消费习惯都是以产品为单元来付费；但同时也应该生成客户账单，如果一个客户选择了运营商的多个产品，那么客户如果需要一个所有产品的账单，运营商应当提供，同时集团客户需要一个集团所有客户的消费明细，也需要有一个集团客户账单。</p>
<p>用户和账户的映射关系，主要就是销账规则。销账流程中处理模型应当也是按照用户的账单来销账，而不是按照客户账单，客户的账单应当只是用户账单的简单算术运算的得到的账单，只提供打印。</p>
<p>客户和账户应当有一个归属的对应规则，该规则应当是一种归属关系，个人账户应该归属于个人客户，集团账户应当归属于集团客户。但这只是一种归属关系，而没有付费关系，账户可以跨客户为几个用户付费，也可以为单个用户账单的某个账目付费。</p>
<p>产品在市场提供时难免会遇到，产品的某项子功能的交叉优惠，这种交叉优惠，应当打包成为一个产品。在具体的系统模型中的体现就是增加一个用户，并赋予一定的资费，同时指定一个账户来为其销账，就统一了整个模型。</p>
<p>账户的生命周期：</p>
<p><img src="https://www.biaodianfu.com/wp-content/uploads/2020/09/account.png" alt=""></p>
<p><strong>账户建模</strong></p>
<p>在支付系统中，账户的建模，主要是从如下几个方面来考虑：</p>
<ul>
<li>交易的需求，比如检查账户是否被锁定、余额是否足够、是否有效等。</li>
<li>记账的需求，按照公司会计需求记录账户上的所有行为，包括支出、充值、转账等。</li>
<li>对账的需求，包括和支付渠道、商户、个人的对账需求，核对交易和账户余额是否正确。</li>
<li>风控的需求，如反洗钱、反欺诈等，都需要依赖于账户体系来提供核心数据。</li>
<li>信用的需求，对用户、资产、商户等主体进行信用评估时，也需要依赖账户体系来提供的核心数据。</li>
</ul>
<p>这五个需求，按照其设计的优先级，也是从支付、记账、对账、风控来进行。支付系统根据其发展所处的阶段，逐步将新增需求纳入设计中。</p>
<p>根据业务需要，可以设置多种账户，如支付账户、预付卡账户、代扣账户、零钱账户、结算账户等。一般来说电商系统中涉及的账户类型有：</p>
<ul>
<li>虚拟币账号：用户和使用虚拟币的商户都需要建立虚拟币账户。</li>
<li>代扣账号： 用来支持订阅类型的定期代扣；</li>
<li>零钱账号：即电商的内部账号，用户、商户、清算单位需要建立零钱账户</li>
<li>第三方支付账号：用户在第三方支付机构建立的账户。</li>
<li>银行卡账号：用户的银行卡信息，每个卡对应一个账户。</li>
<li>结算账号：用来支持和第三方支付公司、银行进行结算用。 第三方支付需要为每个商户号建立结算账号；银行需要为借记卡、贷记卡分别建立结算账号（有必要吗？银行卡直连时使用）。</li>
<li>代扣代缴账户：用来支持代扣税款业务。</li>
</ul>
<p>注意，有些第三方信息是不能保存的，如信用卡的CV号等。</p>
<h3>三层身份模型</h3>
<p>从使用层面，三户模型更加适合交易类网站，三层身份模型可能更加适合社交性质的网站。三层身份模型将用户分层三个层次，分别为：账户标识符，登录标识符和公开标识符。翻译成大白话可以是：账户ID、登陆账号、昵称。</p>
<p><img src="https://www.biaodianfu.com/wp-content/uploads/2020/09/the-tripartite-identity-pattern.gif" alt=""></p>
<h4>账户标识符（DB Key）</h4>
<p>从软件工程的角度，需要在数据库中存在一个用户标识(key)来记录每个用户的记录。这个用户标识可能会被用在Cookies或者URL中，这个账户标识符必须是永久的、唯一的。通常是由系统自动生成的一个ID，这个ID不受用户的控制，从用户角度这个标识符应该是不不可见或至少是惰性的，这个标识符不应该与一些公共名称，比如手机号或邮箱。</p>
<h4>登录标识符（会话认证）</h4>
<p>在创建与账户标识符关联的有效会话（Session）时，登陆标识符时必须要的，他们用来从服务中获取授权。通常由唯一的账号/密码对表示（这里的账号可以是邮箱或手机号，也可以是用户选择的用户名）。注意，账户/密码并不是一定需要存在的，比如通过oAuth形式的授权登陆（类似微信登陆、微博登陆等）。</p>
<p>将登陆标识符与账户标识符分开，可以使得用户更加容易的改变登陆方式。由于账户标识符不需要更改，因此可以避免更换登陆方式或登陆账号带来的数据迁移问题。最重要的是，可以提供多个不同登陆标识符附加到单个账户上，从而可以允许服务聚合从多个身份供应商收集的信息。（如授权获得微信或微博的个人信息）</p>
<h4>公开标识符（社会标识）</h4>
<p>与账户标识符和登陆标识符不同，公开标识符标识用户希望如何被服务商的其他用户感知。在线用户的公共标识符通常是复合对象：照片，昵称，可能还有年龄，性别和位置。它为任何观众提供了足够的信息，可以快速解读个人背景。公共标识符通常链接到详细的用户配置文件，其中可以进一步识别身份。公开标识符在某些情况下需要唯一（比如类似微博的@功能），有时是不需要唯一的（如微信的昵称）。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ab9f9bc568942ddd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"CEV2RmJ4qYe381pMG-_gT\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"domain\",\"%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%B8%89%E5%B1%82%E8%BA%AB%E4%BB%BD%E6%A8%A1%E5%9E%8B\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/domain/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%B8%89%E5%B1%82%E8%BA%AB%E4%BB%BD%E6%A8%A1%E5%9E%8B\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ab9f9bc568942ddd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/domain/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%B8%89%E5%B1%82%E8%BA%AB%E4%BB%BD%E6%A8%A1%E5%9E%8B\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"zbGau_h0VPu0eqF6LTGFyv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n19:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T3a5b,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e用户系统设计:三户模型\u0026amp;三层身份模型\u003c/h1\u003e\n\u003ch3\u003e三户模型\u003c/h3\u003e\n\u003cp\u003e三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建立用户和账户。这三个是相互关联的实体，这种关联只是一个归属和映射的关系，而三个实体本身是相互独立的，分别是体现完全不同的几个域的信息，\u003cstrong\u003e客户\u003c/strong\u003e是体现了\u003cstrong\u003e社会域\u003c/strong\u003e的信息，\u003cstrong\u003e用户\u003c/strong\u003e体现了\u003cstrong\u003e业务域\u003c/strong\u003e的信息，\u003cstrong\u003e账户\u003c/strong\u003e体现的是\u003cstrong\u003e资金域\u003c/strong\u003e的信息。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户（customer）：是指客户（自然人、公司、集团公司）的基本资料信息。例如自然人的姓名、手机号、身份证、邮箱地址等等；公司的五证一照、行业、联系人、网站地址、通讯地址等等。如无特指，一般客户指个人客户。\u003c/li\u003e\n\u003cli\u003e用户（user）：指客户在系统的登录账号信息，包括账号、密码、人员权限、角色等等。对应的，法人客户在系统中注册后，被称之为商户。\u003c/li\u003e\n\u003cli\u003e账户（account）：指客户在系统的虚拟账户，主要与交易记账相关。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://www.biaodianfu.com/wp-content/uploads/2020/09/customer-user-account.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e以电信业务为例：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户：人\u003c/li\u003e\n\u003cli\u003e用户：电信产品的实例表现\u003c/li\u003e\n\u003cli\u003e账户：付费的账号\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e假设张三是中国典电信的一个客户，张三办理了一个手机SIM卡和一个宽带业务。其中手机SIM卡和宽带业务分别作为一个用户存在（电信产品实例）。下面还有一个账户的概念，账户是用户进行付费的。一般情况，一个用户只有一个账户，以上例为例，张三有一个账户，为手机号和宽带付费。当然，有的人可能存在多个账户，例如手机号是一个账户，宽带是是一个账户。\u003c/p\u003e\n\u003cp\u003e总结一下，一个客户（张三）可以有多个用户（一个手机号和一个宽带业务），但一个用户只能归属于一个客户。一个客户可以用多个账户，但一个账户也只能归属于一个客户。账户和用户的关系比较复杂，一般情况，一个账户可以给多个用户付费，但也允许，一个用户的不同费用由多个账户付费，所以账户和用户之间是多对多的关系。\u003c/p\u003e\n\u003ch4\u003e客户\u003c/h4\u003e\n\u003cp\u003e客户是一个社会化的概念，一个自然人或一个法人就称之为一个客户，法人客户既可以是一个企业，也可以是与这个企业、集团相关的自然人客户，可以称之为一个集团客户组。\u003c/p\u003e\n\u003cp\u003e客户可分为个人客户，企业客户。一个客户可以包含多个用户，客户通过唯一的客户标识来确定。客户描述一个客户的自然属性，客户可以和用户一一对应，也可以和用户一对多。\u003cstrong\u003e即使不使用业务，也可能存在客户\u003c/strong\u003e，因为客户是自然存在的。客户信息包含客户名，地址，邮政编码，性别，年龄，职业，证件号码等等信息，是自然存在的信息。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e个人客户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在互联网系统中，一般是用户先注册，先有用户，然后补充客户身份信息。也就是客户身份信息是在运行过程中逐步完善的。在电信体系或银行体系，客户的主键通常是证件号（如身份证），将所有相同的证件视为同一客户。在互联网行业通常是将手机号识别为主键（\u003cstrong\u003e注意：手机号有注销、更换等问题\u003c/strong\u003e），这里面就有一个关键业务，既然相同证件的证件号或手机号会识别成一个客户，当相同的证件号或手机号进入系统时，系统是如何处理的？当然是合成一个了，这个过程叫做客户归并，即：将客户合成同一个客户号的过程，我们称为归并。归并是有风险的，所以需要一些\u003cstrong\u003e鉴权手段\u003c/strong\u003e来处理。\u003c/p\u003e\n\u003cp\u003e在互联网应用中，一个系统中的生命周期如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://www.biaodianfu.com/wp-content/uploads/2020/09/customer.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e正常的互联网站点一般只有正常和禁入2种状态，银行业可能还会包含冻结和止付状态（以司法协查为例，某个客户被协查以致账户冻结，需要冻结该客户下所有资金账户，这些账户都被止付）。\u003c/p\u003e\n\u003cp\u003e注意在这个流程中\u003cstrong\u003e没有销户的状态\u003c/strong\u003e。 这是为了\u003cstrong\u003e支持历史业务的处理\u003c/strong\u003e，客户一般不做销户。 此外这个流程和支付账户的流程比较类似，这是为了方便在客户层面做账户控制。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e存在问题，用户手机号更换带来的身份识别不能解决。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e企业客户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e企业客户相对个人客户来说比较复杂点，但三户模型仍然适用。企业客户是一个组织，其账户必然是组织授权内部人员去操作。但是这个操作人，同个人客户一样，只是系统的使用者，即用户。企业的资金比较大，并且有严格的业务流程，所以在系统使用上，一般是多个用户操作一个或多个资金账户。这种关系本身来说，也是一种授权关系，企业授权相应的用户来操作特定的资金账户，只不过为了管理方便，可以引入角色管理机制来实现。对于支付公司来说，企业客户通常都是发展商户过程中产生的。企业客户的识别同个人客户识别也是一样的，通过企业证件来统一识别。相同的企业证件号归并到同一个企业客户下面。建立企业客户的好处在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有些企业本身只开通了企业服务业务，而不开通商户服务\u003c/li\u003e\n\u003cli\u003e一个企业可以开通多个商户，企业客户是这些多个商户的统计口径\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e用户\u003c/h4\u003e\n\u003cp\u003e用户是在产品基础上产生的实体。如果说一个客户使用了多个产品，那么一个客户就会对应好几个用户（即产品）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e个体用户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e用户与资金账户之间我们可以抽象出一种授权关系，凡是授权用户，都可以操作资金账户，当然，这种授权包括客户自己的用户。用户的建立比较简单，一般自助注册后就可以生成用户实体了。\u003c/p\u003e\n\u003cp\u003e用户的生命周期如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://www.biaodianfu.com/wp-content/uploads/2020/09/user.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e如果用户想要销户，收到销户申请后，不能直接销户，客户是通过用户来进行资金账户的管理与操作的，所以，此时有个确认过程，要求各业务系统确认此用户下的所有账户是否可以销户，如果没有问题，先销资金账户，当用户下的所有资金账户都销户完毕，再销用户，用户销户完成后，会释放出此用户占用的资源，如注册手机号。\u003c/p\u003e\n\u003cp\u003e在互联网环境比较多的场景是用户更新手机号，用户更新手机号的时候涉及到的两个手机号都需要验证。需要注意的是， 更新手机号需要涉及到更新客户ID。\u003c/p\u003e\n\u003cp\u003e用户除了生命周期状态外，还有一个管理状态，比如锁定，从现实模型中来说，这个是不应该放在用户层面的而是放在账户层面上的，但互联网模式下，一个用户有多个资金账户，为了用户体验，把这些放在了用户层面上了，就如同支付密码放在用户层面上一样。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e商户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e商户是企业客户的一个业务影子，或是看成资金账户分组的一个手段。商户是客户一个外围业务，如果把它看成用户平级层面也是可以的，即：此商户所有业务产生的资金进入到一个分类资金账户里。不论怎么说，一个企业不论开多少个商户，每个商户又开通多少个资金账户，都改变不了资金账户的归属关系，它是现实客户这个实体的。\u003c/p\u003e\n\u003ch4\u003e账户\u003c/h4\u003e\n\u003cp\u003e账户的概念起源于金融业，只是一个客户存放资金的实体，目的是为选择的产品付费。一个客户可以拥有一个账户也可以拥有多个账户，账户上的资金可以为客户本人的用户付费，也可以为其他客户的用户付费，这种付费关系需要一个付费规则进行关联。\u003c/p\u003e\n\u003cp\u003e既然账户关系到付费规则，必然会引出账单的概念。一般来首先要生成用户账单，账单应该归属于用户。\u003c/p\u003e\n\u003cp\u003e账单分为两级，客户账单和用户账单：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户账单是根据用户账单按照规则进行简单的算术加和得到的。\u003c/li\u003e\n\u003cli\u003e用户账单可以进一步细分为账单项，账单项是为客户打印账单提供清晰明了的消费明细。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e账单应当归属于用户，为客户提供的账单应当以产品为单元来生成账单，一般的消费习惯都是以产品为单元来付费；但同时也应该生成客户账单，如果一个客户选择了运营商的多个产品，那么客户如果需要一个所有产品的账单，运营商应当提供，同时集团客户需要一个集团所有客户的消费明细，也需要有一个集团客户账单。\u003c/p\u003e\n\u003cp\u003e用户和账户的映射关系，主要就是销账规则。销账流程中处理模型应当也是按照用户的账单来销账，而不是按照客户账单，客户的账单应当只是用户账单的简单算术运算的得到的账单，只提供打印。\u003c/p\u003e\n\u003cp\u003e客户和账户应当有一个归属的对应规则，该规则应当是一种归属关系，个人账户应该归属于个人客户，集团账户应当归属于集团客户。但这只是一种归属关系，而没有付费关系，账户可以跨客户为几个用户付费，也可以为单个用户账单的某个账目付费。\u003c/p\u003e\n\u003cp\u003e产品在市场提供时难免会遇到，产品的某项子功能的交叉优惠，这种交叉优惠，应当打包成为一个产品。在具体的系统模型中的体现就是增加一个用户，并赋予一定的资费，同时指定一个账户来为其销账，就统一了整个模型。\u003c/p\u003e\n\u003cp\u003e账户的生命周期：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://www.biaodianfu.com/wp-content/uploads/2020/09/account.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e账户建模\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在支付系统中，账户的建模，主要是从如下几个方面来考虑：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e交易的需求，比如检查账户是否被锁定、余额是否足够、是否有效等。\u003c/li\u003e\n\u003cli\u003e记账的需求，按照公司会计需求记录账户上的所有行为，包括支出、充值、转账等。\u003c/li\u003e\n\u003cli\u003e对账的需求，包括和支付渠道、商户、个人的对账需求，核对交易和账户余额是否正确。\u003c/li\u003e\n\u003cli\u003e风控的需求，如反洗钱、反欺诈等，都需要依赖于账户体系来提供核心数据。\u003c/li\u003e\n\u003cli\u003e信用的需求，对用户、资产、商户等主体进行信用评估时，也需要依赖账户体系来提供的核心数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这五个需求，按照其设计的优先级，也是从支付、记账、对账、风控来进行。支付系统根据其发展所处的阶段，逐步将新增需求纳入设计中。\u003c/p\u003e\n\u003cp\u003e根据业务需要，可以设置多种账户，如支付账户、预付卡账户、代扣账户、零钱账户、结算账户等。一般来说电商系统中涉及的账户类型有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e虚拟币账号：用户和使用虚拟币的商户都需要建立虚拟币账户。\u003c/li\u003e\n\u003cli\u003e代扣账号： 用来支持订阅类型的定期代扣；\u003c/li\u003e\n\u003cli\u003e零钱账号：即电商的内部账号，用户、商户、清算单位需要建立零钱账户\u003c/li\u003e\n\u003cli\u003e第三方支付账号：用户在第三方支付机构建立的账户。\u003c/li\u003e\n\u003cli\u003e银行卡账号：用户的银行卡信息，每个卡对应一个账户。\u003c/li\u003e\n\u003cli\u003e结算账号：用来支持和第三方支付公司、银行进行结算用。 第三方支付需要为每个商户号建立结算账号；银行需要为借记卡、贷记卡分别建立结算账号（有必要吗？银行卡直连时使用）。\u003c/li\u003e\n\u003cli\u003e代扣代缴账户：用来支持代扣税款业务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意，有些第三方信息是不能保存的，如信用卡的CV号等。\u003c/p\u003e\n\u003ch3\u003e三层身份模型\u003c/h3\u003e\n\u003cp\u003e从使用层面，三户模型更加适合交易类网站，三层身份模型可能更加适合社交性质的网站。三层身份模型将用户分层三个层次，分别为：账户标识符，登录标识符和公开标识符。翻译成大白话可以是：账户ID、登陆账号、昵称。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://www.biaodianfu.com/wp-content/uploads/2020/09/the-tripartite-identity-pattern.gif\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch4\u003e账户标识符（DB Key）\u003c/h4\u003e\n\u003cp\u003e从软件工程的角度，需要在数据库中存在一个用户标识(key)来记录每个用户的记录。这个用户标识可能会被用在Cookies或者URL中，这个账户标识符必须是永久的、唯一的。通常是由系统自动生成的一个ID，这个ID不受用户的控制，从用户角度这个标识符应该是不不可见或至少是惰性的，这个标识符不应该与一些公共名称，比如手机号或邮箱。\u003c/p\u003e\n\u003ch4\u003e登录标识符（会话认证）\u003c/h4\u003e\n\u003cp\u003e在创建与账户标识符关联的有效会话（Session）时，登陆标识符时必须要的，他们用来从服务中获取授权。通常由唯一的账号/密码对表示（这里的账号可以是邮箱或手机号，也可以是用户选择的用户名）。注意，账户/密码并不是一定需要存在的，比如通过oAuth形式的授权登陆（类似微信登陆、微博登陆等）。\u003c/p\u003e\n\u003cp\u003e将登陆标识符与账户标识符分开，可以使得用户更加容易的改变登陆方式。由于账户标识符不需要更改，因此可以避免更换登陆方式或登陆账号带来的数据迁移问题。最重要的是，可以提供多个不同登陆标识符附加到单个账户上，从而可以允许服务聚合从多个身份供应商收集的信息。（如授权获得微信或微博的个人信息）\u003c/p\u003e\n\u003ch4\u003e公开标识符（社会标识）\u003c/h4\u003e\n\u003cp\u003e与账户标识符和登陆标识符不同，公开标识符标识用户希望如何被服务商的其他用户感知。在线用户的公共标识符通常是复合对象：照片，昵称，可能还有年龄，性别和位置。它为任何观众提供了足够的信息，可以快速解读个人背景。公共标识符通常链接到详细的用户配置文件，其中可以进一步识别身份。公开标识符在某些情况下需要唯一（比如类似微博的@功能），有时是不需要唯一的（如微信的昵称）。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T49d8,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eSpring Boot启动原理与运行时动态扩展机制\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSpring Boot 的\u0026quot;约定优于配置\u0026quot;背后是一套精密的启动和扩展机制。理解 \u003ccode\u003eSpringApplication\u003c/code\u003e 的启动全流程、SPI 加载原理和运行时动态扩展手段，是深入掌握 Spring 生态的关键。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e一、SpringApplication 启动全流程\u003c/h2\u003e\n\u003ch3\u003e1.1 入口分析\u003c/h3\u003e\n\u003cp\u003e一个标准的 Spring Boot 应用入口：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eSpringApplication.run()\u003c/code\u003e 内部分为两步：\u003cstrong\u003e构造 SpringApplication 对象\u003c/strong\u003e + \u003cstrong\u003e执行 run() 方法\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static ConfigurableApplicationContext run(Class\u0026lt;?\u0026gt;[] primarySources, String[] args) {\n    return new SpringApplication(primarySources).run(args);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e1.2 构造阶段：初始化\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eSpringApplication\u003c/code\u003e 构造函数完成四项关键初始化：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic SpringApplication(ResourceLoader resourceLoader, Class\u0026lt;?\u0026gt;... primarySources) {\n    this.primarySources = new LinkedHashSet\u0026lt;\u0026gt;(Arrays.asList(primarySources));\n\n    // 1. 推断应用类型\n    this.webApplicationType = WebApplicationType.deduceFromClasspath();\n\n    // 2. 加载 ApplicationContextInitializer\n    setInitializers(getSpringFactoriesInstances(ApplicationContextInitializer.class));\n\n    // 3. 加载 ApplicationListener\n    setListeners(getSpringFactoriesInstances(ApplicationListener.class));\n\n    // 4. 推断主类\n    this.mainApplicationClass = deduceMainApplicationClass();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e应用类型推断\u003c/strong\u003e（\u003ccode\u003ededuceFromClasspath()\u003c/code\u003e）：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e类型\u003c/th\u003e\n\u003cth\u003e判断依据\u003c/th\u003e\n\u003cth\u003e使用的 ApplicationContext\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSERVLET\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eclasspath 中存在 \u003ccode\u003eServlet\u003c/code\u003e 和 \u003ccode\u003eConfigurableWebApplicationContext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAnnotationConfigServletWebServerApplicationContext\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eREACTIVE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eclasspath 中存在 \u003ccode\u003eDispatcherHandler\u003c/code\u003e 且无 \u003ccode\u003eServlet\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAnnotationConfigReactiveWebServerApplicationContext\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eNONE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e以上条件均不满足\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAnnotationConfigApplicationContext\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e推断逻辑通过 \u003ccode\u003eClassUtils.isPresent()\u003c/code\u003e 探测类是否存在，不实际加载类。\u003c/p\u003e\n\u003ch3\u003e1.3 SPI 机制：spring.factories\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egetSpringFactoriesInstances()\u003c/code\u003e 是 Spring Boot 的核心扩展点，基于 \u003cstrong\u003eSpringFactoriesLoader\u003c/strong\u003e 从 \u003ccode\u003eMETA-INF/spring.factories\u003c/code\u003e 文件中加载实现类。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003e# META-INF/spring.factories 示例\norg.springframework.context.ApplicationContextInitializer=\\\n    com.example.MyInitializer1,\\\n    com.example.MyInitializer2\n\norg.springframework.context.ApplicationListener=\\\n    com.example.MyListener\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e加载流程：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSpringFactoriesLoader.loadFactoryNames(factoryType, classLoader)\n    → 扫描所有 JAR 中的 META-INF/spring.factories\n    → 按 factoryType 过滤\n    → 实例化并排序（@Order）\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这一机制是 Spring Boot \u003cstrong\u003e自动配置\u003c/strong\u003e的基础——\u003ccode\u003espring-boot-autoconfigure.jar\u003c/code\u003e 的 \u003ccode\u003espring.factories\u003c/code\u003e 中声明了所有自动配置类。\u003c/p\u003e\n\u003ch3\u003e1.4 run() 阶段：核心执行流程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic ConfigurableApplicationContext run(String... args) {\n    // 1. 创建 StopWatch 计时\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n\n    // 2. 获取 SpringApplicationRunListeners（通过 spring.factories）\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n\n    // 3. 准备环境（解析配置文件、环境变量、命令行参数）\n    ConfigurableEnvironment environment = prepareEnvironment(listeners, args);\n\n    // 4. 打印 Banner\n    printBanner(environment);\n\n    // 5. 创建 ApplicationContext\n    ConfigurableApplicationContext context = createApplicationContext();\n\n    // 6. 准备 Context（应用 Initializer、注册主类为 Bean）\n    prepareContext(context, environment, listeners, args);\n\n    // 7. 刷新 Context（核心：触发自动配置、Bean 实例化）\n    refreshContext(context);\n\n    // 8. 后置处理\n    afterRefresh(context, args);\n\n    stopWatch.stop();\n    listeners.started(context);\n\n    // 9. 执行 CommandLineRunner / ApplicationRunner\n    callRunners(context, args);\n\n    listeners.running(context);\n    return context;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e关键步骤详解\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e步骤\u003c/th\u003e\n\u003cth\u003e核心动作\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eprepareEnvironment\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并配置源\u003c/td\u003e\n\u003ctd\u003e系统属性 → 环境变量 → application.yml → 命令行参数\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecreateApplicationContext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e根据应用类型创建 Context\u003c/td\u003e\n\u003ctd\u003eServlet / Reactive / None\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eprepareContext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e执行所有 \u003ccode\u003eApplicationContextInitializer\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e在 \u003ccode\u003erefresh()\u003c/code\u003e 之前的扩展点\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003erefreshContext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e调用 \u003ccode\u003eAbstractApplicationContext.refresh()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e触发 BeanDefinition 加载、自动配置、Bean 实例化\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecallRunners\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e执行 \u003ccode\u003eCommandLineRunner\u003c/code\u003e / \u003ccode\u003eApplicationRunner\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e应用启动后的初始化逻辑\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e1.5 自动配置原理\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@SpringBootApplication\u003c/code\u003e 是三个注解的组合：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootConfiguration    // 等同于 @Configuration\n@EnableAutoConfiguration    // 启用自动配置\n@ComponentScan              // 包扫描\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e@EnableAutoConfiguration\u003c/code\u003e 通过 \u003ccode\u003e@Import(AutoConfigurationImportSelector.class)\u003c/code\u003e 触发自动配置类的加载：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAutoConfigurationImportSelector\n    → SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class)\n    → 从 spring.factories 中读取所有自动配置类\n    → 根据 @Conditional 系列注解过滤\n    → 注册为 BeanDefinition\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e@Conditional 条件注解\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e注解\u003c/th\u003e\n\u003cth\u003e生效条件\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@ConditionalOnClass\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eclasspath 中存在指定类\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@ConditionalOnMissingClass\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eclasspath 中不存在指定类\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@ConditionalOnBean\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e容器中存在指定 Bean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@ConditionalOnMissingBean\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e容器中不存在指定 Bean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@ConditionalOnProperty\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e配置属性满足指定条件\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e@ConditionalOnWebApplication\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e当前是 Web 应用\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这就是\u0026quot;约定优于配置\u0026quot;的实现原理——当你引入 \u003ccode\u003espring-boot-starter-web\u003c/code\u003e 时，classpath 中出现了 \u003ccode\u003eDispatcherServlet\u003c/code\u003e，\u003ccode\u003e@ConditionalOnClass(DispatcherServlet.class)\u003c/code\u003e 的自动配置类自动生效，无需手动配置。\u003c/p\u003e\n\u003ch2\u003e二、运行时动态 Bean 注册\u003c/h2\u003e\n\u003cp\u003eSpring 容器的 Bean 注册通常在启动阶段完成（XML、\u003ccode\u003e@Component\u003c/code\u003e、\u003ccode\u003e@Bean\u003c/code\u003e）。但某些场景需要在运行时动态注册 Bean。\u003c/p\u003e\n\u003ch3\u003e2.1 BeanDefinitionRegistryPostProcessor\u003c/h3\u003e\n\u003cp\u003e这是 Spring 提供的\u003cstrong\u003e最规范的动态注册扩展点\u003c/strong\u003e，在所有常规 BeanDefinition 加载完成后、Bean 实例化之前执行。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class DynamicBeanRegistrar implements BeanDefinitionRegistryPostProcessor {\n\n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n        // 根据配置决定注册哪个实现\n        String implType = System.getProperty(\u0026quot;dao.type\u0026quot;, \u0026quot;jpa\u0026quot;);\n\n        GenericBeanDefinition definition = new GenericBeanDefinition();\n        if (\u0026quot;mybatis\u0026quot;.equals(implType)) {\n            definition.setBeanClass(MyBatisUserDao.class);\n        } else {\n            definition.setBeanClass(JpaUserDao.class);\n        }\n        definition.setScope(BeanDefinition.SCOPE_SINGLETON);\n        definition.setLazyInit(false);\n        definition.setAutowireCandidate(true);\n\n        registry.registerBeanDefinition(\u0026quot;userDao\u0026quot;, definition);\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory factory) {\n        // 可选：对 BeanFactory 进行后处理\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e适用场景\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e根据配置动态选择接口实现（如数据源、DAO 层实现）\u003c/li\u003e\n\u003cli\u003e框架内部根据元数据批量注册 Bean\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2.2 DefaultListableBeanFactory 直接注册\u003c/h3\u003e\n\u003cp\u003e在应用运行过程中（Context 已刷新完成），可以通过 \u003ccode\u003eDefaultListableBeanFactory\u003c/code\u003e 直接注册 Bean：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class RuntimeBeanRegistrar implements ApplicationContextAware {\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public void setApplicationContext(ApplicationContext ctx) {\n        this.applicationContext = ctx;\n    }\n\n    public void registerBean(String name, Class\u0026lt;?\u0026gt; beanClass, Object... constructorArgs) {\n        DefaultListableBeanFactory factory =\n            (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext)\n                .getBeanFactory();\n\n        BeanDefinitionBuilder builder = BeanDefinitionBuilder\n            .genericBeanDefinition(beanClass);\n\n        // 设置属性\n        builder.addPropertyValue(\u0026quot;name\u0026quot;, \u0026quot;dynamicValue\u0026quot;);\n        builder.addPropertyReference(\u0026quot;dependency\u0026quot;, \u0026quot;existingBean\u0026quot;);\n        builder.setScope(BeanDefinition.SCOPE_SINGLETON);\n\n        factory.registerBeanDefinition(name, builder.getBeanDefinition());\n    }\n\n    public void removeBean(String name) {\n        DefaultListableBeanFactory factory =\n            (DefaultListableBeanFactory) ((ConfigurableApplicationContext) applicationContext)\n                .getBeanFactory();\n        factory.removeBeanDefinition(name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e注意事项\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e运行时注册的 Bean 不会触发已完成的 \u003ccode\u003eBeanPostProcessor\u003c/code\u003e 链路\u003c/li\u003e\n\u003cli\u003e如需完整的生命周期管理，应确保在注册后手动触发初始化\u003c/li\u003e\n\u003cli\u003e移除 Bean 时，已注入该 Bean 的其他对象不会自动更新引用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2.3 两种方式的对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003eBeanDefinitionRegistryPostProcessor\u003c/th\u003e\n\u003cth\u003eDefaultListableBeanFactory\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e执行时机\u003c/td\u003e\n\u003ctd\u003e启动阶段（refresh 之前）\u003c/td\u003e\n\u003ctd\u003e运行时（任意时刻）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e生命周期\u003c/td\u003e\n\u003ctd\u003e完整（所有 PostProcessor 均生效）\u003c/td\u003e\n\u003ctd\u003e不完整（需手动管理）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全性\u003c/td\u003e\n\u003ctd\u003e高（Spring 框架保证）\u003c/td\u003e\n\u003ctd\u003e中（需自行处理线程安全和依赖）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e适用场景\u003c/td\u003e\n\u003ctd\u003e启动时根据条件选择实现\u003c/td\u003e\n\u003ctd\u003e运行时插件化加载\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e三、Spring Cloud 热更新机制\u003c/h2\u003e\n\u003cp\u003eSpring Cloud 的热更新允许在不重启应用的情况下，动态刷新配置和重建 Bean。\u003c/p\u003e\n\u003ch3\u003e3.1 触发方式\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方式\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e/actuator/refresh\u003c/code\u003e 端点\u003c/td\u003e\n\u003ctd\u003e手动 POST 触发\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud Bus\u003c/td\u003e\n\u003ctd\u003e通过 MQ 广播 \u003ccode\u003eRefreshRemoteApplicationEvent\u003c/code\u003e，集群统一刷新\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud Config Monitor\u003c/td\u003e\n\u003ctd\u003e配置仓库（Git）的 Webhook 自动触发\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e3.2 ContextRefresher 执行流程\u003c/h3\u003e\n\u003cp\u003e当收到刷新事件时，\u003ccode\u003eContextRefresher.refresh()\u003c/code\u003e 编排整个刷新过程：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic synchronized Set\u0026lt;String\u0026gt; refresh() {\n    // 1. 刷新 Environment：重新加载配置源\n    Set\u0026lt;String\u0026gt; keys = refreshEnvironment();\n\n    // 2. 刷新 RefreshScope：销毁并重建作用域内的 Bean\n    this.scope.refreshAll();\n\n    return keys;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eStep 1：refreshEnvironment()\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1. 提取当前 Environment 的所有属性源（排除系统属性、环境变量等标准源）\n2. 创建一个临时的 SpringApplication（仅加载 BootstrapApplicationListener 和\n   ConfigFileApplicationListener）\n3. 运行临时 Application 以重新加载配置文件\n4. 将新的属性源替换到当前 Environment\n5. 对比新旧属性，返回变更的 Key 集合\n6. 发布 EnvironmentChangeEvent\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eStep 2：EnvironmentChangeEvent 的处理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eEnvironmentChangeEvent\u003c/code\u003e 触发两个动作：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e处理器\u003c/th\u003e\n\u003cth\u003e动作\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eConfigurationPropertiesRebinder\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e重新绑定所有 \u003ccode\u003e@ConfigurationProperties\u003c/code\u003e Bean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLoggingRebinder\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e根据新配置重置日志级别\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eConfigurationPropertiesRebinder 的实现\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 简化后的核心逻辑\npublic void rebind(String beanName) {\n    // 1. 获取目标 Bean（处理 CGLIB 代理）\n    Object bean = applicationContext.getBean(beanName);\n    if (AopUtils.isCglibProxy(bean)) {\n        bean = getTargetObject(bean);\n    }\n\n    // 2. 销毁 Bean（触发 @PreDestroy）\n    applicationContext.getAutowireCapableBeanFactory().destroyBean(bean);\n\n    // 3. 重新初始化 Bean（重新绑定属性 + 触发 @PostConstruct）\n    applicationContext.getAutowireCapableBeanFactory().initializeBean(bean, beanName);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003einitializeBean()\u003c/code\u003e 内部执行完整的 Bean 初始化生命周期：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eapplyBeanPostProcessorsBeforeInitialization  → 前置处理\n    → invokeInitMethods（@PostConstruct / InitializingBean.afterPropertiesSet）\n        → applyBeanPostProcessorsAfterInitialization  → 后置处理\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这意味着 \u003ccode\u003e@ConfigurationProperties\u003c/code\u003e Bean 的属性会被重新从 Environment 中绑定，\u003ccode\u003e@PostConstruct\u003c/code\u003e 会重新执行。\u003c/p\u003e\n\u003ch3\u003e3.3 @RefreshScope 原理\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e@RefreshScope\u003c/code\u003e 是 Spring Cloud 提供的一个自定义 Scope，它的核心机制是\u003cstrong\u003e懒初始化 + 缓存\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@RefreshScope\n@Component\npublic class DynamicConfig {\n    @Value(\u0026quot;${app.feature.enabled}\u0026quot;)\n    private boolean featureEnabled;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e原理\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e正常状态：\n  第一次 getBean() → 创建实例 → 缓存在 RefreshScope 的 cache 中\n  后续 getBean()   → 直接返回缓存实例\n\n刷新时（refreshAll）：\n  清空 RefreshScope 的 cache\n  发布 RefreshScopeRefreshedEvent\n  下一次 getBean() → 重新创建实例（读取最新配置）→ 放入缓存\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// RefreshScope 的简化实现\npublic class RefreshScope extends GenericScope {\n    private final Map\u0026lt;String, Object\u0026gt; cache = new ConcurrentHashMap\u0026lt;\u0026gt;();\n\n    @Override\n    public Object get(String name, ObjectFactory\u0026lt;?\u0026gt; objectFactory) {\n        return cache.computeIfAbsent(name, k -\u0026gt; objectFactory.getObject());\n    }\n\n    public void refreshAll() {\n        cache.clear();  // 清空缓存，下次访问时重新创建\n        publishEvent(new RefreshScopeRefreshedEvent());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3.4 @ConfigurationProperties vs @RefreshScope\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e维度\u003c/th\u003e\n\u003cth\u003e@ConfigurationProperties + Rebind\u003c/th\u003e\n\u003cth\u003e@RefreshScope\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e刷新方式\u003c/td\u003e\n\u003ctd\u003e同一实例重新绑定属性\u003c/td\u003e\n\u003ctd\u003e销毁旧实例，创建新实例\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBean 引用\u003c/td\u003e\n\u003ctd\u003e引用不变\u003c/td\u003e\n\u003ctd\u003e通过代理间接引用，引用不变\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e适用场景\u003c/td\u003e\n\u003ctd\u003e配置属性类（结构化绑定）\u003c/td\u003e\n\u003ctd\u003e需要完全重建的 Bean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e开销\u003c/td\u003e\n\u003ctd\u003e低（属性重新绑定）\u003c/td\u003e\n\u003ctd\u003e中（实例重建）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e选择建议\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e纯配置类优先使用 \u003ccode\u003e@ConfigurationProperties\u003c/code\u003e，属性变更时自动 Rebind\u003c/li\u003e\n\u003cli\u003e包含初始化逻辑的 Bean（如连接池、客户端实例），使用 \u003ccode\u003e@RefreshScope\u003c/code\u003e 确保完全重建\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.5 热更新的边界\u003c/h3\u003e\n\u003cp\u003e热更新不是万能的，以下场景无法通过刷新解决：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e场景\u003c/th\u003e\n\u003cth\u003e原因\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e新增自动配置类\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e@Conditional\u003c/code\u003e 只在启动时评估一次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据源切换\u003c/td\u003e\n\u003ctd\u003e连接池需要关闭旧连接、建立新连接，通常需要重启\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eBean 定义变更\u003c/td\u003e\n\u003ctd\u003e新增/删除 Bean 不会被刷新机制处理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第三方库配置\u003c/td\u003e\n\u003ctd\u003e非 Spring 管理的组件不受刷新影响\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eSpring Boot 的启动和扩展机制可以按三个层次理解：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e启动层\u003c/strong\u003e：\u003ccode\u003eSpringApplication\u003c/code\u003e 构造阶段通过 SPI 加载初始化器和监听器，\u003ccode\u003erun()\u003c/code\u003e 阶段通过 \u003ccode\u003e@EnableAutoConfiguration\u003c/code\u003e + \u003ccode\u003e@Conditional\u003c/code\u003e 实现自动配置。核心入口是 \u003ccode\u003espring.factories\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e静态扩展\u003c/strong\u003e：\u003ccode\u003eBeanDefinitionRegistryPostProcessor\u003c/code\u003e 在启动阶段根据运行时条件动态注册 Bean，享有完整的 Bean 生命周期\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e运行时扩展\u003c/strong\u003e：Spring Cloud 的 \u003ccode\u003eContextRefresher\u003c/code\u003e 通过重新加载 Environment + Rebind \u003ccode\u003e@ConfigurationProperties\u003c/code\u003e + 清空 \u003ccode\u003e@RefreshScope\u003c/code\u003e 缓存，实现不停机的配置热更新\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSpring Boot 的设计哲学是\u0026quot;约定优于配置\u0026quot;，但其扩展点设计遵循的是\u0026quot;开放封闭原则\u0026quot;——框架的核心流程是封闭的，但每个关键节点都预留了开放的扩展接口（Initializer、PostProcessor、Listener、Scope）。理解这些扩展点的执行时机和作用范围，是高效使用 Spring 生态的前提。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"18:T508f,"])</script><script>self.__next_f.push([1,"\u003cp\u003e　　账户体系是支付系统的基础，它的设计直接影响整个系统的特性。这里探讨如何针对电子商务系统的账户体系设计。我们从一些基本概念开始入手，了解怎么建模。\u003c/p\u003e\n\u003ch3\u003e1 三户模型 \u003ca href=\"#t1\" id=\"t1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e　　三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建立用户和账户，这三个是相互关联的实体。近年来，金融行业也逐步接受和采用了三户模型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e客户\u003c/strong\u003e，指自然人或者法人。法人一般被称之为企业客户。如无特指，一般客户指个人客户。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e用户\u003c/strong\u003e，指通过注册的方式进入系统，使用系统提供的服务的实体，也称为登录账户，即用户在系统中登录凭证和个人信息。对应的，法人客户在系统中注册后，被称之为商户。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e账户\u003c/strong\u003e，这里特指支付账户，指用户在支付系统中用于交易的资金所有者权益的凭证。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2 客户 \u003ca href=\"#t2\" id=\"t2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.1 个人客户 \u003ca href=\"#t3\" id=\"t3\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　在银行体系中，一般是先有客户，再有用户。早期个人客户通过柜台人员操作注册到银行体系中，柜台人员在处理时，先添加客户信息，再注册账户信息。而在互联网系统中， 一般是用户先注册，先有用户，然后补充客户身份信息。也就是客户身份信息是在运行过程中逐步完善的。在银行柜台，操作人员通过面签或实名方式在系统中建立客户对象。这个对象的业务主键是证件号（如，身份证，假设目前 18 位证件都不重号），所有相同证件我们都视为同一个客户，不论是不是同一个系统中。同一个证件号，不论在工行还是中行，开出来的客户，其实都对应着现实中的同一个人。\u003c/p\u003e\n\u003cp\u003e　　在一个平台体系中，通过系统给客户分配的唯一 ID 号客户 ID 来标识客户对像。这里面就有一个关键业务，既然相同证件都会识别成一个客户，那么当相同的证件号进入系统时，系统是如何处理的？当然是合成一个了，这个过程叫做客户归并，即：\u003cstrong\u003e将相同证件的客户合成同一个客户号的过程，我们称为归并\u003c/strong\u003e。归并是有风险的，所以需要一些鉴权手段来处理。在互联网应用中，一个系统中客户的生命周期如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/business-image_3_1.png\" alt=\"image_3_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e注意在这个流程中没有销户的状态。这是为了支持历史业务的处理，客户一般不做销户。此外这个流程和支付账户的流程比较类似，这是为了方便在客户层面做账户控制。以司法协查为例，某个客户被协查以致账户冻结，需要冻结该客户下所有资金账户，这些账户都被止付。\u003c/p\u003e\n\u003ch4\u003e2.2 企业客户 \u003ca href=\"#t4\" id=\"t4\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　企业客户相对个人客户来说比较复杂点，但三户模型仍然适用。同个人客户一样，企业客户在银行或支付平台开设资金账户，资金账户归属于此客户。企业客户是一个组织，其账户必然是组织授权内部人员去操作。但是这个操作人，同个人客户一样，只是系统的使用者，即用户。企业的资金比较大，并且有严格的业务流程，所以在系统使用上，一般是多个用户操作一个或多个资金账户。这种关系本身来说，也是一种授权关系，企业授权相应的用户来操作特定的资金账户，只不过为了管理方便，可以引入角色管理机制来实现。对于支付公司来说，企业客户通常都是发展商户过程中产生的。企业客户的识别同个人客户识别也是一样的，通过企业证件来统一识别。相同的企业证件号归并到同一个企业客户下面。建立企业客户的好处在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有些企业本身只开通了企业服务业务，而不开通商户服务；\u003c/li\u003e\n\u003cli\u003e一个企业可以开通多个商户，企业客户是这些多个商户的统计口径。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2.3 客户模型 \u003ca href=\"#t5\" id=\"t5\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　对客户的处理，在银行系统中是 CIF 系统或 ECIF 系统，而在互联网模式下，很多都是基于微服务的体系，如何划分微服务，这块要从客户系统对提供的业务主题来分。比如：对于个人客户，客户识别就是一个服务主题，对于一个客户有多种多样的识别方式，除了证件外，还包括生物识别，比如画像、指纹等。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e基本信息也是一个服务主题：包括客户的最基本的信息，姓名、年令、职业等;\u003c/li\u003e\n\u003cli\u003e管理信息也是一个服务主题：比如这个客户的评级、是否集团员工等；\u003c/li\u003e\n\u003cli\u003e客户标签也是一个服务主题：所谓标签，就是从不同的维度来给客户做个标记，一个客户有多个标签，当然，前提是要对标签做好规划；\u003c/li\u003e\n\u003cli\u003e协议管理也是客户的一个服务主题：这里面有授权协议、委托协议等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然，客户还有其它的一些主题，这个要看公司的业务了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/business-image_3_2.png\" alt=\"image_3_2.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e3 用户和商户 \u003ca href=\"#t6\" id=\"t6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e3.1 用户 \u003ca href=\"#t7\" id=\"t7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　用户是账户的操作实体，它是由客户来注册到系统中来的。虽然用户通过客户间接的拥有了资金账户，但这种关系并不是绝对的，比如，一个用户可以授权另一个用户进行账户的余额查询。所以，用户与资金账户之间我们可以抽象出一种授权关系，凡是授权用户，都可以操作资金账户，当然，这种授权包括客户自己的用户。用户的建立比较简单，一般自助注册后就可以生成用户实体了。用户的生命周期如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/business-image_3_3.png\" alt=\"image_3_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e　　如果用户通过简易注册方式生成，这种情况下生成的是个预开户状态的用户，用户需要进一步完善一些信息才能变成正常用户，比如有些平台，在用户第一次登录时要求设置密保问题及答案。如果用户采用标准注册方式注册 的，可以直接成正常状态用户，正常做业务了。\u003c/p\u003e\n\u003cp\u003e　　如果用户想要销户，收到销户申请后，不能直接销户，前面我们说过了，客户是通过用户来进行资金账户的管理与操作的，没有用户，资金账户就有可能没法玩了（假设客户只授权自己的一个而且只有一个用户来操作资金账户），特别是一些账户还存在债务。所以，此时有个确认过程，要求各业务系统确认此用户下的所有账户是否可以销户，如果没有问题，先销资金账户，当用户下的所有资金账户都销户完毕，再销用户，用户销户完成后，会释放出此用户占用的资源，如注册手机号。\u003c/p\u003e\n\u003cp\u003e　　用户除了生命周期状态外，还有一个管理状态，比如冻结，从现实模型中来说，这个是不应该放在用户层面的而是放在资金账户层面上的，但互联网模式下，一个用户有多个资金账户，为了用户体验，把这些放在了用户层面上了，就如同支付密码放在用户层面上一样。\u003c/p\u003e\n\u003ch4\u003e3.2 商户 \u003ca href=\"#t8\" id=\"t8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　商户是企业客户的一个业务影子，或是看成资金账户分组的一个手段。商户是客户一个外围业务，如果把它看成用户平级层面也是可以的，即：此商户所有业务产生的资金进入到一个分类资金账户里。不论怎么说，一个企业不论开多少个商户，每个商户又开通多少个资金账户，都改变不了资金账户的归属关系，它是现实客户这个实体的。对客户的处理，在银行系统中是 CIF 系统或 ECIF 系统，而在互联网模式下，很多都是基于微服务的体系，如何划分微服务，这块要从客户系统对提供的业务主题来分。\u003c/p\u003e\n\u003ch3\u003e4 账户 \u003ca href=\"#t9\" id=\"t9\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e4.1 基本概念 \u003ca href=\"#t10\" id=\"t10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　账户设置，一般是从交易开始的。交易的实现必须有账户的支持，账户是交易的基本构成元素。从支付系统的角度，交易中涉及到的资金流是资金从一个账户流向另一个账户。发起交易的一方，被称之为交易主体，他可以是个人，也可以是一个机构。资金从该主体所拥有的账户中流出。而接收交易的一方，被称为交易对手，他也可以是个人，或者机构。和第三方支付或者金融机构的交易不同，电商系统中，交易还会涉及到渠道。由于电商系统本身并无清结算的资质，所有资金从交易主体到交易对手的账户的流动，在大部分情况下，并没有经过电商系统，而是由电商系统调用支付渠道提供的接口，由它来完成真正的支付过程。当然，渠道也不是活雷锋，在这个过程中，渠道要收取费用。所以，在电商系统中，一次交易会涉及到三个账户： 交易主体账户、交易对手账户以及支付渠道账户。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e支付账户和登录账户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e　　账户体系设计首先要区分两个概念，支付账户和登录账户。这是两个不同业务领域的概念。\u003cstrong\u003e支付账户\u003c/strong\u003e指用户在支付系统中用于交易的资金所有者权益的凭证。\u003cstrong\u003e登录账号\u003c/strong\u003e指用户在系统中的登录的凭证和个人信息。一个用户可以有多个登录账户，一个登录账户可以有多个支付账户，比如零钱账户，储值卡账户等。 一般来说，支付账户不会在多个登录账户之间共用。如果没有特殊说明，下文中的账户，都默认指支付账户。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e会计科目与账户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e　　公司的会计需要对每一笔交易都要做详细的记录，即记账。公司每天都产生大量的交易行为，为了便于管理和统计，一个简单的方法是对交易进行分类，比如食品、带宽、办公用品等等。这个分类，按照公司的规模和业务复杂度，可以有一级、二级、三级或者更多级的结构，这被称之为\u003cstrong\u003e会计科目\u003c/strong\u003e。记账时，除了交易明细，还需要在每个级别上对交易额进行汇总。 一般来说，一级科目上汇总称为\u003cstrong\u003e总帐科目\u003c/strong\u003e，而详细记录称为\u003cstrong\u003e明细科目\u003c/strong\u003e。在电商系统中，由于涉及到的参与方较多，记账也相对复杂，但基本方法也是类似的。电商的参与者可以分为商户、买家和渠道，对这三类参与者，都需要分别建立总帐账户和明细账户。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e内部账户和外部账户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e　　当用户使用银行卡来支付时，电商支付系统需要和银行对接，从用户银行卡所代表的账户上扣除资金。对接了银行，第三方支付等机构的电商支付系统，它需要连接到用户在这些机构的账户来执行扣款或者充值操作，这些账户称为\u003cstrong\u003e外部账户\u003c/strong\u003e。对外部账户，支付系统只能记录账户在本系统的明细以及累计消费额，无法得知账户真正余额。不少电商在玩零钱的概念，也就是让用户充值到零钱，使用的时候就直接从零钱中扣除。这就需要零钱账户。这是电商系统中自己设立的账户，所以也叫\u003cstrong\u003e内部账户\u003c/strong\u003e，可以知道账户的全部消费明细和余额。当然，除了零钱账户，也可以有储值卡账户、信用账户等。那问题来了，什么时候需要建立账户，比如优惠券，需要账户吗？一次消费的储值卡和可以充值的储值卡，需要建立账户吗？这里先埋个雷。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e收款账户和收单账户\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e　　当电商要对接银行时，往往都会被要求开设一个收款账户。用户通过这个银行来支付时，钱就被转到这个账户上。对第三方支付也是一样。收款账户是开设在银行或者第三方支付这边的，即渠道侧。一般来说，渠道每天都可以提供这个账户的交易流水供电商对账用。这样在电商这边，渠道就成为一个收单机构。所以在电商这边，建立这个收款账户对应的对账用的收单账号，用来记录通过这个渠道进行的各项交易流水。\u003c/p\u003e\n\u003ch4\u003e4.2 三类账户 \u003ca href=\"#t11\" id=\"t11\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e　　在设计支付账户系统时，合规是第一要求，和账户相关的法规，最重要的是近期央行发布的三个文件。 从 2013 年 3 月起，国家相继制定一系列“互联网+”计划，推动了移动互联网、大数据等与现代制造业、服务业相结合，引导企业转型，促进经济健康发展。在此背景下，央行相继发布了三个文件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e「\u003cstrong\u003e中国人民银行关于改进个人银行账户服务加强账户管理的通知\u003c/strong\u003e」，银发〔2015〕392 号，2015 年 12 月 25 日发文，正式启动账户分类管理工作。\u003c/li\u003e\n\u003cli\u003e「\u003cstrong\u003e中国人民银行关于落实个人银行账户分类管理制度的通知\u003c/strong\u003e」，银发〔2016〕302 号, 2016 年 11 月 25 日发文，明确了同一个人在同一个银行只能有一个\u003ccode\u003eI\u003c/code\u003e类账户的要求。\u003c/li\u003e\n\u003cli\u003e「\u003cstrong\u003e中国人民银行关于加强支付结算管理防范电信网络新型违法犯罪有关事项的通知\u003c/strong\u003e」，银发〔2016〕261 号， 2016 年 9 月 20 日发文，调整并细化了账户分类及使用要求。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在这些文件中，央行明确对账户实施分类管理的要求。 对这三类账户区别，总结如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/business-image_3_4.png\" alt=\"image_3_4.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e4.3 生命周期 \u003ca href=\"#t12\" id=\"t12\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/business-image_3_5.png\" alt=\"image_3_5.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e账户开立与绑卡\u003c/strong\u003e：同一个人在同一银行只能开立一个\u003ccode\u003eⅠ\u003c/code\u003e类户，\u003ccode\u003eI\u003c/code\u003e类户的设立需要面对面审核，电子渠道开立的\u003ccode\u003eⅡ\u003c/code\u003e类户和\u003ccode\u003eⅢ\u003c/code\u003e类户需绑定银行账户进行验证，不得绑定支付机构账户验证，\u003ccode\u003eⅡ\u003c/code\u003e类户需向绑定账户验证\u003ccode\u003e5\u003c/code\u003e要素（\u003ccode\u003e4\u003c/code\u003e要素：姓名、身份证号、手机号、银行卡号，额外增加账户等级），\u003ccode\u003eⅢ\u003c/code\u003e类户需验证\u003ccode\u003e4\u003c/code\u003e要素，银联支持支持\u003ccode\u003eⅡ\u003c/code\u003e、\u003ccode\u003eⅢ\u003c/code\u003e类账户跨行验证绑定账户信息。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e资金互转\u003c/strong\u003e：对非面对面开立的\u003ccode\u003eⅡ\u003c/code\u003e、\u003ccode\u003eⅢ\u003c/code\u003e类户，限制非绑定账户转入，允许\u003ccode\u003eⅡ\u003c/code\u003e、\u003ccode\u003eⅢ\u003c/code\u003e类户向绑定账户直接借记资金，银联支持\u003ccode\u003eⅡ\u003c/code\u003e、\u003ccode\u003eⅢ\u003c/code\u003e类账户与绑定账户间通过借记和贷记业务实现灵活便捷的资金划付。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e账户使用\u003c/strong\u003e：\u003ccode\u003eI\u003c/code\u003e类账户、对面核实身份的\u003ccode\u003eⅡ\u003c/code\u003e类户可以发行实体银行卡，其他账户不能使用实体银行卡，\u003ccode\u003eⅡ\u003c/code\u003e、\u003ccode\u003eⅢ\u003c/code\u003e类户可以通过云闪付、二维码等支付工具来完成支付，银联支持\u003ccode\u003eⅡ\u003c/code\u003e、\u003ccode\u003eⅢ\u003c/code\u003e类账户便捷生成基于安全芯片、主机卡模拟或二维码等技术的支付工具。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e4.3 账户建模 \u003ca href=\"#t13\" id=\"t13\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e在支付系统中，账户的建模，主要是从如下几个方面来考虑：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e交易的需求\u003c/strong\u003e，比如检查账户是否被锁定、余额是否足够、是否有效等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e记账的需求\u003c/strong\u003e，按照公司会计需求记录账户上的所有行为，包括支出、充值、转账等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e对账的需求\u003c/strong\u003e，包括和支付渠道、商户、个人的对账需求，核对交易和账户余额是否正确。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e风控的需求\u003c/strong\u003e，如反洗钱、反欺诈等，都需要依赖于账户体系来提供核心数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e信用的需求\u003c/strong\u003e，对用户、资产、商户等主体进行信用评估时，也需要依赖账户体系来提供的核心数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这五个需求，按照其设计的优先级，也是从支付、记账、对账、风控来进行。 支付系统根据其发展所处的阶段，逐步将新增需求纳入设计中。说了这么多，目的是为了对账户建模。账户模型是和公司业务密切相关的，公司不同规模，发展的不同阶段需要不同的模型。从交易模型中可以衍生出针对各个角色的账户流水，即明细模型，用于支持对账。根据业务需要，可以设置多种账户，如支付账户、预付卡账户、代扣账户、零钱账户、结算账户等。从类别上来说，这里的账户，一般指总账账户。一般来说电商系统中涉及的账户类型有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e虚拟币账户\u003c/strong\u003e：用户和使用虚拟币的商户都需要建立虚拟币账户；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e代扣账户\u003c/strong\u003e： 用来支持订阅类型的定期代扣；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e零钱账户\u003c/strong\u003e：电商的内部账号，用户、商户、清算单位需要建立零钱账户。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e第三方支付账户\u003c/strong\u003e：用户在第三方支付机构建立的账户。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e银行卡账户\u003c/strong\u003e：用户的银行卡信息，每个卡对应一个账户。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e结算账户\u003c/strong\u003e：用来支持和第三方支付公司、银行进行结算用，第三方支付需要为每个商户号建立结算账户；银行需要为借记卡、贷记卡分别建立结算账户，一般在银行卡直连时使用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e代扣代缴账户\u003c/strong\u003e：用来支持代扣税款业务。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对这些账户，需要设置如下属性，基本属性，包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e账户号或称为账户 ID\u003c/strong\u003e，一般是系统自动生成。特别注意的是，要事先约定好账户 ID 的规则，比如头三位用来表示账户类型，后几位用来表示账户编号等，务必保证根据账号号能够快速确定账户类型，并且保证账户号是不重复的。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e账户名称\u003c/strong\u003e，一般是由用户自己设置的，显示用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e账户使用的货币类型\u003c/strong\u003e，注意虽然一张银行卡可以支持多个币种，实际在内部，还是针对每个币种建立独立的子账户。涉及到多币种的账户，也可以采用类似的建模方案。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e会计科目代码\u003c/strong\u003e，一般是一级会计科目的代码。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e账户控制相关：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e是否允许充值；\u003c/li\u003e\n\u003cli\u003e是否允许提现；\u003c/li\u003e\n\u003cli\u003e是否允许透支；\u003c/li\u003e\n\u003cli\u003e是否允许支付；\u003c/li\u003e\n\u003cli\u003e是否允许转账进入；\u003c/li\u003e\n\u003cli\u003e是否允许转账转出；\u003c/li\u003e\n\u003cli\u003e是否有安全保障；\u003c/li\u003e\n\u003cli\u003e是否激活；\u003c/li\u003e\n\u003cli\u003e是否冻结。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e资金相关：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当前账户余额，等于可用余额+冻结余额；\u003c/li\u003e\n\u003cli\u003e当前账户可用余额；\u003c/li\u003e\n\u003cli\u003e当前账户冻结的余额，冻结余额指在账户上暂不能使用的额度。在支付的时候，往往是先冻结，商品出库后，再实际执行扣款。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e银行卡、第三方支付信息：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第三方实体的 ID；\u003c/li\u003e\n\u003cli\u003e第三方账号，如银行卡号或者在第三方支付的\u003ccode\u003eopen_id\u003c/code\u003e等；\u003c/li\u003e\n\u003cli\u003e第三方的\u003ccode\u003eapp_id\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e账号的失效日期，该账号什么时候失效。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意，有些第三方信息是不能保存的，如用户的账号密码、信用卡的 CV 号等。为了避免账户信息被爬库或者数据库信息意外泄露，一般还需要对敏感字段，如密码等，进行加密保存，甚至保存到另外的表中。更进一步，为了避免账户信息被意外修改，还可以增加一个校验字段，在写入数据时设置该字段，在读取数据时做校验，一旦发现数据有问题，则关闭该账号。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/domain/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"领域建模\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-03-01\",\"children\":\"2024年03月01日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"用户系统设计——三户模型及三层身份模型\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"业务架构\",{\"href\":\"/blog/tag/%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"业务架构\"}],[\"$\",\"$L13\",\"用户系统\",{\"href\":\"/blog/tag/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"用户系统\"}],[\"$\",\"$L13\",\"三户模型\",{\"href\":\"/blog/tag/%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"三户模型\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/middleware/Spring Boot启动原理与运行时动态扩展机制\",\"title\":\"Spring Boot启动原理与运行时动态扩展机制\",\"description\":\"从源码级别剖析Spring Boot的启动全流程，涵盖SpringApplication构造、自动配置加载、SPI扩展机制，以及运行时动态Bean注册与Spring Cloud热更新的实现原理。\",\"pubDate\":\"2024-02-15\",\"tags\":[\"Spring Boot\",\"Spring Cloud\",\"Java\",\"源码分析\",\"动态扩展\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/domain/解析三户模型及建立账户模型\",\"title\":\"解析三户模型及建立账户模型\",\"description\":\"账户体系是支付系统的基础，它的设计直接影响整个系统的特性。这里探讨如何针对电子商务系统的账户体系设计。我们从一些基本概念开始入手，了解怎么建模。三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。\",\"pubDate\":\"2024-03-03\",\"tags\":[\"业务架构\",\"三户模型\",\"账户体系\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"业务架构\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"用户系统\":{\"prev\":null,\"next\":null},\"三户模型\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"}}}]}],[\"$\",\"$L19\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"用户系统设计——三户模型及三层身份模型 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建...\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"用户系统设计——三户模型及三层身份模型\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建...\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-03-01\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"用户系统设计——三户模型及三层身份模型\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"三户模型最早是在增强型电信运营图（Enhanced Telecom Operations Map，eTOM）中提出，在电信行业中得到广泛使用。 三户指客户（Customer）、用户（User）和账户(Account)。eTOM 引入是电信行业营销模型转向“以客户为中心”的理念而产生的成果。围绕客户建...\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
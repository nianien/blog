1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-51baccc14cf1da9e.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
5:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
7:I[59665,[],"OutletBoundary"]
a:I[74911,[],"AsyncMetadataOutlet"]
c:I[59665,[],"ViewportBoundary"]
e:I[59665,[],"MetadataBoundary"]
10:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/0458d6941a120cde.css","style"]
0:{"P":null,"b":"FgU69Zrmn0O2x2maK5qhG","p":"","c":["","blog","engineering","agentic","12-LangChain%20vs%20LangGraph",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/agentic/12-LangChain%20vs%20LangGraph","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/0458d6941a120cde.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8","children":[["$","div",null,{"className":"flex justify-center space-x-6 md:order-2","children":[["$","$L5",null,{"href":"/about","className":"text-gray-600 hover:text-gray-800","children":"关于"}],["$","$L5",null,{"href":"/blog","className":"text-gray-600 hover:text-gray-800","children":"博客"}],["$","$L5",null,{"href":"/contact","className":"text-gray-600 hover:text-gray-800","children":"联系"}]]}],["$","div",null,{"className":"mt-8 md:order-1 md:mt-0","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-600","children":"© 2024 Skyfalling Blog. All rights reserved."}]}]]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/agentic/12-LangChain%20vs%20LangGraph","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","Mx0DVn4J8psyvyWyvysAuv",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Le",null,{"children":"$Lf"}]]}],false]],"m":"$undefined","G":["$10","$undefined"],"s":false,"S":true}
11:"$Sreact.suspense"
12:I[74911,[],"AsyncMetadata"]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
19:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
f:["$","div",null,{"hidden":true,"children":["$","$11",null,{"fallback":null,"children":["$","$L12",null,{"promise":"$@13"}]}]}]
15:Td1b4,<h1>LangChain vs LangGraph: 框架的价值与边界</h1>
<blockquote>
<p>框架是加速器，不是必需品。它替你做了决策——有些决策是好的，有些会在深夜的生产事故中反噬你。</p>
<p>本文是 Agentic 系列第 12 篇。前面 11 篇我们从零构建了 Agent 的每一个组件——控制循环、工具调用、记忆、规划、多 Agent 协作。现在是时候回过头来，以工程师的视角冷静审视：框架提供了什么，隐藏了什么，限制了什么。</p>
</blockquote>
<hr>
<h2>1. 开篇：你真的需要框架吗？</h2>
<p>这个问题的答案不是&quot;需要&quot;或&quot;不需要&quot;，而是&quot;取决于&quot;。</p>
<p>如果你已经读完本系列前 7 篇文章（从控制循环到自研 Runtime），你已经具备了从零构建一个 Agent 系统的能力。你知道 Tool Calling 的 JSON Schema 契约，知道控制循环的 Observe-Think-Plan-Act-Reflect-Update 六阶段，知道 Memory 的短期/长期分层，知道 Planner 的 ReAct 与分层规划。</p>
<p>这时候你面临一个决策：</p>
<pre><code>选择 A：自己实现所有组件，完全掌控
选择 B：使用框架，快速启动，接受其抽象和约束
选择 C：理解框架的实现，选择性地借鉴或使用其部分模块
</code></pre>
<p>大多数成熟的工程团队最终会走向选择 C。但要做到选择 C，你必须先深入理解框架到底在做什么。这就是本文的目的。</p>
<hr>
<h2>2. 为什么需要框架</h2>
<p>框架存在是有道理的。在深入批判之前，先公正地承认它们解决了哪些真实的工程问题。</p>
<h3>2.1 减少重复代码</h3>
<p>每一个 Agent 系统都需要处理以下样板代码：</p>
<ul>
<li><strong>工具注册与调度</strong>：维护一个 <code>tool_name → callable</code> 的映射表，处理参数校验和错误捕获</li>
<li><strong>消息格式管理</strong>：构造和维护 <code>messages</code> 列表，处理不同角色（system/user/assistant/tool）的消息格式</li>
<li><strong>LLM 调用封装</strong>：处理 API 差异（OpenAI、Anthropic、本地模型的接口都不同）、流式输出、重试、降级</li>
<li><strong>状态序列化</strong>：将 Agent 的运行状态持久化到数据库或文件系统</li>
</ul>
<p>这些代码在每个项目中高度相似，但又充满细节（比如 OpenAI 的 <code>tool_calls</code> 和 Anthropic 的 <code>tool_use</code> 格式差异）。框架把这些细节屏蔽了。</p>
<h3>2.2 社区生态</h3>
<p>成熟框架最大的资产不是代码，而是生态：</p>
<ul>
<li><strong>预置 Tool 集成</strong>：搜索引擎（Tavily、SerpAPI）、数据库（SQL、MongoDB）、文件系统、浏览器等，开箱即用</li>
<li><strong>预置 Retriever</strong>：支持各种向量数据库（Pinecone、Weaviate、Chroma、FAISS）的统一接口</li>
<li><strong>文档与教程</strong>：从入门到进阶的学习路径</li>
<li><strong>社区问答</strong>：遇到问题时有人讨论、有 issue 可以搜索</li>
</ul>
<h3>2.3 最佳实践封装</h3>
<p>框架将社区沉淀的设计模式编码为默认行为：</p>
<ul>
<li>ReAct 模式的标准实现</li>
<li>Retrieval-Augmented Generation 的标准 pipeline</li>
<li>对话记忆的滑动窗口管理</li>
<li>工具调用的错误处理和重试</li>
</ul>
<p>对于刚接触 Agent 开发的团队，这些封装可以避免很多常见的设计错误。</p>
<h3>2.4 快速原型验证</h3>
<p>当你需要在两天内验证一个想法是否可行时，框架的价值最大化。10 行代码就能跑通一个带工具调用的 Agent 原型，比从零实现快一个数量级。</p>
<pre><code class="language-python"># 10 行代码验证一个想法——这是框架的甜蜜点
from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.prompts import ChatPromptTemplate
from langchain_community.tools.tavily_search import TavilySearchResults

llm = ChatOpenAI(model=&quot;gpt-4o&quot;)
tools = [TavilySearchResults(max_results=3)]
prompt = ChatPromptTemplate.from_messages([
    (&quot;system&quot;, &quot;You are a helpful research assistant.&quot;),
    (&quot;human&quot;, &quot;{input}&quot;),
    (&quot;placeholder&quot;, &quot;{agent_scratchpad}&quot;),
])
agent = create_tool_calling_agent(llm, tools, prompt)
executor = AgentExecutor(agent=agent, tools=tools, verbose=True)
result = executor.invoke({&quot;input&quot;: &quot;2025 年 AI Agent 领域有哪些重要进展？&quot;})
</code></pre>
<p>这段代码在 5 分钟内就能跑通。但如果你打算把它部署到生产环境——请继续往下读。</p>
<hr>
<h2>3. LangChain 深入分析</h2>
<p>LangChain 是 AI Agent 领域生态最大的框架，也是争议最多的框架。我们不吹不黑，从架构和工程两个维度来分析。</p>
<h3>3.1 核心抽象</h3>
<p>LangChain 的设计围绕四个核心抽象：</p>
<table>
<thead>
<tr>
<th>抽象</th>
<th>本质</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Chain</strong></td>
<td>链式调用</td>
<td>将多个步骤串联为顺序执行的管道</td>
</tr>
<tr>
<td><strong>Agent</strong></td>
<td>工具选择 + 循环</td>
<td>LLM 自主决定调用哪个工具，循环直到完成</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>对话状态管理</td>
<td>维护对话历史，支持滑动窗口、摘要等策略</td>
</tr>
<tr>
<td><strong>Retriever</strong></td>
<td>知识检索</td>
<td>从向量数据库或其他数据源检索相关文档</td>
</tr>
</tbody></table>
<p>这四个抽象之间的关系可以用下图表示：</p>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                    LangChain Architecture                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│   ┌──────────┐    ┌──────────┐    ┌──────────────────┐  │
│   │  Chain   │    │  Agent   │    │  AgentExecutor   │  │
│   │          │    │          │    │  (Control Loop)  │  │
│   │ step1 →  │    │ LLM +   │    │                  │  │
│   │ step2 →  │    │ Tools +  │    │  while not done: │  │
│   │ step3    │    │ Prompt   │    │    plan()        │  │
│   └────┬─────┘    └────┬─────┘    │    execute()     │  │
│        │               │          │    observe()     │  │
│        │               └──────────┤                  │  │
│        │                          └────────┬─────────┘  │
│        │                                   │            │
│   ┌────▼───────────────────────────────────▼─────────┐  │
│   │              LLM Abstraction Layer               │  │
│   │  ChatOpenAI │ ChatAnthropic │ ChatOllama │ ...   │  │
│   └────────────────────┬─────────────────────────────┘  │
│                        │                                │
│   ┌────────────────────▼─────────────────────────────┐  │
│   │                  Memory                          │  │
│   │  ConversationBufferMemory │ ConversationSummary  │  │
│   │  VectorStoreMemory │ EntityMemory │ ...          │  │
│   └──────────────────────────────────────────────────┘  │
│                                                         │
│   ┌──────────────────────────────────────────────────┐  │
│   │                  Retriever                       │  │
│   │  VectorStoreRetriever │ BM25 │ MultiQuery │ ... │  │
│   └──────────────────────────────────────────────────┘  │
│                                                         │
│   ┌──────────────────────────────────────────────────┐  │
│   │                  Tools                           │  │
│   │  Search │ Calculator │ SQL │ FileSystem │ ...    │  │
│   └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3>3.2 代码示例：用 LangChain 实现工具调用 Agent</h3>
<p>下面用 LangChain 实现一个能查天气和创建日程的 Agent，同时标注每一层抽象的存在：</p>
<pre><code class="language-python">from langchain_openai import ChatOpenAI
from langchain.agents import create_tool_calling_agent, AgentExecutor
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.tools import tool

# --- 第 1 层抽象：@tool 装饰器 ---
# LangChain 用装饰器将普通函数包装为 Tool 对象
# 自动从类型注解和 docstring 生成 JSON Schema
@tool
def get_weather(city: str, date: str) -&gt; str:
    &quot;&quot;&quot;获取指定城市在指定日期的天气预报。

    Args:
        city: 城市名称，例如 &quot;北京&quot;
        date: 日期，格式 YYYY-MM-DD
    &quot;&quot;&quot;
    # 实际调用天气 API
    return f&#39;{{&quot;city&quot;: &quot;{city}&quot;, &quot;date&quot;: &quot;{date}&quot;, &quot;temp&quot;: &quot;31°C&quot;, &quot;condition&quot;: &quot;多云转雷阵雨&quot;}}&#39;

@tool
def create_reminder(title: str, time: str, note: str) -&gt; str:
    &quot;&quot;&quot;创建一个日程提醒。

    Args:
        title: 提醒标题
        time: 提醒时间，ISO 8601 格式
        note: 提醒备注内容
    &quot;&quot;&quot;
    return f&#39;{{&quot;status&quot;: &quot;created&quot;, &quot;title&quot;: &quot;{title}&quot;, &quot;time&quot;: &quot;{time}&quot;}}&#39;

# --- 第 2 层抽象：LLM 封装 ---
# ChatOpenAI 封装了 OpenAI API 的调用细节
llm = ChatOpenAI(model=&quot;gpt-4o&quot;, temperature=0)

# --- 第 3 层抽象：Prompt Template ---
# ChatPromptTemplate 管理消息的组装逻辑
prompt = ChatPromptTemplate.from_messages([
    (&quot;system&quot;, &quot;你是一个智能助手，可以查询天气和管理日程。今天是 2025-09-01。&quot;),
    (&quot;human&quot;, &quot;{input}&quot;),
    MessagesPlaceholder(variable_name=&quot;agent_scratchpad&quot;),  # Agent 的工作记忆
])

# --- 第 4 层抽象：Agent 构造 ---
# create_tool_calling_agent 将 LLM + Tools + Prompt 组合为一个 Agent
tools = [get_weather, create_reminder]
agent = create_tool_calling_agent(llm, tools, prompt)

# --- 第 5 层抽象：AgentExecutor ---
# AgentExecutor 提供控制循环：调用 Agent → 执行工具 → 反馈结果 → 循环
executor = AgentExecutor(
    agent=agent,
    tools=tools,
    verbose=True,       # 输出每一步的推理过程
    max_iterations=10,  # 最大循环次数
    handle_parsing_errors=True,  # 自动处理 LLM 输出格式错误
)

# --- 运行 ---
result = executor.invoke({&quot;input&quot;: &quot;帮我查看明天北京的天气，然后创建一个提醒&quot;})
print(result[&quot;output&quot;])
</code></pre>
<p>数一数：从你的业务逻辑（两个工具函数）到最终执行，经过了 <strong>5 层抽象</strong>。每一层都在&quot;帮你做决策&quot;——消息格式、工具注册方式、控制循环策略、错误处理逻辑、输出解析方式。</p>
<h3>3.3 优点</h3>
<p><strong>1. 生态最大、集成最多</strong></p>
<p>截至 2025 年，LangChain 拥有 AI Agent 框架领域最庞大的集成生态：</p>
<ul>
<li>70+ LLM 提供商（OpenAI、Anthropic、Google、Mistral、本地模型等）</li>
<li>50+ 向量数据库</li>
<li>100+ 预置工具</li>
<li>30+ Document Loader（PDF、HTML、CSV、Notion、Confluence 等）</li>
</ul>
<p><strong>2. 社区活跃</strong></p>
<p>GitHub 上最活跃的 AI 项目之一。遇到问题时，StackOverflow 和 GitHub Issues 中大概率能找到讨论。</p>
<p><strong>3. 上手快</strong></p>
<p>对于 PoC（Proof of Concept）和原型验证，LangChain 能让你在几小时内从零到一跑通一个完整的 Agent。</p>
<p><strong>4. 抽象统一</strong></p>
<p>不同 LLM 提供商的 API 差异被封装在统一接口下。切换 OpenAI → Anthropic 只需要换一行代码（理论上如此，实际上有细微差异）。</p>
<h3>3.4 问题</h3>
<p>以下不是主观吐槽，而是在生产环境中反复遇到的工程问题。</p>
<p><strong>问题 1：过度抽象——简单的事情被包了太多层</strong></p>
<p>考虑一个最基本的需求：调用 LLM 并获取结构化输出。</p>
<pre><code class="language-python"># 不用框架：3 行代码，直白清晰
import openai
response = openai.chat.completions.create(
    model=&quot;gpt-4o&quot;,
    messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;分析这段文本的情感&quot;}],
    response_format={&quot;type&quot;: &quot;json_object&quot;},
)
result = json.loads(response.choices[0].message.content)

# 用 LangChain：需要理解 ChatOpenAI、BaseOutputParser、RunnableSequence、
# StrOutputParser vs JsonOutputParser、LCEL 管道语法...
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import JsonOutputParser
from langchain_core.prompts import ChatPromptTemplate

prompt = ChatPromptTemplate.from_template(&quot;分析这段文本的情感: {text}&quot;)
llm = ChatOpenAI(model=&quot;gpt-4o&quot;)
parser = JsonOutputParser()
chain = prompt | llm | parser  # LCEL 管道语法
result = chain.invoke({&quot;text&quot;: &quot;这个产品太棒了&quot;})
</code></pre>
<p>LangChain 版本代码量更多不是问题——问题在于它引入了多个你需要理解的新概念（<code>ChatPromptTemplate</code>、<code>JsonOutputParser</code>、LCEL 管道操作符 <code>|</code>），而这些概念只是在封装原本就很简单的操作。</p>
<p><strong>问题 2：调试困难——错误信息穿过多层封装后难以定位</strong></p>
<p>当 LangChain 链条中的某一环出错时，错误堆栈可能长达 20-30 层，涉及 <code>RunnableSequence</code>、<code>RunnableParallel</code>、<code>RunnableLambda</code> 等内部抽象。你需要在这些框架内部类之间导航，才能找到真正的错误源。</p>
<pre><code># 真实场景中的错误堆栈（简化版）
Traceback:
  langchain_core/runnables/base.py      RunnableSequence.invoke()
  langchain_core/runnables/base.py      RunnableSequence._invoke()
  langchain_core/runnables/base.py      Runnable.invoke()
  langchain_core/runnables/base.py      RunnableLambda.invoke()
  langchain/agents/output_parsers.py    ToolsAgentOutputParser.parse()
  ...
  # 15 层之后...
  你的代码.py                            你的函数()   ← 真正的问题在这里
</code></pre>
<p>在生产环境的 3 AM 报警中，这种调试体验是痛苦的。</p>
<p><strong>问题 3：版本混乱——API 变动频繁</strong></p>
<p>LangChain 在快速迭代中经历了多次重大 API 变更：</p>
<ul>
<li><code>langchain</code> → <code>langchain-core</code> + <code>langchain-community</code> 的包拆分</li>
<li><code>LLMChain</code> → LCEL（LangChain Expression Language）的范式转换</li>
<li><code>initialize_agent</code> → <code>create_tool_calling_agent</code> 的 Agent 创建方式变更</li>
<li>Memory 接口的多次重构</li>
</ul>
<p>6 个月前写的代码，今天大概率跑不通。网上的教程和 StackOverflow 答案大量过时。对于需要长期维护的生产系统，这是一个严重的风险。</p>
<p><strong>问题 4：&quot;Chain&quot; 思维的局限——线性链无法表达复杂的分支和循环</strong></p>
<p>LangChain 的核心抽象是 &quot;Chain&quot;——链式调用。这个模型对于线性流水线（A → B → C）非常优雅，但现实中的 Agent 逻辑往往是非线性的：</p>
<pre><code>线性 Chain 能表达的：

    A ──→ B ──→ C ──→ D
    (检索)  (摘要)  (格式化) (输出)


现实中 Agent 需要的：

    A ──→ B ──→ C ──→ D
    │     │     ▲     │
    │     ├─→ E ─┘     │     ← 条件分支
    │     │             │
    │     └─→ F ──→ G ──┘     ← 并行执行
    │           │
    └───────────┘              ← 循环重试
</code></pre>
<p>LangChain 的 LCEL 可以通过 <code>RunnableBranch</code> 和 <code>RunnableParallel</code> 实现一些分支和并行，但语法变得复杂且不直观。这正是 LangGraph 诞生的原因。</p>
<hr>
<h2>4. LangGraph 深入分析</h2>
<p>LangGraph 是 LangChain 团队推出的下一代框架，核心思想是用<strong>有向图（Directed Graph）</strong> 替代<strong>链（Chain）</strong> 作为基础抽象。这不是一个小改动——它从根本上改变了 Agent 逻辑的表达方式。</p>
<h3>4.1 核心抽象</h3>
<p>LangGraph 的设计围绕四个概念：</p>
<table>
<thead>
<tr>
<th>抽象</th>
<th>本质</th>
<th>对应的计算模型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>State</strong></td>
<td>共享状态对象</td>
<td>状态机的 State</td>
</tr>
<tr>
<td><strong>Node</strong></td>
<td>一个函数</td>
<td>状态机的 State Handler</td>
</tr>
<tr>
<td><strong>Edge</strong></td>
<td>节点间的连接</td>
<td>状态机的 Transition</td>
</tr>
<tr>
<td><strong>Graph</strong></td>
<td>节点和边的组合</td>
<td>有限状态机（FSM）</td>
</tr>
</tbody></table>
<p>核心思想：<strong>Agent 的执行流程就是一个状态机。</strong> 每个节点是一个处理函数，每条边是一个转移条件，整个图定义了 Agent 的所有可能执行路径。</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│                   LangGraph State Machine                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                  Shared State                       │   │
│   │  {messages: [...], tool_results: {...}, plan: [...]} │   │
│   └────────────────────────┬────────────────────────────┘   │
│                            │                                │
│               ┌────────────▼────────────┐                   │
│               │       START             │                   │
│               └────────────┬────────────┘                   │
│                            │                                │
│               ┌────────────▼────────────┐                   │
│               │      agent_node         │                   │
│               │   (LLM Reasoning)       │                   │
│               └────────────┬────────────┘                   │
│                            │                                │
│               ┌────────────▼────────────┐                   │
│              ╱    should_continue?       ╲                   │
│             ╱  (Conditional Edge)         ╲                  │
│            ╱                               ╲                 │
│      tool_calls?                      no tool_calls?        │
│           │                                │                │
│  ┌────────▼─────────┐          ┌──────────▼──────────┐     │
│  │    tool_node      │          │       END            │     │
│  │  (Execute Tools)  │          │   (Return Result)    │     │
│  └────────┬──────────┘          └─────────────────────┘     │
│           │                                                 │
│           └──────────────────┐                              │
│                              │ (feed tool results back)     │
│               ┌──────────────▼──────────┐                   │
│               │      agent_node         │ ← 回到推理节点    │
│               └─────────────────────────┘                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p>这个图可以清晰地表达：</p>
<ul>
<li><strong>循环</strong>：<code>agent_node → tool_node → agent_node</code>（工具调用循环）</li>
<li><strong>分支</strong>：<code>should_continue?</code> 条件路由</li>
<li><strong>终止</strong>：到达 <code>END</code> 节点时退出</li>
</ul>
<h3>4.2 代码示例：用 LangGraph 实现同一个 Agent</h3>
<p>用 LangGraph 实现与上文 LangChain 相同的天气查询 + 日程创建 Agent：</p>
<pre><code class="language-python">from typing import Annotated, TypedDict
from langchain_openai import ChatOpenAI
from langchain_core.tools import tool
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph import StateGraph, START, END
from langgraph.graph.message import add_messages
from langgraph.prebuilt import ToolNode


# ============================================================
# Step 1: 定义共享状态（State）
# ============================================================
# 这是 LangGraph 与 LangChain 的核心差异：
# 显式定义 Agent 的完整状态结构
class AgentState(TypedDict):
    messages: Annotated[list[BaseMessage], add_messages]  # 消息列表，自动追加


# ============================================================
# Step 2: 定义工具（和 LangChain 相同）
# ============================================================
@tool
def get_weather(city: str, date: str) -&gt; str:
    &quot;&quot;&quot;获取指定城市在指定日期的天气预报。&quot;&quot;&quot;
    return f&#39;{{&quot;city&quot;: &quot;{city}&quot;, &quot;date&quot;: &quot;{date}&quot;, &quot;temp&quot;: &quot;31°C&quot;, &quot;condition&quot;: &quot;多云转雷阵雨&quot;}}&#39;

@tool
def create_reminder(title: str, time: str, note: str) -&gt; str:
    &quot;&quot;&quot;创建一个日程提醒。&quot;&quot;&quot;
    return f&#39;{{&quot;status&quot;: &quot;created&quot;, &quot;title&quot;: &quot;{title}&quot;, &quot;time&quot;: &quot;{time}&quot;}}&#39;

tools = [get_weather, create_reminder]


# ============================================================
# Step 3: 定义节点（Node）
# ============================================================
llm = ChatOpenAI(model=&quot;gpt-4o&quot;, temperature=0).bind_tools(tools)

def agent_node(state: AgentState) -&gt; dict:
    &quot;&quot;&quot;推理节点：LLM 根据当前状态决定下一步&quot;&quot;&quot;
    system_message = {
        &quot;role&quot;: &quot;system&quot;,
        &quot;content&quot;: &quot;你是一个智能助手，可以查询天气和管理日程。今天是 2025-09-01。&quot;
    }
    messages = [system_message] + state[&quot;messages&quot;]
    response = llm.invoke(messages)
    return {&quot;messages&quot;: [response]}

# ToolNode 是 LangGraph 的内置节点，自动执行工具调用
tool_node = ToolNode(tools)


# ============================================================
# Step 4: 定义边（Edge）—— 条件路由
# ============================================================
def should_continue(state: AgentState) -&gt; str:
    &quot;&quot;&quot;条件路由：检查最后一条消息是否包含工具调用&quot;&quot;&quot;
    last_message = state[&quot;messages&quot;][-1]
    if hasattr(last_message, &quot;tool_calls&quot;) and last_message.tool_calls:
        return &quot;tools&quot;     # 有工具调用 → 去 tool_node
    return &quot;end&quot;           # 无工具调用 → 任务完成


# ============================================================
# Step 5: 构建图（Graph）
# ============================================================
graph_builder = StateGraph(AgentState)

# 添加节点
graph_builder.add_node(&quot;agent&quot;, agent_node)
graph_builder.add_node(&quot;tools&quot;, tool_node)

# 添加边
graph_builder.add_edge(START, &quot;agent&quot;)                        # 入口 → 推理
graph_builder.add_conditional_edges(&quot;agent&quot;, should_continue, {
    &quot;tools&quot;: &quot;tools&quot;,                                         # 推理 → 工具执行
    &quot;end&quot;: END,                                               # 推理 → 结束
})
graph_builder.add_edge(&quot;tools&quot;, &quot;agent&quot;)                      # 工具执行 → 回到推理

# 编译图
graph = graph_builder.compile()


# ============================================================
# Step 6: 运行
# ============================================================
result = graph.invoke({
    &quot;messages&quot;: [HumanMessage(content=&quot;帮我查看明天北京的天气，然后创建一个提醒&quot;)]
})

# 输出最终结果
for message in result[&quot;messages&quot;]:
    print(f&quot;[{message.type}] {message.content}&quot;)
</code></pre>
<p>对比 LangChain 版本，LangGraph 的关键差异：</p>
<ol>
<li><strong>显式状态定义</strong>：<code>AgentState</code> 明确声明了 Agent 运行时的完整状态</li>
<li><strong>显式控制流</strong>：<code>add_edge</code> 和 <code>add_conditional_edges</code> 让执行路径一目了然</li>
<li><strong>图可视化</strong>：编译后的 <code>graph</code> 可以直接渲染为流程图，便于理解和调试</li>
<li><strong>没有隐藏的循环</strong>：循环通过 <code>tools → agent</code> 的边显式定义，而不是藏在 <code>AgentExecutor</code> 内部</li>
</ol>
<h3>4.3 优点</h3>
<p><strong>1. 状态机模型比 Chain 更强大</strong></p>
<p>Chain 只能表达线性流水线。Graph 可以表达任意拓扑——分支、循环、并行、条件汇聚。这与现实中 Agent 的执行逻辑天然匹配。</p>
<p><strong>2. 确定性的控制流 + 非确定性的 LLM 决策</strong></p>
<p>这是 LangGraph 最精妙的设计哲学：</p>
<pre><code>确定性（代码定义）：            非确定性（LLM 决定）：
├── 有哪些节点                 ├── 每个节点内部的推理
├── 节点间如何连接              ├── 工具选择和参数
├── 条件路由的判断逻辑          ├── 是否继续循环
└── 状态的数据结构              └── 最终输出内容
</code></pre>
<p>图的拓扑结构是确定性的（你在编译时就知道所有可能的执行路径），但每一步走哪条路径是 LLM 在运行时决定的。这实现了<strong>可预测的系统行为</strong>与<strong>灵活的智能决策</strong>之间的平衡。</p>
<p><strong>3. Checkpoint 支持——暂停、恢复、Time-Travel</strong></p>
<p>LangGraph 内置了状态检查点机制。这意味着：</p>
<pre><code class="language-python">from langgraph.checkpoint.memory import MemorySaver

# 带 checkpoint 的图
checkpointer = MemorySaver()
graph = graph_builder.compile(checkpointer=checkpointer)

# 运行时传入 thread_id
config = {&quot;configurable&quot;: {&quot;thread_id&quot;: &quot;user-123&quot;}}
result = graph.invoke({&quot;messages&quot;: [HumanMessage(content=&quot;查天气&quot;)]}, config)

# 可以暂停、恢复、回放
# - 暂停：interrupt_before=[&quot;tool_node&quot;] 在工具执行前暂停，等待人类审批
# - 恢复：再次 invoke 同一个 thread_id，从上次中断点继续
# - Time-travel：回滚到任意 checkpoint，重新执行
</code></pre>
<p>这在 Human-in-the-Loop（人机协作）场景中极其有价值——Agent 可以在执行敏感操作前暂停，等待人类确认。</p>
<p><strong>4. 可以表达复杂的多 Agent 架构</strong></p>
<p>上一篇我们讨论的 Supervisor/Worker 模式、并行 Agent 协作，在 LangGraph 中可以自然地表达为图结构：</p>
<pre><code>                 ┌──────────────┐
                 │  Supervisor  │
                 └──────┬───────┘
                        │
              ┌─────────┼─────────┐
              ▼         ▼         ▼
        ┌──────────┐ ┌──────┐ ┌──────────┐
        │ Researcher│ │Coder │ │ Reviewer │
        └──────────┘ └──────┘ └──────────┘
              │         │         │
              └─────────┼─────────┘
                        ▼
                 ┌──────────────┐
                 │  Supervisor  │ ← 回到 Supervisor 决定是否继续
                 └──────────────┘
</code></pre>
<h3>4.4 问题</h3>
<p><strong>问题 1：学习曲线较陡</strong></p>
<p>LangGraph 要求你理解状态机、有向图、条件路由等概念。对于习惯了&quot;调用一个函数就能跑&quot;的开发者来说，需要一段适应期。</p>
<p>特别是 <code>Annotated[list[BaseMessage], add_messages]</code> 这样的状态定义语法（使用 <code>Annotated</code> 类型指定 reducer 函数），对 Python 类型系统不熟悉的开发者可能感到困惑。</p>
<p><strong>问题 2：状态定义需要提前规划</strong></p>
<p>在 LangChain 中，你可以随意传递数据，框架会帮你管理。在 LangGraph 中，所有状态必须在 <code>AgentState</code> 中预先定义。这意味着你需要在写代码之前就想清楚 Agent 需要哪些状态。</p>
<pre><code class="language-python"># 如果开发到一半发现需要新的状态字段，
# 你需要修改 State 定义，并确保所有节点兼容
class AgentState(TypedDict):
    messages: Annotated[list[BaseMessage], add_messages]
    plan: list[str]                    # 后来加的
    current_step: int                  # 后来加的
    tool_results: dict[str, str]       # 后来加的
    retry_count: int                   # 后来加的
    # ... 状态会越来越复杂
</code></pre>
<p>对于探索性的开发来说，这种&quot;先定义后使用&quot;的约束会拖慢迭代速度。</p>
<p><strong>问题 3：小任务过度工程化</strong></p>
<p>如果你的 Agent 逻辑就是&quot;调用 LLM → 可能调用工具 → 返回结果&quot;这个简单循环，用 LangGraph 定义 State、Node、Edge、Conditional Edge 就像是用大炮打蚊子。</p>
<pre><code class="language-python"># 一个简单的 ReAct Agent，用 LangGraph 需要 40+ 行图定义代码
# 用原生 Python 只需要一个 while 循环：
while True:
    response = llm.chat(messages, tools=tools)
    if not response.tool_calls:
        return response.content
    for tc in response.tool_calls:
        result = execute_tool(tc)
        messages.append(tool_message(tc.id, result))
</code></pre>
<p>当你的 Agent 逻辑不涉及复杂的分支和并行时，LangGraph 的开销不值得。</p>
<hr>
<h2>5. 其他框架概览</h2>
<p>除了 LangChain 和 LangGraph，AI Agent 领域还有多个值得关注的框架。以下不深入展开，重点给出定位和适用场景。</p>
<h3>5.1 框架定位速览</h3>
<table>
<thead>
<tr>
<th>框架</th>
<th>开发者</th>
<th>核心抽象</th>
<th>定位</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>LangChain</strong></td>
<td>LangChain Inc.</td>
<td>Chain（链式调用）</td>
<td>通用 AI 应用框架</td>
<td>原型验证、RAG、简单 Agent</td>
</tr>
<tr>
<td><strong>LangGraph</strong></td>
<td>LangChain Inc.</td>
<td>Graph（状态机）</td>
<td>复杂 Agent 编排</td>
<td>多步推理、Human-in-the-Loop、多 Agent</td>
</tr>
<tr>
<td><strong>CrewAI</strong></td>
<td>CrewAI Inc.</td>
<td>Crew + Agent + Task</td>
<td>多 Agent 协作</td>
<td>角色扮演式多 Agent 工作流</td>
</tr>
<tr>
<td><strong>AutoGen</strong></td>
<td>Microsoft</td>
<td>Agent + Conversation</td>
<td>多 Agent 对话</td>
<td>研究型多 Agent 系统、代码生成</td>
</tr>
<tr>
<td><strong>Semantic Kernel</strong></td>
<td>Microsoft</td>
<td>Kernel + Plugin + Planner</td>
<td>企业级 AI 编排</td>
<td>企业应用集成、.NET 生态</td>
</tr>
<tr>
<td><strong>Haystack</strong></td>
<td>deepset</td>
<td>Pipeline + Component</td>
<td>RAG 专用</td>
<td>文档检索、知识问答</td>
</tr>
<tr>
<td><strong>DSPy</strong></td>
<td>Stanford NLP</td>
<td>Module + Signature + Optimizer</td>
<td>Prompt 优化</td>
<td>需要自动调优 Prompt 的系统</td>
</tr>
</tbody></table>
<h3>5.2 简要点评</h3>
<p><strong>CrewAI</strong> 的核心思路是&quot;角色扮演&quot;——你定义多个 Agent，每个 Agent 有一个角色（Researcher、Writer、Reviewer），然后把一个任务分配给这个&quot;团队&quot;。这个抽象直观好懂，但在复杂场景中角色定义和任务分配的灵活性不足。</p>
<pre><code class="language-python"># CrewAI 的核心抽象：角色 + 任务 + 团队
from crewai import Agent, Task, Crew

researcher = Agent(role=&quot;Researcher&quot;, goal=&quot;查找相关信息&quot;, ...)
writer = Agent(role=&quot;Writer&quot;, goal=&quot;撰写报告&quot;, ...)
task1 = Task(description=&quot;研究 AI Agent 的最新进展&quot;, agent=researcher)
task2 = Task(description=&quot;基于研究结果撰写报告&quot;, agent=writer)
crew = Crew(agents=[researcher, writer], tasks=[task1, task2])
result = crew.kickoff()
</code></pre>
<p><strong>AutoGen</strong>（Microsoft）强调多 Agent 之间的对话作为协作机制。Agent 之间通过消息传递交互，可以构建复杂的对话流程。适合研究和实验性项目，生产部署的工程支持较弱。</p>
<p><strong>Semantic Kernel</strong>（Microsoft）面向企业用户，强调与现有企业系统的集成。如果你的技术栈是 .NET/C#，或者需要与 Microsoft 365/Azure 深度集成，Semantic Kernel 是更自然的选择。</p>
<p><strong>Haystack</strong>（deepset）不试图做通用 Agent 框架，而是专注于 RAG pipeline。如果你的核心需求是文档检索和知识问答（而不是 Agent 的自主决策和工具调用），Haystack 的 Pipeline 抽象比 LangChain 更干净。</p>
<p><strong>DSPy</strong>（Stanford NLP）走了一条完全不同的路——它不是一个 Agent 运行时框架，而是一个 Prompt 优化框架。核心思想是把 Prompt 当作可学习的参数，通过编译和优化自动找到最佳 Prompt。适合对 Prompt 质量有极高要求的场景。</p>
<h3>5.3 框架选型决策树</h3>
<pre><code>你的核心需求是什么？
│
├─── 快速原型 / PoC
│    └─→ LangChain（生态最大，上手最快）
│
├─── 复杂 Agent 逻辑（分支/循环/并行）
│    └─→ LangGraph（状态机模型天然适合）
│
├─── 多 Agent 协作
│    ├─── 角色扮演式 → CrewAI
│    ├─── 对话式协作 → AutoGen
│    └─── 图编排式   → LangGraph
│
├─── RAG / 知识问答
│    ├─── 需要灵活性  → LangChain + Retriever
│    └─── 需要干净抽象 → Haystack
│
├─── 企业级集成（.NET / Azure）
│    └─→ Semantic Kernel
│
├─── Prompt 自动优化
│    └─→ DSPy
│
└─── 生产系统（需要精细控制）
     └─→ 自研，或只使用框架的底层模块
</code></pre>
<hr>
<h2>6. 框架 vs 自研的决策矩阵</h2>
<p>这是本文最重要的一节。不存在&quot;框架一定好&quot;或&quot;自研一定好&quot;的结论——关键是根据你的具体场景做出理性决策。</p>
<h3>6.1 决策矩阵</h3>
<table>
<thead>
<tr>
<th>考量因素</th>
<th>倾向选框架</th>
<th>倾向选自研</th>
</tr>
</thead>
<tbody><tr>
<td><strong>项目阶段</strong></td>
<td>原型验证、MVP</td>
<td>生产系统、需要长期维护</td>
</tr>
<tr>
<td><strong>团队规模</strong></td>
<td>1-3 人小团队</td>
<td>5+ 人专职 AI 团队</td>
</tr>
<tr>
<td><strong>定制化程度</strong></td>
<td>标准 ReAct/RAG 模式</td>
<td>有独特的控制流或状态管理需求</td>
</tr>
<tr>
<td><strong>调试要求</strong></td>
<td>能接受黑盒</td>
<td>需要完全可观测、可追踪</td>
</tr>
<tr>
<td><strong>性能要求</strong></td>
<td>对 latency 不敏感</td>
<td>需要极致优化每一毫秒</td>
</tr>
<tr>
<td><strong>依赖容忍度</strong></td>
<td>能接受第三方依赖的版本变化</td>
<td>需要完全掌控依赖</td>
</tr>
<tr>
<td><strong>上线时间</strong></td>
<td>2 周内上线</td>
<td>3 个月以上的工程周期</td>
</tr>
<tr>
<td><strong>团队 AI 经验</strong></td>
<td>初次接触 Agent 开发</td>
<td>对 Agent 架构有深入理解</td>
</tr>
</tbody></table>
<h3>6.2 常见场景分析</h3>
<p><strong>场景 1：初创团队做 AI 产品的 MVP</strong></p>
<p>推荐：LangChain（快速原型）→ 验证产品方向 → 决定是否重写</p>
<p>理由：此时最大的风险不是技术债，而是方向错误。花 3 个月自研一个完美的 Agent Runtime，结果发现用户不需要 Agent——这才是最大的浪费。用框架在 2 周内验证想法，确认方向后再决定技术路线。</p>
<p><strong>场景 2：大厂 AI 平台团队</strong></p>
<p>推荐：自研核心 Runtime + 选择性使用框架的底层模块</p>
<p>理由：大厂有足够的工程资源，且对可靠性、可观测性、安全性的要求远超框架的默认支持。自研 Runtime 可以完全掌控控制循环、状态管理、错误处理、日志追踪。但可以借鉴框架的设计模式，或使用框架的工具集成层（比如 LangChain 的 Tool/Retriever 集成）。</p>
<p><strong>场景 3：企业内部的 AI 助手</strong></p>
<p>推荐：LangGraph（如果逻辑复杂）或 LangChain（如果逻辑简单）</p>
<p>理由：企业内部项目通常有明确的需求边界和合理的 SLA 要求，框架能满足大部分需求。LangGraph 的 Human-in-the-Loop 支持对企业审批流程特别有用。</p>
<p><strong>场景 4：研究实验</strong></p>
<p>推荐：AutoGen 或自研轻量框架</p>
<p>理由：研究需要最大的灵活性来尝试新想法。框架的抽象可能限制实验空间。但如果实验涉及多 Agent 交互，AutoGen 的对话式抽象可以减少样板代码。</p>
<h3>6.3 一个务实的折中方案</h3>
<p>在实践中，最常见的成熟方案是<strong>分层使用框架</strong>：</p>
<pre><code>┌─────────────────────────────────────────────────┐
│              你的应用层代码                        │
│         (业务逻辑、API 接口、用户交互)              │
├─────────────────────────────────────────────────┤
│              自研 Agent Runtime                    │
│    (控制循环、状态管理、错误处理、可观测性)          │
├───────────────┬─────────────────────────────────┤
│  自研工具调度   │   框架的集成模块（可选使用）       │
│  自研消息管理   │   LangChain Tool/Retriever       │
│  自研状态存储   │   LangChain Document Loader      │
│               │   LangChain Embedding 接口        │
├───────────────┴─────────────────────────────────┤
│              LLM Provider SDK                     │
│         (openai, anthropic, etc.)                 │
└─────────────────────────────────────────────────┘
</code></pre>
<p>核心思路：</p>
<ul>
<li><strong>控制循环自研</strong>：这是 Agent 最核心的逻辑，也是最需要定制的部分。用 40-60 行 Python 就能实现一个健壮的控制循环（回顾第 07 篇）</li>
<li><strong>LLM 调用用原生 SDK</strong>：OpenAI SDK 和 Anthropic SDK 本身就很好用，不需要再包一层</li>
<li><strong>工具集成可以借用框架</strong>：LangChain 的 Tool 生态确实强大。你可以只 <code>pip install langchain-community</code> 来使用其预置工具，而不用采纳整个框架</li>
<li><strong>状态管理自研</strong>：根据你的持久化需求（Redis、PostgreSQL、内存）定制</li>
</ul>
<p>这个方案的好处是：你在最关键的层面保留了完全掌控力，同时在最不需要掌控的层面（第三方服务的集成）借助了框架的生态。</p>
<hr>
<h2>7. 框架的正确使用姿势</h2>
<p>无论你最终选择什么方案，以下原则都适用。</p>
<h3>7.1 理解原理再用框架</h3>
<p>这正是本系列前 7 篇文章的价值。当你理解了控制循环的六个阶段、Tool Calling 的 JSON Schema 契约、Memory 的分层架构之后，框架在你眼中就不再是黑盒——它只是这些原理的一种实现。</p>
<pre><code>不理解原理时使用框架：
    框架 = 黑魔法（出错时手足无措）

理解原理后使用框架：
    框架 = 已知原理的一种实现（出错时知道去哪里找原因）
</code></pre>
<p>具体来说：</p>
<ul>
<li>当 LangChain 的 <code>AgentExecutor</code> 出错时，你知道它内部在跑一个控制循环，可以猜测问题出在哪个阶段</li>
<li>当 LangGraph 的状态转移出现异常时，你知道这本质上是一个状态机的转移条件判断错误</li>
<li>当框架的 Memory 管理不符合你的需求时，你知道自己需要什么样的记忆架构，可以替换或扩展</li>
</ul>
<h3>7.2 不要被框架限制思维</h3>
<p>框架提供了一组默认的设计模式。这些模式覆盖了 80% 的常见场景，但你的场景可能落在剩下的 20%。</p>
<p><strong>反模式</strong>：为了适配框架的抽象而扭曲自己的业务逻辑。</p>
<pre><code class="language-python"># 反模式：业务逻辑需要 Agent 在两个工具的结果之间做比较，
# 但框架不直接支持，于是你&quot;发明&quot;了一个假工具来绕过限制

@tool
def compare_results(result_a: str, result_b: str) -&gt; str:
    &quot;&quot;&quot;比较两个结果（实际上这应该是 Agent 内部的推理逻辑，不是工具）&quot;&quot;&quot;
    # 这不应该是一个 Tool —— 这是把框架的抽象当成了唯一的解法
    return llm.invoke(f&quot;比较: {result_a} vs {result_b}&quot;)
</code></pre>
<p><strong>正确做法</strong>：框架不支持的逻辑，用原生代码实现，然后插入到框架的流程中（或者干脆不用框架处理这部分）。</p>
<h3>7.3 框架代码是最好的学习材料</h3>
<p>即使你决定自研，框架的源码仍然是宝贵的学习资源。以下是几个值得阅读的代码文件：</p>
<ul>
<li><strong>LangGraph 的 <code>StateGraph</code></strong>：理解如何用 Python 实现一个状态机运行时</li>
<li><strong>LangChain 的 <code>ToolNode</code></strong>：理解如何将 LLM 的 tool_call 输出映射为实际的函数调用</li>
<li><strong>LangChain 的 <code>ChatOpenAI</code></strong>：理解如何封装 LLM Provider 的 API 差异</li>
<li><strong>LangGraph 的 <code>MemorySaver</code></strong>：理解 checkpoint 和状态持久化的实现</li>
</ul>
<p>阅读源码时，关注的不是具体的 API，而是<strong>设计决策</strong>：为什么这样抽象？这个 trade-off 是什么？有没有更好的方案？</p>
<h3>7.4 随时准备好替换或去掉框架</h3>
<p>一个健康的架构应该允许你在不重写业务逻辑的情况下替换底层框架。实现方式：</p>
<pre><code class="language-python"># 定义你自己的接口（不依赖任何框架）
from abc import ABC, abstractmethod

class BaseLLM(ABC):
    @abstractmethod
    def chat(self, messages: list[dict], tools: list[dict] | None = None) -&gt; dict:
        ...

class BaseToolExecutor(ABC):
    @abstractmethod
    def execute(self, tool_name: str, args: dict) -&gt; str:
        ...

class BaseMemory(ABC):
    @abstractmethod
    def get_messages(self, limit: int = 20) -&gt; list[dict]:
        ...
    @abstractmethod
    def add_message(self, message: dict) -&gt; None:
        ...


# 框架实现（可替换）
class LangChainLLM(BaseLLM):
    def __init__(self):
        from langchain_openai import ChatOpenAI
        self._llm = ChatOpenAI(model=&quot;gpt-4o&quot;)

    def chat(self, messages, tools=None):
        # 将你的接口适配为 LangChain 接口
        ...

# 原生实现（可替换）
class NativeLLM(BaseLLM):
    def __init__(self):
        import openai
        self._client = openai.OpenAI()

    def chat(self, messages, tools=None):
        response = self._client.chat.completions.create(
            model=&quot;gpt-4o&quot;, messages=messages, tools=tools
        )
        ...


# 你的 Agent 代码只依赖自己的接口
class MyAgent:
    def __init__(self, llm: BaseLLM, tools: BaseToolExecutor, memory: BaseMemory):
        self.llm = llm
        self.tools = tools
        self.memory = memory

    def run(self, user_input: str) -&gt; str:
        # 业务逻辑不依赖任何框架
        ...
</code></pre>
<p>这不是过度设计——这是<strong>依赖倒置原则</strong>在 Agent 架构中的直接应用。当框架发生 breaking change（LangChain 几乎每季度都有）时，你只需要修改适配层，而不是重写整个系统。</p>
<hr>
<h2>8. LangChain vs LangGraph：直接对比</h2>
<p>最后，用一张表格直接对比 LangChain 和 LangGraph 在各维度的差异：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>LangChain</th>
<th>LangGraph</th>
</tr>
</thead>
<tbody><tr>
<td><strong>核心抽象</strong></td>
<td>Chain（线性管道）</td>
<td>Graph（有向状态机）</td>
</tr>
<tr>
<td><strong>控制流表达</strong></td>
<td>线性为主，分支/循环需要 hack</td>
<td>天然支持分支、循环、并行</td>
</tr>
<tr>
<td><strong>状态管理</strong></td>
<td>隐式（框架内部管理）</td>
<td>显式（开发者定义 State 类型）</td>
</tr>
<tr>
<td><strong>学习曲线</strong></td>
<td>低（上手快）</td>
<td>中等（需要理解状态机概念）</td>
</tr>
<tr>
<td><strong>调试体验</strong></td>
<td>差（多层抽象遮蔽错误源）</td>
<td>中等（图结构可视化，但状态流转需追踪）</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>简单 Agent、RAG、原型验证</td>
<td>复杂 Agent、多 Agent、Human-in-the-Loop</td>
</tr>
<tr>
<td><strong>生态集成</strong></td>
<td>最丰富</td>
<td>继承 LangChain 生态</td>
</tr>
<tr>
<td><strong>Human-in-the-Loop</strong></td>
<td>不原生支持</td>
<td>原生 Checkpoint + Interrupt 支持</td>
</tr>
<tr>
<td><strong>多 Agent</strong></td>
<td>需要自行编排</td>
<td>原生支持子图嵌套</td>
</tr>
<tr>
<td><strong>生产就绪度</strong></td>
<td>中等（需要大量自定义）</td>
<td>较高（状态持久化、检查点内置）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>框架约束多，突破框架难</td>
<td>图定义灵活，但需要提前规划</td>
</tr>
<tr>
<td><strong>版本稳定性</strong></td>
<td>差（API 频繁变更）</td>
<td>较好（API 相对稳定）</td>
</tr>
</tbody></table>
<p><strong>总结</strong>：如果 LangChain 是一条<strong>传送带</strong>（把东西从 A 运到 B），那么 LangGraph 就是一张<strong>铁路网</strong>（可以在任意站点之间调度列车）。传送带简单高效，铁路网灵活强大——选哪个取决于你要运的东西有多复杂。</p>
<hr>
<h2>9. 结语与进一步思考</h2>
<h3>核心立场回顾</h3>
<p>本文的核心立场可以用三句话概括：</p>
<ol>
<li><p><strong>框架是加速器，不是必需品。</strong> 它加速了开发，但也隐藏了复杂性。当隐藏的复杂性成为你的瓶颈时，框架就从加速器变成了减速器。</p>
</li>
<li><p><strong>理解原理比掌握框架更重要。</strong> 框架会变（LangChain 已经经历了多次 API 大改），但控制循环、状态管理、工具调用的基本原理不会变。前 7 篇文章构建的知识，是你评估和使用任何框架的基础。</p>
</li>
<li><p><strong>最好的架构是&quot;框架可替换&quot;的架构。</strong> 把框架当作可插拔的实现层，而不是系统的骨架。你的业务逻辑应该依赖自己定义的接口，而不是某个框架的 API。</p>
</li>
</ol>
<h3>框架解决了&quot;怎么写&quot;，协议解决&quot;怎么连接&quot;</h3>
<p>框架帮你解决了一个 Agent 内部的组件编排问题：如何组织 LLM 调用、工具执行、状态管理。但当你有多个 Agent、多个工具提供者、多个模型时，一个更根本的问题浮现出来：</p>
<blockquote>
<p>这些组件之间用什么协议通信？工具如何被发现和注册？能力如何被声明和协商？</p>
</blockquote>
<p>这不是框架能解决的问题——这需要<strong>协议（Protocol）</strong>。下一篇我们将讨论 MCP（Model Context Protocol），看看 Agent 工具生态的协议化未来。</p>
<h3>留给读者的思考</h3>
<p><strong>关于框架的未来</strong>：LLM 本身的能力在快速增强。当模型原生支持复杂的多步推理（如 o1/o3 的 chain-of-thought）、原生支持长对话记忆（如 Gemini 的长上下文窗口）、原生支持工具调用时，框架的价值会被压缩还是放大？换句话说——当 LLM 足够强时，我们还需要框架在中间做多少事？</p>
<p><strong>关于抽象的代价</strong>：每一层抽象都在隐藏复杂性。隐藏复杂性是好事（让你专注于业务逻辑），但也是坏事（让你在出问题时无法理解系统行为）。在 Agent 这样本身就充满不确定性的系统中，你能接受多少&quot;隐藏的复杂性&quot;？</p>
<p><strong>关于生态锁定</strong>：选择一个框架意味着接受它的抽象、它的生态、它的更新节奏、它的设计理念。当框架的方向与你的需求分叉时，迁移的成本有多高？这个成本是否在你的决策时被低估了？</p>
<p>这些问题没有标准答案。但作为 AI 工程师，能够清晰地提出这些问题，本身就是一种重要的能力。</p>
<hr>
<blockquote>
<p><strong>系列导航</strong>：本文是 Agentic 系列的第 12 篇。</p>
<ul>
<li>上一篇：<a href="/blog/engineering/agentic/11-Multi-Agent%20Collaboration">11 | Multi-Agent Collaboration</a></li>
<li>下一篇：<a href="/blog/engineering/agentic/13-MCP%20and%20Tool%20Protocol">13 | MCP and Tool Protocol</a></li>
<li>完整目录：<a href="/blog/engineering/agentic/01-From%20LLM%20to%20Agent">01 | From LLM to Agent</a></li>
</ul>
</blockquote>
17:Tf833,<h1>Multi-Agent Collaboration: 多 Agent 协作模式与架构</h1>
<blockquote>
<p>一个人可以走得很快，但一群人才能走得很远。Agent 也是如此。</p>
<p>本文是 Agentic 系列第 11 篇。前 10 篇我们一直在讨论单个 Agent 如何更聪明——更好的记忆、更强的工具、更深的规划。这一篇，我们把视角从&quot;个体智能&quot;拉升到&quot;集体智能&quot;：当一个 Agent 不够用时，多个 Agent 如何协作？</p>
</blockquote>
<hr>
<h2>1. 为什么单 Agent 不够</h2>
<h3>1.1 一个类比：从独立开发者到工程团队</h3>
<p>想象你是一个全栈工程师，独自完成一个项目。前端、后端、数据库、DevOps、测试、文档——全部一个人扛。小项目可以，但当系统规模增长到一定程度，你会发现：</p>
<ul>
<li><strong>注意力是瓶颈</strong>：你不可能同时想着 CSS 布局和数据库索引优化</li>
<li><strong>专业化有上限</strong>：一个人很难同时成为安全专家、性能专家和 UX 专家</li>
<li><strong>效率有天花板</strong>：就算你是 10x 工程师，你的时间也是串行的</li>
<li><strong>单点风险</strong>：你生病了，整个项目就停了</li>
</ul>
<p>这就是人类发明&quot;团队协作&quot;的原因。Agent 面临完全相同的结构性限制。</p>
<h3>1.2 Single-Agent 的四个天花板</h3>
<p><strong>天花板一：Context Window 限制</strong></p>
<p>一个 Agent 的 System Prompt 需要包含：角色定义、工具描述、输出格式约束、领域知识、示例。当你试图让一个 Agent 同时承担搜索、分析、写作、代码生成、数据可视化等多个职能时，光是工具描述就可能占据数万 token。留给实际任务执行的上下文空间被严重压缩。</p>
<pre><code>一个&quot;全能&quot; Agent 的 Context 分配：

┌─────────────────────────────────────────────────┐
│ System Prompt (角色 + 规则)         ~2,000 tokens │
│ Tool Schemas (15 个工具)            ~6,000 tokens │
│ 领域知识 (RAG 检索结果)             ~4,000 tokens │
│ 对话历史                            ~8,000 tokens │
│ 当前任务 + 中间状态                 ~3,000 tokens │
├─────────────────────────────────────────────────┤
│ 剩余可用空间                        ~9,000 tokens │ ← 越来越捉襟见肘
│ (128K 窗口下比例更好，但工具越多问题越突出)         │
└─────────────────────────────────────────────────┘
</code></pre>
<p>更关键的是，研究表明 LLM 在超长上下文中存在&quot;Lost in the Middle&quot;问题——中间位置的信息检索准确率显著下降。塞得越多，每条信息被有效利用的概率越低。</p>
<p><strong>天花板二：专业化限制</strong></p>
<p>一个 System Prompt 很难让 LLM 同时扮演好多个角色。你告诉它&quot;你是一个严谨的数据分析师&quot;，它分析数据时很好；但同一个 prompt 里你又说&quot;你也是一个有创意的文案写手&quot;，这两种人格的行为模式是矛盾的。严谨和创意在同一个 prompt 中互相干扰，最终两个角色都做不好。</p>
<p>这不是 prompt engineering 的技巧问题，而是注意力分配的结构性问题——一个 LLM 调用只有一个 attention 分布，强调了分析的严谨性，就必然削弱了文案的创造性。</p>
<p><strong>天花板三：可靠性限制</strong></p>
<p>单 Agent 是一个 Single Point of Failure。如果它在第 5 步推理出错（比如工具调用参数写错），整个任务链路都会受到污染。虽然我们在第 10 篇讨论了 Reflection 和自我纠错，但自我纠错的前提是&quot;能发现自己错了&quot;——而 LLM 对自身错误的检测能力是有限的。</p>
<p><strong>天花板四：并行度限制</strong></p>
<p>单 Agent 的执行是串行的——一次 LLM 调用，等待结果，再进行下一次。如果一个任务可以分解为三个独立子任务（比如同时搜索三个数据源），单 Agent 只能顺序执行，浪费了大量时间。</p>
<pre><code>Single-Agent 串行执行：

  Task ──→ [Search A] ──→ [Search B] ──→ [Search C] ──→ [Synthesize]
                                                         Total: ~40s

Multi-Agent 并行执行：

           ┌─→ [Search A] ─┐
  Task ──→ ├─→ [Search B] ─┼──→ [Synthesize]
           └─→ [Search C] ─┘
                              Total: ~15s
</code></pre>
<hr>
<h2>2. Multi-Agent 的四种协作模式</h2>
<p>当我们决定使用多个 Agent 时，第一个架构问题是：<strong>它们之间的协作关系是什么？</strong> 不同的关系模式适用于不同的场景，选错模式比用错框架更致命。</p>
<h3>2.1 模式一：Supervisor-Worker（上级分配型）</h3>
<pre><code>                    ┌──────────────────┐
                    │    Supervisor    │
                    │   (任务分解 +    │
                    │    结果合成)     │
                    └──────┬───────────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
              ▼            ▼            ▼
       ┌──────────┐ ┌──────────┐ ┌──────────┐
       │ Worker A │ │ Worker B │ │ Worker C │
       │ (搜索)   │ │ (分析)   │ │ (写作)   │
       └──────────┘ └──────────┘ └──────────┘
              │            │            │
              └────────────┼────────────┘
                           │
                           ▼
                    ┌──────────────────┐
                    │    Supervisor    │
                    │   (收集 + 合成   │
                    │    最终输出)     │
                    └──────────────────┘
</code></pre>
<p><strong>工作流程</strong>：</p>
<ol>
<li>Supervisor Agent 接收用户任务</li>
<li>Supervisor 将任务分解为子任务，分配给不同的 Worker Agent</li>
<li>每个 Worker 独立执行各自的子任务</li>
<li>Supervisor 收集所有 Worker 的结果，合成最终输出</li>
</ol>
<p><strong>核心特征</strong>：</p>
<ul>
<li>有一个明确的中央协调者</li>
<li>Worker 之间不直接通信，只与 Supervisor 交互</li>
<li>Supervisor 负责全局决策，Worker 负责局部执行</li>
</ul>
<p><strong>适用场景</strong>：任务可以明确分解的场景。比如撰写一篇技术调研报告：Search Agent 负责信息搜集，Analyze Agent 负责数据分析，Write Agent 负责报告撰写。Supervisor 负责协调整个流程。</p>
<p><strong>Trade-off</strong>：Supervisor 是单点——如果 Supervisor 对任务的分解不合理，所有 Worker 的努力都会被浪费。此外，Supervisor 本身也是一个 LLM 调用，它对任务的理解能力决定了整个系统的上限。</p>
<h3>2.2 模式二：Peer-to-Peer（平等协商型）</h3>
<pre><code>       ┌──────────┐          ┌──────────┐
       │ Agent A  │◀────────▶│ Agent B  │
       │ (作者)   │          │ (审稿人) │
       └────┬─────┘          └────┬─────┘
            │                     │
            │    ┌──────────┐     │
            └───▶│ Agent C  │◀────┘
                 │ (编辑)   │
                 └──────────┘

       消息流是双向的，没有固定的上下级关系
       每个 Agent 都可以发起对话、提出意见、做出决策
</code></pre>
<p><strong>工作流程</strong>：</p>
<ol>
<li>多个 Agent 地位平等，通过消息传递进行协商</li>
<li>没有中央协调者——Agent 之间直接通信</li>
<li>通过多轮对话达成共识或完成任务</li>
</ol>
<p><strong>核心特征</strong>：</p>
<ul>
<li>去中心化</li>
<li>Agent 之间直接消息传递</li>
<li>适合需要多视角碰撞的任务</li>
</ul>
<p><strong>适用场景</strong>：辩论式分析（多个 Agent 从不同立场论证）、代码审查（Author Agent 写代码，Reviewer Agent 审查，双方来回沟通直到代码质量达标）、多角度决策（乐观分析师 + 悲观分析师 + 风险评估师共同评估一个投资决策）。</p>
<p><strong>Trade-off</strong>：没有中央协调意味着可能出现无限循环（两个 Agent 互相不同意，永远达不成共识）。需要额外的终止机制——最大轮次限制、外部仲裁者、投票制度等。调试也更困难，因为没有一个中心节点可以观察全局状态。</p>
<h3>2.3 模式三：Pipeline（流水线型）</h3>
<pre><code>  Input                                                          Output
    │                                                              ▲
    ▼                                                              │
┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
│ Draft  │───▶│ Review │───▶│  Edit  │───▶│  Fact  │───▶│ Format │
│ Agent  │    │ Agent  │    │ Agent  │    │ Check  │    │ Agent  │
│        │    │        │    │        │    │ Agent  │    │        │
└────────┘    └────────┘    └────────┘    └────────┘    └────────┘

  Stage 1       Stage 2       Stage 3       Stage 4       Stage 5
  生成初稿      审查质量       修改完善      事实核查       格式化输出
</code></pre>
<p><strong>工作流程</strong>：</p>
<ol>
<li>Agent 按顺序串联，形成流水线</li>
<li>上游 Agent 的输出是下游 Agent 的输入</li>
<li>每个 Agent 专注于一个处理阶段</li>
</ol>
<p><strong>核心特征</strong>：</p>
<ul>
<li>类似 Unix 管道：<code>cmd1 | cmd2 | cmd3</code></li>
<li>数据单向流动</li>
<li>每个阶段的 Agent 有明确、单一的职责</li>
</ul>
<p><strong>适用场景</strong>：内容生产流水线（起草 -&gt; 审查 -&gt; 编辑 -&gt; 排版）、数据处理管道（提取 -&gt; 清洗 -&gt; 转换 -&gt; 加载）、多阶段审批（初审 -&gt; 复审 -&gt; 终审）。</p>
<p><strong>Trade-off</strong>：流水线是严格串行的——上游不完成，下游无法开始。如果中间某个 Agent 输出质量差，后续所有阶段都会受影响（错误传播）。但好处是架构简单、易于理解和调试、每个阶段可以独立优化。</p>
<h3>2.4 模式四：Dynamic Routing（动态路由型）</h3>
<pre><code>                    ┌──────────────────┐
                    │   Router Agent   │
                    │ (意图识别 + 路由) │
                    └──────┬───────────┘
                           │
              ┌────────────┼────────────┐
              │            │            │
              ▼            ▼            ▼
       ┌──────────┐ ┌──────────┐ ┌──────────┐
       │ 技术支持  │ │ 售后服务  │ │ 销售咨询  │
       │ Agent    │ │ Agent    │ │ Agent    │
       │          │ │          │ │          │
       │ 处理技术  │ │ 处理退款  │ │ 处理购买  │
       │ 故障排查  │ │ 换货投诉  │ │ 产品推荐  │
       └──────────┘ └──────────┘ └──────────┘

  路由依据：用户输入的意图分类
  每个专家 Agent 有独立的 System Prompt、Tools、知识库
</code></pre>
<p><strong>工作流程</strong>：</p>
<ol>
<li>Router Agent 接收用户输入</li>
<li>根据意图分类，将请求路由到对应的专家 Agent</li>
<li>专家 Agent 处理请求并返回结果</li>
<li>必要时 Router 可以在专家之间进行二次路由</li>
</ol>
<p><strong>核心特征</strong>：</p>
<ul>
<li>一个轻量级的 Router 做决策</li>
<li>多个重量级的专家 Agent 做执行</li>
<li>Router 可以用简单模型（快速、便宜），专家用强大模型（准确、深入）</li>
</ul>
<p><strong>适用场景</strong>：客服系统（技术问题 -&gt; 技术 Agent，退款问题 -&gt; 售后 Agent）、多领域知识问答（医疗问题 -&gt; 医疗 Agent，法律问题 -&gt; 法律 Agent）、代码助手（Python 问题 -&gt; Python 专家，Rust 问题 -&gt; Rust 专家）。</p>
<p><strong>Trade-off</strong>：路由准确率是整个系统的瓶颈——路由错了，后面再专业也没用。模糊意图（&quot;我买的东西有技术问题&quot;——这是技术支持还是售后？）需要特殊处理。一种常见策略是允许 Router 在不确定时同时咨询多个专家，再综合判断。</p>
<h3>2.5 四种模式的对比决策</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>Supervisor-Worker</th>
<th>Peer-to-Peer</th>
<th>Pipeline</th>
<th>Dynamic Routing</th>
</tr>
</thead>
<tbody><tr>
<td>控制结构</td>
<td>中心化</td>
<td>去中心化</td>
<td>线性</td>
<td>分发型</td>
</tr>
<tr>
<td>通信模式</td>
<td>星形</td>
<td>网状</td>
<td>链式</td>
<td>扇出</td>
</tr>
<tr>
<td>并行度</td>
<td>高（Worker 并行）</td>
<td>中</td>
<td>低（严格串行）</td>
<td>高（请求级并行）</td>
</tr>
<tr>
<td>适用复杂度</td>
<td>高</td>
<td>中</td>
<td>中</td>
<td>低-中</td>
</tr>
<tr>
<td>调试难度</td>
<td>中</td>
<td>高</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>典型场景</td>
<td>报告生成、项目规划</td>
<td>辩论、审查</td>
<td>内容流水线</td>
<td>客服、问答路由</td>
</tr>
</tbody></table>
<p><strong>决策原则</strong>：</p>
<ul>
<li>任务可以并行分解 -&gt; Supervisor-Worker</li>
<li>需要多视角碰撞 -&gt; Peer-to-Peer</li>
<li>处理有明确阶段 -&gt; Pipeline</li>
<li>请求类型多样，专家各有擅长 -&gt; Dynamic Routing</li>
<li>不确定？先从最简单的 Pipeline 开始，逐步演进</li>
</ul>
<hr>
<h2>3. Agent 间通信机制</h2>
<p>多个 Agent 之间需要交换信息，通信机制的选择直接影响系统的可扩展性、耦合度和调试难度。</p>
<h3>3.1 共享内存（Blackboard Pattern）</h3>
<p>所有 Agent 读写同一个共享状态存储。这是最简单直接的通信方式。</p>
<pre><code>       ┌──────────┐   ┌──────────┐   ┌──────────┐
       │ Agent A  │   │ Agent B  │   │ Agent C  │
       └────┬─────┘   └────┬─────┘   └────┬─────┘
            │  read/write   │  read/write   │
            ▼              ▼              ▼
       ┌──────────────────────────────────────────┐
       │           Shared Blackboard              │
       │                                          │
       │  { &quot;search_results&quot;: [...],              │
       │    &quot;analysis&quot;: {...},                    │
       │    &quot;draft&quot;: &quot;...&quot;,                       │
       │    &quot;status&quot;: {&quot;search&quot;: &quot;done&quot;, ...} }   │
       └──────────────────────────────────────────┘
</code></pre>
<pre><code class="language-python">from dataclasses import dataclass, field
from typing import Any
import threading


@dataclass
class Blackboard:
    &quot;&quot;&quot;共享黑板：所有 Agent 的公共状态空间&quot;&quot;&quot;
    _state: dict[str, Any] = field(default_factory=dict)
    _lock: threading.Lock = field(default_factory=threading.Lock)
    _history: list[dict] = field(default_factory=list)

    def read(self, key: str) -&gt; Any:
        with self._lock:
            return self._state.get(key)

    def write(self, key: str, value: Any, author: str = &quot;unknown&quot;):
        with self._lock:
            self._history.append({
                &quot;action&quot;: &quot;write&quot;,
                &quot;key&quot;: key,
                &quot;author&quot;: author,
                &quot;old_value&quot;: self._state.get(key),
                &quot;new_value&quot;: value,
            })
            self._state[key] = value

    def read_all(self) -&gt; dict[str, Any]:
        with self._lock:
            return dict(self._state)
</code></pre>
<p><strong>优点</strong>：实现简单，Agent 之间完全解耦（不需要知道彼此的存在），天然支持任意读写模式。</p>
<p><strong>缺点</strong>：共享状态意味着潜在的竞争条件——两个 Agent 同时写同一个 key 怎么办？需要锁机制或更复杂的冲突解决策略。随着 Agent 数量增加，Blackboard 可能成为瓶颈。</p>
<h3>3.2 消息传递（Message Passing）</h3>
<p>Agent 之间通过显式的消息进行通信。每个 Agent 有自己的收件箱。</p>
<pre><code>       ┌──────────┐         ┌──────────┐
       │ Agent A  │──msg───▶│ Agent B  │
       │          │◀──msg───│          │
       └──────────┘         └──────────┘
            │                     ▲
            │         msg         │
            ▼                     │
       ┌──────────┐              │
       │ Agent C  │──────msg─────┘
       └──────────┘
</code></pre>
<pre><code class="language-python">from dataclasses import dataclass, field
from collections import defaultdict
from queue import Queue


@dataclass
class Message:
    sender: str
    receiver: str
    content: Any
    msg_type: str = &quot;default&quot;  # &quot;task&quot;, &quot;result&quot;, &quot;feedback&quot;, &quot;error&quot;


class MessageBus:
    &quot;&quot;&quot;点对点消息传递&quot;&quot;&quot;

    def __init__(self):
        self._queues: dict[str, Queue] = defaultdict(Queue)

    def send(self, message: Message):
        self._queues[message.receiver].put(message)

    def receive(self, agent_id: str, timeout: float = None) -&gt; Message | None:
        try:
            return self._queues[agent_id].get(timeout=timeout)
        except Exception:
            return None

    def has_messages(self, agent_id: str) -&gt; bool:
        return not self._queues[agent_id].empty()
</code></pre>
<p><strong>优点</strong>：通信关系显式、可追踪、可审计。每条消息都有明确的发送者和接收者。</p>
<p><strong>缺点</strong>：Agent 需要知道其他 Agent 的存在（至少知道 ID），耦合度比 Blackboard 高。如果通信拓扑复杂（多对多），消息管理会变得困难。</p>
<h3>3.3 事件驱动（Event Bus）</h3>
<p>Agent 通过发布/订阅事件进行间接通信。Agent 不需要知道谁会消费它的事件。</p>
<pre><code>       ┌──────────┐   ┌──────────┐   ┌──────────┐
       │ Agent A  │   │ Agent B  │   │ Agent C  │
       │ pub: X   │   │ sub: X   │   │ sub: X,Y │
       └────┬─────┘   └────┬─────┘   └────┬─────┘
            │  publish      │  subscribe   │
            ▼              ▼              ▼
       ┌──────────────────────────────────────────┐
       │              Event Bus                    │
       │                                          │
       │  topic &quot;search_done&quot;  → [Agent B, C]     │
       │  topic &quot;analysis_done&quot; → [Agent C]        │
       │  topic &quot;error&quot;        → [Supervisor]      │
       └──────────────────────────────────────────┘
</code></pre>
<pre><code class="language-python">from collections import defaultdict
from typing import Callable


class EventBus:
    &quot;&quot;&quot;发布/订阅事件总线&quot;&quot;&quot;

    def __init__(self):
        self._subscribers: dict[str, list[Callable]] = defaultdict(list)
        self._event_log: list[dict] = []

    def subscribe(self, topic: str, handler: Callable):
        self._subscribers[topic].append(handler)

    def publish(self, topic: str, data: Any, publisher: str = &quot;unknown&quot;):
        event = {&quot;topic&quot;: topic, &quot;data&quot;: data, &quot;publisher&quot;: publisher}
        self._event_log.append(event)
        for handler in self._subscribers.get(topic, []):
            handler(event)

    def get_event_log(self) -&gt; list[dict]:
        return list(self._event_log)
</code></pre>
<p><strong>优点</strong>：Agent 之间完全解耦——发布者不知道有谁在监听，订阅者不知道事件从哪里来。扩展性好，新增 Agent 只需订阅相关事件。</p>
<p><strong>缺点</strong>：事件流难以追踪——&quot;这个事件是谁发的？谁处理了？处理结果在哪里？&quot;调试时需要完整的事件日志。事件顺序可能不确定，需要额外的排序机制。</p>
<h3>3.4 通信机制对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>Blackboard</th>
<th>Message Passing</th>
<th>Event Bus</th>
</tr>
</thead>
<tbody><tr>
<td>耦合度</td>
<td>低（通过 key 间接通信）</td>
<td>中（需要知道目标 Agent）</td>
<td>低（通过 topic 间接通信）</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>低</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>调试友好度</td>
<td>中（看状态快照）</td>
<td>高（消息链路清晰）</td>
<td>低（事件流分散）</td>
</tr>
<tr>
<td>并发安全</td>
<td>需要锁/MVCC</td>
<td>天然安全（队列隔离）</td>
<td>需要考虑处理顺序</td>
</tr>
<tr>
<td>适用模式</td>
<td>Supervisor-Worker</td>
<td>Peer-to-Peer</td>
<td>Pipeline, 事件驱动架构</td>
</tr>
<tr>
<td>可观测性</td>
<td>状态快照</td>
<td>消息轨迹</td>
<td>事件日志</td>
</tr>
</tbody></table>
<p><strong>实践建议</strong>：大多数 Multi-Agent 系统可以从 Blackboard 开始——它最简单，且对 Supervisor-Worker 模式特别友好。当系统复杂度增长到需要解耦 Agent 间关系时，再考虑 Event Bus。Message Passing 适合 Agent 之间有明确的、频繁的双向交互的场景。</p>
<hr>
<h2>4. 完整实现：Supervisor-Worker 协作框架</h2>
<p>下面用 Python 从零实现一个 Supervisor-Worker 框架。这不依赖任何 Agent 框架，完全基于第一性原理构建。</p>
<h3>4.1 基础抽象</h3>
<pre><code class="language-python">import json
import asyncio
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any


# ---- LLM 调用抽象（与具体 SDK 解耦）----

async def call_llm(
    messages: list[dict],
    model: str = &quot;gpt-4o&quot;,
    response_format: dict | None = None,
) -&gt; str:
    &quot;&quot;&quot;LLM 调用的统一接口（简化版，生产中替换为真实 SDK 调用）&quot;&quot;&quot;
    import openai
    client = openai.AsyncOpenAI()
    kwargs = {&quot;model&quot;: model, &quot;messages&quot;: messages}
    if response_format:
        kwargs[&quot;response_format&quot;] = response_format
    response = await client.chat.completions.create(**kwargs)
    return response.choices[0].message.content


# ---- 任务与结果的数据结构 ----

@dataclass
class Task:
    &quot;&quot;&quot;一个可执行的子任务&quot;&quot;&quot;
    task_id: str
    description: str
    assigned_to: str = &quot;&quot;          # Worker Agent 名称
    context: dict = field(default_factory=dict)  # 来自上游的上下文
    status: str = &quot;pending&quot;        # pending | running | done | failed
    result: str = &quot;&quot;
    error: str = &quot;&quot;


@dataclass
class TeamResult:
    &quot;&quot;&quot;团队执行的最终结果&quot;&quot;&quot;
    success: bool
    output: str
    tasks: list[Task]
    total_tokens: int = 0
    total_llm_calls: int = 0
</code></pre>
<h3>4.2 Worker Agent</h3>
<p>每个 Worker 是一个专注于特定领域的 Agent，拥有独立的 System Prompt 和能力边界。</p>
<pre><code class="language-python">class WorkerAgent:
    &quot;&quot;&quot;Worker Agent：接收子任务，独立执行，返回结果&quot;&quot;&quot;

    def __init__(self, name: str, system_prompt: str, model: str = &quot;gpt-4o&quot;):
        self.name = name
        self.system_prompt = system_prompt
        self.model = model
        self._call_count = 0

    async def execute(self, task: Task) -&gt; Task:
        &quot;&quot;&quot;执行一个子任务&quot;&quot;&quot;
        task.status = &quot;running&quot;
        task.assigned_to = self.name

        messages = [
            {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: self.system_prompt},
            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: self._build_prompt(task)},
        ]

        try:
            result = await call_llm(messages, model=self.model)
            self._call_count += 1
            task.result = result
            task.status = &quot;done&quot;
        except Exception as e:
            task.error = str(e)
            task.status = &quot;failed&quot;

        return task

    def _build_prompt(self, task: Task) -&gt; str:
        prompt = f&quot;## 任务\n{task.description}\n&quot;
        if task.context:
            prompt += f&quot;\n## 上下文信息\n{json.dumps(task.context, ensure_ascii=False, indent=2)}\n&quot;
        prompt += &quot;\n请完成上述任务，直接输出结果。&quot;
        return prompt
</code></pre>
<h3>4.3 Supervisor Agent</h3>
<p>Supervisor 负责三件事：任务分解、任务分配、结果合成。</p>
<pre><code class="language-python">DECOMPOSE_PROMPT = &quot;&quot;&quot;你是一个任务分解专家。给定一个复杂任务，将其分解为可以独立执行的子任务。

可用的 Worker 及其能力：
{workers_description}

请将任务分解为子任务，并指定每个子任务应该分配给哪个 Worker。
输出 JSON 格式：
{{
  &quot;subtasks&quot;: [
    {{
      &quot;task_id&quot;: &quot;task_1&quot;,
      &quot;description&quot;: &quot;具体的子任务描述&quot;,
      &quot;assigned_to&quot;: &quot;worker 名称&quot;,
      &quot;depends_on&quot;: []
    }}
  ]
}}

注意：
- 每个子任务应该足够具体，让 Worker 能独立完成
- depends_on 标明依赖关系（某个子任务需要等另一个完成后才能开始）
- 尽可能让子任务并行执行以提高效率
&quot;&quot;&quot;

SYNTHESIZE_PROMPT = &quot;&quot;&quot;你是一个结果合成专家。多个专业 Agent 已经分别完成了子任务。
请根据它们的结果，合成一个完整、连贯、高质量的最终输出。

原始任务：{original_task}

各子任务的执行结果：
{subtask_results}

请整合以上信息，生成最终的完整输出。确保：
1. 信息完整，没有遗漏
2. 逻辑连贯，前后一致
3. 去除重复内容
4. 保持专业质量
&quot;&quot;&quot;


class SupervisorAgent:
    &quot;&quot;&quot;Supervisor Agent：任务分解、分配、合成&quot;&quot;&quot;

    def __init__(self, model: str = &quot;gpt-4o&quot;):
        self.model = model
        self._call_count = 0

    async def decompose(
        self, task: str, workers: dict[str, WorkerAgent]
    ) -&gt; list[Task]:
        &quot;&quot;&quot;将复杂任务分解为子任务&quot;&quot;&quot;
        workers_desc = &quot;\n&quot;.join(
            f&quot;- {name}: {w.system_prompt[:200]}&quot;
            for name, w in workers.items()
        )

        messages = [
            {
                &quot;role&quot;: &quot;system&quot;,
                &quot;content&quot;: DECOMPOSE_PROMPT.format(
                    workers_description=workers_desc
                ),
            },
            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: task},
        ]

        result = await call_llm(
            messages,
            model=self.model,
            response_format={&quot;type&quot;: &quot;json_object&quot;},
        )
        self._call_count += 1

        parsed = json.loads(result)
        tasks = []
        for st in parsed.get(&quot;subtasks&quot;, []):
            tasks.append(Task(
                task_id=st[&quot;task_id&quot;],
                description=st[&quot;description&quot;],
                assigned_to=st.get(&quot;assigned_to&quot;, &quot;&quot;),
            ))
        return tasks

    async def synthesize(
        self, original_task: str, completed_tasks: list[Task]
    ) -&gt; str:
        &quot;&quot;&quot;合成所有 Worker 的结果&quot;&quot;&quot;
        results_text = &quot;\n\n&quot;.join(
            f&quot;### {t.task_id} ({t.assigned_to})\n{t.result}&quot;
            for t in completed_tasks
            if t.status == &quot;done&quot;
        )

        messages = [
            {
                &quot;role&quot;: &quot;system&quot;,
                &quot;content&quot;: SYNTHESIZE_PROMPT.format(
                    original_task=original_task,
                    subtask_results=results_text,
                ),
            },
            {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;请合成最终结果。&quot;},
        ]

        result = await call_llm(messages, model=self.model)
        self._call_count += 1
        return result
</code></pre>
<h3>4.4 AgentTeam：编排层</h3>
<p>AgentTeam 管理多个 Agent 的生命周期、通信和执行流程。</p>
<pre><code class="language-python">class AgentTeam:
    &quot;&quot;&quot;Agent 团队：管理 Supervisor + Workers 的协作&quot;&quot;&quot;

    def __init__(self, supervisor: SupervisorAgent):
        self.supervisor = supervisor
        self.workers: dict[str, WorkerAgent] = {}
        self.blackboard = Blackboard()
        self.execution_log: list[dict] = []

    def add_worker(self, worker: WorkerAgent):
        self.workers[worker.name] = worker

    async def run(self, task: str, max_retries: int = 2) -&gt; TeamResult:
        &quot;&quot;&quot;执行完整的 Multi-Agent 协作流程&quot;&quot;&quot;
        self._log(&quot;team&quot;, f&quot;接收任务: {task[:100]}...&quot;)

        # Phase 1: Supervisor 分解任务
        self._log(&quot;supervisor&quot;, &quot;开始任务分解&quot;)
        subtasks = await self.supervisor.decompose(task, self.workers)
        self._log(&quot;supervisor&quot;, f&quot;分解为 {len(subtasks)} 个子任务&quot;)

        for st in subtasks:
            self._log(&quot;supervisor&quot;, f&quot;  {st.task_id} -&gt; {st.assigned_to}: {st.description[:80]}&quot;)

        # Phase 2: Workers 并行执行（考虑依赖关系）
        completed = await self._execute_tasks(subtasks, max_retries)

        # Phase 3: Supervisor 合成结果
        self._log(&quot;supervisor&quot;, &quot;开始合成结果&quot;)
        final_output = await self.supervisor.synthesize(task, completed)
        self._log(&quot;supervisor&quot;, &quot;合成完成&quot;)

        # 汇总统计
        total_calls = self.supervisor._call_count + sum(
            w._call_count for w in self.workers.values()
        )

        return TeamResult(
            success=all(t.status == &quot;done&quot; for t in completed),
            output=final_output,
            tasks=completed,
            total_llm_calls=total_calls,
        )

    async def _execute_tasks(
        self, tasks: list[Task], max_retries: int
    ) -&gt; list[Task]:
        &quot;&quot;&quot;执行子任务，支持并行和重试&quot;&quot;&quot;
        completed = []
        pending = list(tasks)

        while pending:
            # 找出当前可以执行的任务（依赖已满足）
            ready = []
            still_pending = []
            completed_ids = {t.task_id for t in completed}

            for task in pending:
                deps = task.context.get(&quot;depends_on&quot;, [])
                if all(d in completed_ids for d in deps):
                    ready.append(task)
                else:
                    still_pending.append(task)

            if not ready:
                # 没有可执行的任务但还有待处理的 -&gt; 可能存在循环依赖
                self._log(&quot;team&quot;, &quot;警告: 检测到无法满足的依赖关系&quot;)
                break

            # 并行执行所有就绪的任务
            results = await asyncio.gather(*[
                self._execute_single(task, max_retries)
                for task in ready
            ])

            for task in results:
                completed.append(task)
                # 将结果写入 Blackboard，供后续任务使用
                if task.status == &quot;done&quot;:
                    self.blackboard.write(
                        task.task_id, task.result, author=task.assigned_to
                    )

            pending = still_pending

        return completed

    async def _execute_single(
        self, task: Task, max_retries: int
    ) -&gt; Task:
        &quot;&quot;&quot;执行单个任务，带重试&quot;&quot;&quot;
        worker = self.workers.get(task.assigned_to)
        if not worker:
            task.status = &quot;failed&quot;
            task.error = f&quot;未找到 Worker: {task.assigned_to}&quot;
            return task

        # 将 Blackboard 上的相关信息注入任务上下文
        task.context[&quot;blackboard&quot;] = self.blackboard.read_all()

        for attempt in range(max_retries + 1):
            self._log(worker.name, f&quot;执行 {task.task_id} (尝试 {attempt + 1})&quot;)
            result = await worker.execute(task)

            if result.status == &quot;done&quot;:
                self._log(worker.name, f&quot;{task.task_id} 完成&quot;)
                return result

            self._log(worker.name, f&quot;{task.task_id} 失败: {result.error}&quot;)

            if attempt &lt; max_retries:
                self._log(worker.name, f&quot;准备重试 {task.task_id}&quot;)

        return result

    def _log(self, source: str, message: str):
        entry = {&quot;source&quot;: source, &quot;message&quot;: message}
        self.execution_log.append(entry)
</code></pre>
<h3>4.5 组装示例：技术调研报告</h3>
<pre><code class="language-python">async def main():
    &quot;&quot;&quot;示例：用 Multi-Agent 团队撰写一篇技术调研报告&quot;&quot;&quot;

    # 创建 Supervisor
    supervisor = SupervisorAgent(model=&quot;gpt-4o&quot;)

    # 创建专业化的 Worker Agent
    search_agent = WorkerAgent(
        name=&quot;searcher&quot;,
        system_prompt=(
            &quot;你是一个信息搜索专家。你的任务是根据给定的主题，&quot;
            &quot;整理出全面的信息摘要，包括关键事实、数据、案例。&quot;
            &quot;输出结构化的搜索结果，标注来源和可信度。&quot;
        ),
    )

    analyze_agent = WorkerAgent(
        name=&quot;analyst&quot;,
        system_prompt=(
            &quot;你是一个技术分析专家。你的任务是根据搜索结果和原始数据，&quot;
            &quot;进行深度分析，提炼洞察，识别趋势、风险和机会。&quot;
            &quot;输出包含数据支撑的分析报告。&quot;
        ),
    )

    write_agent = WorkerAgent(
        name=&quot;writer&quot;,
        system_prompt=(
            &quot;你是一个技术写作专家。你的任务是根据分析结果，&quot;
            &quot;撰写结构清晰、逻辑严谨、可读性强的技术报告。&quot;
            &quot;确保使用专业术语，并配有合适的章节结构。&quot;
        ),
    )

    # 组建团队
    team = AgentTeam(supervisor=supervisor)
    team.add_worker(search_agent)
    team.add_worker(analyze_agent)
    team.add_worker(write_agent)

    # 执行任务
    result = await team.run(
        &quot;撰写一篇关于 LLM Agent 在企业客服场景落地的技术调研报告，&quot;
        &quot;包括行业现状、主流技术方案对比、落地挑战和建议。&quot;
    )

    print(f&quot;成功: {result.success}&quot;)
    print(f&quot;LLM 调用次数: {result.total_llm_calls}&quot;)
    print(f&quot;\n最终输出:\n{result.output[:500]}...&quot;)

    # 查看执行日志
    print(&quot;\n执行链路:&quot;)
    for entry in team.execution_log:
        print(f&quot;  [{entry[&#39;source&#39;]}] {entry[&#39;message&#39;]}&quot;)


# asyncio.run(main())
</code></pre>
<p>这段代码展示了核心的协作模式。生产系统中还需要补充：Token 用量追踪、超时控制、Worker 健康检查、结果缓存等。但架构骨架已经清晰——Supervisor 负责全局调度，Worker 负责局部执行，Blackboard 负责状态共享，AgentTeam 负责生命周期管理。</p>
<hr>
<h2>5. 状态管理的复杂性</h2>
<p>Multi-Agent 系统的状态管理比 Single-Agent 复杂一个数量级。核心难题在于：多个 Agent 同时操作状态，如何保证一致性。</p>
<h3>5.1 共享状态 vs 独立状态</h3>
<pre><code>方案 A：共享状态                     方案 B：独立状态
┌─────────────────┐                ┌──────────┐  ┌──────────┐  ┌──────────┐
│  Global State   │                │ State A  │  │ State B  │  │ State C  │
│                 │                │ (Agent A │  │ (Agent B │  │ (Agent C │
│ Agent A ──write │                │  独占)   │  │  独占)   │  │  独占)   │
│ Agent B ──write │                └──────────┘  └──────────┘  └──────────┘
│ Agent C ──write │                      │              │              │
└─────────────────┘                      └──────────────┼──────────────┘
                                                        ▼
                                                  合并/同步层
</code></pre>
<p><strong>共享状态</strong>的优点是 Agent 之间信息同步即时，任何 Agent 都能看到最新全局状态。缺点是需要处理并发冲突。适合 Supervisor-Worker 模式——Supervisor 需要看到所有 Worker 的进度。</p>
<p><strong>独立状态</strong>的优点是无并发问题，每个 Agent 完全自主。缺点是 Agent 之间信息同步有延迟，需要显式的合并机制。适合 Pipeline 模式——每个阶段独立处理，只在交接时传递状态。</p>
<h3>5.2 冲突解决策略</h3>
<p>当两个 Agent 同时修改同一个状态时，需要冲突解决。常见策略：</p>
<pre><code class="language-python">class ConflictResolver:
    &quot;&quot;&quot;状态冲突解决器&quot;&quot;&quot;

    @staticmethod
    def last_writer_wins(old_value, new_value_a, new_value_b, timestamp_a, timestamp_b):
        &quot;&quot;&quot;最后写入者胜出——简单但可能丢失数据&quot;&quot;&quot;
        return new_value_a if timestamp_a &gt; timestamp_b else new_value_b

    @staticmethod
    def merge_append(old_value, new_value_a, new_value_b):
        &quot;&quot;&quot;合并追加——适用于列表类型的状态&quot;&quot;&quot;
        if isinstance(old_value, list):
            merged = list(old_value)
            if isinstance(new_value_a, list):
                merged.extend(new_value_a)
            if isinstance(new_value_b, list):
                merged.extend(new_value_b)
            return merged
        return new_value_b  # fallback

    @staticmethod
    async def llm_resolve(old_value, new_value_a, new_value_b, context: str):
        &quot;&quot;&quot;用 LLM 判断如何合并冲突——最灵活但最贵&quot;&quot;&quot;
        prompt = (
            f&quot;两个 Agent 同时修改了同一个状态。\n&quot;
            f&quot;原始值: {old_value}\n&quot;
            f&quot;Agent A 的修改: {new_value_a}\n&quot;
            f&quot;Agent B 的修改: {new_value_b}\n&quot;
            f&quot;上下文: {context}\n&quot;
            f&quot;请决定最终值应该是什么，并解释原因。&quot;
        )
        return await call_llm([{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt}])
</code></pre>
<p>实践中，大多数 Multi-Agent 系统通过架构设计来避免冲突，而不是在运行时解决冲突。最有效的方法是<strong>状态分区</strong>——每个 Agent 只写自己负责的状态区域，避免多 Agent 写同一个 key。这也是 Supervisor-Worker 模式天然的优势：每个 Worker 写自己的结果 key，只有 Supervisor 读所有 key。</p>
<hr>
<h2>6. 错误处理与容错</h2>
<p>Multi-Agent 系统的错误处理比 Single-Agent 更复杂，因为错误的传播路径更多。</p>
<h3>6.1 Worker 失败</h3>
<p>Worker 失败是最常见的情况。处理策略按优先级：</p>
<pre><code>Worker 失败处理决策树：

  Worker 执行失败
       │
       ▼
  ┌─ 是否可重试？ ─── 是 ──→ 重试（最多 N 次）──→ 成功？──→ 继续
  │      │                                          │
  │     否                                         否
  │      │                                          │
  │      ▼                                          ▼
  │  ┌─ 有替代 Worker？ ─── 是 ──→ 分配给替代 Worker
  │  │      │
  │  │     否
  │  │      │
  │  │      ▼
  │  │  ┌─ 该子任务是关键路径？
  │  │  │      │            │
  │  │  │     是           否
  │  │  │      │            │
  │  │  │      ▼            ▼
  │  │  │  整体任务失败   降级处理（跳过该子任务，
  │  │  │                 标记结果为不完整）
</code></pre>
<pre><code class="language-python">class ResilientAgentTeam(AgentTeam):
    &quot;&quot;&quot;增强容错能力的 Agent 团队&quot;&quot;&quot;

    def __init__(self, supervisor: SupervisorAgent):
        super().__init__(supervisor)
        self.fallback_workers: dict[str, list[str]] = {}  # Worker 降级链

    def set_fallback(self, worker_name: str, fallbacks: list[str]):
        &quot;&quot;&quot;设置 Worker 的降级替代链&quot;&quot;&quot;
        self.fallback_workers[worker_name] = fallbacks

    async def _execute_single(self, task: Task, max_retries: int) -&gt; Task:
        &quot;&quot;&quot;增强版：支持 Worker 降级&quot;&quot;&quot;
        # 尝试主 Worker
        result = await super()._execute_single(task, max_retries)
        if result.status == &quot;done&quot;:
            return result

        # 主 Worker 失败，尝试降级 Worker
        fallbacks = self.fallback_workers.get(task.assigned_to, [])
        for fb_name in fallbacks:
            self._log(&quot;team&quot;, f&quot;降级: {task.assigned_to} -&gt; {fb_name}&quot;)
            task.assigned_to = fb_name
            task.status = &quot;pending&quot;
            task.error = &quot;&quot;
            result = await super()._execute_single(task, max_retries=1)
            if result.status == &quot;done&quot;:
                return result

        return result
</code></pre>
<h3>6.2 Supervisor 失败</h3>
<p>Supervisor 失败更严重——它是中央协调者，失败意味着整个任务无法继续。处理策略：</p>
<ul>
<li><strong>外部监控</strong>：在 AgentTeam 之上设置一个非 LLM 的监控层，检测 Supervisor 的健康状态</li>
<li><strong>Supervisor 冗余</strong>：准备一个备用 Supervisor（可以用不同的模型），主 Supervisor 失败时切换</li>
<li><strong>Checkpoint 机制</strong>：Supervisor 在每个决策点保存状态快照，失败后从最近的 Checkpoint 恢复</li>
</ul>
<pre><code class="language-python">async def run_with_checkpoint(self, task: str) -&gt; TeamResult:
    &quot;&quot;&quot;带 Checkpoint 的执行流程&quot;&quot;&quot;
    checkpoint = {&quot;phase&quot;: &quot;init&quot;, &quot;subtasks&quot;: [], &quot;completed&quot;: []}

    try:
        # Phase 1: 分解
        checkpoint[&quot;phase&quot;] = &quot;decompose&quot;
        subtasks = await self.supervisor.decompose(task, self.workers)
        checkpoint[&quot;subtasks&quot;] = subtasks

        # Phase 2: 执行
        checkpoint[&quot;phase&quot;] = &quot;execute&quot;
        completed = await self._execute_tasks(subtasks, max_retries=2)
        checkpoint[&quot;completed&quot;] = completed

        # Phase 3: 合成
        checkpoint[&quot;phase&quot;] = &quot;synthesize&quot;
        output = await self.supervisor.synthesize(task, completed)

        return TeamResult(success=True, output=output, tasks=completed)

    except Exception as e:
        self._log(&quot;team&quot;, f&quot;失败于阶段 {checkpoint[&#39;phase&#39;]}: {e}&quot;)
        # 可以从 checkpoint 恢复，跳过已完成的阶段
        return TeamResult(
            success=False,
            output=f&quot;任务在 {checkpoint[&#39;phase&#39;]} 阶段失败: {e}&quot;,
            tasks=checkpoint.get(&quot;completed&quot;, []),
        )
</code></pre>
<h3>6.3 死锁检测</h3>
<p>在 Peer-to-Peer 模式中，两个 Agent 可能互相等待对方的回复，形成死锁。</p>
<pre><code>死锁场景：

  Agent A: &quot;请 Agent B 先确认方案&quot;
           ↓ 等待 B
  Agent B: &quot;请 Agent A 先提供数据&quot;
           ↓ 等待 A
  → 无限等待
</code></pre>
<p>解决方案：</p>
<pre><code class="language-python">class DeadlockDetector:
    &quot;&quot;&quot;简单的死锁检测器&quot;&quot;&quot;

    def __init__(self, timeout_seconds: float = 60):
        self.timeout = timeout_seconds
        self._waiting: dict[str, str] = {}  # agent_id -&gt; waiting_for_agent_id

    def register_wait(self, agent_id: str, waiting_for: str):
        self._waiting[agent_id] = waiting_for
        # 检测环形等待
        if self._has_cycle(agent_id):
            raise DeadlockError(
                f&quot;检测到死锁: {self._trace_cycle(agent_id)}&quot;
            )

    def _has_cycle(self, start: str) -&gt; bool:
        visited = set()
        current = start
        while current in self._waiting:
            if current in visited:
                return True
            visited.add(current)
            current = self._waiting[current]
        return False

    def _trace_cycle(self, start: str) -&gt; str:
        chain = [start]
        current = self._waiting.get(start, &quot;&quot;)
        while current != start and current:
            chain.append(current)
            current = self._waiting.get(current, &quot;&quot;)
        chain.append(start)
        return &quot; -&gt; &quot;.join(chain)


class DeadlockError(Exception):
    pass
</code></pre>
<hr>
<h2>7. Multi-Agent 的成本问题</h2>
<p>成本是 Multi-Agent 系统必须正视的问题。它不只是&quot;贵一点&quot;的问题——可能是&quot;贵一个数量级&quot;的问题。</p>
<h3>7.1 成本模型</h3>
<pre><code>Single-Agent 执行一个任务的 Token 消耗：

  1 x System Prompt   +  N x (Context + Response)
  ~1,000 tokens          ~3,000 tokens x 5 iterations
                         = ~16,000 tokens


Multi-Agent (Supervisor + 3 Workers) 的 Token 消耗：

  Supervisor 分解:   ~4,000 tokens   (System Prompt + 任务分解)
  Worker A 执行:     ~8,000 tokens   (System Prompt + 执行)
  Worker B 执行:     ~8,000 tokens   (System Prompt + 执行)
  Worker C 执行:     ~8,000 tokens   (System Prompt + 执行)
  Supervisor 合成:   ~6,000 tokens   (收集所有结果 + 合成)
                     ──────────────
  Total:             ~34,000 tokens   ← 约 2x Single-Agent

  如果 Worker 内部也有多轮迭代，消耗会更高。
</code></pre>
<h3>7.2 什么时候 Multi-Agent 的收益大于成本</h3>
<p>不是所有场景都值得用 Multi-Agent。一个简单的决策框架：</p>
<pre><code>                        任务复杂度
                    低 ─────────── 高
                    │               │
  专业化需求  低    │  Single-Agent │  Single-Agent
              │    │  (够用)       │  + Better Prompt
              │    │               │
              高    │  Single-Agent │  Multi-Agent ✓
                    │  + Tools      │  (值得投入)
                    │               │
</code></pre>
<p>Multi-Agent 在以下条件下收益最大：</p>
<ol>
<li><strong>任务天然可并行</strong>：子任务之间独立性高，Multi-Agent 通过并行执行缩短总耗时，即使 token 消耗增加，时间成本下降</li>
<li><strong>专业化收益显著</strong>：专家 Agent 在自己的领域比通用 Agent 的输出质量显著更高，质量提升值得额外成本</li>
<li><strong>Single-Agent 已经到达能力瓶颈</strong>：Context Window 不够、单个 prompt 角色冲突、输出质量不稳定</li>
<li><strong>任务的商业价值足够高</strong>：生成一份价值数万元的分析报告，多花几美元的 API 费用是可以接受的</li>
</ol>
<h3>7.3 成本优化策略</h3>
<pre><code class="language-python">class CostAwareTeam(AgentTeam):
    &quot;&quot;&quot;成本感知的 Agent 团队&quot;&quot;&quot;

    def __init__(self, supervisor, token_budget: int = 100_000):
        super().__init__(supervisor)
        self.token_budget = token_budget
        self.token_used = 0

    def _select_model_for_task(self, task: Task) -&gt; str:
        &quot;&quot;&quot;根据任务复杂度选择模型——不是所有子任务都需要最强模型&quot;&quot;&quot;
        if task.context.get(&quot;complexity&quot;) == &quot;low&quot;:
            return &quot;gpt-4o-mini&quot;     # 简单任务用小模型
        elif task.context.get(&quot;complexity&quot;) == &quot;high&quot;:
            return &quot;gpt-4o&quot;          # 复杂任务用大模型
        else:
            return &quot;gpt-4o-mini&quot;     # 默认用小模型，够用即可

    def _should_continue(self) -&gt; bool:
        &quot;&quot;&quot;预算检查&quot;&quot;&quot;
        if self.token_used &gt;= self.token_budget:
            self._log(&quot;team&quot;, f&quot;Token 预算耗尽 ({self.token_used}/{self.token_budget})&quot;)
            return False
        return True
</code></pre>
<p>关键原则：<strong>Router 和 Supervisor 可以用轻量模型，只有需要深度推理的 Worker 才用重量级模型。</strong> 这类似人类组织中，项目经理不需要是技术最强的人，但专家必须在各自领域足够专业。</p>
<hr>
<h2>8. Multi-Agent 的调试挑战</h2>
<p>Multi-Agent 系统的调试难度是 Single-Agent 的平方级增长——不仅每个 Agent 内部可能出错，Agent 之间的交互也可能出错。</p>
<h3>8.1 执行链路追踪</h3>
<p>每次 Multi-Agent 执行都应该生成一个完整的 Trace，记录每个 Agent 的每次 LLM 调用、输入、输出和耗时。</p>
<pre><code class="language-python">import time
import uuid
from dataclasses import dataclass, field


@dataclass
class Span:
    &quot;&quot;&quot;一个执行跨度（对应一次 Agent 操作）&quot;&quot;&quot;
    span_id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    parent_id: str = &quot;&quot;
    agent_name: str = &quot;&quot;
    operation: str = &quot;&quot;          # &quot;decompose&quot;, &quot;execute&quot;, &quot;synthesize&quot;
    input_summary: str = &quot;&quot;
    output_summary: str = &quot;&quot;
    start_time: float = 0.0
    end_time: float = 0.0
    token_count: int = 0
    status: str = &quot;running&quot;      # running | done | failed
    children: list = field(default_factory=list)

    @property
    def duration_ms(self) -&gt; float:
        return (self.end_time - self.start_time) * 1000


class Tracer:
    &quot;&quot;&quot;Multi-Agent 执行链路追踪器&quot;&quot;&quot;

    def __init__(self):
        self.root_span: Span | None = None
        self._span_stack: list[Span] = []

    def start_span(self, agent_name: str, operation: str, input_summary: str = &quot;&quot;) -&gt; Span:
        span = Span(
            agent_name=agent_name,
            operation=operation,
            input_summary=input_summary[:200],
            start_time=time.time(),
        )
        if self._span_stack:
            parent = self._span_stack[-1]
            span.parent_id = parent.span_id
            parent.children.append(span)
        else:
            self.root_span = span

        self._span_stack.append(span)
        return span

    def end_span(self, output_summary: str = &quot;&quot;, status: str = &quot;done&quot;):
        if self._span_stack:
            span = self._span_stack.pop()
            span.end_time = time.time()
            span.output_summary = output_summary[:200]
            span.status = status

    def print_trace(self, span: Span = None, indent: int = 0):
        &quot;&quot;&quot;打印可视化的执行链路&quot;&quot;&quot;
        span = span or self.root_span
        if not span:
            return

        prefix = &quot;  &quot; * indent
        status_icon = &quot;OK&quot; if span.status == &quot;done&quot; else &quot;FAIL&quot;
        print(
            f&quot;{prefix}[{status_icon}] {span.agent_name}.{span.operation} &quot;
            f&quot;({span.duration_ms:.0f}ms)&quot;
        )
        if span.input_summary:
            print(f&quot;{prefix}  IN:  {span.input_summary[:80]}&quot;)
        if span.output_summary:
            print(f&quot;{prefix}  OUT: {span.output_summary[:80]}&quot;)

        for child in span.children:
            self.print_trace(child, indent + 1)
</code></pre>
<p>输出示例：</p>
<pre><code>[OK] supervisor.decompose (2340ms)
  IN:  撰写一篇关于 LLM Agent 在企业客服场景落地的技术调研报告...
  OUT: {&quot;subtasks&quot;: [{&quot;task_id&quot;: &quot;task_1&quot;, ...}, ...]}
  [OK] searcher.execute (5120ms)
    IN:  搜索 LLM Agent 客服场景的行业现状和主流方案...
    OUT: ## 行业现状\n1. 2024 年全球智能客服市场规模...
  [OK] analyst.execute (4800ms)
    IN:  分析搜索结果，提炼关键洞察和趋势...
    OUT: ## 分析结论\n1. 技术成熟度：LLM 客服处于...
  [OK] writer.execute (6200ms)
    IN:  根据分析结果撰写完整的技术调研报告...
    OUT: # LLM Agent 企业客服落地技术调研报告\n\n## 1. 执行摘要...
[OK] supervisor.synthesize (3100ms)
  IN:  请合成最终结果。
  OUT: # LLM Agent 企业客服落地技术调研报告（终稿）...
</code></pre>
<h3>8.2 Bug 复现</h3>
<p>Multi-Agent 场景的 bug 复现特别困难，因为：</p>
<ul>
<li>LLM 输出是非确定性的——相同输入可能产生不同输出</li>
<li>Agent 之间的交互是动态的——执行路径取决于中间结果</li>
<li>并发执行的时序不确定——Worker A 和 B 谁先完成可能影响最终结果</li>
</ul>
<p>应对策略：</p>
<ol>
<li><strong>记录完整的 LLM 输入/输出</strong>：在 Trace 中保存每次 LLM 调用的完整 messages 和 response，不只是摘要</li>
<li><strong>Deterministic Replay</strong>：用固定的 seed 和 temperature=0 复现执行，或者直接 mock LLM 响应</li>
<li><strong>快照式调试</strong>：在每个 Agent 决策点保存完整的 Blackboard 状态快照，出问题时可以回溯到任意时间点</li>
</ol>
<pre><code class="language-python">class ReplayableTeam(AgentTeam):
    &quot;&quot;&quot;可回放的 Agent 团队——记录完整的 LLM 交互供复现&quot;&quot;&quot;

    def __init__(self, supervisor):
        super().__init__(supervisor)
        self._llm_recordings: list[dict] = []

    def record_llm_call(self, agent_name: str, messages: list[dict], response: str):
        self._llm_recordings.append({
            &quot;agent&quot;: agent_name,
            &quot;messages&quot;: messages,
            &quot;response&quot;: response,
            &quot;timestamp&quot;: time.time(),
        })

    def save_recording(self, path: str):
        &quot;&quot;&quot;保存录制数据，用于后续回放和调试&quot;&quot;&quot;
        with open(path, &quot;w&quot;) as f:
            json.dump(self._llm_recordings, f, ensure_ascii=False, indent=2)
</code></pre>
<h3>8.3 可观测性设计</h3>
<p>一个生产级 Multi-Agent 系统至少需要以下可观测性指标：</p>
<table>
<thead>
<tr>
<th>指标类别</th>
<th>具体指标</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td><strong>延迟</strong></td>
<td>每个 Agent 的执行时间、端到端总时间</td>
<td>定位性能瓶颈</td>
</tr>
<tr>
<td><strong>成本</strong></td>
<td>每个 Agent 的 Token 消耗、总消耗</td>
<td>成本监控和预算控制</td>
</tr>
<tr>
<td><strong>质量</strong></td>
<td>任务成功率、重试次数、降级次数</td>
<td>评估系统可靠性</td>
</tr>
<tr>
<td><strong>链路</strong></td>
<td>完整的 Trace（Agent、操作、输入、输出）</td>
<td>问题排查</td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td>Blackboard 的状态变更历史</td>
<td>数据流追踪</td>
</tr>
<tr>
<td><strong>通信</strong></td>
<td>Agent 间消息数量、消息大小</td>
<td>通信效率分析</td>
</tr>
</tbody></table>
<hr>
<h2>9. 设计 Multi-Agent 系统的决策清单</h2>
<p>在你决定构建 Multi-Agent 系统之前，逐一回答以下问题：</p>
<p><strong>必要性验证</strong>：</p>
<ul>
<li>单个 Agent 真的不够吗？是否尝试过优化 prompt、增加工具、使用更强的模型？</li>
<li>任务是否天然需要多角色/多视角？还是只是因为你觉得&quot;多 Agent 更酷&quot;？</li>
<li>团队的 LLM API 预算能否支撑多 Agent 的额外消耗？</li>
</ul>
<p><strong>架构选择</strong>：</p>
<ul>
<li>任务结构更接近哪种模式？Supervisor-Worker / Peer-to-Peer / Pipeline / Dynamic Routing？</li>
<li>Agent 之间需要什么样的通信？单向传递 / 双向协商 / 广播通知？</li>
<li>状态应该共享还是独立？冲突解决策略是什么？</li>
</ul>
<p><strong>工程保障</strong>：</p>
<ul>
<li>每个 Agent 的失败影响范围是什么？有降级方案吗？</li>
<li>如何追踪一个请求在多个 Agent 之间的完整执行链路？</li>
<li>如何测试多 Agent 协作的正确性——单元测试（单个 Agent）+ 集成测试（Agent 交互）？</li>
</ul>
<hr>
<h2>10. 结语与展望</h2>
<p>本文是 Phase 3（How to Scale Agent Intelligence）的最后一篇。在 Phase 3 的四篇文章中，我们从单个 Agent 的四个维度进行了升级：</p>
<pre><code>Phase 3 知识路线：

  第 08 篇 Memory       → Agent 有了&quot;记忆&quot;
  第 09 篇 RAG          → Agent 有了&quot;外部知识&quot;
  第 10 篇 Planning     → Agent 有了&quot;规划和反思&quot;
  第 11 篇 Multi-Agent  → Agent 有了&quot;团队协作&quot;（本文）
</code></pre>
<p>至此，我们已经拥有构建一个&quot;聪明的&quot; Agent 系统所需的全部核心概念。但&quot;聪明&quot;不等于&quot;可用&quot;。一个在本地跑通 demo 的 Multi-Agent 系统，距离生产环境还有巨大的鸿沟——框架选型、协议标准化、可观测性、安全性、成本控制、评估体系。</p>
<p>这正是 Phase 4（How to Ship Agents to Production）要解决的问题：</p>
<ul>
<li><strong>下一篇（12）</strong>：LangChain vs LangGraph —— 你应该用框架还是自己写？框架的价值边界在哪里？我们会从 Chain 和 Graph 两种抽象出发，讨论框架在什么时候是加速器，什么时候是束缚。</li>
<li><strong>第 13 篇</strong>：MCP and Tool Protocol —— Agent 的工具需要标准化。MCP 协议如何让不同 Agent 共享工具？工具的发现、声明、权限控制。</li>
<li><strong>第 14 篇</strong>：Production-Grade Agent Systems —— 最后一篇，打通最后一公里：评估、安全、成本、灰度、监控。</li>
</ul>
<h3>进一步思考</h3>
<p><strong>关于协作模式的演化</strong>：本文介绍的四种模式是&quot;纯模式&quot;。真实系统中，你很可能需要混合模式——比如 Supervisor-Worker 的 Worker 内部用 Pipeline，或者 Dynamic Routing 的专家 Agent 内部用 Peer-to-Peer 辩论。如何设计这种嵌套的多层协作结构，是一个值得深入探索的方向。</p>
<p><strong>关于 Agent 的涌现行为</strong>：当多个 Agent 协作时，是否会出现超越单个 Agent 能力的&quot;涌现行为&quot;？还是说 Multi-Agent 的上限永远被最强的那个 Agent 决定？这个问题在学术界尚无定论，但从实践角度看，好的协作架构确实能产出超越任何单个 Agent 的结果——正如一个好的工程团队能完成任何个人都无法独自完成的项目。</p>
<p><strong>关于 Human-in-the-Loop</strong>：本文讨论的全是 Agent-to-Agent 的协作。但在生产环境中，最重要的&quot;Agent&quot;可能是人类。如何设计一个 Multi-Agent 系统，让人类能在关键节点介入、审核和纠正？Human-Agent 协作可能比 Agent-Agent 协作更有实用价值，也更有挑战性。</p>
<hr>
<blockquote>
<p><strong>系列导航</strong>：本文是 Agentic 系列的第 11 篇。</p>
<ul>
<li>上一篇：<a href="/blog/engineering/agentic/10-Planning%20and%20Reflection">10 | Planning and Reflection</a></li>
<li>下一篇：<a href="/blog/engineering/agentic/12-LangChain%20vs%20LangGraph">12 | LangChain vs LangGraph</a></li>
<li>完整目录：<a href="/blog/engineering/agentic/01-From%20LLM%20to%20Agent">01 | From LLM to Agent</a></li>
</ul>
</blockquote>
18:Taba2,<h1>MCP and Tool Protocol: Agent 工具的协议化未来</h1>
<blockquote>
<p>每一次技术生态的成熟，都伴随着协议的诞生。Web 有 HTTP，邮件有 SMTP，实时通信有 WebSocket。当 Agent 从实验走向生产，工具调用也必然需要自己的协议层。</p>
<p>本文是 Agentic 系列第 13 篇。我们将从当前工具集成的痛点出发，深入分析 MCP（Model Context Protocol）的设计哲学与技术细节，探讨工具协议化对 Agent 生态的深远影响。</p>
</blockquote>
<hr>
<h2>1. 开篇：重复造轮子的困境</h2>
<p>假设你正在构建一个 Agent，需要它能够：查询 Jira 工单、读取 GitHub PR、搜索 Confluence 文档、发送 Slack 消息。</p>
<p>如果你用 LangChain，你需要找到或编写四个 LangChain Tool wrapper。如果明天切换到 LlamaIndex，这四个 wrapper 全部作废。如果后天决定用 OpenAI Assistants API，又得按 Function Calling 的 schema 再来一遍。<strong>同样的能力，被实现了三遍。</strong></p>
<p>这个问题并不新鲜。Web 技术演进史上，我们见过完全相同的模式：</p>
<pre><code>早期 Web：每个 CGI 脚本都有自己的通信方式
  → HTTP 统一了通信 → REST 统一了风格 → OpenAPI 统一了描述

Agent 工具（当前）：每个框架都有自己的工具定义格式
  → ??? 统一工具通信 → ??? 统一工具描述 → ??? 统一工具发现
</code></pre>
<p>从 CGI 到 HTTP，Web 用了十年。Agent 工具生态能更快吗？MCP 正在尝试回答这个问题。</p>
<hr>
<h2>2. 工具集成的现状与问题</h2>
<h3>2.1 五大痛点</h3>
<p><strong>硬编码模式</strong>：工具在代码中写死，新增工具需要改代码、重新部署。<strong>框架绑定</strong>：LangChain Tool、OpenAI Function、Anthropic Tool 各有格式，互不兼容——工具提供者要么选边站，要么维护三份代码。<strong>缺乏发现机制</strong>：Agent 不知道有哪些工具可用。<strong>缺乏权限控制</strong>：Agent 可以调用任何已注册的工具。<strong>缺乏版本管理</strong>：工具升级可能静默破坏 Agent 行为。</p>
<h3>2.2 N x M 集成问题</h3>
<p>这些痛点的根源，是经典的 <strong>N x M 集成问题</strong>：</p>
<pre><code>当前：N 个框架 × M 个工具 = N×M 个适配器

  ┌──────────┐   ┌──────────┐   ┌──────────┐
  │LangChain │   │LlamaIndex│   │  OpenAI  │
  └──┬─┬─┬───┘   └──┬─┬─┬───┘   └──┬─┬─┬───┘
     │ │ │          │ │ │          │ │ │
     ▼ ▼ ▼          ▼ ▼ ▼          ▼ ▼ ▼       ← 15 个适配器
  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
  │ Jira │ │GitHub│ │Slack │ │  DB  │ │Search│
  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘

期望：通过协议层解耦，N + M

  ┌──────────┐   ┌──────────┐   ┌──────────┐
  │LangChain │   │LlamaIndex│   │  OpenAI  │
  └────┬─────┘   └────┬─────┘   └────┬─────┘
       ▼               ▼               ▼
  ┌──────────────────────────────────────────┐
  │           标准化协议层（MCP）              │
  └──┬───────┬───────┬───────┬───────┬───────┘
     ▼       ▼       ▼       ▼       ▼         ← 8 个实现
  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
  │ Jira │ │GitHub│ │Slack │ │  DB  │ │Search│
  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘
</code></pre>
<p><strong>将 N x M 降为 N + M</strong>——这正是 MCP 试图解决的核心问题。</p>
<hr>
<h2>3. MCP 深入分析</h2>
<h3>3.1 什么是 MCP</h3>
<p>MCP（Model Context Protocol）是 Anthropic 于 2024 年末提出的开放协议，定义了 AI 应用与外部工具/数据源之间的标准化通信方式。不绑定任何特定 LLM 或框架。</p>
<p>类比：<strong>USB-C 之于硬件外设，正如 MCP 之于 Agent 工具。</strong> 没有 USB-C 时，每个设备一种接口；有了 USB-C，一个接口连接一切。MCP 的目标是同样的——一个协议连接所有工具。</p>
<h3>3.2 核心架构：Host → Client → Server</h3>
<pre><code>┌─────────────────────────────────────────────────────┐
│  Host (Claude Desktop / IDE / 自定义 Agent)           │
│                                                      │
│  ┌────────────────────────────────────────────────┐  │
│  │              MCP Client                        │  │
│  └───┬──────────────┬──────────────┬──────────────┘  │
└──────┼──────────────┼──────────────┼─────────────────┘
       │              │              │
       ▼              ▼              ▼
┌────────────┐ ┌────────────┐ ┌────────────┐
│ MCP Server │ │ MCP Server │ │ MCP Server │
│  (GitHub)  │ │  (Slack)   │ │ (Database) │
│ Tools:     │ │ Tools:     │ │ Tools:     │
│ -search    │ │ -send_msg  │ │ -query     │
│ -create_pr │ │ -list_ch   │ │ -insert    │
└────────────┘ └────────────┘ └────────────┘
</code></pre>
<ul>
<li><strong>Host</strong>：最终用户面对的应用，创建和管理 MCP Client 实例。</li>
<li><strong>Client</strong>：协议客户端，与 Server 保持一对一连接，负责能力协商与请求路由。</li>
<li><strong>Server</strong>：工具/数据提供者，暴露 Tools、Resources 和 Prompts。轻量级，不需了解 LLM。</li>
</ul>
<h3>3.3 三大原语</h3>
<p>MCP 定义了三种核心原语，覆盖 Agent 与外部世界交互的主要模式：</p>
<pre><code>┌────────────┬──────────────┬──────────────────────────────┐
│   原语      │  控制权归属    │  语义                        │
├────────────┼──────────────┼──────────────────────────────┤
│  Tools     │  Model 控制   │  可执行操作，LLM 自主决定调用  │
│  Resources │  App 控制     │  可读数据源，Host 决定读取     │
│  Prompts   │  User 控制    │  交互模板，用户显式选择        │
└────────────┴──────────────┴──────────────────────────────┘
</code></pre>
<p>这种<strong>分层控制</strong>是 MCP 设计中最精妙的部分——避免&quot;一切交给 LLM&quot;的风险，保留人类最终控制权。Tools 是 Agent 的&quot;手&quot;，Resources 是&quot;眼&quot;，Prompts 是&quot;工作手册&quot;。</p>
<hr>
<h2>4. 通信机制</h2>
<h3>4.1 传输层</h3>
<p><strong>stdio</strong>：本地进程间通信。零网络开销、简单可靠，但仅限同一台机器。<br><strong>HTTP + SSE</strong>：远程服务通信。Client 通过 HTTP POST 发请求，Server 通过 SSE 推响应。2025 年的 Streamable HTTP 更新进一步统一了远程传输层。</p>
<h3>4.2 消息格式：JSON-RPC 2.0</h3>
<p>MCP 使用成熟的 JSON-RPC 2.0（2010 年发布，大量现成实现）：</p>
<pre><code class="language-json">// 请求
{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1, &quot;method&quot;: &quot;tools/call&quot;,
 &quot;params&quot;: {&quot;name&quot;: &quot;query_db&quot;, &quot;arguments&quot;: {&quot;sql&quot;: &quot;SELECT * FROM users&quot;}}}

// 响应
{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;id&quot;: 1,
 &quot;result&quot;: {&quot;content&quot;: [{&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Found 42 users...&quot;}]}}
</code></pre>
<h3>4.3 生命周期</h3>
<pre><code>Client                                       Server
  │  ① initialize (clientInfo, capabilities)    │
  │ ───────────────────────────────────────────▶│
  │  ② response (serverInfo, capabilities)      │
  │◀─────────────────────────────────────────── │
  │  ③ notifications/initialized                │
  │ ───────────────────────────────────────────▶│
  │  ④ Normal: tools/list, tools/call ...       │
  │◀───────────────────────────────────────────▶│
  │  ⑤ Shutdown                                 │
</code></pre>
<p>初始化阶段的<strong>能力协商</strong>是关键设计——Client 和 Server 各自声明支持的能力，只使用交集。这使得旧 Client 可以连新 Server，只是无法使用新功能。</p>
<h3>4.4 一次完整的工具调用</h3>
<p>关键设计：<strong>LLM 不直接与 MCP Server 通信</strong>。LLM 只表达&quot;我想调用某工具&quot;，Host 运行时执行实际 MCP 调用。这层间接性让 Host 可以在调用前进行权限检查、参数验证、用户确认。</p>
<pre><code>User → Host: &quot;查询活跃用户&quot;
Host → LLM:  消息 + 可用工具列表
LLM  → Host: tool_use: query_db(sql=&quot;...&quot;)
Host → MCP Client → MCP Server: tools/call
MCP Server → MCP Client → Host: 结果
Host → LLM:  工具结果 + 继续对话
LLM  → Host: &quot;共 42 个活跃用户&quot;
Host → User: 最终回答
</code></pre>
<hr>
<h2>5. 实现一个 MCP Server</h2>
<p>使用官方 <code>mcp</code> Python SDK 实现一个项目管理工具 Server：</p>
<pre><code class="language-python">from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent, Resource
import json, asyncio

server = Server(&quot;project-manager&quot;)
TASKS = {
    &quot;TASK-001&quot;: {&quot;title&quot;: &quot;实现用户认证&quot;, &quot;status&quot;: &quot;done&quot;, &quot;assignee&quot;: &quot;alice&quot;},
    &quot;TASK-002&quot;: {&quot;title&quot;: &quot;设计 DB schema&quot;, &quot;status&quot;: &quot;in_progress&quot;, &quot;assignee&quot;: &quot;bob&quot;},
    &quot;TASK-003&quot;: {&quot;title&quot;: &quot;编写 API 文档&quot;, &quot;status&quot;: &quot;todo&quot;, &quot;assignee&quot;: &quot;alice&quot;},
}

@server.list_tools()
async def list_tools() -&gt; list[Tool]:
    return [
        Tool(name=&quot;list_tasks&quot;,
             description=&quot;列出项目任务，可按状态和负责人筛选&quot;,
             inputSchema={&quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: {
                 &quot;status&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [&quot;todo&quot;, &quot;in_progress&quot;, &quot;done&quot;]},
                 &quot;assignee&quot;: {&quot;type&quot;: &quot;string&quot;},
             }}),
        Tool(name=&quot;update_task_status&quot;,
             description=&quot;更新任务状态&quot;,
             inputSchema={&quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: {
                 &quot;task_id&quot;: {&quot;type&quot;: &quot;string&quot;},
                 &quot;new_status&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [&quot;todo&quot;, &quot;in_progress&quot;, &quot;done&quot;]},
             }, &quot;required&quot;: [&quot;task_id&quot;, &quot;new_status&quot;]}),
    ]

@server.call_tool()
async def call_tool(name: str, arguments: dict) -&gt; list[TextContent]:
    if name == &quot;list_tasks&quot;:
        results = {tid: t for tid, t in TASKS.items()
                   if (not arguments.get(&quot;status&quot;) or t[&quot;status&quot;] == arguments[&quot;status&quot;])
                   and (not arguments.get(&quot;assignee&quot;) or t[&quot;assignee&quot;] == arguments[&quot;assignee&quot;])}
        return [TextContent(type=&quot;text&quot;, text=json.dumps(results, ensure_ascii=False, indent=2))]
    elif name == &quot;update_task_status&quot;:
        tid, ns = arguments[&quot;task_id&quot;], arguments[&quot;new_status&quot;]
        if tid not in TASKS:
            return [TextContent(type=&quot;text&quot;, text=f&quot;任务 {tid} 不存在&quot;)]
        old = TASKS[tid][&quot;status&quot;]
        TASKS[tid][&quot;status&quot;] = ns
        return [TextContent(type=&quot;text&quot;, text=f&quot;已将 {tid} 从 {old} 更新为 {ns}&quot;)]
    return [TextContent(type=&quot;text&quot;, text=f&quot;未知工具: {name}&quot;)]

@server.list_resources()
async def list_resources() -&gt; list[Resource]:
    return [Resource(uri=&quot;project://tasks/summary&quot;, name=&quot;项目任务总览&quot;,
                     description=&quot;任务统计摘要&quot;, mimeType=&quot;application/json&quot;)]

@server.read_resource()
async def read_resource(uri: str) -&gt; str:
    if str(uri) == &quot;project://tasks/summary&quot;:
        summary = {&quot;total&quot;: len(TASKS), &quot;by_status&quot;: {}, &quot;by_assignee&quot;: {}}
        for t in TASKS.values():
            summary[&quot;by_status&quot;][t[&quot;status&quot;]] = summary[&quot;by_status&quot;].get(t[&quot;status&quot;], 0) + 1
            summary[&quot;by_assignee&quot;][t[&quot;assignee&quot;]] = summary[&quot;by_assignee&quot;].get(t[&quot;assignee&quot;], 0) + 1
        return json.dumps(summary, ensure_ascii=False, indent=2)
    raise ValueError(f&quot;未知资源: {uri}&quot;)

async def main():
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<p>核心模式：<strong>声明式工具注册</strong>（<code>list_tools</code> 返回名称、描述、JSON Schema）→ <strong>请求路由</strong>（<code>call_tool</code> 根据工具名分发）→ <strong>资源暴露</strong>（URI 标识的可读数据源）→ <strong>传输透明</strong>（同一份代码可跑 stdio 或 HTTP）。</p>
<p>Host 通过配置文件声明连接：</p>
<pre><code class="language-json">{
    &quot;mcpServers&quot;: {
        &quot;project-manager&quot;: {
            &quot;command&quot;: &quot;python&quot;,
            &quot;args&quot;: [&quot;path/to/server.py&quot;]
        },
        &quot;github&quot;: {
            &quot;command&quot;: &quot;npx&quot;,
            &quot;args&quot;: [&quot;-y&quot;, &quot;@modelcontextprotocol/server-github&quot;],
            &quot;env&quot;: {&quot;GITHUB_TOKEN&quot;: &quot;ghp_xxxx&quot;}
        }
    }
}
</code></pre>
<h3>5.1 实现一个 MCP Client</h3>
<p>上面实现了 Server 端。现在看另一半——Client 如何连接 Server、发现工具、并与 LLM Agent 循环集成。</p>
<p>以下代码展示一个完整的 MCP Client，它连接 Server、获取工具列表、将工具转换为 LLM Function Calling 格式、并在 Agent 循环中路由 LLM 的 <code>tool_use</code> 请求回 MCP：</p>
<pre><code class="language-python">from mcp import ClientSession
from mcp.client.stdio import stdio_client, StdioServerParameters
import json, asyncio

class MCPAgentClient:
    &quot;&quot;&quot;MCP Client：连接 Server，桥接 LLM Function Calling&quot;&quot;&quot;

    def __init__(self, server_command: str, server_args: list[str]):
        self.server_params = StdioServerParameters(
            command=server_command, args=server_args
        )
        self.session: ClientSession | None = None
        self._tools_cache: list[dict] = []

    async def connect(self, read_stream, write_stream):
        &quot;&quot;&quot;建立连接并完成初始化握手&quot;&quot;&quot;
        self.session = ClientSession(read_stream, write_stream)
        await self.session.initialize()
        # 初始化后立即拉取工具列表
        await self.refresh_tools()

    async def refresh_tools(self):
        &quot;&quot;&quot;从 Server 获取最新工具列表&quot;&quot;&quot;
        result = await self.session.list_tools()
        self._tools_cache = [
            {
                &quot;name&quot;: tool.name,
                &quot;description&quot;: tool.description,
                &quot;input_schema&quot;: tool.inputSchema
            }
            for tool in result.tools
        ]

    def get_tools_for_llm(self) -&gt; list[dict]:
        &quot;&quot;&quot;将 MCP 工具转换为 LLM Function Calling 格式

        关键桥接：MCP 工具描述 → LLM 能理解的 function schema
        不同 LLM 的格式略有差异，这里以常见格式为例。
        &quot;&quot;&quot;
        return [
            {
                &quot;type&quot;: &quot;function&quot;,
                &quot;function&quot;: {
                    &quot;name&quot;: tool[&quot;name&quot;],
                    &quot;description&quot;: tool[&quot;description&quot;],
                    &quot;parameters&quot;: tool[&quot;input_schema&quot;]
                }
            }
            for tool in self._tools_cache
        ]

    async def route_tool_call(self, tool_name: str, arguments: dict) -&gt; str:
        &quot;&quot;&quot;将 LLM 的 tool_use 请求路由到 MCP Server&quot;&quot;&quot;
        result = await self.session.call_tool(tool_name, arguments)
        # 提取文本内容返回给 LLM
        return &quot;\n&quot;.join(
            block.text for block in result.content
            if hasattr(block, &quot;text&quot;)
        )


async def agent_loop(llm_client, mcp_client: MCPAgentClient):
    &quot;&quot;&quot;Agent 主循环：LLM 决策 → MCP 执行 → 结果反馈&quot;&quot;&quot;
    tools = mcp_client.get_tools_for_llm()
    messages = [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;帮我看看 alice 有哪些进行中的任务&quot;}]

    while True:
        response = await llm_client.chat(messages=messages, tools=tools)

        # LLM 没有调用工具，对话结束
        if not response.tool_calls:
            print(f&quot;Agent: {response.content}&quot;)
            break

        # LLM 请求调用工具 → 路由到 MCP Server
        for call in response.tool_calls:
            tool_result = await mcp_client.route_tool_call(
                call.function.name,
                json.loads(call.function.arguments)
            )
            messages.append({
                &quot;role&quot;: &quot;tool&quot;,
                &quot;tool_call_id&quot;: call.id,
                &quot;content&quot;: tool_result
            })


async def main():
    client = MCPAgentClient(&quot;python&quot;, [&quot;server.py&quot;])
    async with stdio_client(client.server_params) as (read, write):
        await client.connect(read, write)
        print(f&quot;已连接，发现 {len(client._tools_cache)} 个工具：&quot;)
        for t in client._tools_cache:
            print(f&quot;  - {t[&#39;name&#39;]}: {t[&#39;description&#39;]}&quot;)
        # await agent_loop(llm_client, client)

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<p>核心模式总结：<strong>连接与握手</strong>（<code>initialize</code> 完成能力协商）→ <strong>工具发现</strong>（<code>list_tools</code> 获取 Server 暴露的所有工具）→ <strong>格式转换</strong>（MCP Tool schema → LLM Function Calling schema，这是 Client 的关键职责）→ <strong>请求路由</strong>（LLM 输出 <code>tool_use</code> → Client 调用 <code>call_tool</code> → 结果回填到对话上下文）。</p>
<p>注意 Client 在架构中的定位：它是 <strong>LLM 世界与 MCP 世界之间的翻译层</strong>。LLM 不知道 MCP 的存在，MCP Server 不知道 LLM 的存在。Client 把两边连接起来，同时也是插入权限检查、参数验证、超时控制等逻辑的最佳位置。</p>
<hr>
<h2>6. 工具发现与动态注册</h2>
<p><strong>静态发现</strong>：配置文件声明所有 Server，Host 启动时初始化。简单可靠，但新增 Server 需重启。</p>
<p><strong>动态发现</strong>：MCP 支持 <code>notifications/tools/list_changed</code> 通知——Server 可在运行时告知 Client 工具列表变更，无需重启连接。</p>
<p>更大的愿景是<strong>工具注册中心（Tool Registry）</strong>——Agent 在运行时查询&quot;有哪些 MCP Server 可用&quot;，按需连接。本质上是 Agent 版的 Service Discovery。</p>
<p>与传统 Service Discovery 的核心区别：传统消费者是确定性代码（知道要调哪个 API），MCP 消费者是 LLM（根据自然语言意图选工具）。因此工具描述的<strong>语义质量</strong>至关重要——模糊的 description 会导致 LLM 误选工具。</p>
<hr>
<h2>7. 安全与权限控制</h2>
<h3>7.1 威胁模型</h3>
<p>Agent 工具调用面临五类威胁：<strong>Prompt Injection</strong>（诱导调用不该调用的工具）、<strong>权限越权</strong>（只读 Agent 执行写入）、<strong>数据泄露</strong>（敏感数据通过 LLM 响应外泄）、<strong>恶意 Server</strong>（第三方 Server 返回恶意内容）、<strong>参数篡改</strong>（被诱导传入 SQL 注入等恶意参数）。</p>
<h3>7.2 防护策略</h3>
<p><strong>工具级 ACL</strong>：在 Host 层实现访问控制——白名单/黑名单决定哪些 Agent 可调用哪些工具。</p>
<p><strong>参数级约束</strong>：即使允许调用，也限制参数范围（如 SQL 工具只允许 SELECT、禁止 DROP/DELETE）。</p>
<p><strong>Human-in-the-Loop</strong>：高风险操作（写入、删除、发送消息）要求用户显式确认后再执行。</p>
<p><strong>审计日志</strong>：记录所有工具调用的时间戳、Agent ID、工具名、参数、结果、耗时、状态。</p>
<pre><code class="language-python"># 工具级 ACL 示例
async def guarded_tool_call(agent_id: str, tool_name: str, arguments: dict):
    perms = TOOL_PERMISSIONS[agent_id]
    if tool_name in perms[&quot;denied&quot;]:
        raise PermissionError(f&quot;{agent_id} cannot call {tool_name}&quot;)
    # 参数验证
    validate_arguments(tool_name, arguments)
    # 高风险确认
    if tool_name in HIGH_RISK_TOOLS:
        if not await prompt_user(f&quot;允许调用 {tool_name}? [y/n]&quot;):
            return {&quot;error&quot;: &quot;用户拒绝&quot;}
    return await mcp_client.call_tool(tool_name, arguments)
</code></pre>
<h3>7.3 Sandbox 执行</h3>
<p>MCP 的 stdio 模式天然提供进程级隔离。更严格的方案：容器隔离（Docker）→ VM 隔离（Firecracker）→ WASM 沙箱。执行不可信代码的 Server，容器隔离是最低要求。</p>
<h3>7.4 错误处理与容错</h3>
<p>MCP Server 的错误最终会进入 LLM 的上下文窗口。这意味着错误信息的设计有双重读者——<strong>人类开发者</strong>需要 debug 信息，<strong>LLM</strong> 需要可理解、可行动的恢复指引。</p>
<p><strong>错误传播设计原则</strong>：</p>
<pre><code>❌ 糟糕的错误：  &quot;Internal Server Error&quot;
   → LLM 无法理解原因，只能对用户说 &quot;出了点问题&quot;

❌ 过于技术化：  &quot;psycopg2.OperationalError: connection refused on port 5432&quot;
   → LLM 不知道该重试还是放弃

✅ 面向 LLM 的错误：  &quot;数据库连接暂时不可用。这是临时性故障，建议等待 30 秒后重试。
   如果多次重试仍失败，请告知用户数据库服务可能在维护中。&quot;
</code></pre>
<p>核心思路：错误信息中要包含<strong>原因分类</strong>（临时故障/参数错误/权限不足）、<strong>建议动作</strong>（重试/换参数/告知用户），以及<strong>足够的上下文</strong>让 LLM 能生成有意义的回复。</p>
<p><strong>Timeout 与 Retry 策略</strong>：MCP 工具调用需要明确的超时边界。没有 timeout 的工具调用可能永远挂起，阻塞整个 Agent 循环。Retry 应使用 exponential backoff，且只对临时性故障重试（网络超时、服务暂时不可用），对确定性错误（参数无效、权限不足）不应重试。</p>
<p><strong>Circuit Breaker 模式</strong>：对于不可靠的外部 Server，连续失败应触发熔断，避免浪费 LLM tokens 反复尝试一个已知不可用的服务。</p>
<p>以下是一个整合 timeout、retry 和 circuit breaker 的 MCP Client 容错封装：</p>
<pre><code class="language-python">import asyncio
import time
from dataclasses import dataclass, field
from mcp import ClientSession

@dataclass
class CircuitBreaker:
    &quot;&quot;&quot;简单的 Circuit Breaker：连续失败超过阈值则熔断&quot;&quot;&quot;
    failure_threshold: int = 5
    recovery_timeout: float = 60.0  # 熔断恢复等待时间（秒）
    _failure_count: int = field(default=0, init=False)
    _last_failure_time: float = field(default=0.0, init=False)
    _state: str = field(default=&quot;closed&quot;, init=False)  # closed / open / half_open

    def record_success(self):
        self._failure_count = 0
        self._state = &quot;closed&quot;

    def record_failure(self):
        self._failure_count += 1
        self._last_failure_time = time.time()
        if self._failure_count &gt;= self.failure_threshold:
            self._state = &quot;open&quot;

    def allow_request(self) -&gt; bool:
        if self._state == &quot;closed&quot;:
            return True
        if self._state == &quot;open&quot;:
            if time.time() - self._last_failure_time &gt; self.recovery_timeout:
                self._state = &quot;half_open&quot;
                return True  # 允许试探性请求
            return False
        return True  # half_open: 允许一次试探

class ResilientMCPClient:
    &quot;&quot;&quot;带容错能力的 MCP Client 封装&quot;&quot;&quot;

    def __init__(self, session: ClientSession, timeout: float = 30.0,
                 max_retries: int = 3, base_delay: float = 1.0):
        self.session = session
        self.timeout = timeout
        self.max_retries = max_retries
        self.base_delay = base_delay
        self._breakers: dict[str, CircuitBreaker] = {}

    def _get_breaker(self, tool_name: str) -&gt; CircuitBreaker:
        if tool_name not in self._breakers:
            self._breakers[tool_name] = CircuitBreaker()
        return self._breakers[tool_name]

    async def call_tool(self, tool_name: str, arguments: dict) -&gt; dict:
        breaker = self._get_breaker(tool_name)

        if not breaker.allow_request():
            return {
                &quot;error&quot;: f&quot;工具 {tool_name} 当前不可用（连续失败已触发熔断）。&quot;
                         f&quot;请告知用户该服务暂时不可用，大约 {breaker.recovery_timeout} 秒后可重试。&quot;
            }

        last_error = None
        for attempt in range(self.max_retries):
            try:
                result = await asyncio.wait_for(
                    self.session.call_tool(tool_name, arguments),
                    timeout=self.timeout
                )
                breaker.record_success()
                return {&quot;content&quot;: result.content}

            except asyncio.TimeoutError:
                last_error = f&quot;工具 {tool_name} 调用超时（&gt;{self.timeout}s）&quot;
                breaker.record_failure()
            except Exception as e:
                if _is_permanent_error(e):
                    # 参数错误、权限不足等确定性失败，不重试
                    return {&quot;error&quot;: f&quot;工具调用失败：{e}。请检查参数后重新尝试。&quot;}
                last_error = str(e)
                breaker.record_failure()

            if attempt &lt; self.max_retries - 1:
                delay = self.base_delay * (2 ** attempt)  # exponential backoff
                await asyncio.sleep(delay)

        return {&quot;error&quot;: f&quot;工具 {tool_name} 在 {self.max_retries} 次重试后仍然失败：{last_error}。&quot;
                         f&quot;这可能是临时性故障，建议稍后重试或告知用户。&quot;}

def _is_permanent_error(e: Exception) -&gt; bool:
    &quot;&quot;&quot;判断是否为确定性错误（不应重试）&quot;&quot;&quot;
    permanent_types = (ValueError, PermissionError, KeyError)
    return isinstance(e, permanent_types)
</code></pre>
<p>这个封装的设计思路：<strong>timeout 防挂起</strong>（每次调用有明确的时间上限）→ <strong>retry 抗抖动</strong>（临时性故障用 exponential backoff 重试）→ <strong>circuit breaker 防雪崩</strong>（连续失败后快速失败，避免反复调用一个已知坏掉的服务）→ <strong>LLM 友好的错误信息</strong>（每个错误路径都返回 LLM 可理解的文本描述）。</p>
<hr>
<h2>8. MCP 之外的协议探索</h2>
<p><strong>OpenAI Function Calling</strong>：定义了工具描述格式，但更多是 API 特性而非通信协议——没有定义工具发现、连接管理、生命周期。MCP 是完整的端到端协议。</p>
<p><strong>Google Genkit</strong>：跨语言 Agent 开发框架。注意区分：<strong>框架绑定实现</strong>（你的代码运行在框架中），<strong>协议解耦实现</strong>（你的代码遵循协议通信，实现自由选择）。</p>
<p><strong>Agent Protocol（by e2b）</strong>：标准化 Agent 本身的通信接口，与 MCP（Agent 与工具的通信）互补。</p>
<p><strong>OpenAPI / AsyncAPI</strong>：可用于工具描述，但缺少面向 LLM 优化的语义——工具描述需要让模型&quot;理解&quot;何时该用，而非只让人类开发者读懂。</p>
<p>趋势清晰：<strong>工具协议化正在发生</strong>。MCP 目前的优势在于开放协议、社区快速增长、设计简洁实用。</p>
<h3>8.1 协议对比矩阵</h3>
<p>以下从六个维度横向对比当前主要的工具/Agent 协议方案：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>MCP</th>
<th>OpenAI Function Calling</th>
<th>Google Genkit</th>
<th>Agent Protocol (e2b)</th>
<th>OpenAPI</th>
</tr>
</thead>
<tbody><tr>
<td><strong>工具发现</strong></td>
<td>动态发现，<code>tools/list</code> + <code>list_changed</code> 通知</td>
<td>无，工具需在请求中硬编码传入</td>
<td>框架内注册，支持反射式发现</td>
<td>无工具发现，聚焦 Agent 任务管理</td>
<td>静态，通过 spec 文件描述</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>JSON-RPC 2.0 over stdio / HTTP+SSE</td>
<td>HTTP API（嵌入 Chat Completion 请求）</td>
<td>框架内函数调用（Go/JS）</td>
<td>REST API（HTTP）</td>
<td>REST / HTTP</td>
</tr>
<tr>
<td><strong>安全模型</strong></td>
<td>Host 层 ACL + 参数约束 + Human-in-the-Loop</td>
<td>API Key 级别，无工具粒度控制</td>
<td>框架内中间件</td>
<td>API Token 认证</td>
<td>OAuth / API Key</td>
</tr>
<tr>
<td><strong>多语言支持</strong></td>
<td>Python, TypeScript, Java, Kotlin 等 SDK</td>
<td>任何能发 HTTP 的语言</td>
<td>Go, JavaScript/TypeScript</td>
<td>任何能发 HTTP 的语言</td>
<td>语言无关（spec 是 YAML/JSON）</td>
</tr>
<tr>
<td><strong>生态成熟度</strong></td>
<td>快速增长，1000+ 社区 Server</td>
<td>最大用户基数，但非独立协议</td>
<td>较新，Google 生态内使用</td>
<td>小众，e2b 社区为主</td>
<td>极成熟，但非 AI 原生</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>Agent ↔ 工具的标准化通信</td>
<td>单一 LLM 的工具调用</td>
<td>Google 生态内的全栈 AI 应用</td>
<td>Agent 间的任务编排与通信</td>
<td>传统 API 描述与集成</td>
</tr>
</tbody></table>
<p>几个关键观察：</p>
<p><strong>MCP 是唯一面向 Agent 工具设计的完整协议</strong>。Function Calling 只解决了&quot;LLM 怎么表达想调用工具&quot;，但没有解决&quot;工具怎么被发现、怎么连接、怎么管理生命周期&quot;。MCP 覆盖了从发现到调用到关闭的完整链路。</p>
<p><strong>OpenAPI 有潜力但缺 AI 语义</strong>。OpenAPI spec 描述了 API 的结构，但缺少面向 LLM 优化的语义层——什么时候该用这个 API？参数的哪些组合是有意义的？错误时该怎么恢复？这些信息在 OpenAPI spec 中要么缺失，要么只面向人类开发者。已有项目尝试将 OpenAPI spec 自动转换为 MCP Server，桥接两个生态。</p>
<p><strong>Agent Protocol 与 MCP 是互补关系</strong>。MCP 标准化 Agent 与工具的通信，Agent Protocol 标准化 Agent 与 Agent（或 Agent 与编排器）的通信。未来的 Multi-Agent 系统可能同时需要两者。</p>
<hr>
<h2>9. Trade-off 分析</h2>
<h3>9.1 标准化 vs 灵活性</h3>
<p>标准化收益显而易见（生态共享、减少重复、互操作），代价是表达力受限和演进惯性。关键判断：<strong>MCP 的抽象层次选得好</strong>。它定义通信方式但不限制工具实现——类似 HTTP 定义请求-响应模式但不限制 body 内容。</p>
<h3>9.2 额外复杂度</h3>
<p>没有 MCP 时工具就是函数调用。有了 MCP 需要进程管理、连接维护、序列化。决策框架：</p>
<pre><code>工具少（&lt; 5）且团队单一   → 直接硬编码
工具多（&gt; 10）且跨团队    → MCP 收益显现
工具需被多 Agent 共享     → MCP 几乎必需
工具需独立部署和升级      → MCP 最佳选择
</code></pre>
<h3>9.3 生态依赖</h3>
<p>MCP 由 Anthropic 主导——缓解策略：MIT 开源可 fork、Server 是独立进程（最坏只需换 Client）、核心业务逻辑应与协议层分离。<strong>投入合理，但要做好隔离。</strong></p>
<h3>9.4 性能</h3>
<p>stdio 通信 0.1-1ms，HTTP 通信 1-50ms，连接初始化 100ms-2s。相比 LLM 推理耗时（100ms-10s），<strong>MCP 性能开销可忽略</strong>。</p>
<hr>
<h2>10. 实践建议</h2>
<h3>10.1 工具描述的最佳实践</h3>
<p>这是最影响效果的环节。工具描述不是给人类读的 API 文档——它是 LLM 的决策依据。描述质量直接决定 Agent 选对工具的概率。</p>
<p><strong>反面示例</strong>：</p>
<pre><code class="language-python">Tool(
    name=&quot;search&quot;,
    description=&quot;Search for things&quot;,
    inputSchema={&quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: {
        &quot;q&quot;: {&quot;type&quot;: &quot;string&quot;},
    }}
)
</code></pre>
<p>问题：<code>search</code> 搜什么？&quot;things&quot; 是什么？参数 <code>q</code> 代表什么？LLM 无法准确判断何时应该调用这个工具。</p>
<p><strong>正面示例</strong>：</p>
<pre><code class="language-python">Tool(
    name=&quot;search_jira_issues&quot;,
    description=(
        &quot;在 Jira 中搜索 issue。适用场景：用户想查找 bug、需求、任务等工单。&quot;
        &quot;支持 JQL 语法。不适用于搜索 Confluence 文档或代码仓库。&quot;
        &quot;返回匹配的 issue 列表，包含 key、标题、状态、负责人。&quot;
        &quot;最多返回 50 条结果。&quot;
    ),
    inputSchema={&quot;type&quot;: &quot;object&quot;, &quot;properties&quot;: {
        &quot;jql&quot;: {
            &quot;type&quot;: &quot;string&quot;,
            &quot;description&quot;: &quot;Jira Query Language 查询语句，例如: &#39;project = BACKEND AND status = Open&#39;&quot;
        },
        &quot;max_results&quot;: {
            &quot;type&quot;: &quot;integer&quot;,
            &quot;description&quot;: &quot;最大返回条数，默认 20，最大 50&quot;,
            &quot;default&quot;: 20
        },
    }, &quot;required&quot;: [&quot;jql&quot;]}
)
</code></pre>
<p>关键原则：<strong>名称具体</strong>（<code>search_jira_issues</code> 而非 <code>search</code>）、<strong>描述含边界</strong>（说清楚能做什么和不能做什么）、<strong>参数有示例</strong>（LLM 看到 JQL 示例才知道该用什么语法）、<strong>返回值说明</strong>（LLM 知道能拿到什么，才能决定要不要调用）。</p>
<h3>10.2 Server 粒度设计</h3>
<p><strong>保持 Server 单一职责</strong>：<code>github-server</code>、<code>database-server</code>、<code>slack-server</code> 而非 <code>all-tools-server</code>——独立升级、细粒度权限、缩小故障面。</p>
<p>但&quot;单一职责&quot;的粒度怎么把握？以下是决策框架：</p>
<pre><code>何时拆分 Server：
  - 工具属于不同领域（GitHub vs Slack）         → 拆
  - 工具需要不同权限凭证                        → 拆
  - 工具有不同的故障域（一个挂了不该影响另一个）  → 拆
  - 工具需要独立的部署和升级周期                 → 拆

何时合并 Server：
  - 工具间共享状态（同一数据库连接）             → 合
  - 工具总是一起使用（read_file + write_file）   → 合
  - 工具数量少（&lt; 3）且属于同一上下文            → 合
</code></pre>
<p>实际案例——一个数据分析场景：</p>
<pre><code>❌ 过细：query-server, chart-server, export-server  （3 个进程管理成本高，且紧耦合）
❌ 过粗：analytics-server（含 20 个工具，LLM 选择困难）
✅ 合适：data-query-server（查询+聚合）, visualization-server（图表+导出）
</code></pre>
<h3>10.3 测试策略</h3>
<p>MCP Server 本质是一个暴露工具的进程，需要三层测试覆盖：</p>
<p><strong>单元测试</strong>：测试工具的核心逻辑，不涉及 MCP 协议。</p>
<pre><code class="language-python">import pytest

# 直接测试业务逻辑函数，不通过 MCP 协议
async def test_list_tasks_filter_by_status():
    result = filter_tasks(TASKS, status=&quot;in_progress&quot;)
    assert len(result) == 1
    assert &quot;TASK-002&quot; in result

async def test_update_task_nonexistent():
    with pytest.raises(TaskNotFoundError):
        update_task_status(&quot;TASK-999&quot;, &quot;done&quot;)
</code></pre>
<p><strong>集成测试</strong>：通过 MCP Client 连接 Server，测试完整的协议交互。</p>
<pre><code class="language-python">from mcp import ClientSession
from mcp.client.stdio import stdio_client, StdioServerParameters

async def test_mcp_tool_call():
    &quot;&quot;&quot;通过 MCP 协议发起完整的工具调用&quot;&quot;&quot;
    params = StdioServerParameters(command=&quot;python&quot;, args=[&quot;server.py&quot;])
    async with stdio_client(params) as (read, write):
        async with ClientSession(read, write) as session:
            await session.initialize()

            # 验证工具列表
            tools = await session.list_tools()
            tool_names = [t.name for t in tools.tools]
            assert &quot;list_tasks&quot; in tool_names

            # 验证工具调用
            result = await session.call_tool(&quot;list_tasks&quot;, {&quot;status&quot;: &quot;todo&quot;})
            assert &quot;TASK-003&quot; in result.content[0].text
</code></pre>
<p><strong>LLM 端到端测试</strong>：验证 LLM 在给定上下文中能正确选择和使用工具。这类测试成本高、有非确定性，但对关键流程不可或缺。</p>
<pre><code class="language-python">async def test_llm_selects_correct_tool():
    &quot;&quot;&quot;验证 LLM 面对用户意图时选择正确的工具&quot;&quot;&quot;
    tools = await get_tool_definitions()  # 从 MCP Server 获取
    response = await llm.chat(
        messages=[{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;帮我看看 alice 有哪些待做的任务&quot;}],
        tools=tools
    )
    # 断言 LLM 选择了 list_tasks 而非 update_task_status
    assert response.tool_calls[0].name == &quot;list_tasks&quot;
    assert response.tool_calls[0].arguments[&quot;assignee&quot;] == &quot;alice&quot;
    assert response.tool_calls[0].arguments[&quot;status&quot;] == &quot;todo&quot;
</code></pre>
<p><strong>做好错误处理</strong>：MCP Server 的错误会进入 LLM 上下文。清晰的错误信息（&quot;任务 TASK-999 不存在，请用 list_tasks 查看可用任务&quot;）能帮助 LLM 自我纠正。详见 7.4 节的错误处理设计。</p>
<hr>
<h2>11. 进一步思考</h2>
<p>MCP 正在快速演进，几个未解问题值得关注：</p>
<p><strong>工具组合</strong>：工具 A 输出作为工具 B 输入时，由 LLM 串联（灵活但低效）还是协议层支持工具链（高效但复杂）？</p>
<p><strong>有状态交互</strong>：当前每次调用独立。但数据库事务、多步操作需要跨调用的状态。如何在协议层表达？</p>
<p><strong>工具质量评估</strong>：Agent 如何判断 MCP Server 的描述是否准确、响应是否可靠？需要&quot;工具信誉系统&quot;。</p>
<p><strong>多模态工具</strong>：MCP 已支持 <code>ImageContent</code>，但多模态生态仍在早期。</p>
<p>长远来看，工具协议化的终局可能是一个<strong>去中心化的 Agent 工具市场</strong>——发布 MCP Server 如同发布 npm 包，Agent 在运行时动态发现、评估、连接、使用工具。协议保证互操作性，市场机制保证质量。</p>
<hr>
<h2>12. 总结</h2>
<ol>
<li><strong>当前工具集成不可持续</strong>。标准化协议将 N x M 降为 N + M。</li>
<li><strong>MCP 设计务实</strong>。三大原语覆盖主要交互模式，JSON-RPC 2.0 成熟可靠，双传输层适配不同场景。</li>
<li><strong>安全不是事后补丁</strong>。ACL、参数约束、Human-in-the-Loop、审计日志需在架构设计阶段考虑。</li>
<li><strong>协议化成本可控</strong>。性能可忽略，规模增长时收益迅速超过成本。</li>
<li><strong>保持务实的乐观</strong>。MCP 目前最有前途，但要做好业务逻辑与协议层的解耦。</li>
</ol>
<p>工具协议化是 Agent 生态从&quot;手工作坊&quot;走向&quot;工业化&quot;的关键一步。</p>
<blockquote>
<p><strong>系列导航</strong>：本文是 Agentic 系列的第 13 篇。</p>
<ul>
<li>上一篇：<a href="/blog/engineering/agentic/12-LangChain%20vs%20LangGraph">12 | LangChain vs LangGraph</a></li>
<li>下一篇：<a href="/blog/engineering/agentic/14-Production-Grade%20Agent%20Systems">14 | Production-Grade Agent Systems</a></li>
<li>完整目录：<a href="/blog/engineering/agentic/01-From%20LLM%20to%20Agent">01 | From LLM to Agent</a></li>
</ul>
</blockquote>
6:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2026-01-22","children":"2026年01月22日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"LangChain vs LangGraph: 框架的价值与边界"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L5","Agentic",{"href":"/blog/tag/Agentic/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Agentic"}],["$","$L5","AI Engineering",{"href":"/blog/tag/AI%20Engineering/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"AI Engineering"}],["$","$L5","Framework",{"href":"/blog/tag/Framework/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Framework"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$11",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/agentic/11-Multi-Agent Collaboration","title":"Multi-Agent Collaboration: 多 Agent 协作模式与架构","description":"单个 Agent 的能力有天花板——Context Window 有限、专业化受限、单点故障、串行瓶颈。本文系统拆解多 Agent 协作的四种核心模式（Supervisor-Worker、Peer-to-Peer、Pipeline、Dynamic Routing），深入 Agent 间通信机制、状态管理、错误处理与成本控制，并用 Python 从零实现一个 Supervisor-Worker 协作框架。","pubDate":"2026-01-17","tags":["Agentic","AI Engineering","Multi-Agent"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/agentic/13-MCP and Tool Protocol","title":"MCP and Tool Protocol: Agent 工具的协议化未来","description":"当前 Agent 工具集成面临 N×M 问题：每个框架、每个应用都在重复造轮子。MCP（Model Context Protocol）正在尝试成为 Agent 工具世界的 HTTP——一个标准化的通信协议。本文深入剖析 MCP 的架构设计、通信机制与安全模型，探讨工具协议化的趋势、trade-off 与未来走向。","pubDate":"2026-01-27","tags":["Agentic","AI Engineering","MCP","Protocol"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"Agentic":{"prev":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:next"},"AI Engineering":{"prev":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:next"},"Framework":{"prev":null,"next":null}}}]}],["$","$L19",null,{}]]}]}]}]
9:null
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
b:{"metadata":[["$","title","0",{"children":"LangChain vs LangGraph: 框架的价值与边界 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"Agentic 系列第 12 篇。客观审视 AI Agent 框架的价值与局限。深入分析 LangChain 的抽象模型与陷阱、LangGraph 的状态机优势与学习曲线，横向对比 CrewAI、AutoGen、Semantic Kernel 等框架，最终给出框架 vs 自研的决策矩阵。核心立场：理解原理再用框架，框架是加速器而非必需品。"}],["$","meta","2",{"property":"og:title","content":"LangChain vs LangGraph: 框架的价值与边界"}],["$","meta","3",{"property":"og:description","content":"Agentic 系列第 12 篇。客观审视 AI Agent 框架的价值与局限。深入分析 LangChain 的抽象模型与陷阱、LangGraph 的状态机优势与学习曲线，横向对比 CrewAI、AutoGen、Semantic Kernel 等框架，最终给出框架 vs 自研的决策矩阵。核心立场：理解原理再用框架，框架是加速器而非必需品。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2026-01-22"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"LangChain vs LangGraph: 框架的价值与边界"}],["$","meta","9",{"name":"twitter:description","content":"Agentic 系列第 12 篇。客观审视 AI Agent 框架的价值与局限。深入分析 LangChain 的抽象模型与陷阱、LangGraph 的状态机优势与学习曲线，横向对比 CrewAI、AutoGen、Semantic Kernel 等框架，最终给出框架 vs 自研的决策矩阵。核心立场：理解原理再用框架，框架是加速器而非必需品。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
13:{"metadata":"$b:metadata","error":null,"digest":"$undefined"}

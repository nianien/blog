1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/7dd6b3ec14b0b1d8.css","style"]
0:{"P":null,"b":"kLuGQpYNrv7rzQ0jpQCVp","p":"","c":["","blog","engineering","agentic","06-Prompt%20Engineering%20for%20Agents",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/agentic/06-Prompt%20Engineering%20for%20Agents","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7dd6b3ec14b0b1d8.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/agentic/06-Prompt%20Engineering%20for%20Agents","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","PIy94o8GagUPjmzlp9xqzv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1b:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:Td28a,<h1>Prompt Engineering for Agents: 面向 Agent 的提示词工程</h1>
<blockquote>
<p>Agentic 系列第 06 篇。前文我们讨论了 Tool Calling 的设计哲学与工程实践，LLM 已经具备了&quot;使用工具&quot;的能力。但工具只是 Agent 的四肢，Prompt 才是 Agent 的大脑皮层——它定义了 Agent 如何感知、如何推理、如何决策、如何行动。</p>
<p>本文的核心观点：<strong>Agent 的 Prompt 不是&quot;聊天提示词&quot;，而是&quot;系统接口规范&quot;。</strong> Chatbot 的 Prompt 追求对话自然，Agent 的 Prompt 追求行为可控。这两者的设计哲学截然不同。</p>
</blockquote>
<hr>
<h2>1. 从&quot;对话技巧&quot;到&quot;接口规范&quot;</h2>
<p>大多数人对 Prompt Engineering 的印象停留在&quot;写好提示词让 AI 回答更好&quot;的阶段。这在 Chatbot 场景下基本成立——你调整措辞、给几个例子、加一句&quot;请一步一步思考&quot;，模型输出的质量就会改善。</p>
<p>但 Agent 场景完全不同。</p>
<p>Agent 的 Prompt 不是写给&quot;一个聊天助手&quot;的，而是写给&quot;一个程序运行时&quot;的。它的目的不是让输出&quot;看起来更好&quot;，而是让输出<strong>可解析、可路由、可执行</strong>。一个 Agent Prompt 的失败，不是&quot;回答不够好&quot;，而是<strong>系统崩溃</strong>——JSON 解析失败、工具调用参数错误、无限循环、状态机卡死。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Chatbot Prompt</th>
<th>Agent Prompt</th>
</tr>
</thead>
<tbody><tr>
<td>目标</td>
<td>自然、有帮助的回复</td>
<td>可解析、可执行的结构化输出</td>
</tr>
<tr>
<td>消费者</td>
<td>人类用户</td>
<td>程序代码（Parser / Router / Executor）</td>
</tr>
<tr>
<td>失败模式</td>
<td>回答质量下降</td>
<td>系统崩溃、无限循环、安全漏洞</td>
</tr>
<tr>
<td>格式要求</td>
<td>宽松，Markdown 即可</td>
<td>严格，JSON / XML / 特定 Schema</td>
</tr>
<tr>
<td>可测试性</td>
<td>主观评估</td>
<td>可自动化断言</td>
</tr>
<tr>
<td>版本管理</td>
<td>通常不管理</td>
<td>必须版本控制，等同于代码</td>
</tr>
</tbody></table>
<p>这意味着，<strong>Agent 的 Prompt Engineering 本质上是一种接口设计（Interface Design）</strong>，而不是文案写作。</p>
<hr>
<h2>2. Agent Prompt 的分层架构</h2>
<p>一个成熟的 Agent 系统，发送给 LLM 的 Prompt 不是一坨字符串，而是多个层次动态组装的结果。</p>
<h3>2.1 四层结构</h3>
<pre><code>┌─────────────────────────────────────────────────────┐
│                   Final Prompt                       │
│  ┌───────────────────────────────────────────────┐  │
│  │  Layer 1: System Prompt (静态)                 │  │
│  │  - 身份定义（你是谁，你的职责是什么）            │  │
│  │  - 行为约束（必须做什么，禁止做什么）            │  │
│  │  - 输出格式规范（JSON Schema / XML 模板）       │  │
│  ├───────────────────────────────────────────────┤  │
│  │  Layer 2: Context Injection (动态)             │  │
│  │  - 可用工具列表及其描述                         │  │
│  │  - 历史对话摘要 / 关键事实                      │  │
│  │  - 当前系统状态（已完成步骤、中间结果）           │  │
│  │  - 检索到的外部知识（RAG 结果）                  │  │
│  ├───────────────────────────────────────────────┤  │
│  │  Layer 3: User Input (外部)                    │  │
│  │  - 用户的原始请求                               │  │
│  │  - 或上一步 Agent 的输出（在 Multi-Agent 中）    │  │
│  ├───────────────────────────────────────────────┤  │
│  │  Layer 4: Constraints &amp; Guardrails (静态+动态)  │  │
│  │  - 安全边界（禁止调用的工具、禁止访问的数据）     │  │
│  │  - 输出限制（最大步骤数、Token 预算）            │  │
│  │  - 当前 Turn 的特殊指令                         │  │
│  └───────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
</code></pre>
<h3>2.2 组装过程</h3>
<p>Prompt 组装不是简单的字符串拼接，而是一个有优先级、有裁剪策略的构建过程：</p>
<pre><code>                  Token Budget: 8000
                       │
      ┌────────────────┼────────────────┐
      │                │                │
      ▼                ▼                ▼
 System Prompt    Context Injection   User Input
 (固定预算:2000)  (弹性预算:4500)    (固定预算:1500)
      │                │                │
      │          ┌─────┴─────┐          │
      │          │           │          │
      │      Tool Descs   History       │
      │      (1500 max)  (3000 max)     │
      │          │           │          │
      │          │     [若超预算]        │
      │          │     → 压缩/截断      │
      │          │           │          │
      ▼          ▼           ▼          ▼
     ┌──────────────────────────────────┐
     │      Prompt Assembler            │
     │  1. 拼装各层                      │
     │  2. 计算总 Token                  │
     │  3. 若超预算 → 压缩 Context 层    │
     │  4. 注入 Constraints              │
     └──────────────────────────────────┘
                    │
                    ▼
              Final Prompt
</code></pre>
<p>关键设计决策：<strong>System Prompt 和 User Input 的预算是固定的，Context Injection 的预算是弹性的。</strong> 当总 Token 超出预算时，优先压缩 Context 层（截断历史、精简工具描述），而非删减 System Prompt 中的行为约束。因为行为约束一旦丢失，Agent 的行为就不可控了。</p>
<h3>2.3 Python 示例：Prompt 组装器</h3>
<pre><code class="language-python">from dataclasses import dataclass, field

@dataclass
class PromptLayer:
    content: str
    priority: int        # 越高越不容易被裁剪
    max_tokens: int
    compressible: bool   # 是否允许被压缩

@dataclass
class PromptAssembler:
    total_budget: int = 8000
    layers: list[PromptLayer] = field(default_factory=list)

    def add_layer(self, layer: PromptLayer):
        self.layers.append(layer)

    def assemble(self) -&gt; str:
        # 按优先级排序：高优先级最后处理（最不容易被裁剪）
        sorted_layers = sorted(self.layers, key=lambda l: l.priority)

        total_used = sum(estimate_tokens(l.content) for l in self.layers)

        if total_used &gt; self.total_budget:
            overflow = total_used - self.total_budget
            # 从低优先级开始压缩
            for layer in sorted_layers:
                if not layer.compressible:
                    continue
                available_cut = estimate_tokens(layer.content) - 100  # 至少保留 100 token
                cut = min(overflow, available_cut)
                layer.content = truncate_to_tokens(layer.content,
                                                    estimate_tokens(layer.content) - cut)
                overflow -= cut
                if overflow &lt;= 0:
                    break

        # 按原始顺序拼装
        return &quot;\n\n&quot;.join(l.content for l in self.layers)
</code></pre>
<hr>
<h2>3. 四种关键 Agent Prompt 设计模式</h2>
<p>Agent 系统中，不同角色的 Agent 需要不同风格的 Prompt。以下是四种最核心的设计模式，每种都给出完整可用的 Prompt 示例。</p>
<h3>3.1 Router Prompt：意图路由</h3>
<p>Router 的职责是根据用户输入<strong>选择正确的工具或子流程</strong>，而不是自己去执行任务。它是 Agent 系统的&quot;交通警察&quot;。</p>
<pre><code class="language-python">ROUTER_PROMPT = &quot;&quot;&quot;You are a request router. Your ONLY job is to analyze the user&#39;s
request and select the appropriate tool. Do NOT attempt to answer the question yourself.

## Available Tools
{tool_descriptions}

## Routing Rules
1. If the request involves real-time data (weather, stock prices, news) → use `web_search`
2. If the request involves the user&#39;s own data (files, emails, calendar) → use `data_query`
3. If the request involves code generation or debugging → use `code_assistant`
4. If the request involves image generation or editing → use `image_tool`
5. If the request is ambiguous, ask a clarifying question instead of guessing.
6. If NO tool matches, respond with tool_name: &quot;none&quot; and explain why.

## Output Format (strict JSON, no markdown fence)
{{
  &quot;reasoning&quot;: &quot;&lt;one sentence explaining your routing decision&gt;&quot;,
  &quot;tool_name&quot;: &quot;&lt;exact tool name from the list above, or &#39;none&#39;&gt;&quot;,
  &quot;tool_input&quot;: {{&lt;parameters to pass to the selected tool&gt;}},
  &quot;confidence&quot;: &lt;float between 0.0 and 1.0&gt;
}}

## Critical Constraints
- NEVER fabricate a tool name not in the list.
- NEVER return free-form text. ALWAYS return valid JSON.
- If confidence &lt; 0.6, set tool_name to &quot;none&quot; and ask for clarification.
&quot;&quot;&quot;
</code></pre>
<p><strong>设计要点：</strong></p>
<ul>
<li>明确告诉 LLM &quot;你不负责回答问题&quot;，避免它自作主张直接回答</li>
<li>提供确定性的路由规则（if-then），减少 LLM 的自由裁量空间</li>
<li>要求输出 confidence 分数，让调用方可以做二次判断</li>
<li>兜底规则：没有匹配的工具时，显式输出 &quot;none&quot;</li>
</ul>
<h3>3.2 Planner Prompt：任务规划</h3>
<p>Planner 的职责是将一个复杂请求<strong>分解为可执行的子任务列表</strong>。它是 Agent 的&quot;项目经理&quot;。</p>
<pre><code class="language-python">PLANNER_PROMPT = &quot;&quot;&quot;You are a task planner. Given a complex user request, decompose it
into a sequence of concrete, executable sub-tasks.

## Planning Principles
1. Each sub-task must be independently executable by a single tool call.
2. Sub-tasks should be ordered by dependency — a task can only depend on tasks before it.
3. Minimize the number of steps. Do NOT over-decompose simple requests.
4. If a request can be done in ONE tool call, return a plan with ONE step.

## Available Tools
{tool_descriptions}

## Output Format (strict JSON)
{{
  &quot;analysis&quot;: &quot;&lt;brief analysis of the request&#39;s complexity and required resources&gt;&quot;,
  &quot;plan&quot;: [
    {{
      &quot;step_id&quot;: 1,
      &quot;description&quot;: &quot;&lt;what this step does&gt;&quot;,
      &quot;tool_name&quot;: &quot;&lt;tool to use&gt;&quot;,
      &quot;tool_input&quot;: {{&lt;parameters&gt;}},
      &quot;depends_on&quot;: []
    }},
    {{
      &quot;step_id&quot;: 2,
      &quot;description&quot;: &quot;&lt;what this step does&gt;&quot;,
      &quot;tool_name&quot;: &quot;&lt;tool to use&gt;&quot;,
      &quot;tool_input&quot;: {{&lt;parameters, can reference $step_1_result&gt;}},
      &quot;depends_on&quot;: [1]
    }}
  ],
  &quot;estimated_steps&quot;: &lt;int&gt;,
  &quot;can_parallelize&quot;: [&lt;list of step_id groups that can run concurrently&gt;]
}}

## Constraints
- Maximum 8 steps. If the task seems to need more, simplify or ask the user to narrow scope.
- NEVER include steps like &quot;verify result&quot; or &quot;report to user&quot; — those are handled by the system.
- Use $step_N_result to reference the output of a previous step.
&quot;&quot;&quot;
</code></pre>
<p><strong>设计要点：</strong></p>
<ul>
<li>&quot;最小化步骤数&quot;原则防止 LLM 过度分解（这是规划器最常见的问题）</li>
<li><code>depends_on</code> 字段使得执行引擎可以识别并行机会</li>
<li>明确设置步骤上限（8 步），避免 LLM 生成无休止的计划</li>
<li>禁止 LLM 添加&quot;元步骤&quot;（验证、汇报），这些是系统层的职责</li>
</ul>
<h3>3.3 Executor Prompt：执行操作</h3>
<p>Executor 的职责是<strong>执行单个具体操作</strong>，并以严格的格式返回结果。它是 Agent 的&quot;操作工&quot;。</p>
<pre><code class="language-python">EXECUTOR_PROMPT = &quot;&quot;&quot;You are a task executor. You will receive a specific sub-task and
must execute it using the provided tool.

## Current Task
{task_description}

## Tool to Use
Name: {tool_name}
Schema: {tool_schema}

## Context from Previous Steps
{previous_results}

## Execution Rules
1. Call the tool EXACTLY ONCE with the correct parameters.
2. Do NOT deviate from the task description.
3. Do NOT call tools not specified for this task.
4. If the tool call fails, report the error — do NOT retry or improvise.

## Output Format (strict JSON)
{{
  &quot;tool_call&quot;: {{
    &quot;name&quot;: &quot;{tool_name}&quot;,
    &quot;arguments&quot;: {{&lt;filled parameters&gt;}}
  }},
  &quot;explanation&quot;: &quot;&lt;one sentence on why these parameters were chosen&gt;&quot;
}}
&quot;&quot;&quot;
</code></pre>
<p><strong>设计要点：</strong></p>
<ul>
<li>Executor 的设计哲学是&quot;最小权限&quot;——只做被告知的事</li>
<li>严禁 Executor 自主决策，发现错误只能上报，不能自行重试</li>
<li>这种设计让 Executor 成为一个确定性单元，便于测试和审计</li>
</ul>
<h3>3.4 Reflector Prompt：结果反思</h3>
<p>Reflector 的职责是<strong>评估执行结果</strong>，判断是否达成目标，如果未达成则提出修正方案。它是 Agent 的&quot;质量检查员&quot;。</p>
<pre><code class="language-python">REFLECTOR_PROMPT = &quot;&quot;&quot;You are a result evaluator. Given the original user request and the
execution result, determine whether the task has been completed successfully.

## Original Request
{user_request}

## Execution Plan
{plan}

## Execution Results
{results}

## Evaluation Criteria
1. Completeness: Does the result fully address the user&#39;s request?
2. Correctness: Is the result factually and logically correct?
3. Format: Is the result in the expected format?

## Output Format (strict JSON)
{{
  &quot;evaluation&quot;: {{
    &quot;completeness&quot;: {{&quot;score&quot;: &lt;1-5&gt;, &quot;reason&quot;: &quot;&lt;explanation&gt;&quot;}},
    &quot;correctness&quot;: {{&quot;score&quot;: &lt;1-5&gt;, &quot;reason&quot;: &quot;&lt;explanation&gt;&quot;}},
    &quot;format&quot;: {{&quot;score&quot;: &lt;1-5&gt;, &quot;reason&quot;: &quot;&lt;explanation&gt;&quot;}}
  }},
  &quot;overall_pass&quot;: &lt;true|false&gt;,
  &quot;action&quot;: &quot;&lt;one of: &#39;accept&#39;, &#39;retry_step&#39;, &#39;replan&#39;, &#39;escalate&#39;&gt;&quot;,
  &quot;retry_details&quot;: {{
    &quot;step_id&quot;: &lt;which step to retry, if applicable&gt;,
    &quot;modification&quot;: &quot;&lt;what to change in the retry&gt;&quot;
  }}
}}

## Decision Rules
- If all scores &gt;= 4: action = &quot;accept&quot;
- If any score &lt;= 2 and retry_count &lt; 3: action = &quot;retry_step&quot; or &quot;replan&quot;
- If retry_count &gt;= 3: action = &quot;escalate&quot; (ask user for help)
- NEVER accept a result with correctness score &lt;= 2.
&quot;&quot;&quot;
</code></pre>
<p><strong>设计要点：</strong></p>
<ul>
<li>多维度评估（完整性、正确性、格式）而非简单的 pass/fail</li>
<li>明确的决策规则，减少 LLM 判断的主观性</li>
<li>retry_count 上限防止无限重试循环</li>
<li>&quot;escalate&quot; 作为最终兜底——承认失败比无限循环好得多</li>
</ul>
<h3>3.5 四种模式的协作</h3>
<pre><code>User Request
     │
     ▼
 ┌────────┐     tool_name + input     ┌──────────┐
 │ Router │ ──── (简单请求直接执行) ───→│ Executor │──→ Result
 └────┬───┘                           └──────────┘
      │ (复杂请求)                          ▲
      ▼                                    │
 ┌─────────┐    plan[step_1..N]     ┌──────┴───┐
 │ Planner │ ─────────────────────→│ Executor  │
 └─────────┘                       │ (per step)│
                                   └──────┬───┘
                                          │ results
                                          ▼
                                   ┌───────────┐
                                   │ Reflector  │
                                   └─────┬─────┘
                                         │
                              ┌──────────┼──────────┐
                              │          │          │
                           accept    retry_step   replan
                              │          │          │
                              ▼          ▼          ▼
                           Return    Executor    Planner
                           to User  (重试该步)   (重新规划)
</code></pre>
<hr>
<h2>4. Chain-of-Thought 在 Agent 中的应用</h2>
<h3>4.1 标准 CoT vs Agent CoT</h3>
<p>标准的 Chain-of-Thought（CoT）是一种推理增强技术——&quot;Let&#39;s think step by step&quot;。但在 Agent 中，CoT 的用途和形式有本质不同：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>标准 CoT</th>
<th>Agent CoT</th>
</tr>
</thead>
<tbody><tr>
<td>目的</td>
<td>提高推理准确性</td>
<td>让中间推理过程可审计、可路由</td>
</tr>
<tr>
<td>消费者</td>
<td>最终输出的一部分</td>
<td>Agent Runtime 的中间状态</td>
</tr>
<tr>
<td>格式</td>
<td>自然语言</td>
<td>结构化（通常嵌入 JSON 的某个字段）</td>
</tr>
<tr>
<td>是否返回用户</td>
<td>通常是</td>
<td>通常不是（内部消费）</td>
</tr>
</tbody></table>
<p>Agent 的 CoT 更像是一个<strong>内部日志</strong>，而非用户可见的推理过程。它的首要目标是让系统（而非人类）能够理解和利用中间推理。</p>
<h3>4.2 Scratchpad 模式</h3>
<p>Scratchpad 模式是 Agent CoT 的典型实现——在 Prompt 中显式开辟一个&quot;草稿区&quot;，让 LLM 在其中进行中间推理，然后输出最终决策。</p>
<pre><code class="language-python">SCRATCHPAD_PROMPT = &quot;&quot;&quot;Analyze the user&#39;s request and decide on an action.

## User Request
{user_request}

## Available Tools
{tools}

## Instructions
Use the &lt;scratchpad&gt; section to think through your decision. This section will NOT be
shown to the user. Then provide your final action in the &lt;action&gt; section.

&lt;scratchpad&gt;
Think through:
1. What is the user actually asking for?
2. Which tools could help? What are the pros/cons of each?
3. What information am I missing?
4. What&#39;s the simplest approach that works?
&lt;/scratchpad&gt;

&lt;action&gt;
Return strict JSON here:
{{&quot;tool_name&quot;: &quot;...&quot;, &quot;tool_input&quot;: {{...}}, &quot;reasoning_summary&quot;: &quot;...&quot;}}
&lt;/action&gt;
&quot;&quot;&quot;
</code></pre>
<p>Runtime 解析时，只提取 <code>&lt;action&gt;</code> 标签中的内容作为执行指令，<code>&lt;scratchpad&gt;</code> 的内容记录到日志中用于调试和审计。</p>
<h3>4.3 显式推理 vs 隐式推理的 Trade-off</h3>
<p><strong>显式推理（Explicit Reasoning）：</strong> 在 Prompt 中要求 LLM 输出推理过程。</p>
<p>优势：</p>
<ul>
<li>可审计，出了问题能追溯&quot;为什么做了这个决策&quot;</li>
<li>推理质量通常更高（CoT 效应）</li>
<li>便于调试</li>
</ul>
<p>劣势：</p>
<ul>
<li>消耗更多 Token（推理内容可能占输出的 50%+）</li>
<li>增加延迟</li>
<li>推理内容可能包含敏感的内部逻辑</li>
</ul>
<p><strong>隐式推理（Implicit Reasoning）：</strong> 直接要求 LLM 输出最终决策，不要求中间过程。</p>
<p>优势：</p>
<ul>
<li>Token 用量更低，延迟更短</li>
<li>输出更简洁，解析更简单</li>
</ul>
<p>劣势：</p>
<ul>
<li>黑盒，无法理解决策过程</li>
<li>在复杂场景下准确率下降明显</li>
</ul>
<p><strong>工程决策建议：</strong></p>
<ul>
<li>Router 和 Executor（简单、确定性高）：倾向隐式推理，追求速度</li>
<li>Planner 和 Reflector（复杂、需要判断）：必须显式推理，追求准确性和可审计性</li>
<li>在系统稳定后，可以通过 A/B 测试逐步将显式推理切换为隐式推理以降低成本</li>
</ul>
<hr>
<h2>5. Few-shot vs Zero-shot 在 Agent 场景的选择</h2>
<p>这是 Agent Prompt 设计中一个重要但常被忽视的决策点。</p>
<h3>5.1 决策矩阵</h3>
<pre><code>                    输出结构化程度
                 低 ◄──────────► 高
                 │                │
  任务复杂度  高  │  Few-shot      │  Zero-shot + Schema
                 │  (复杂规划)     │  (结构化反思)
                 │                │
              低  │  Zero-shot     │  Zero-shot + Schema
                 │  (简单对话)     │  (工具调用)
                 │                │
</code></pre>
<h3>5.2 工具调用：Zero-shot 优先</h3>
<p>工具调用场景天然适合 Zero-shot。原因是 <strong>JSON Schema 本身就是最好的&quot;示例&quot;</strong>——它精确定义了每个参数的名称、类型、描述和约束，比任何 Few-shot 示例都更完整。</p>
<pre><code class="language-python"># 工具调用不需要 few-shot，Schema 就是最好的约束
tool_schema = {
    &quot;name&quot;: &quot;search_database&quot;,
    &quot;description&quot;: &quot;Search the product database with filters&quot;,
    &quot;parameters&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;query&quot;: {&quot;type&quot;: &quot;string&quot;, &quot;description&quot;: &quot;Search keywords&quot;},
            &quot;category&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;enum&quot;: [&quot;electronics&quot;, &quot;clothing&quot;, &quot;books&quot;],
                &quot;description&quot;: &quot;Product category filter&quot;
            },
            &quot;max_results&quot;: {
                &quot;type&quot;: &quot;integer&quot;,
                &quot;default&quot;: 10,
                &quot;minimum&quot;: 1,
                &quot;maximum&quot;: 100
            }
        },
        &quot;required&quot;: [&quot;query&quot;]
    }
}
</code></pre>
<p>加 Few-shot 反而可能引入问题：LLM 可能过度拟合示例中的具体值，而不是理解 Schema 的通用约束。</p>
<h3>5.3 复杂规划：Few-shot 有价值</h3>
<p>规划场景是 Few-shot 真正发挥价值的地方。因为&quot;好的计划&quot;是一个模糊的概念——仅凭输出格式定义不足以引导 LLM 产出高质量的计划。</p>
<pre><code class="language-python">PLANNER_WITH_EXAMPLES = &quot;&quot;&quot;You are a task planner.

## Example 1: Multi-step data analysis
User: &quot;Compare last month&#39;s sales with the same period last year and visualize the trend&quot;
Plan:
[
  {{&quot;step_id&quot;: 1, &quot;tool&quot;: &quot;data_query&quot;, &quot;input&quot;: &quot;sales data for 2025-07&quot;, &quot;depends_on&quot;: []}},
  {{&quot;step_id&quot;: 2, &quot;tool&quot;: &quot;data_query&quot;, &quot;input&quot;: &quot;sales data for 2024-07&quot;, &quot;depends_on&quot;: []}},
  {{&quot;step_id&quot;: 3, &quot;tool&quot;: &quot;data_compare&quot;, &quot;input&quot;: &quot;$step_1_result, $step_2_result&quot;, &quot;depends_on&quot;: [1, 2]}},
  {{&quot;step_id&quot;: 4, &quot;tool&quot;: &quot;chart_gen&quot;, &quot;input&quot;: &quot;$step_3_result, type=line&quot;, &quot;depends_on&quot;: [3]}}
]
Note: Steps 1 and 2 can run in parallel since they have no dependencies.

## Example 2: Simple single-step task
User: &quot;What&#39;s the weather in Tokyo?&quot;
Plan:
[
  {{&quot;step_id&quot;: 1, &quot;tool&quot;: &quot;weather_api&quot;, &quot;input&quot;: &quot;Tokyo&quot;, &quot;depends_on&quot;: []}}
]
Note: Simple requests should NOT be over-decomposed.

## Now plan for:
User: &quot;{user_request}&quot;
&quot;&quot;&quot;
</code></pre>
<p>Few-shot 示例在这里传递了两个关键信息：</p>
<ol>
<li><strong>粒度标准</strong>——什么程度的分解是合适的</li>
<li><strong>并行意识</strong>——独立步骤应该标记为可并行</li>
</ol>
<h3>5.4 反思评估：Zero-shot + 结构化输出</h3>
<p>反思（Reflection）场景适合 Zero-shot + 结构化输出。原因是反思本质上是&quot;评判&quot;，而评判标准已经通过评估维度（completeness / correctness / format）和评分规则完整定义了。给出 Few-shot 示例反而可能让 LLM 锚定在示例的评分上，而不是独立评估当前结果。</p>
<p><strong>总结决策原则：</strong></p>
<ul>
<li>格式约束充分（JSON Schema / 评分规则）→ Zero-shot</li>
<li>需要传递&quot;风格&quot;或&quot;粒度标准&quot; → Few-shot</li>
<li>两者都可以时 → 优先 Zero-shot（更省 Token，更不容易过拟合）</li>
</ul>
<hr>
<h2>6. Prompt 工程化实践</h2>
<p>当 Agent 系统超过原型阶段，Prompt 管理就变成了一个严肃的工程问题。</p>
<h3>6.1 Prompt 模板化</h3>
<p>核心思想：<strong>分离静态结构和动态内容</strong>。静态部分（身份定义、行为规则、输出格式）是模板，动态部分（工具列表、历史消息、当前状态）通过变量注入。</p>
<pre><code class="language-python">from typing import Any
from string import Template
import hashlib
import json
from datetime import datetime


class PromptTemplate:
    &quot;&quot;&quot;可管理、可版本化、可测试的 Prompt 模板&quot;&quot;&quot;

    def __init__(self, name: str, template: str, version: str,
                 required_vars: list[str], metadata: dict | None = None):
        self.name = name
        self.template = template
        self.version = version
        self.required_vars = required_vars
        self.metadata = metadata or {}
        self._hash = hashlib.sha256(template.encode()).hexdigest()[:12]

    def render(self, **kwargs) -&gt; str:
        # 校验所有必需变量都已提供
        missing = set(self.required_vars) - set(kwargs.keys())
        if missing:
            raise ValueError(f&quot;Missing required variables: {missing}&quot;)

        # 渲染模板
        rendered = self.template
        for key, value in kwargs.items():
            placeholder = &quot;{&quot; + key + &quot;}&quot;
            if isinstance(value, (dict, list)):
                value = json.dumps(value, indent=2, ensure_ascii=False)
            rendered = rendered.replace(placeholder, str(value))

        return rendered

    def fingerprint(self) -&gt; str:
        &quot;&quot;&quot;返回模板内容的哈希指纹，用于版本追踪&quot;&quot;&quot;
        return f&quot;{self.name}@{self.version}#{self._hash}&quot;


class PromptRegistry:
    &quot;&quot;&quot;Prompt 模板注册中心：集中管理所有 Agent 使用的 Prompt&quot;&quot;&quot;

    def __init__(self):
        self._templates: dict[str, dict[str, PromptTemplate]] = {}  # name -&gt; {version -&gt; template}

    def register(self, template: PromptTemplate):
        if template.name not in self._templates:
            self._templates[template.name] = {}
        self._templates[template.name][template.version] = template

    def get(self, name: str, version: str = &quot;latest&quot;) -&gt; PromptTemplate:
        if name not in self._templates:
            raise KeyError(f&quot;Template &#39;{name}&#39; not found&quot;)

        versions = self._templates[name]
        if version == &quot;latest&quot;:
            latest_version = sorted(versions.keys())[-1]
            return versions[latest_version]

        if version not in versions:
            raise KeyError(f&quot;Version &#39;{version}&#39; not found for template &#39;{name}&#39;&quot;)
        return versions[version]

    def list_all(self) -&gt; dict[str, list[str]]:
        return {name: sorted(vers.keys()) for name, vers in self._templates.items()}


# ── 使用示例 ──

registry = PromptRegistry()

# 注册 Router Prompt v1
registry.register(PromptTemplate(
    name=&quot;router&quot;,
    version=&quot;1.0&quot;,
    template=&quot;&quot;&quot;You are a request router.
Available tools: {tool_descriptions}
Route the following request: {user_input}
Output JSON: {{&quot;tool_name&quot;: &quot;...&quot;, &quot;tool_input&quot;: {{...}}}}&quot;&quot;&quot;,
    required_vars=[&quot;tool_descriptions&quot;, &quot;user_input&quot;],
    metadata={&quot;author&quot;: &quot;agent-team&quot;, &quot;last_tested&quot;: &quot;2025-08-10&quot;}
))

# 注册 Router Prompt v2（增加了 confidence 字段）
registry.register(PromptTemplate(
    name=&quot;router&quot;,
    version=&quot;2.0&quot;,
    template=&quot;&quot;&quot;You are a request router. Your ONLY job is to route, not to answer.
Available tools: {tool_descriptions}
Route the following request: {user_input}
Output JSON: {{&quot;tool_name&quot;: &quot;...&quot;, &quot;tool_input&quot;: {{...}}, &quot;confidence&quot;: &lt;0.0-1.0&gt;}}&quot;&quot;&quot;,
    required_vars=[&quot;tool_descriptions&quot;, &quot;user_input&quot;],
    metadata={&quot;author&quot;: &quot;agent-team&quot;, &quot;last_tested&quot;: &quot;2025-08-13&quot;}
))

# 获取并渲染
router_prompt = registry.get(&quot;router&quot;, version=&quot;2.0&quot;)
final_prompt = router_prompt.render(
    tool_descriptions=&quot;1. web_search: Search the web\n2. calculator: Do math&quot;,
    user_input=&quot;What is 42 * 17?&quot;
)
</code></pre>
<h3>6.2 Prompt 版本控制</h3>
<p>为什么 Prompt 需要版本控制？因为 <strong>Prompt 是 Agent 行为的源代码</strong>。改一个词可能导致 Agent 行为的巨大变化——从正确路由变成错误路由，从结构化输出变成自由文本。</p>
<p>版本控制策略：</p>
<pre><code>prompts/
├── router/
│   ├── v1.0.txt          # 初始版本
│   ├── v1.1.txt          # 修复：低 confidence 时的行为
│   ├── v2.0.txt          # 重大变更：新增 confidence 字段
│   └── changelog.md      # 变更记录
├── planner/
│   ├── v1.0.txt
│   └── v1.1.txt
├── executor/
│   └── v1.0.txt
└── reflector/
    └── v1.0.txt
</code></pre>
<p>关键实践：</p>
<ul>
<li><strong>每次 Prompt 变更都有对应的测试结果</strong>（下面会详述）</li>
<li><strong>生产环境使用固定版本号</strong>，而非 &quot;latest&quot;</li>
<li><strong>支持灰度发布</strong>：新版 Prompt 可以先对 10% 的流量生效</li>
<li><strong>保留回滚能力</strong>：发现新版 Prompt 导致问题时，立即切回旧版</li>
</ul>
<h3>6.3 Prompt 测试</h3>
<p>Prompt 测试的核心挑战是 LLM 输出的非确定性。我们不能像测试普通函数那样做精确断言，但可以做<strong>结构化断言</strong>和<strong>统计性断言</strong>。</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass
class PromptTestCase:
    name: str
    input_vars: dict[str, Any]       # 模板变量
    assertions: list[dict]            # 断言列表

    # 断言类型：
    # {&quot;type&quot;: &quot;json_valid&quot;}                           → 输出是合法 JSON
    # {&quot;type&quot;: &quot;has_field&quot;, &quot;field&quot;: &quot;tool_name&quot;}      → JSON 中包含指定字段
    # {&quot;type&quot;: &quot;field_in&quot;, &quot;field&quot;: &quot;tool_name&quot;, &quot;values&quot;: [&quot;a&quot;, &quot;b&quot;]} → 字段值在范围内
    # {&quot;type&quot;: &quot;no_field&quot;, &quot;field&quot;: &quot;apology&quot;}         → 不包含某字段（防止 LLM 废话）
    # {&quot;type&quot;: &quot;max_tokens&quot;, &quot;limit&quot;: 200}             → 输出长度不超过限制


class PromptTestRunner:
    def __init__(self, llm_client, template: PromptTemplate):
        self.llm = llm_client
        self.template = template

    def run_test(self, test_case: PromptTestCase, n_runs: int = 5) -&gt; dict:
        &quot;&quot;&quot;对同一个测试用例运行 N 次，统计通过率&quot;&quot;&quot;
        prompt = self.template.render(**test_case.input_vars)
        results = []

        for _ in range(n_runs):
            output = self.llm.generate(prompt)
            pass_all = True
            details = []

            for assertion in test_case.assertions:
                passed = self._check_assertion(output, assertion)
                details.append({&quot;assertion&quot;: assertion, &quot;passed&quot;: passed})
                if not passed:
                    pass_all = False

            results.append({&quot;output&quot;: output, &quot;passed&quot;: pass_all, &quot;details&quot;: details})

        pass_rate = sum(1 for r in results if r[&quot;passed&quot;]) / n_runs
        return {
            &quot;test_case&quot;: test_case.name,
            &quot;template&quot;: self.template.fingerprint(),
            &quot;n_runs&quot;: n_runs,
            &quot;pass_rate&quot;: pass_rate,
            &quot;results&quot;: results
        }

    def _check_assertion(self, output: str, assertion: dict) -&gt; bool:
        if assertion[&quot;type&quot;] == &quot;json_valid&quot;:
            try:
                json.loads(output)
                return True
            except json.JSONDecodeError:
                return False

        if assertion[&quot;type&quot;] == &quot;has_field&quot;:
            try:
                data = json.loads(output)
                return assertion[&quot;field&quot;] in data
            except (json.JSONDecodeError, TypeError):
                return False

        if assertion[&quot;type&quot;] == &quot;field_in&quot;:
            try:
                data = json.loads(output)
                return data.get(assertion[&quot;field&quot;]) in assertion[&quot;values&quot;]
            except (json.JSONDecodeError, TypeError):
                return False

        return False  # 未知断言类型


# ── 测试用例示例 ──

test_cases = [
    PromptTestCase(
        name=&quot;math_request_should_route_to_calculator&quot;,
        input_vars={
            &quot;tool_descriptions&quot;: &quot;1. web_search: Search the web\n2. calculator: Do math&quot;,
            &quot;user_input&quot;: &quot;What is 1024 * 768?&quot;
        },
        assertions=[
            {&quot;type&quot;: &quot;json_valid&quot;},
            {&quot;type&quot;: &quot;has_field&quot;, &quot;field&quot;: &quot;tool_name&quot;},
            {&quot;type&quot;: &quot;field_in&quot;, &quot;field&quot;: &quot;tool_name&quot;, &quot;values&quot;: [&quot;calculator&quot;]},
        ]
    ),
    PromptTestCase(
        name=&quot;ambiguous_request_should_not_guess&quot;,
        input_vars={
            &quot;tool_descriptions&quot;: &quot;1. web_search: Search the web\n2. calculator: Do math&quot;,
            &quot;user_input&quot;: &quot;Help me with my project&quot;
        },
        assertions=[
            {&quot;type&quot;: &quot;json_valid&quot;},
            {&quot;type&quot;: &quot;has_field&quot;, &quot;field&quot;: &quot;tool_name&quot;},
            {&quot;type&quot;: &quot;field_in&quot;, &quot;field&quot;: &quot;tool_name&quot;, &quot;values&quot;: [&quot;none&quot;]},
        ]
    ),
]
</code></pre>
<p><strong>测试策略建议：</strong></p>
<ul>
<li>每个 Prompt 版本至少 10 个测试用例，覆盖正常路径、边界情况和对抗输入</li>
<li>每个测试用例运行 5-10 次，要求通过率 &gt;= 90%（而非 100%，因为 LLM 输出非确定性）</li>
<li>将测试集纳入 CI，每次 Prompt 变更触发回归测试</li>
</ul>
<h3>6.4 Prompt 组合：模块化拼装</h3>
<p>复杂 Agent 的 Prompt 往往由多个模块组合而成。与其维护一个巨大的单体 Prompt，不如将其拆分为可复用的模块：</p>
<pre><code class="language-python">class PromptComposer:
    &quot;&quot;&quot;将多个 Prompt 模块按顺序组合&quot;&quot;&quot;

    def __init__(self):
        self._modules: list[tuple[str, PromptTemplate]] = []

    def add(self, section_name: str, template: PromptTemplate):
        self._modules.append((section_name, template))
        return self  # 支持链式调用

    def compose(self, **all_vars) -&gt; str:
        sections = []
        for section_name, template in self._modules:
            # 每个模块只取自己需要的变量
            relevant_vars = {k: v for k, v in all_vars.items()
                           if k in template.required_vars}
            rendered = template.render(**relevant_vars)
            sections.append(f&quot;## {section_name}\n{rendered}&quot;)
        return &quot;\n\n&quot;.join(sections)


# 使用方式
identity_module = PromptTemplate(
    name=&quot;identity&quot;, version=&quot;1.0&quot;,
    template=&quot;You are {agent_role}. {agent_description}&quot;,
    required_vars=[&quot;agent_role&quot;, &quot;agent_description&quot;]
)

tools_module = PromptTemplate(
    name=&quot;tools&quot;, version=&quot;1.0&quot;,
    template=&quot;Available tools:\n{tool_descriptions}&quot;,
    required_vars=[&quot;tool_descriptions&quot;]
)

output_format_module = PromptTemplate(
    name=&quot;output_format&quot;, version=&quot;1.0&quot;,
    template=&quot;You MUST respond in the following JSON format:\n{json_schema}&quot;,
    required_vars=[&quot;json_schema&quot;]
)

constraints_module = PromptTemplate(
    name=&quot;constraints&quot;, version=&quot;1.0&quot;,
    template=&quot;Constraints:\n{constraint_list}&quot;,
    required_vars=[&quot;constraint_list&quot;]
)

# 组合
composer = PromptComposer()
composer.add(&quot;Identity&quot;, identity_module) \
        .add(&quot;Tools&quot;, tools_module) \
        .add(&quot;Output Format&quot;, output_format_module) \
        .add(&quot;Constraints&quot;, constraints_module)

final_prompt = composer.compose(
    agent_role=&quot;a task router&quot;,
    agent_description=&quot;You route user requests to the appropriate tool.&quot;,
    tool_descriptions=&quot;1. search: web search\n2. calc: calculator&quot;,
    json_schema=&#39;{&quot;tool_name&quot;: &quot;string&quot;, &quot;tool_input&quot;: &quot;object&quot;}&#39;,
    constraint_list=&quot;- Never fabricate tool names\n- Always return valid JSON&quot;
)
</code></pre>
<p>模块化的好处：</p>
<ul>
<li>同一个 <code>output_format_module</code> 可以被 Router、Planner、Executor 共享</li>
<li>修改 constraints 不需要触碰 identity 和 tools 部分</li>
<li>每个模块可以独立测试和版本控制</li>
</ul>
<hr>
<h2>7. Context Window 管理</h2>
<p>Agent 的 Context Window 管理是一个独特且关键的工程挑战。与 Chatbot 的&quot;对话越长体验越差&quot;不同，Agent 的 context 膨胀会直接导致<strong>系统性故障</strong>。</p>
<h3>7.1 Agent 的 Context 膨胀问题</h3>
<p>Agent 的 context 会从三个维度快速膨胀：</p>
<pre><code>Turn 1:  System(2000) + User(200) + Response(500)              = 2,700 tokens
Turn 2:  + Tool_Result(3000) + Response(800)                   = 6,500 tokens
Turn 3:  + Tool_Result(5000) + Error_Msg(1000) + Response(600) = 13,100 tokens
Turn 4:  + Tool_Result(2000) + Response(400)                   = 15,500 tokens
Turn 5:  + RAG_Context(4000) + Response(1000)                  = 20,500 tokens
  ...
Turn 10: 很容易突破 50,000 tokens
</code></pre>
<p>三大膨胀源：</p>
<ol>
<li><strong>工具返回值</strong>：一次数据库查询可能返回几千 token 的 JSON，一次网页抓取可能返回上万 token</li>
<li><strong>历史消息积累</strong>：每一轮的 user message + assistant response + tool calls 都在累积</li>
<li><strong>错误信息</strong>：工具调用失败的 traceback、重试过程中的冗余信息</li>
</ol>
<h3>7.2 消息压缩策略</h3>
<p><strong>策略 1：摘要压缩（Summarization）</strong></p>
<p>将早期的对话历史压缩为摘要，只保留关键事实和决策结果。</p>
<pre><code class="language-python">def compress_history(messages: list[dict], llm_client,
                     keep_recent: int = 4) -&gt; list[dict]:
    &quot;&quot;&quot;将早期历史压缩为摘要，保留最近 N 轮完整消息&quot;&quot;&quot;
    if len(messages) &lt;= keep_recent:
        return messages

    old_messages = messages[:-keep_recent]
    recent_messages = messages[-keep_recent:]

    # 用 LLM 生成摘要
    summary_prompt = f&quot;&quot;&quot;Summarize the following conversation history into key facts
and decisions. Keep only information that might be needed for future steps.
Be concise — maximum 200 words.

{format_messages(old_messages)}&quot;&quot;&quot;

    summary = llm_client.generate(summary_prompt)

    # 将摘要作为一条 system message 注入
    summary_message = {
        &quot;role&quot;: &quot;system&quot;,
        &quot;content&quot;: f&quot;[Conversation Summary]\n{summary}&quot;
    }

    return [summary_message] + recent_messages
</code></pre>
<p><strong>策略 2：滑动窗口（Sliding Window）</strong></p>
<p>更简单粗暴——只保留最近 N 条消息，丢弃更早的消息。</p>
<pre><code class="language-python">def sliding_window(messages: list[dict], max_messages: int = 10) -&gt; list[dict]:
    &quot;&quot;&quot;保留 system message + 最近 N 条消息&quot;&quot;&quot;
    system_msgs = [m for m in messages if m[&quot;role&quot;] == &quot;system&quot;]
    non_system = [m for m in messages if m[&quot;role&quot;] != &quot;system&quot;]
    return system_msgs + non_system[-max_messages:]
</code></pre>
<p><strong>策略 3：选择性保留（Selective Retention）</strong></p>
<p>根据消息的&quot;重要性&quot;决定保留还是丢弃。</p>
<pre><code class="language-python">def selective_retain(messages: list[dict], token_budget: int) -&gt; list[dict]:
    &quot;&quot;&quot;按重要性保留消息，直到填满 token 预算&quot;&quot;&quot;

    def importance_score(msg: dict) -&gt; int:
        if msg[&quot;role&quot;] == &quot;system&quot;:
            return 100  # 永远保留
        if msg.get(&quot;is_final_result&quot;):
            return 90   # 最终结果必须保留
        if msg[&quot;role&quot;] == &quot;user&quot;:
            return 80   # 用户输入高优先
        if msg.get(&quot;tool_error&quot;):
            return 20   # 错误信息低优先（已经被处理过了）
        if msg.get(&quot;tool_result&quot;):
            return 40   # 工具结果中等优先
        return 50

    scored = [(importance_score(m), i, m) for i, m in enumerate(messages)]
    scored.sort(key=lambda x: (-x[0], x[1]))  # 按重要性降序，原始顺序升序

    retained = []
    used_tokens = 0
    for score, idx, msg in scored:
        msg_tokens = estimate_tokens(msg[&quot;content&quot;])
        if used_tokens + msg_tokens &lt;= token_budget:
            retained.append((idx, msg))
            used_tokens += msg_tokens

    # 恢复原始顺序
    retained.sort(key=lambda x: x[0])
    return [msg for _, msg in retained]
</code></pre>
<h3>7.3 Token 预算分配</h3>
<p>一个经验性的 Token 预算分配方案（以 8K context window 为例）：</p>
<pre><code>Total Context Window: 8,192 tokens
                    │
    ┌───────────────┼───────────────┐
    │               │               │
System Prompt    Working Area     Reserved for
  ~25%            ~60%            Output ~15%
 (2,048)         (4,915)          (1,229)
    │               │
    │         ┌─────┴──────┐
    │         │            │
    │    Tool Descs    History + State
    │     ~15%          ~45%
    │    (1,229)       (3,686)
    │
    ├── Identity &amp; Role: 500
    ├── Behavior Rules: 800
    ├── Output Format: 500
    └── Constraints: 248
</code></pre>
<p>关键原则：</p>
<ul>
<li><strong>Output Reserved 不能省</strong>：如果留给输出的空间不足，LLM 会输出截断的 JSON，导致解析失败</li>
<li><strong>System Prompt 预算固定</strong>：行为约束不能因为 context 紧张而被裁剪</li>
<li><strong>History 是最大的压缩空间</strong>：优先在这里节省 Token</li>
<li><strong>工具描述可以按需加载</strong>：如果 Router 已经选定了工具，后续 Executor 只需要注入被选中工具的描述，而非全部工具</li>
</ul>
<h3>7.4 工具返回值的处理</h3>
<p>工具返回值是 context 膨胀的最大单点源头。以下是几种处理策略：</p>
<pre><code class="language-python">def process_tool_result(result: str, max_tokens: int = 1500) -&gt; str:
    &quot;&quot;&quot;处理工具返回值，防止 context 爆炸&quot;&quot;&quot;

    result_tokens = estimate_tokens(result)

    if result_tokens &lt;= max_tokens:
        return result

    # 策略 1：截断（适用于文本类结果）
    if is_text(result):
        return truncate_to_tokens(result, max_tokens) + &quot;\n[... truncated]&quot;

    # 策略 2：提取摘要（适用于 JSON 类结果）
    if is_json(result):
        data = json.loads(result)
        if isinstance(data, list):
            # 只保留前 N 条记录 + 总数信息
            summary = {
                &quot;total_count&quot;: len(data),
                &quot;showing_first&quot;: 5,
                &quot;records&quot;: data[:5],
                &quot;note&quot;: f&quot;Truncated from {len(data)} records. Request specific filters for more.&quot;
            }
            return json.dumps(summary, ensure_ascii=False, indent=2)

    # 策略 3：兜底截断
    return truncate_to_tokens(result, max_tokens) + &quot;\n[... truncated]&quot;
</code></pre>
<hr>
<h2>8. 常见陷阱</h2>
<h3>8.1 Prompt 太长导致 LLM &quot;忘记&quot;关键指令</h3>
<p><strong>现象：</strong> System Prompt 有 3000 token，其中包含 20 条行为规则。LLM 在前几轮严格遵守，但随着 context 变长，开始&quot;遗忘&quot;中间的规则——尤其是第 8-15 条。</p>
<p><strong>原因：</strong> LLM 对 prompt 中不同位置内容的&quot;注意力&quot;不均匀。开头和结尾的内容通常被更好地遵循（primacy effect 和 recency effect），中间的内容最容易被忽略。</p>
<p><strong>应对：</strong></p>
<ul>
<li>将最关键的规则放在 System Prompt 的开头和结尾</li>
<li>将规则数量控制在 7 条以内（与人类工作记忆容量一致，也利于 LLM）</li>
<li>在消息末尾添加 reminder：&quot;Remember: always output valid JSON. Never fabricate tool names.&quot;</li>
<li>按当前 Turn 的需要动态注入最相关的规则子集，而非每次都注入全部规则</li>
</ul>
<h3>8.2 工具描述和 System Prompt 冲突</h3>
<p><strong>现象：</strong> System Prompt 说&quot;不要执行任何数据删除操作&quot;，但某个工具的 description 中包含&quot;Deletes records matching the query&quot;。LLM 收到删除请求时，行为不确定——有时遵循 System Prompt 的禁令，有时遵循工具描述的能力。</p>
<p><strong>原因：</strong> LLM 看到的是拼装后的完整 prompt，它不理解&quot;System Prompt 优先级高于工具描述&quot;这个层级关系。两段相互矛盾的文本让 LLM 陷入冲突。</p>
<p><strong>应对：</strong></p>
<ul>
<li>在 Prompt 组装阶段做<strong>一致性检查</strong>：扫描工具描述中的关键词，与 System Prompt 的禁止列表做匹配</li>
<li>如果某个工具被禁用，<strong>直接不注入它的描述</strong>，而不是注入描述然后在 System Prompt 中禁止</li>
<li>在 System Prompt 中明确声明优先级：&quot;If any tool description conflicts with these rules, these rules take priority.&quot;</li>
</ul>
<h3>8.3 过度约束导致 LLM 无法灵活应对</h3>
<p><strong>现象：</strong> 为了保证安全，System Prompt 中加了大量限制：&quot;只能调用列表中的工具&quot;、&quot;只能输出 JSON&quot;、&quot;不能包含任何解释&quot;、&quot;不能问用户问题&quot;、&quot;必须在一次调用中完成&quot;......结果 LLM 在遇到无法处理的请求时，输出空 JSON 或无意义的工具调用，而不是合理地拒绝或请求澄清。</p>
<p><strong>原因：</strong> 过度约束堵死了 LLM 所有的&quot;逃生通道&quot;。它没有被允许说&quot;我不知道&quot;或&quot;我需要更多信息&quot;，所以只能在约束框架内硬凑一个输出。</p>
<p><strong>应对：</strong></p>
<ul>
<li>永远为 LLM 保留一个&quot;安全出口&quot;：允许它输出 <code>{&quot;action&quot;: &quot;clarify&quot;, &quot;question&quot;: &quot;...&quot;}</code> 或 <code>{&quot;action&quot;: &quot;refuse&quot;, &quot;reason&quot;: &quot;...&quot;}</code></li>
<li>区分&quot;硬约束&quot;和&quot;软约束&quot;：硬约束（安全规则）不可违反，软约束（输出偏好）在特殊情况下可以放松</li>
<li>将约束从&quot;禁止列表&quot;改为&quot;优先级列表&quot;：先尝试 X，如果不行可以 Y，最后可以 Z</li>
</ul>
<h3>8.4 Prompt Injection 在 Agent 中的放大效应</h3>
<p>在 Chatbot 中，Prompt Injection 最多让模型输出不当内容。但在 Agent 中，Prompt Injection 可能触发<strong>真实的工具调用</strong>——删除数据、发送邮件、调用 API。</p>
<p><strong>应对：</strong></p>
<ul>
<li>用户输入和系统指令之间必须有明确的分隔标记</li>
<li>工具调用前做参数校验（schema validation），而非完全信任 LLM 输出</li>
<li>高危操作（删除、支付、发送）增加人工确认步骤</li>
<li>将用户输入视为&quot;不可信数据&quot;，在 Prompt 中明确标注：<code>[USER INPUT - UNTRUSTED]: {user_message}</code></li>
</ul>
<hr>
<h2>9. 结语：从 Prompt 到 Runtime</h2>
<p>Prompt Engineering for Agents 的本质是<strong>为 LLM 定义一套可编程的行为接口</strong>。我们在本文中讨论了分层架构、设计模式、推理策略、测试方法和 context 管理——这些都是让 Agent &quot;可控&quot;的基础设施。</p>
<p>但 Prompt 本身只是 Agent 系统的一个组件。再好的 Prompt 也需要一个可靠的 Runtime 来驱动——处理 LLM 的响应、管理状态机的转换、执行工具调用、处理错误和重试。</p>
<p>下一篇文章《Agent Runtime from Scratch: 不依赖框架构建 Agent》将从零开始实现一个完整的 Agent 运行时。我们会把本文设计的 Prompt 模式，放进一个真实可运行的控制循环中，展示 Prompt、工具、状态管理和错误处理如何在代码层面协同工作。</p>
<p><strong>进一步思考：</strong></p>
<ol>
<li><p><strong>Prompt 的自动优化</strong>：如果我们有了 Prompt 测试框架和评估指标，是否可以用搜索算法（DSPy 的思路）自动优化 Prompt？这和手工调优的 trade-off 在哪里？</p>
</li>
<li><p><strong>Multi-Model Prompt 策略</strong>：Router 用小模型（快、便宜），Planner 用大模型（准、贵），Executor 用中等模型。不同模型对 Prompt 的响应特性不同，如何为不同模型定制 Prompt？</p>
</li>
<li><p><strong>Prompt 的可解释性</strong>：当 Agent 做出错误决策时，我们如何从 Prompt 和输出中定位问题根因？这需要什么样的 observability 基础设施？</p>
</li>
<li><p><strong>动态 Prompt 生成</strong>：是否可以让一个 &quot;Meta-Agent&quot; 根据当前任务特征，动态生成最合适的 Prompt？这会引入什么样的复杂性和风险？</p>
</li>
</ol>
<hr>
<blockquote>
<p><strong>系列导航</strong>：本文是 Agentic 系列的第 06 篇。</p>
<ul>
<li>上一篇：<a href="/blog/engineering/agentic/05-Tool%20Calling%20Deep%20Dive">05 | Tool Calling Deep Dive</a></li>
<li>下一篇：<a href="/blog/engineering/agentic/07-Agent%20Runtime%20from%20Scratch">07 | Agent Runtime from Scratch</a></li>
<li>完整目录：<a href="/blog/engineering/agentic/01-From%20LLM%20to%20Agent">01 | From LLM to Agent</a></li>
</ul>
</blockquote>
17:T7a49,<h1>架构师的认知升级：从技术深度到系统决策能力</h1>
<blockquote>
<p>架构的本质不是技术选型，而是在约束条件下做出最合理的决策。架构师的成长不是一蹴而就的技能习得，而是从&quot;解决问题&quot;到&quot;定义问题&quot;的思维蜕变。</p>
</blockquote>
<p>技术人的职业发展中，&quot;架构师&quot;是一个绕不开的里程碑。但很多人对架构师的认知停留在&quot;画架构图&quot;或&quot;选技术栈&quot;的层面，这远远不够。真正的架构能力是一种系统化的思维方式——它要求你既能深入技术细节，又能站在全局视角做出取舍。</p>
<p>本文将从架构的本质定义出发，系统梳理架构师的能力模型、知识体系、设计方法论与成长路径，为技术人提供一份可落地的架构认知框架。</p>
<h2>什么是架构？</h2>
<h3>从定义到本质</h3>
<p>IEEE 1471 对软件架构的定义是：</p>
<blockquote>
<p><strong>软件架构是一个系统的基本组织，由其组件、组件之间的关系以及与环境之间的关系，还有指导其设计和演化的原则所体现。</strong></p>
</blockquote>
<p>这个定义包含三个关键要素：</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>组件（Components）</strong></td>
<td>系统的构成单元</td>
<td>服务、模块、数据库、消息队列</td>
</tr>
<tr>
<td><strong>关系（Relationships）</strong></td>
<td>组件之间的交互方式</td>
<td>同步调用、异步消息、事件驱动</td>
</tr>
<tr>
<td><strong>原则（Principles）</strong></td>
<td>指导设计决策的约束</td>
<td>高内聚低耦合、最终一致性、服务自治</td>
</tr>
</tbody></table>
<p>架构的本质可以用一句话概括：<strong>架构 = 结构 + 决策 + 演进</strong>。</p>
<ul>
<li><strong>结构</strong>是系统的静态组织方式</li>
<li><strong>决策</strong>是在多种方案中做出的关键取舍</li>
<li><strong>演进</strong>是架构随业务发展持续适应的能力</li>
</ul>
<h3>架构的四个层次</h3>
<p>在企业级系统中，架构通常分为四个层次，每一层关注的维度不同：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>关注点</th>
<th>核心问题</th>
<th>典型产出</th>
</tr>
</thead>
<tbody><tr>
<td><strong>业务架构</strong></td>
<td>业务域、能力、流程</td>
<td>业务边界在哪？核心能力是什么？</td>
<td>业务能力地图、流程图</td>
</tr>
<tr>
<td><strong>应用架构</strong></td>
<td>系统边界、服务划分</td>
<td>系统如何拆分？服务如何协作？</td>
<td>应用全景图、服务依赖图</td>
</tr>
<tr>
<td><strong>技术架构</strong></td>
<td>技术选型、基础设施</td>
<td>用什么技术实现？如何部署？</td>
<td>技术栈选型、部署架构图</td>
</tr>
<tr>
<td><strong>数据架构</strong></td>
<td>数据模型、流转、存储</td>
<td>数据如何组织？如何流转？</td>
<td>数据模型、数据流图</td>
</tr>
</tbody></table>
<p>四个层次之间的关系是<strong>自上而下驱动、自下而上支撑</strong>：</p>
<pre><code>业务架构（WHY）
    ↓ 驱动
应用架构（WHAT）
    ↓ 驱动
技术架构 + 数据架构（HOW）
</code></pre>
<p>很多技术人在做架构设计时直接跳到&quot;用什么技术&quot;，忽略了业务架构和应用架构的推导过程。<strong>脱离业务的架构设计就是空中楼阁。</strong></p>
<h2>架构师的核心能力模型</h2>
<p>架构师不是一个纯技术角色，而是技术与业务之间的桥梁。一个合格的架构师需要具备以下六个维度的能力：</p>
<h3>能力雷达图</h3>
<table>
<thead>
<tr>
<th>能力维度</th>
<th>定义</th>
<th>初级要求</th>
<th>高级要求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>技术深度</strong></td>
<td>对核心技术的原理级理解</td>
<td>掌握主力技术栈源码</td>
<td>能从原理推导解决方案</td>
</tr>
<tr>
<td><strong>技术广度</strong></td>
<td>对多领域技术的了解</td>
<td>熟悉 3+ 技术领域</td>
<td>能做跨领域技术整合</td>
</tr>
<tr>
<td><strong>抽象能力</strong></td>
<td>从具象中提炼本质的能力</td>
<td>能做模块抽象</td>
<td>能做业务域建模</td>
</tr>
<tr>
<td><strong>业务理解</strong></td>
<td>对业务本质和商业逻辑的洞察</td>
<td>理解业务流程</td>
<td>能用技术语言翻译业务战略</td>
</tr>
<tr>
<td><strong>系统思维</strong></td>
<td>全局视角和权衡取舍的能力</td>
<td>能做技术方案对比</td>
<td>能在复杂约束下做最优决策</td>
</tr>
<tr>
<td><strong>沟通影响</strong></td>
<td>跨团队协调和技术布道的能力</td>
<td>能清晰表达方案</td>
<td>能影响组织技术方向</td>
</tr>
</tbody></table>
<h3>架构思维的三个核心</h3>
<p><strong>1. 抽象思维</strong></p>
<p>抽象是架构师最重要的思维能力。抽象不是简单的&quot;去掉细节&quot;，而是<strong>识别事物的本质特征，忽略非本质差异</strong>。</p>
<pre><code>具体问题: 订单超时未支付需要自动取消
    ↓ 抽象
通用问题: 延时任务调度
    ↓ 进一步抽象
核心模型: 时间驱动的状态机
</code></pre>
<p>好的抽象应该是<strong>稳定的</strong>——业务在变，但抽象出的模型不轻易变化。比如&quot;购物车&quot;的业务形态千差万别，但抽象到本质就是&quot;临时容器 + 商品列表 + 计价规则&quot;。</p>
<p><strong>2. 分解思维</strong></p>
<p>复杂系统必须被分解才能被理解和管理。分解的关键是找到<strong>正确的切面</strong>：</p>
<table>
<thead>
<tr>
<th>分解方式</th>
<th>切面</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>水平分层</td>
<td>职责层次</td>
<td>展示层 / 业务层 / 数据层</td>
</tr>
<tr>
<td>垂直切分</td>
<td>业务域</td>
<td>按业务领域拆分微服务</td>
</tr>
<tr>
<td>功能分解</td>
<td>能力单元</td>
<td>将系统拆分为可独立部署的功能模块</td>
</tr>
<tr>
<td>流程分解</td>
<td>时间序列</td>
<td>将长流程拆分为异步编排的子流程</td>
</tr>
</tbody></table>
<p><strong>3. 权衡思维</strong></p>
<p>架构设计没有银弹，只有 Trade-off。架构师需要在以下维度中不断权衡：</p>
<ul>
<li><strong>一致性 vs 可用性</strong>（CAP 定理）</li>
<li><strong>性能 vs 可维护性</strong>（内联 vs 抽象）</li>
<li><strong>灵活性 vs 复杂度</strong>（配置化 vs 硬编码）</li>
<li><strong>当前成本 vs 未来成本</strong>（快速交付 vs 技术债务）</li>
<li><strong>理想方案 vs 资源约束</strong>（完美设计 vs 现实落地）</li>
</ul>
<blockquote>
<p>架构师的价值不在于设计出最优方案，而在于在给定约束下设计出最合理的方案。</p>
</blockquote>
<h2>架构设计三原则</h2>
<p>在做架构决策时，有三条根本性原则需要遵循：</p>
<h3>合适原则</h3>
<p><strong>合适优于先进。</strong> 没有最好的架构，只有最合适的架构。</p>
<p>一个日活 1000 的内部管理系统不需要微服务架构；一个创业期产品不需要分布式事务框架。架构的选择必须匹配：</p>
<ul>
<li><strong>业务阶段</strong>：0→1 阶段优先快速验证，1→N 阶段优先可扩展性</li>
<li><strong>团队能力</strong>：团队驾驭不了的架构就是最差的架构</li>
<li><strong>资源约束</strong>：时间、人力、基础设施的现实限制</li>
</ul>
<h3>简单原则</h3>
<p><strong>简单优于复杂。</strong> 如果两个方案能达到相同效果，选更简单的那个。</p>
<p>复杂度是软件系统的头号杀手。每引入一个组件、一层抽象、一种模式，都要问自己：<strong>这个复杂度带来的收益，是否大于它引入的成本？</strong></p>
<pre><code>单体应用能解决的问题 → 不要用微服务
本地缓存能解决的问题 → 不要用分布式缓存
同步调用能解决的问题 → 不要用消息队列
</code></pre>
<h3>演化原则</h3>
<p><strong>演化优于一步到位。</strong> 架构不是一次性设计出来的，而是演化出来的。</p>
<p>优秀的架构师不会试图在第一天就设计出&quot;完美架构&quot;，而是：</p>
<ol>
<li>识别当前最关键的架构决策，做出合理选择</li>
<li>为未来的变化预留扩展点（而不是过度设计）</li>
<li>建立持续演进的机制（架构治理、技术债务管理）</li>
</ol>
<h2>技术知识体系全景</h2>
<p>架构师需要具备广泛而有深度的技术知识。以下是一个体系化的技术知识地图：</p>
<h3>编程基础与语言</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心知识点</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构与算法</td>
<td>树、图、哈希、排序、动态规划、时间/空间复杂度分析</td>
</tr>
<tr>
<td>设计模式</td>
<td>创建型、结构型、行为型模式；反模式识别</td>
</tr>
<tr>
<td>编程范式</td>
<td>OOP、函数式编程、响应式编程</td>
</tr>
<tr>
<td>JVM 体系</td>
<td>内存模型、GC 算法、类加载机制、JIT 编译、性能调优</td>
</tr>
<tr>
<td>并发编程</td>
<td>线程模型、锁机制、AQS、并发容器、线程池、协程</td>
</tr>
</tbody></table>
<h3>框架与中间件</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心技术</th>
<th>需要理解的深度</th>
</tr>
</thead>
<tbody><tr>
<td>Web 框架</td>
<td>Spring Boot / Spring MVC</td>
<td>IoC 容器原理、AOP 实现、自动配置机制</td>
</tr>
<tr>
<td>ORM 框架</td>
<td>MyBatis / JPA</td>
<td>SQL 映射原理、缓存机制、N+1 问题</td>
</tr>
<tr>
<td>RPC 框架</td>
<td>Dubbo / gRPC</td>
<td>序列化协议、服务发现、负载均衡策略</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka / RocketMQ / RabbitMQ</td>
<td>消息模型、持久化机制、顺序性保证、事务消息</td>
</tr>
<tr>
<td>缓存系统</td>
<td>Redis / Caffeine</td>
<td>数据结构、持久化、集群方案、缓存一致性</td>
</tr>
<tr>
<td>搜索引擎</td>
<td>Elasticsearch</td>
<td>倒排索引、分词、相关性评分、集群管理</td>
</tr>
<tr>
<td>数据库</td>
<td>MySQL / PostgreSQL</td>
<td>索引原理（B+ 树）、事务隔离级别、锁机制、主从复制</td>
</tr>
</tbody></table>
<h3>分布式与云原生</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心知识点</th>
</tr>
</thead>
<tbody><tr>
<td>分布式理论</td>
<td>CAP 定理、BASE 理论、FLP 不可能定理</td>
</tr>
<tr>
<td>一致性协议</td>
<td>Paxos、Raft、ZAB、Gossip</td>
</tr>
<tr>
<td>分布式事务</td>
<td>2PC、3PC、TCC、Saga、本地消息表</td>
</tr>
<tr>
<td>服务治理</td>
<td>服务发现、负载均衡、熔断降级、限流、灰度发布</td>
</tr>
<tr>
<td>容器与编排</td>
<td>Docker、Kubernetes、Service Mesh（Istio）</td>
</tr>
<tr>
<td>DevOps</td>
<td>CI/CD、GitOps、IaC、可观测性（Metrics/Logging/Tracing）</td>
</tr>
</tbody></table>
<h3>架构设计能力</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心知识点</th>
</tr>
</thead>
<tbody><tr>
<td>架构模式</td>
<td>分层架构、微服务、事件驱动、CQRS、六边形架构</td>
</tr>
<tr>
<td>高可用设计</td>
<td>冗余、故障转移、限流降级、异地多活</td>
</tr>
<tr>
<td>高性能设计</td>
<td>缓存策略、异步化、并行化、池化、零拷贝</td>
</tr>
<tr>
<td>可扩展设计</td>
<td>水平扩展、分库分表、读写分离、弹性伸缩</td>
</tr>
<tr>
<td>安全设计</td>
<td>认证授权、数据加密、SQL 注入防御、OWASP Top 10</td>
</tr>
</tbody></table>
<h2>分布式系统核心理论</h2>
<p>分布式系统是现代架构的基石，理解其核心理论是架构师的必修课。</p>
<h3>CAP 定理</h3>
<p>分布式系统不可能同时满足以下三个特性：</p>
<ul>
<li><strong>C（Consistency）一致性</strong>：所有节点在同一时刻看到的数据一致</li>
<li><strong>A（Availability）可用性</strong>：每个请求都能收到非错误响应</li>
<li><strong>P（Partition Tolerance）分区容错性</strong>：网络分区时系统仍能继续运行</li>
</ul>
<p>由于网络分区在分布式环境中不可避免，实际上的选择是在 <strong>CP</strong> 和 <strong>AP</strong> 之间做取舍：</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>含义</th>
<th>典型场景</th>
<th>代表系统</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP</strong></td>
<td>牺牲可用性保一致性</td>
<td>金融交易、库存扣减</td>
<td>ZooKeeper、etcd、HBase</td>
</tr>
<tr>
<td><strong>AP</strong></td>
<td>牺牲一致性保可用性</td>
<td>商品展示、用户动态</td>
<td>Cassandra、DynamoDB、Eureka</td>
</tr>
</tbody></table>
<h3>BASE 理论</h3>
<p>BASE 是对 CAP 中 AP 方案的延伸，是大规模互联网系统的实践指导：</p>
<ul>
<li><strong>BA（Basically Available）基本可用</strong>：允许部分功能降级，保证核心功能可用</li>
<li><strong>S（Soft State）软状态</strong>：允许中间状态存在，不要求实时一致</li>
<li><strong>E（Eventually Consistent）最终一致性</strong>：经过一段时间后，数据最终达到一致</li>
</ul>
<h3>一致性协议</h3>
<p>分布式共识是解决多节点数据一致性的核心手段：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>核心思想</th>
<th>复杂度</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Paxos</strong></td>
<td>提案-承诺-接受三阶段</td>
<td>高，难以工程实现</td>
<td>Google Chubby</td>
</tr>
<tr>
<td><strong>Raft</strong></td>
<td>Leader 选举 + 日志复制</td>
<td>中，易于理解和实现</td>
<td>etcd、Consul</td>
</tr>
<tr>
<td><strong>ZAB</strong></td>
<td>崩溃恢复 + 消息广播</td>
<td>中</td>
<td>ZooKeeper</td>
</tr>
<tr>
<td><strong>Gossip</strong></td>
<td>去中心化的信息传播</td>
<td>低，最终一致</td>
<td>Redis Cluster、Consul（成员管理）</td>
</tr>
</tbody></table>
<h3>分布式事务</h3>
<p>跨服务的数据一致性是分布式系统最具挑战性的问题之一：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>一致性</th>
<th>性能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2PC</strong></td>
<td>准备-提交两阶段</td>
<td>强一致</td>
<td>低（同步阻塞）</td>
<td>数据库层面的跨库事务</td>
</tr>
<tr>
<td><strong>TCC</strong></td>
<td>Try-Confirm-Cancel</td>
<td>强一致</td>
<td>中</td>
<td>资金类高一致性业务</td>
</tr>
<tr>
<td><strong>Saga</strong></td>
<td>正向操作 + 补偿操作</td>
<td>最终一致</td>
<td>高</td>
<td>长流程业务编排</td>
</tr>
<tr>
<td><strong>本地消息表</strong></td>
<td>本地事务 + 异步消息</td>
<td>最终一致</td>
<td>高</td>
<td>跨服务异步通知</td>
</tr>
<tr>
<td><strong>事务消息</strong></td>
<td>半消息 + 确认机制</td>
<td>最终一致</td>
<td>高</td>
<td>基于 MQ 的数据同步</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>实践建议</strong>：绝大多数业务场景不需要强一致性。优先考虑最终一致性方案（Saga、本地消息表），只有在资金、库存等核心场景才使用 TCC。</p>
</blockquote>
<h2>架构演进：从单体到云原生</h2>
<p>架构不是一成不变的，它随着业务规模和技术发展不断演进。理解每个阶段的特征和驱动力，比记住具体方案更重要。</p>
<h3>演进路线</h3>
<pre><code>单体架构 → 垂直拆分 → SOA → 微服务 → 云原生 → Serverless
</code></pre>
<h3>各阶段特征对比</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>核心特征</th>
<th>解决的问题</th>
<th>引入的问题</th>
<th>适用规模</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单体架构</strong></td>
<td>所有功能在一个进程</td>
<td>开发部署简单</td>
<td>扩展困难、技术栈锁定</td>
<td>初创期、小团队</td>
</tr>
<tr>
<td><strong>垂直拆分</strong></td>
<td>按业务线拆分独立应用</td>
<td>业务隔离、独立扩展</td>
<td>公共功能重复、数据冗余</td>
<td>多业务线</td>
</tr>
<tr>
<td><strong>SOA</strong></td>
<td>服务化 + ESB 集中治理</td>
<td>服务复用、统一治理</td>
<td>ESB 单点瓶颈、治理复杂</td>
<td>中大型企业</td>
</tr>
<tr>
<td><strong>微服务</strong></td>
<td>细粒度服务 + 去中心化</td>
<td>独立部署、技术异构</td>
<td>运维复杂度、分布式事务</td>
<td>大型互联网</td>
</tr>
<tr>
<td><strong>云原生</strong></td>
<td>容器化 + 编排 + 服务网格</td>
<td>弹性伸缩、基础设施抽象</td>
<td>技术栈门槛高、学习曲线陡</td>
<td>规模化互联网</td>
</tr>
<tr>
<td><strong>Serverless</strong></td>
<td>函数计算 + 事件驱动</td>
<td>零运维、按需付费</td>
<td>冷启动、厂商锁定</td>
<td>事件驱动型业务</td>
</tr>
</tbody></table>
<h3>演进的驱动力</h3>
<p>架构演进不是为了追新，而是被以下力量推动的：</p>
<ol>
<li><strong>业务复杂度增长</strong>：单体无法承载越来越复杂的业务逻辑</li>
<li><strong>团队规模扩大</strong>：多团队并行开发需要服务边界隔离</li>
<li><strong>流量规模变化</strong>：从百级到亿级 QPS 需要不同的架构模式</li>
<li><strong>交付效率要求</strong>：从月级发布到日级发布需要服务独立部署</li>
<li><strong>技术生态成熟</strong>：容器、服务网格等基础设施的成熟降低了架构升级的门槛</li>
</ol>
<blockquote>
<p><strong>关键认知</strong>：架构演进应该是业务驱动的、渐进式的。不要因为&quot;微服务很火&quot;就拆分单体，也不要因为&quot;Kubernetes 很酷&quot;就上云原生。每次架构升级都应该有明确的业务收益支撑。</p>
</blockquote>
<h2>架构设计方法论</h2>
<p>光有知识储备还不够，架构师需要一套系统化的方法论来指导架构设计过程。</p>
<h3>TOGAF：企业架构框架</h3>
<p>TOGAF（The Open Group Architecture Framework）是最广泛采用的企业架构框架，其核心是 <strong>ADM（Architecture Development Method）</strong> 架构开发方法：</p>
<pre><code>预备阶段 → 架构愿景 → 业务架构 → 信息系统架构 → 技术架构
    → 机会和解决方案 → 迁移规划 → 实施治理 → 架构变更管理
</code></pre>
<p>TOGAF 的核心价值在于提供了一套<strong>从业务到技术的推导过程</strong>，避免架构设计的随意性。</p>
<h3>架构设计的四步法</h3>
<p>在实际工作中，可以将架构设计简化为四个步骤：</p>
<p><strong>第一步：需求分析与约束识别</strong></p>
<pre><code>功能需求 → 系统需要做什么？
质量需求 → 性能、可用性、安全性指标是什么？
约束条件 → 时间、人力、技术栈、合规要求有哪些？
</code></pre>
<p><strong>第二步：关键决策与方案选型</strong></p>
<p>识别架构中的关键决策点（通常是那些一旦确定就难以更改的决策），然后对每个决策点做方案对比：</p>
<table>
<thead>
<tr>
<th>决策点</th>
<th>方案 A</th>
<th>方案 B</th>
<th>选择依据</th>
</tr>
</thead>
<tbody><tr>
<td>服务通信</td>
<td>REST</td>
<td>gRPC</td>
<td>内部服务间高频调用选 gRPC</td>
</tr>
<tr>
<td>数据存储</td>
<td>MySQL</td>
<td>MongoDB</td>
<td>结构化数据 + 事务需求选 MySQL</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka</td>
<td>RocketMQ</td>
<td>需要事务消息选 RocketMQ</td>
</tr>
</tbody></table>
<p><strong>第三步：架构方案设计</strong></p>
<p>从全局到局部，分层输出架构方案：</p>
<ol>
<li>系统上下文图（C4 Level 1）：系统与外部的关系</li>
<li>容器图（C4 Level 2）：系统内部的主要构件</li>
<li>组件图（C4 Level 3）：关键服务的内部结构</li>
<li>关键流程的时序图</li>
</ol>
<p><strong>第四步：架构评审与验证</strong></p>
<p>使用 <strong>ATAM（Architecture Tradeoff Analysis Method）</strong> 对架构方案进行评审：</p>
<ul>
<li>识别架构中的风险点</li>
<li>验证方案是否满足质量属性需求</li>
<li>确认 Trade-off 是否被利益相关者接受</li>
</ul>
<h3>架构决策记录（ADR）</h3>
<p>每个重要的架构决策都应该被记录下来，格式可以采用 ADR：</p>
<pre><code># ADR-001: 采用事件驱动架构处理订单状态变更

## 状态
已采纳

## 背景
订单状态变更需要通知下游 10+ 个系统，同步调用导致耦合严重且响应时间过长。

## 决策
采用事件驱动架构，订单状态变更时发布领域事件，下游系统订阅事件自行处理。

## 影响
- 正面：服务解耦、响应时间降低、可扩展性增强
- 负面：引入最终一致性、增加消息中间件运维成本、需要处理消息幂等

## 备选方案
1. 同步 HTTP 调用（被否：耦合度高、链路过长）
2. 数据库轮询（被否：实时性差、数据库压力大）
</code></pre>
<h2>高可用架构设计</h2>
<p>高可用是架构设计中最核心的质量属性之一。它的本质是<strong>通过冗余和自动化来对抗故障的不确定性</strong>。</p>
<h3>可用性度量</h3>
<table>
<thead>
<tr>
<th>可用性等级</th>
<th>年度不可用时间</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td>99%（2 个 9）</td>
<td>3.65 天</td>
<td>内部管理系统</td>
</tr>
<tr>
<td>99.9%（3 个 9）</td>
<td>8.76 小时</td>
<td>一般业务系统</td>
</tr>
<tr>
<td>99.99%（4 个 9）</td>
<td>52.56 分钟</td>
<td>核心交易系统</td>
</tr>
<tr>
<td>99.999%（5 个 9）</td>
<td>5.26 分钟</td>
<td>金融核心系统</td>
</tr>
</tbody></table>
<h3>高可用设计策略</h3>
<p><strong>冗余策略</strong>：消除单点故障</p>
<pre><code>单点             →  冗余方案
单台应用服务器    →  集群 + 负载均衡
单个数据库实例    →  主从复制 + 自动切换
单个机房          →  同城双活 / 异地多活
单个注册中心      →  集群部署 + 多节点
</code></pre>
<p><strong>容错策略</strong>：优雅应对局部故障</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>原理</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>超时控制</td>
<td>避免无限等待</td>
<td>设置合理的超时时间</td>
</tr>
<tr>
<td>重试机制</td>
<td>应对瞬时故障</td>
<td>指数退避 + 最大重试次数</td>
</tr>
<tr>
<td>熔断器</td>
<td>防止故障蔓延</td>
<td>Hystrix / Sentinel / Resilience4j</td>
</tr>
<tr>
<td>降级策略</td>
<td>保核心弃非核心</td>
<td>返回默认值、关闭非关键功能</td>
</tr>
<tr>
<td>限流控制</td>
<td>保护系统容量</td>
<td>令牌桶、滑动窗口</td>
</tr>
<tr>
<td>隔离机制</td>
<td>故障域隔离</td>
<td>线程池隔离、信号量隔离、泳道隔离</td>
</tr>
</tbody></table>
<p><strong>发布策略</strong>：变更是故障的主要来源</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>原理</th>
<th>风险</th>
</tr>
</thead>
<tbody><tr>
<td>蓝绿部署</td>
<td>两套环境瞬间切换</td>
<td>资源成本翻倍</td>
</tr>
<tr>
<td>滚动发布</td>
<td>逐步替换旧实例</td>
<td>新旧版本短暂共存</td>
</tr>
<tr>
<td>金丝雀发布</td>
<td>小流量验证后全量</td>
<td>需要流量分配能力</td>
</tr>
<tr>
<td>Feature Flag</td>
<td>功能开关控制上线</td>
<td>代码分支复杂度增加</td>
</tr>
</tbody></table>
<h2>高性能架构设计</h2>
<p>高性能不是&quot;用最快的技术&quot;，而是&quot;在每个环节消除不必要的等待和浪费&quot;。</p>
<h3>性能优化的分层思路</h3>
<pre><code>用户端 → CDN/静态资源优化 → 接入层(负载均衡/连接池)
    → 应用层(缓存/异步/并行) → 数据层(索引/分库分表/读写分离)
</code></pre>
<h3>核心优化策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>原理</th>
<th>典型实践</th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓存</strong></td>
<td>用空间换时间</td>
<td>多级缓存（L1 本地 → L2 分布式 → DB）</td>
</tr>
<tr>
<td><strong>异步化</strong></td>
<td>将串行变并行</td>
<td>消息队列异步处理非关键路径</td>
</tr>
<tr>
<td><strong>并行化</strong></td>
<td>充分利用多核</td>
<td>CompletableFuture 并行调用多个下游</td>
</tr>
<tr>
<td><strong>池化</strong></td>
<td>复用昂贵资源</td>
<td>连接池、线程池、对象池</td>
</tr>
<tr>
<td><strong>批量化</strong></td>
<td>减少 I/O 次数</td>
<td>批量查询、批量写入、Pipeline</td>
</tr>
<tr>
<td><strong>预计算</strong></td>
<td>提前计算结果</td>
<td>离线计算报表、预生成推荐结果</td>
</tr>
<tr>
<td><strong>压缩</strong></td>
<td>减少传输量</td>
<td>Gzip 压缩、Protocol Buffers</td>
</tr>
</tbody></table>
<h3>缓存设计的三大问题</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓存穿透</strong></td>
<td>查询不存在的数据</td>
<td>布隆过滤器、空值缓存</td>
</tr>
<tr>
<td><strong>缓存击穿</strong></td>
<td>热点 Key 过期瞬间</td>
<td>互斥锁、永不过期 + 异步更新</td>
</tr>
<tr>
<td><strong>缓存雪崩</strong></td>
<td>大量 Key 同时过期</td>
<td>过期时间加随机值、多级缓存</td>
</tr>
</tbody></table>
<h2>架构师的软实力</h2>
<p>技术能力是架构师的基础，但真正决定架构师高度的是软实力。</p>
<h3>决策能力：在不确定性中做选择</h3>
<p>架构决策往往发生在信息不完全的情况下。优秀的架构师需要：</p>
<ul>
<li><strong>识别关键决策与次要决策</strong>：不是每个技术选择都需要深度分析，把精力放在不可逆的关键决策上</li>
<li><strong>设定决策框架</strong>：明确评估维度和权重，避免拍脑袋决策</li>
<li><strong>接受&quot;足够好&quot;而非&quot;最优&quot;</strong>：在时间压力下，80% 的正确比 100% 的犹豫更有价值</li>
</ul>
<h3>沟通能力：让技术方案&quot;被买单&quot;</h3>
<p>架构师的方案再好，如果不能被团队理解和接受，就等于零。有效的技术沟通需要：</p>
<ul>
<li><strong>面向不同听众调整表达</strong>：给 CEO 讲业务价值，给研发讲技术方案，给运维讲部署方案</li>
<li><strong>用图说话</strong>：一张好的架构图胜过千字描述</li>
<li><strong>讲清&quot;为什么不选 B&quot;</strong>：决策的说服力不在于方案 A 有多好，而在于你对备选方案的分析有多透彻</li>
</ul>
<h3>平衡能力：在理想与现实之间</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>理想主义</th>
<th>务实主义</th>
<th>平衡点</th>
</tr>
</thead>
<tbody><tr>
<td>代码质量</td>
<td>完美的代码</td>
<td>能跑就行</td>
<td>核心模块高质量，边缘模块可接受</td>
</tr>
<tr>
<td>技术债务</td>
<td>零债务</td>
<td>先上线</td>
<td>有计划地管理技术债务</td>
</tr>
<tr>
<td>架构设计</td>
<td>一步到位</td>
<td>走一步算一步</td>
<td>关键决策前瞻设计 + 渐进演化</td>
</tr>
<tr>
<td>新技术</td>
<td>全面拥抱</td>
<td>保守不动</td>
<td>在非核心场景试点验证</td>
</tr>
</tbody></table>
<h2>架构师成长路径</h2>
<h3>成长阶段</h3>
<pre><code>初级开发 → 高级开发 → 技术主管 → 架构师 → 首席架构师/CTO
</code></pre>
<p>每个阶段的核心差异在于<strong>视野的宽度和决策的影响范围</strong>：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>关注范围</th>
<th>核心能力</th>
<th>时间分配</th>
</tr>
</thead>
<tbody><tr>
<td><strong>初级开发</strong></td>
<td>单个功能模块</td>
<td>编码能力、调试能力</td>
<td>80% 编码 + 20% 设计</td>
</tr>
<tr>
<td><strong>高级开发</strong></td>
<td>单个系统/服务</td>
<td>系统设计、性能优化</td>
<td>60% 编码 + 40% 设计</td>
</tr>
<tr>
<td><strong>技术主管</strong></td>
<td>多个系统/团队</td>
<td>技术决策、团队管理</td>
<td>30% 编码 + 50% 设计 + 20% 管理</td>
</tr>
<tr>
<td><strong>架构师</strong></td>
<td>技术体系全局</td>
<td>架构设计、技术战略</td>
<td>10% 编码 + 60% 设计 + 30% 沟通</td>
</tr>
<tr>
<td><strong>首席架构师</strong></td>
<td>技术 + 业务全局</td>
<td>技术愿景、组织影响</td>
<td>70% 战略 + 30% 关键问题攻坚</td>
</tr>
</tbody></table>
<h3>从开发到架构师的关键跨越</h3>
<p>很多优秀的开发者在向架构师转型时会遇到瓶颈。核心原因在于需要完成三个关键跨越：</p>
<p><strong>跨越一：从&quot;怎么做&quot;到&quot;做不做&quot;</strong></p>
<p>开发者关注的是&quot;如何实现一个功能&quot;，架构师关注的是&quot;这个功能应不应该做，用什么方式做最合理&quot;。这是从执行思维到决策思维的跨越。</p>
<p><strong>跨越二：从&quot;局部最优&quot;到&quot;全局最优&quot;</strong></p>
<p>开发者追求单个模块的代码质量，架构师追求整个系统的平衡。有时候某个模块的&quot;不完美&quot;恰恰是全局最优的选择。</p>
<p><strong>跨越三：从&quot;技术驱动&quot;到&quot;业务驱动&quot;</strong></p>
<p>开发者用技术解决问题，架构师用技术创造业务价值。如果不理解业务，就无法做出正确的架构决策。</p>
<h3>持续成长的方法</h3>
<ol>
<li><strong>深度学习</strong>：选 2-3 个核心技术领域，深入到源码级别理解</li>
<li><strong>广度拓展</strong>：关注技术趋势，了解不同领域的架构模式</li>
<li><strong>实践总结</strong>：每个项目结束后做架构复盘，记录 ADR</li>
<li><strong>输出分享</strong>：写技术博客、做技术分享，输出倒逼输入</li>
<li><strong>跨界学习</strong>：了解业务、产品、运营，建立全局视角</li>
</ol>
<h2>总结</h2>
<p>架构师的成长是一条从&quot;技术专精&quot;到&quot;架构思维&quot;的蜕变之路。这条路上有几个核心认知需要建立：</p>
<ol>
<li><strong>架构是决策，不是画图</strong>。架构师的核心价值在于在复杂约束条件下做出合理的技术决策</li>
<li><strong>业务是根基，技术是手段</strong>。脱离业务的架构设计没有意义，技术选型必须服务于业务目标</li>
<li><strong>简单是终极的复杂</strong>。能用简单方案解决的问题，不要用复杂方案；能不引入的组件，就不引入</li>
<li><strong>演化优于完美</strong>。不要追求一步到位的架构设计，建立持续演进的能力比设计完美的架构更重要</li>
<li><strong>Trade-off 是永恒的主题</strong>。没有银弹，只有在给定约束下的最佳平衡</li>
</ol>
<blockquote>
<p><strong>一个架构师的成熟度，不在于他掌握了多少种技术，而在于他知道什么时候不该用某种技术。</strong></p>
</blockquote>
18:T5870,<blockquote>
<p>Java 中的大部分同步工具（ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）都基于 AbstractQueuedSynchronizer（AQS）实现。理解 AQS，就等于掌握了 Java 并发编程的底层脉络。本文从设计思想出发，逐层深入 AQS 的数据结构、核心流程和源码实现，并通过 ReentrantLock 串联全局，最后梳理 AQS 在 JUC 中的应用全景。</p>
</blockquote>
<h2>AQS 是什么？</h2>
<p>AQS（AbstractQueuedSynchronizer）是 <code>java.util.concurrent.locks</code> 包中的一个<strong>抽象类</strong>，是构建锁和同步器的基础框架。Doug Lea 设计 AQS 的核心目标是：</p>
<ul>
<li>降低构建锁和同步器的工作量</li>
<li>避免在多个位置处理竞争问题</li>
<li>在基于 AQS 的同步器中，阻塞只可能在一个时刻发生，降低上下文切换开销，提高吞吐量</li>
</ul>
<p>AQS 支持两种工作模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
<th>典型实现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>独占模式（Exclusive）</strong></td>
<td>同一时刻只能有一个线程获取到锁</td>
<td>ReentrantLock</td>
</tr>
<tr>
<td><strong>共享模式（Shared）</strong></td>
<td>同一时刻可以有多个线程同时获取</td>
<td>CountDownLatch、ReadWriteLock、Semaphore</td>
</tr>
</tbody></table>
<p>无论哪种模式，本质上都是对 AQS 内部一个 <strong><code>state</code> 变量</strong>的获取和释放。</p>
<h2>AQS 的整体架构</h2>
<p>AQS 框架共分为<strong>五层</strong>，自上而下由浅入深：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>第一层</td>
<td>API 层</td>
<td>自定义同步器需重写的方法（tryAcquire、tryRelease 等）</td>
</tr>
<tr>
<td>第二层</td>
<td>获取/释放方法</td>
<td>acquire、release、acquireShared、releaseShared</td>
</tr>
<tr>
<td>第三层</td>
<td>队列操作</td>
<td>addWaiter、acquireQueued、shouldParkAfterFailedAcquire</td>
</tr>
<tr>
<td>第四层</td>
<td>线程阻塞/唤醒</td>
<td>LockSupport.park / unpark</td>
</tr>
<tr>
<td>第五层</td>
<td>基础数据</td>
<td>state、Node、CLH 变体队列</td>
</tr>
</tbody></table>
<p>当接入自定义同步器时，<strong>只需重写第一层的部分方法即可</strong>，不需要关注底层实现。当加锁或解锁操作触发时，沿着第一层到第五层逐层深入。</p>
<h2>核心数据结构</h2>
<h3>同步状态 State</h3>
<p>AQS 使用一个 <code>volatile int</code> 类型的成员变量 <code>state</code> 来表示同步状态：</p>
<pre><code class="language-java">private volatile int state;
</code></pre>
<p>State 的含义由具体的同步器定义，例如：</p>
<ul>
<li><strong>ReentrantLock</strong>：state 表示锁被重入的次数，0 表示未被持有</li>
<li><strong>Semaphore</strong>：state 表示可用许可的数量</li>
<li><strong>CountDownLatch</strong>：state 表示计数器的值</li>
</ul>
<p>AQS 提供三个方法操作 state，均为 <code>final</code> 修饰，子类不可重写：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>getState()</code></td>
<td>获取当前 state 值</td>
</tr>
<tr>
<td><code>setState(int)</code></td>
<td>设置 state 值</td>
</tr>
<tr>
<td><code>compareAndSetState(int, int)</code></td>
<td>CAS 方式更新 state</td>
</tr>
</tbody></table>
<h3>CLH 变体队列与 Node 节点</h3>
<p>AQS 的核心思想是：如果请求的共享资源空闲，就将当前线程设置为有效的工作线程，并将资源设置为锁定状态；<strong>如果资源被占用，就通过一个 CLH 变体的 FIFO 双向队列来管理等待线程</strong>。</p>
<blockquote>
<p>CLH 队列以其发明者 Craig、Landin 和 Hagersten 命名，原始 CLH 是单向链表。AQS 中的变体是虚拟双向队列，通过将每条请求线程封装成 Node 节点来实现锁的分配。</p>
</blockquote>
<p>Node 节点的关键属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>thread</code></td>
<td>该节点代表的线程</td>
</tr>
<tr>
<td><code>waitStatus</code></td>
<td>当前节点在队列中的等待状态</td>
</tr>
<tr>
<td><code>prev</code></td>
<td>前驱指针</td>
</tr>
<tr>
<td><code>next</code></td>
<td>后继指针</td>
</tr>
<tr>
<td><code>nextWaiter</code></td>
<td>指向下一个处于 CONDITION 状态的节点</td>
</tr>
</tbody></table>
<p><code>waitStatus</code> 的枚举值：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>默认值</td>
<td>Node 初始化时的状态</td>
</tr>
<tr>
<td>1</td>
<td>CANCELLED</td>
<td>线程获取锁的请求已取消</td>
</tr>
<tr>
<td>-1</td>
<td>SIGNAL</td>
<td>后继节点的线程需要被唤醒</td>
</tr>
<tr>
<td>-2</td>
<td>CONDITION</td>
<td>节点在条件队列中，等待 Condition 唤醒</td>
</tr>
<tr>
<td>-3</td>
<td>PROPAGATE</td>
<td>共享模式下，释放操作需要向后传播</td>
</tr>
</tbody></table>
<p>AQS 内部还维护了<strong>两种队列</strong>：</p>
<ul>
<li><strong>同步队列（Sync Queue）</strong>：获取资源失败的线程进入此队列自旋等待，当前驱节点是头节点时尝试获取资源</li>
<li><strong>条件队列（Condition Queue）</strong>：基于 <code>Condition</code> 实现，调用 <code>await()</code> 时线程进入条件队列，调用 <code>signal()</code> 时转移到同步队列</li>
</ul>
<blockquote>
<p>注意：双向链表的<strong>头节点是一个虚节点</strong>（不存储实际线程信息），真正的第一个有效节点从第二个开始。</p>
</blockquote>
<h2>自定义同步器需要重写的方法</h2>
<p>AQS 采用<strong>模板方法模式</strong>，自定义同步器只需根据需要重写以下方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tryAcquire(int)</code></td>
<td>独占</td>
<td>尝试获取资源，成功返回 true</td>
</tr>
<tr>
<td><code>tryRelease(int)</code></td>
<td>独占</td>
<td>尝试释放资源，成功返回 true</td>
</tr>
<tr>
<td><code>tryAcquireShared(int)</code></td>
<td>共享</td>
<td>尝试获取资源，负数=失败，0=成功但无剩余，正数=成功且有剩余</td>
</tr>
<tr>
<td><code>tryReleaseShared(int)</code></td>
<td>共享</td>
<td>尝试释放资源，如果释放后允许唤醒后续节点返回 true</td>
</tr>
<tr>
<td><code>isHeldExclusively()</code></td>
<td>独占</td>
<td>当前线程是否独占资源，用到 Condition 时需实现</td>
</tr>
</tbody></table>
<p>独占模式实现 <code>tryAcquire-tryRelease</code>，共享模式实现 <code>tryAcquireShared-tryReleaseShared</code>。AQS 也支持同时实现两种模式，如 <code>ReentrantReadWriteLock</code>。</p>
<h2>通过 ReentrantLock 理解加锁流程</h2>
<p>ReentrantLock 是 AQS 独占模式最典型的实现。我们以<strong>非公平锁</strong>为例，完整追踪加锁流程。</p>
<h3>第一步：lock()</h3>
<pre><code class="language-java">// ReentrantLock.NonfairSync
final void lock() {
    if (compareAndSetState(0, 1))           // 直接 CAS 尝试获取锁
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);                          // 失败则进入 AQS 框架流程
}
</code></pre>
<p>非公平锁上来就尝试 CAS 抢锁（不管队列中有没有等待线程），这是它&quot;非公平&quot;的体现。</p>
<h3>第二步：acquire()</h3>
<pre><code class="language-java">// AbstractQueuedSynchronizer
public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
</code></pre>
<p>这一行代码浓缩了整个加锁流程的四个步骤：</p>
<pre><code>tryAcquire → addWaiter → acquireQueued → selfInterrupt
</code></pre>
<ol>
<li><strong>tryAcquire</strong>：尝试获取锁（由子类实现）</li>
<li><strong>addWaiter</strong>：获取失败，将当前线程封装为 Node 加入队列尾部</li>
<li><strong>acquireQueued</strong>：在队列中自旋等待，直到获取到锁</li>
<li><strong>selfInterrupt</strong>：如果等待过程中被中断过，补上中断</li>
</ol>
<h3>第三步：tryAcquire（公平 vs 非公平）</h3>
<p><strong>非公平锁</strong>的实现：</p>
<pre><code class="language-java">final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {   // 直接 CAS，不检查队列
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {  // 可重入逻辑
        int nextc = c + acquires;
        if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}
</code></pre>
<p><strong>公平锁</strong>的区别仅在于多了一个 <code>hasQueuedPredecessors()</code> 检查：</p>
<pre><code class="language-java">if (c == 0) {
    if (!hasQueuedPredecessors() &amp;&amp;   // 公平锁：先检查队列中是否有等待线程
        compareAndSetState(0, acquires)) {
        setExclusiveOwnerThread(current);
        return true;
    }
}
</code></pre>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>state == 0 时的行为</th>
<th>可重入逻辑</th>
</tr>
</thead>
<tbody><tr>
<td>非公平锁</td>
<td>直接 CAS 抢锁</td>
<td>相同：state + 1</td>
</tr>
<tr>
<td>公平锁</td>
<td>先检查队列再 CAS</td>
<td>相同：state + 1</td>
</tr>
</tbody></table>
<h3>第四步：addWaiter — 入队</h3>
<pre><code class="language-java">private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    Node pred = tail;
    if (pred != null) {            // 队列已初始化，尝试快速入队
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);                     // 快速入队失败或队列未初始化
    return node;
}
</code></pre>
<p><code>enq()</code> 方法通过<strong>自旋 + CAS</strong> 确保入队成功：</p>
<pre><code class="language-java">private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) {                         // 队列为空，初始化
            if (compareAndSetHead(new Node()))    // 创建虚拟头节点
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
</code></pre>
<p>线程获取锁的过程可以形象理解为：</p>
<pre><code>线程1获取锁成功 → 线程2申请锁失败 → 线程2入队等待 → 线程3申请失败 → 线程3排在线程2后面 → ...
</code></pre>
<h3>第五步：acquireQueued — 自旋获取锁</h3>
<pre><code class="language-java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) {   // 前驱是头节点，尝试获取锁
                setHead(node);                     // 获取成功，当前节点成为新的头节点
                p.next = null;                     // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())           // 获取失败，判断是否需要挂起
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
</code></pre>
<p>核心逻辑：<strong>只有前驱节点是头节点的线程才有资格尝试获取锁</strong>。获取失败后，通过 <code>shouldParkAfterFailedAcquire</code> 判断是否需要挂起（将前驱节点的 waitStatus 设为 SIGNAL），然后通过 <code>LockSupport.park()</code> 挂起线程，避免空转浪费 CPU。</p>
<h3>shouldParkAfterFailedAcquire 的三种情况</h3>
<pre><code class="language-java">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)        // 前驱已经是 SIGNAL，可以安全挂起
        return true;
    if (ws &gt; 0) {                 // 前驱已取消，向前找到有效节点
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &gt; 0);
        pred.next = node;
    } else {                      // 前驱状态为 0 或 PROPAGATE，设为 SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
</code></pre>
<table>
<thead>
<tr>
<th>前驱 waitStatus</th>
<th>处理</th>
<th>是否挂起</th>
</tr>
</thead>
<tbody><tr>
<td>SIGNAL (-1)</td>
<td>直接返回 true</td>
<td>是</td>
</tr>
<tr>
<td>CANCELLED (&gt;0)</td>
<td>跳过所有取消节点，重新链接</td>
<td>否，下次循环再判断</td>
</tr>
<tr>
<td>0 或 PROPAGATE</td>
<td>CAS 设为 SIGNAL</td>
<td>否，下次循环再判断</td>
</tr>
</tbody></table>
<h2>解锁流程</h2>
<p>ReentrantLock 解锁时<strong>不区分公平和非公平</strong>：</p>
<pre><code class="language-java">// ReentrantLock
public void unlock() {
    sync.release(1);
}
</code></pre>
<pre><code class="language-java">// AbstractQueuedSynchronizer
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);          // 唤醒后继节点
        return true;
    }
    return false;
}
</code></pre>
<h3>tryRelease — 可重入锁的释放</h3>
<pre><code class="language-java">// ReentrantLock.Sync
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;       // state 减 1
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {                         // 只有 state 减到 0，锁才真正释放
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
</code></pre>
<h3>unparkSuccessor — 唤醒后继线程</h3>
<pre><code class="language-java">private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws &lt; 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    if (s == null || s.waitStatus &gt; 0) {
        s = null;
        // 从尾部向前遍历，找到第一个非取消状态的节点
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)
            if (t.waitStatus &lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);    // 唤醒线程
}
</code></pre>
<blockquote>
<p><strong>为什么要从后向前遍历？</strong> 两个原因：</p>
<ol>
<li><code>addWaiter</code> 中节点入队不是原子操作——<code>node.prev = pred</code> 和 <code>compareAndSetTail</code> 完成后，<code>pred.next = node</code> 可能还未执行。此时从前向后遍历会断链。</li>
<li><code>cancelAcquire</code> 产生 CANCELLED 节点时，先断开的是 next 指针，prev 指针未断开。因此从后向前遍历才能保证遍历完整。</li>
</ol>
</blockquote>
<h2>CANCELLED 节点的处理</h2>
<p>当 <code>acquireQueued</code> 中发生异常时，会执行 <code>cancelAcquire(node)</code> 将节点标记为 CANCELLED。处理逻辑根据节点位置分为三种情况：</p>
<table>
<thead>
<tr>
<th>节点位置</th>
<th>处理方式</th>
</tr>
</thead>
<tbody><tr>
<td>尾节点</td>
<td>将前驱设为新的 tail，其 next 置为 null</td>
</tr>
<tr>
<td>头节点的后继</td>
<td>唤醒当前节点的后继线程（unparkSuccessor）</td>
</tr>
<tr>
<td>中间节点</td>
<td>将前驱的 next 指向当前节点的后继，跳过当前节点</td>
</tr>
</tbody></table>
<blockquote>
<p><code>cancelAcquire</code> 只操作 next 指针，不操作 prev 指针。因为执行 cancel 时前驱可能已经出队，修改 prev 不安全。prev 指针的清理留给 <code>shouldParkAfterFailedAcquire</code>——此方法在获取锁失败时执行，此时共享资源已被占用，前方节点不会变化，修改 prev 是安全的。</p>
</blockquote>
<h2>中断处理机制</h2>
<p>AQS 的 <code>acquire</code> 方法是<strong>不可中断</strong>的——线程在等待过程中不会响应中断，而是记录中断状态，等获取到锁后再&quot;补上&quot;中断：</p>
<pre><code class="language-java">public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 返回 true 说明被中断过
        selfInterrupt();                                  // 补上中断
}

static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
</code></pre>
<p>这种设计的考量是：线程被唤醒时并不知道原因（可能是前驱释放了锁，也可能是被中断），所以通过 <code>Thread.interrupted()</code> 检查并清除中断标记，记录下来，最后在获取锁成功后统一补上。</p>
<h2>park / unpark 机制</h2>
<p>AQS 中线程的阻塞和唤醒通过 <code>LockSupport</code> 实现：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>LockSupport.park(this)</code></td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td><code>LockSupport.unpark(thread)</code></td>
<td>唤醒指定线程</td>
</tr>
</tbody></table>
<p>它们的底层实现是通过 <code>Unsafe</code> 类调用 CPU 原语。相比 <code>Object.wait/notify</code>，park/unpark 的优势在于：</p>
<ul>
<li>不需要在同步块中使用</li>
<li><code>unpark</code> 可以先于 <code>park</code> 调用（基于许可机制）</li>
<li>可以精确唤醒指定线程</li>
</ul>
<p>在 AQS 中使用 park 的主要目的是：<strong>让排队等待的线程挂起，停止自旋以避免浪费 CPU 资源</strong>，并在需要时通过 unpark 精确唤醒。</p>
<h2>AQS 在 JUC 中的应用场景</h2>
<p>AQS 是 JUC 包的基石，几乎所有同步工具都构建在它之上：</p>
<table>
<thead>
<tr>
<th>同步工具</th>
<th>如何使用 AQS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ReentrantLock</strong></td>
<td>state 表示锁的重入次数。获取锁时 state+1，释放时 state-1。state 为 0 表示锁空闲。同时记录持有锁的线程用于重入检测。</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>state 表示可用许可数。<code>acquireShared</code> 减少计数，<code>tryReleaseShared</code> 增加计数。</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>state 表示计数器。每次 <code>countDown()</code> 减 1，<code>await()</code> 等待 state 变为 0 后所有线程被唤醒。</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>state 的高 16 位保存读锁持有次数，低 16 位保存写锁持有次数。读锁用共享模式，写锁用独占模式。</td>
</tr>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>Worker 内部类继承 AQS，利用独占模式实现对工作线程的状态管理。</td>
</tr>
</tbody></table>
<h3>State 在不同同步器中的语义</h3>
<pre><code>ReentrantLock:       state = 重入次数 (0 = 空闲)
Semaphore:           state = 可用许可数
CountDownLatch:      state = 剩余计数 (0 = 所有线程放行)
ReadWriteLock:       state = [高16位:读锁次数][低16位:写锁次数]
</code></pre>
<h2>自定义同步器示例</h2>
<p>理解 AQS 后，我们可以用极少的代码实现一个简单的互斥锁：</p>
<pre><code class="language-java">public class SimpleLock {

    private static class Sync extends AbstractQueuedSynchronizer {
        @Override
        protected boolean tryAcquire(int arg) {
            return compareAndSetState(0, 1);
        }

        @Override
        protected boolean tryRelease(int arg) {
            setState(0);
            return true;
        }

        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
    }

    private final Sync sync = new Sync();

    public void lock()   { sync.acquire(1); }
    public void unlock() { sync.release(1); }
}
</code></pre>
<p>使用：</p>
<pre><code class="language-java">public static void main(String[] args) throws InterruptedException {
    SimpleLock lock = new SimpleLock();
    int[] count = {0};

    Runnable task = () -&gt; {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10000; i++) count[0]++;
        } finally {
            lock.unlock();
        }
    };

    Thread t1 = new Thread(task);
    Thread t2 = new Thread(task);
    t1.start(); t2.start();
    t1.join();  t2.join();
    System.out.println(count[0]);  // 始终输出 20000
}
</code></pre>
<p>只需重写 <code>tryAcquire</code> 和 <code>tryRelease</code>，AQS 就接管了排队、阻塞、唤醒、中断处理等全部复杂逻辑。</p>
<h2>总结</h2>
<p>AQS 的设计精髓可以归纳为以下几点：</p>
<ol>
<li><strong>一个 state 变量统一抽象</strong>：不同的同步器通过赋予 state 不同的语义（重入次数、许可数、计数器等），复用同一套框架</li>
<li><strong>CLH 变体双向队列管理等待线程</strong>：通过 FIFO 队列保证公平性，通过 CAS + 自旋保证入队的线程安全</li>
<li><strong>模板方法模式降低接入成本</strong>：自定义同步器只需实现 tryAcquire/tryRelease 等少量方法，框架处理全部排队和唤醒逻辑</li>
<li><strong>park/unpark 精确控制线程状态</strong>：避免自旋空转浪费 CPU，同时支持精确唤醒</li>
<li><strong>从后向前遍历保证正确性</strong>：在非原子入队操作和 CANCELLED 节点处理中，始终保证能遍历到所有有效节点</li>
</ol>
<blockquote>
<p>AQS 是 Doug Lea 在并发编程领域的杰作。理解了 AQS，就理解了 JUC 包中绝大部分同步工具的底层运作方式。它不仅是面试的高频考点，更是我们在实际工程中设计自定义同步器时可以直接借鉴的框架。</p>
</blockquote>
19:Td4a2,<h1>Tool Calling Deep Dive: 让 LLM 成为可编程接口</h1>
<blockquote>
<p>这是 Agentic 系列的第 05 篇。在前几篇中我们建立了 Agent 的概念模型、控制循环、以及 Agent 与 Workflow 的边界。本篇聚焦于 Agent 能力的核心支点——Tool Calling。</p>
<p>Tool Calling 不是&quot;让 AI 调 API&quot;这么简单。它是 LLM 从 <strong>Text-in/Text-out 的生成模型</strong> 变成 <strong>可编程接口</strong> 的关键转折点。理解它的工作原理、设计约束和工程实践，是构建任何 Agentic 系统的前提。</p>
</blockquote>
<hr>
<h2>1. 为什么 Tool Calling 是关键转折点</h2>
<p>一个纯粹的 LLM 只能做一件事：接受文本，生成文本。它无法查询数据库、无法读取文件、无法发送邮件、无法获取实时天气。它的知识冻结在训练数据的截止日期，它的能力边界就是 token 序列的排列组合。</p>
<p>Tool Calling 改变了这一切。</p>
<p>它的本质不是&quot;让 LLM 调用工具&quot;，而是 <strong>让 LLM 生成结构化的调用意图，由外部运行时代为执行</strong>。这个区分至关重要——LLM 从未真正&quot;执行&quot;过任何工具，它只是学会了在恰当的时机，输出一段符合约定格式的 JSON，表达&quot;我需要调用某个工具，参数是这些&quot;。</p>
<p>这意味着：</p>
<ul>
<li>LLM 变成了一个 <strong>决策引擎</strong>：决定调用什么、传什么参数</li>
<li>Runtime 变成了一个 <strong>执行引擎</strong>：负责真正的 I/O 操作</li>
<li>两者之间的契约是 <strong>JSON Schema</strong></li>
</ul>
<p>这种分离，让 LLM 从一个封闭的文本生成器，变成了一个可以与外部世界交互的可编程接口。</p>
<hr>
<h2>2. Tool Calling 的工作原理</h2>
<h3>2.1 完整流程</h3>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│                    Tool Calling 完整序列图                            │
└──────────────────────────────────────────────────────────────────────┘

  User            LLM (API)          Runtime           Tool (Function)
   │                 │                  │                     │
   │  &quot;北京今天天气&quot;  │                  │                     │
   ├────────────────&gt;│                  │                     │
   │                 │                  │                     │
   │                 │  ┌─────────────┐ │                     │
   │                 │  │ 推理:       │ │                     │
   │                 │  │ 用户想查天气 │ │                     │
   │                 │  │ 需要调用    │ │                     │
   │                 │  │ get_weather │ │                     │
   │                 │  └─────────────┘ │                     │
   │                 │                  │                     │
   │                 │  Tool Call JSON  │                     │
   │                 │ ────────────────&gt;│                     │
   │                 │  {               │                     │
   │                 │   &quot;name&quot;:        │                     │
   │                 │    &quot;get_weather&quot; │                     │
   │                 │   &quot;arguments&quot;:   │                     │
   │                 │    {&quot;city&quot;:      │                     │
   │                 │     &quot;北京&quot;}      │                     │
   │                 │  }               │                     │
   │                 │                  │  get_weather(&quot;北京&quot;) │
   │                 │                  ├────────────────────&gt;│
   │                 │                  │                     │
   │                 │                  │  {&quot;temp&quot;: 28,       │
   │                 │                  │   &quot;condition&quot;:      │
   │                 │                  │   &quot;晴&quot;}              │
   │                 │                  │&lt;────────────────────┤
   │                 │                  │                     │
   │                 │  Tool Result     │                     │
   │                 │ &lt;────────────────│                     │
   │                 │                  │                     │
   │                 │  ┌─────────────┐ │                     │
   │                 │  │ 推理:       │ │                     │
   │                 │  │ 根据工具返回 │ │                     │
   │                 │  │ 组织回答    │ │                     │
   │                 │  └─────────────┘ │                     │
   │                 │                  │                     │
   │ &quot;北京今天28°C,晴&quot;│                  │                     │
   │&lt;────────────────│                  │                     │
   │                 │                  │                     │
</code></pre>
<h3>2.2 关键洞察</h3>
<p>从上面的序列图中，可以提炼出几个核心事实：</p>
<ol>
<li><p><strong>LLM 发起两次推理</strong>。第一次决定是否调用工具、调用哪个、传什么参数；第二次基于工具返回的结果生成最终回答。这意味着每次 Tool Calling 至少消耗两轮 LLM 调用的 token。</p>
</li>
<li><p><strong>LLM 的输出不是自然语言，而是结构化 JSON</strong>。这是模型经过专门训练（fine-tuning）才获得的能力。并非所有 LLM 都支持 Tool Calling——它需要模型在训练阶段就学会&quot;在特定上下文下输出 JSON 而非自然语言&quot;。</p>
</li>
<li><p><strong>Runtime 是不可或缺的中间层</strong>。它负责：解析 LLM 返回的 Tool Call、校验参数、路由到正确的函数、执行函数、收集结果、将结果注入下一轮对话。没有 Runtime，Tool Calling 就是一段无人执行的 JSON。</p>
</li>
<li><p><strong>整个过程对用户透明</strong>。用户看到的只是&quot;问了一个问题，得到了回答&quot;。中间的 Tool Call 调度过程完全由系统内部完成。</p>
</li>
</ol>
<hr>
<h2>3. JSON Schema 作为契约</h2>
<h3>3.1 工具定义的结构</h3>
<p>每个工具的定义由三部分组成：</p>
<pre><code class="language-python">tool_definition = {
    &quot;type&quot;: &quot;function&quot;,
    &quot;function&quot;: {
        &quot;name&quot;: &quot;get_weather&quot;,          # 工具的唯一标识
        &quot;description&quot;: &quot;...&quot;,           # 给 LLM 看的&quot;接口文档&quot;
        &quot;parameters&quot;: {                 # JSON Schema 格式的参数约束
            &quot;type&quot;: &quot;object&quot;,
            &quot;properties&quot;: {
                &quot;city&quot;: {
                    &quot;type&quot;: &quot;string&quot;,
                    &quot;description&quot;: &quot;城市名称，如 &#39;北京&#39;、&#39;上海&#39;&quot;
                }
            },
            &quot;required&quot;: [&quot;city&quot;]
        }
    }
}
</code></pre>
<p>这里的 <code>parameters</code> 遵循 JSON Schema 规范（Draft 2020-12 子集），它不仅定义了参数的类型，还定义了参数的约束、默认值、枚举范围等。JSON Schema 就是 LLM 与 Runtime 之间的 <strong>契约</strong>。</p>
<h3>3.2 好的描述 vs 差的描述</h3>
<p><code>description</code> 是整个工具定义中最容易被低估的字段。它不是给人类看的注释，而是 <strong>给 LLM 看的接口文档</strong>。LLM 完全依赖 description 来决定是否调用这个工具、以及如何填充参数。</p>
<p><strong>差的描述：</strong></p>
<pre><code class="language-python">{
    &quot;name&quot;: &quot;query_db&quot;,
    &quot;description&quot;: &quot;查询数据库&quot;,          # 太模糊：查什么数据库？返回什么？
    &quot;parameters&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;q&quot;: {                        # 参数名不直观
                &quot;type&quot;: &quot;string&quot;
            }
        }
    }
}
</code></pre>
<p><strong>好的描述：</strong></p>
<pre><code class="language-python">{
    &quot;name&quot;: &quot;query_user_orders&quot;,
    &quot;description&quot;: (
        &quot;根据用户 ID 查询该用户的历史订单列表。&quot;
        &quot;返回最近 30 天内的订单，包含订单号、金额、状态。&quot;
        &quot;如果用户不存在，返回空列表。&quot;
        &quot;不支持模糊查询，user_id 必须精确匹配。&quot;
    ),
    &quot;parameters&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;user_id&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;用户的唯一标识符，格式为 &#39;U&#39; + 8位数字，如 &#39;U00012345&#39;&quot;
            },
            &quot;status_filter&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;enum&quot;: [&quot;all&quot;, &quot;pending&quot;, &quot;completed&quot;, &quot;cancelled&quot;],
                &quot;description&quot;: &quot;按订单状态过滤，默认返回所有状态的订单&quot;
            }
        },
        &quot;required&quot;: [&quot;user_id&quot;]
    }
}
</code></pre>
<p>两者之间的差异在于：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>差的描述</th>
<th>好的描述</th>
</tr>
</thead>
<tbody><tr>
<td>功能边界</td>
<td>不清楚能做什么</td>
<td>明确说明查询范围和返回内容</td>
</tr>
<tr>
<td>参数语义</td>
<td><code>q</code> 是什么？</td>
<td><code>user_id</code> 含义清晰，且给出格式示例</td>
</tr>
<tr>
<td>约束条件</td>
<td>无</td>
<td>明确说明不支持模糊查询</td>
</tr>
<tr>
<td>异常行为</td>
<td>未提及</td>
<td>说明了用户不存在时的返回</td>
</tr>
<tr>
<td>枚举约束</td>
<td>无</td>
<td>用 <code>enum</code> 限定合法值</td>
</tr>
</tbody></table>
<h3>3.3 参数设计原则</h3>
<ol>
<li><strong>简单优先</strong>：参数数量尽量少。一个工具如果需要 10 个参数，说明它的职责太大，应该拆分。</li>
<li><strong>类型明确</strong>：用 <code>enum</code> 约束离散值，用 <code>pattern</code> 约束格式，用 <code>minimum</code>/<code>maximum</code> 约束数值范围。</li>
<li><strong>必选与可选分明</strong>：<code>required</code> 字段只放真正必须的参数，可选参数给默认值。</li>
<li><strong>命名即文档</strong>：<code>user_id</code> 比 <code>uid</code> 好，<code>start_date</code> 比 <code>sd</code> 好。LLM 会从参数名推断语义。</li>
<li><strong>避免嵌套过深</strong>：LLM 生成深层嵌套 JSON 的准确率会显著下降。尽量用扁平结构。</li>
</ol>
<hr>
<h2>4. Structured Output vs Free-form Output</h2>
<h3>4.1 为什么结构化输出更可靠</h3>
<p>在 Tool Calling 出现之前，让 LLM 调用工具的常见做法是：在 Prompt 中要求 LLM &quot;用特定格式输出&quot;，然后用正则或字符串解析提取调用意图。</p>
<pre><code># 旧做法（Prompt Hacking）
请用以下格式回答：
Action: &lt;工具名&gt;
Action Input: &lt;参数 JSON&gt;

# LLM 可能的输出（不可靠）
&quot;我觉得应该查一下天气。Action: get_weather Action Input: {&quot;city&quot;: &quot;北京&quot;}&quot;
                       ^^ 前面混入了自然语言，解析会出错
</code></pre>
<p>这种方式的根本问题是：LLM 的输出是 <strong>非确定性的自由文本</strong>，它可能在格式中混入自然语言、遗漏字段、搞错 JSON 语法。</p>
<p>Structured Output（结构化输出）通过 <strong>约束解码（Constrained Decoding）</strong> 从根本上解决了这个问题。模型在生成 token 时，解码器会强制输出符合预定义 JSON Schema 的 token 序列，从而保证输出 100% 可解析。</p>
<h3>4.2 三种机制的区别</h3>
<table>
<thead>
<tr>
<th>机制</th>
<th>原理</th>
<th>可靠性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JSON Mode</strong></td>
<td>告诉模型&quot;输出必须是合法 JSON&quot;，但不约束 schema</td>
<td>中等。JSON 语法正确，但字段可能不对</td>
<td>简单的数据提取</td>
</tr>
<tr>
<td><strong>Function Calling / Tool Use</strong></td>
<td>模型经过 fine-tuning，能在特定上下文下输出 tool call 结构</td>
<td>高。模型专门训练过</td>
<td>Agent 工具调用</td>
</tr>
<tr>
<td><strong>Structured Output</strong></td>
<td>约束解码 + JSON Schema 验证，输出严格匹配 schema</td>
<td>极高。解码层面保证</td>
<td>需要严格 schema 的场景</td>
</tr>
</tbody></table>
<h3>4.3 各大模型的实现差异</h3>
<p>不同模型提供商对 Tool Calling 的 API 设计不尽相同，但核心思想一致：</p>
<p><strong>OpenAI</strong>（GPT-4 系列）：</p>
<ul>
<li>使用 <code>tools</code> 参数传递工具定义</li>
<li>返回 <code>tool_calls</code> 数组，支持并行调用</li>
<li>支持 <code>strict: true</code> 开启 Structured Output 模式</li>
</ul>
<p><strong>Anthropic</strong>（Claude 系列）：</p>
<ul>
<li>使用 <code>tools</code> 参数传递工具定义</li>
<li>Tool Call 以 <code>tool_use</code> content block 返回</li>
<li>Tool 结果以 <code>tool_result</code> content block 传回</li>
<li>原生支持并行工具调用</li>
</ul>
<p><strong>Google</strong>（Gemini 系列）：</p>
<ul>
<li>使用 <code>tools</code> + <code>function_declarations</code> 结构</li>
<li>支持 <code>function_calling_config</code> 控制调用模式（AUTO / ANY / NONE）</li>
<li>返回 <code>function_call</code> part</li>
</ul>
<p>虽然 API 格式不同，但抽象层面是一致的：<strong>定义工具 → LLM 决定调用 → 返回结构化调用请求 → 外部执行 → 结果回传</strong>。这也是为什么我们强调框架无关的原理理解——API 会变，原理不会。</p>
<hr>
<h2>5. 工具注册与发现（Tool Registry）</h2>
<h3>5.1 静态注册</h3>
<p>最简单的方式是在代码中硬编码工具列表：</p>
<pre><code class="language-python">TOOLS = [
    get_weather_tool,
    query_db_tool,
    send_email_tool,
]

response = client.chat.completions.create(
    model=&quot;gpt-4&quot;,
    messages=messages,
    tools=TOOLS,
)
</code></pre>
<p>优点是简单直接，缺点是每次新增或修改工具都需要改代码、重新部署。适合工具数量少且稳定的场景。</p>
<h3>5.2 动态注册</h3>
<p>当工具数量增多或需要根据上下文动态调整时，需要一个 Tool Registry：</p>
<pre><code>┌────────────────────────────────────────────────┐
│                Tool Registry                    │
│                                                │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐     │
│  │ weather  │  │ database │  │  email   │     │
│  │  tool    │  │  tool    │  │  tool    │     │
│  └──────────┘  └──────────┘  └──────────┘     │
│  ┌──────────┐  ┌──────────┐                    │
│  │  calc    │  │   file   │                    │
│  │  tool    │  │  tool    │                    │
│  └──────────┘  └──────────┘                    │
│                                                │
│  register(tool) / unregister(name)             │
│  get_tools(filter?) -&gt; List[Tool]              │
│  get_tool(name) -&gt; Tool                        │
│  get_definitions() -&gt; List[Dict]               │
└────────────────────────────────────────────────┘
         │
         │  get_definitions()
         ▼
   ┌───────────┐     tools=[...]     ┌───────────┐
   │  Runtime   │ ──────────────────&gt; │  LLM API  │
   └───────────┘                     └───────────┘
</code></pre>
<h3>5.3 工具选择问题</h3>
<p>当工具数量超过一定阈值（经验值：15-20 个），LLM 的工具选择准确率会明显下降。原因有两个：</p>
<ol>
<li><strong>Context 膨胀</strong>：每个工具定义占用数百 token，20 个工具就是数千 token 的 system prompt，挤占了有效上下文空间。</li>
<li><strong>选择困难</strong>：工具越多，语义越可能重叠，LLM 越难区分应该调用哪个。</li>
</ol>
<h3>5.4 Tool Selection 策略</h3>
<p><strong>策略一：全量传递</strong></p>
<pre><code>所有工具 ──全部传递──&gt; LLM
</code></pre>
<p>适用场景：工具少于 10 个。简单暴力，无额外开销。</p>
<p><strong>策略二：语义过滤</strong></p>
<pre><code>用户输入 ──Embedding──&gt; 向量
                          │
工具描述 ──Embedding──&gt; 向量库 ──Top-K 相似──&gt; 候选工具 ──&gt; LLM
</code></pre>
<p>用 Embedding 计算用户输入与工具描述的语义相似度，只传递 Top-K 最相关的工具。缺点是可能漏掉正确工具。</p>
<p><strong>策略三：两阶段选择</strong></p>
<pre><code>阶段 1：所有工具名 + 简短描述 ──&gt; LLM ──&gt; 选出候选工具 (3-5 个)
阶段 2：候选工具的完整定义     ──&gt; LLM ──&gt; 执行 Tool Call
</code></pre>
<p>第一阶段只传递工具名和一行描述（token 消耗少），让 LLM 先做粗筛；第二阶段只传递选中工具的完整定义。这种方式在工具数量 50+ 的场景下效果最好，代价是多一轮 LLM 调用。</p>
<hr>
<h2>6. 完整代码示例</h2>
<h3>6.1 工具定义</h3>
<pre><code class="language-python">from dataclasses import dataclass, field
from typing import Any, Callable

@dataclass
class Tool:
    &quot;&quot;&quot;工具的统一抽象&quot;&quot;&quot;
    name: str
    description: str
    parameters: dict          # JSON Schema
    function: Callable        # 实际执行的函数
    requires_confirmation: bool = False  # 是否需要用户确认

    def to_openai_schema(self) -&gt; dict:
        &quot;&quot;&quot;转换为 OpenAI API 格式&quot;&quot;&quot;
        return {
            &quot;type&quot;: &quot;function&quot;,
            &quot;function&quot;: {
                &quot;name&quot;: self.name,
                &quot;description&quot;: self.description,
                &quot;parameters&quot;: self.parameters,
            }
        }

# ── 工具实现 ──────────────────────────────────────────────

def get_weather(city: str, unit: str = &quot;celsius&quot;) -&gt; dict:
    &quot;&quot;&quot;模拟天气查询&quot;&quot;&quot;
    # 实际场景中调用天气 API
    mock_data = {
        &quot;北京&quot;: {&quot;temp&quot;: 28, &quot;condition&quot;: &quot;晴&quot;, &quot;humidity&quot;: 45},
        &quot;上海&quot;: {&quot;temp&quot;: 32, &quot;condition&quot;: &quot;多云&quot;, &quot;humidity&quot;: 78},
    }
    data = mock_data.get(city, {&quot;temp&quot;: 20, &quot;condition&quot;: &quot;未知&quot;, &quot;humidity&quot;: 50})
    if unit == &quot;fahrenheit&quot;:
        data[&quot;temp&quot;] = data[&quot;temp&quot;] * 9 / 5 + 32
    return {&quot;city&quot;: city, **data}


def query_database(sql: str, database: str = &quot;default&quot;) -&gt; dict:
    &quot;&quot;&quot;模拟数据库查询&quot;&quot;&quot;
    # 实际场景中执行 SQL
    return {
        &quot;database&quot;: database,
        &quot;query&quot;: sql,
        &quot;rows&quot;: [
            {&quot;id&quot;: 1, &quot;name&quot;: &quot;Alice&quot;, &quot;amount&quot;: 100.0},
            {&quot;id&quot;: 2, &quot;name&quot;: &quot;Bob&quot;, &quot;amount&quot;: 200.0},
        ],
        &quot;row_count&quot;: 2,
    }


def calculate(expression: str) -&gt; dict:
    &quot;&quot;&quot;安全的数学计算&quot;&quot;&quot;
    allowed_chars = set(&quot;0123456789+-*/.() &quot;)
    if not all(c in allowed_chars for c in expression):
        return {&quot;error&quot;: &quot;表达式包含非法字符&quot;}
    try:
        result = eval(expression)  # 生产环境应使用 ast.literal_eval 或专用解析器
        return {&quot;expression&quot;: expression, &quot;result&quot;: result}
    except Exception as e:
        return {&quot;error&quot;: str(e)}


def read_file(file_path: str, encoding: str = &quot;utf-8&quot;) -&gt; dict:
    &quot;&quot;&quot;读取文件内容&quot;&quot;&quot;
    try:
        with open(file_path, &quot;r&quot;, encoding=encoding) as f:
            content = f.read(10000)  # 限制读取大小
        return {&quot;path&quot;: file_path, &quot;content&quot;: content, &quot;size&quot;: len(content)}
    except FileNotFoundError:
        return {&quot;error&quot;: f&quot;文件不存在: {file_path}&quot;}
    except Exception as e:
        return {&quot;error&quot;: str(e)}


def send_email(to: str, subject: str, body: str) -&gt; dict:
    &quot;&quot;&quot;模拟发送邮件&quot;&quot;&quot;
    # 实际场景中调用邮件服务
    return {&quot;status&quot;: &quot;sent&quot;, &quot;to&quot;: to, &quot;subject&quot;: subject}


# ── 工具注册 ──────────────────────────────────────────────

weather_tool = Tool(
    name=&quot;get_weather&quot;,
    description=(
        &quot;查询指定城市的当前天气信息，包括温度、天气状况和湿度。&quot;
        &quot;支持国内主要城市。如果城市不在数据库中，返回默认值。&quot;
    ),
    parameters={
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;city&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;要查询的城市名称，如 &#39;北京&#39;、&#39;上海&#39;&quot;
            },
            &quot;unit&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;enum&quot;: [&quot;celsius&quot;, &quot;fahrenheit&quot;],
                &quot;description&quot;: &quot;温度单位，默认摄氏度&quot;
            }
        },
        &quot;required&quot;: [&quot;city&quot;],
    },
    function=get_weather,
)

database_tool = Tool(
    name=&quot;query_database&quot;,
    description=(
        &quot;执行 SQL 查询并返回结果。仅支持 SELECT 语句，&quot;
        &quot;不允许执行 INSERT/UPDATE/DELETE 等写操作。&quot;
        &quot;返回结果包含行数据和总行数。&quot;
    ),
    parameters={
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;sql&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;要执行的 SQL SELECT 语句&quot;
            },
            &quot;database&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;enum&quot;: [&quot;default&quot;, &quot;analytics&quot;, &quot;users&quot;],
                &quot;description&quot;: &quot;目标数据库名称，默认为 &#39;default&#39;&quot;
            }
        },
        &quot;required&quot;: [&quot;sql&quot;],
    },
    function=query_database,
)

calculator_tool = Tool(
    name=&quot;calculate&quot;,
    description=(
        &quot;执行数学计算。支持加减乘除和括号。&quot;
        &quot;输入为数学表达式字符串，如 &#39;(3 + 5) * 2&#39;。&quot;
        &quot;不支持变量和函数调用，仅限纯数值运算。&quot;
    ),
    parameters={
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;expression&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;数学表达式，如 &#39;(3 + 5) * 2&#39;&quot;
            }
        },
        &quot;required&quot;: [&quot;expression&quot;],
    },
    function=calculate,
)

file_tool = Tool(
    name=&quot;read_file&quot;,
    description=(
        &quot;读取指定路径的文本文件内容。最多读取 10000 字符。&quot;
        &quot;仅支持文本文件，不支持二进制文件。&quot;
        &quot;如果文件不存在，返回错误信息。&quot;
    ),
    parameters={
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;file_path&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;文件的绝对路径或相对路径&quot;
            },
            &quot;encoding&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;文件编码，默认 utf-8&quot;
            }
        },
        &quot;required&quot;: [&quot;file_path&quot;],
    },
    function=read_file,
)

email_tool = Tool(
    name=&quot;send_email&quot;,
    description=(
        &quot;向指定收件人发送一封电子邮件。&quot;
        &quot;需要提供收件人地址、邮件主题和正文。&quot;
        &quot;正文支持纯文本格式。&quot;
    ),
    parameters={
        &quot;type&quot;: &quot;object&quot;,
        &quot;properties&quot;: {
            &quot;to&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;收件人邮箱地址&quot;
            },
            &quot;subject&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;邮件主题&quot;
            },
            &quot;body&quot;: {
                &quot;type&quot;: &quot;string&quot;,
                &quot;description&quot;: &quot;邮件正文，纯文本格式&quot;
            }
        },
        &quot;required&quot;: [&quot;to&quot;, &quot;subject&quot;, &quot;body&quot;],
    },
    function=send_email,
    requires_confirmation=True,  # 发邮件需要用户确认
)
</code></pre>
<h3>6.2 Tool Registry 实现</h3>
<pre><code class="language-python">import json
from typing import Optional

class ToolRegistry:
    &quot;&quot;&quot;工具注册中心&quot;&quot;&quot;

    def __init__(self):
        self._tools: dict[str, Tool] = {}

    def register(self, tool: Tool) -&gt; None:
        if tool.name in self._tools:
            raise ValueError(f&quot;工具 &#39;{tool.name}&#39; 已注册&quot;)
        self._tools[tool.name] = tool

    def unregister(self, name: str) -&gt; None:
        self._tools.pop(name, None)

    def get_tool(self, name: str) -&gt; Optional[Tool]:
        return self._tools.get(name)

    def get_all_tools(self) -&gt; list[Tool]:
        return list(self._tools.values())

    def get_definitions(self, names: list[str] | None = None) -&gt; list[dict]:
        &quot;&quot;&quot;获取工具定义列表（用于传递给 LLM API）&quot;&quot;&quot;
        tools = self._tools.values()
        if names:
            tools = [t for t in tools if t.name in names]
        return [t.to_openai_schema() for t in tools]

    def get_summary(self) -&gt; str:
        &quot;&quot;&quot;获取工具摘要（用于两阶段选择的第一阶段）&quot;&quot;&quot;
        lines = []
        for tool in self._tools.values():
            # 只取 description 的第一句
            short_desc = tool.description.split(&quot;。&quot;)[0] + &quot;。&quot;
            lines.append(f&quot;- {tool.name}: {short_desc}&quot;)
        return &quot;\n&quot;.join(lines)


# 初始化 Registry
registry = ToolRegistry()
for tool in [weather_tool, database_tool, calculator_tool, file_tool, email_tool]:
    registry.register(tool)
</code></pre>
<h3>6.3 Tool Dispatcher 实现</h3>
<pre><code class="language-python">import json
import traceback
from concurrent.futures import ThreadPoolExecutor, as_completed

class ToolDispatcher:
    &quot;&quot;&quot;
    工具调度器：解析 LLM 返回的 tool calls，执行对应工具，收集结果。
    &quot;&quot;&quot;

    def __init__(self, registry: ToolRegistry, max_parallel: int = 5):
        self.registry = registry
        self.max_parallel = max_parallel

    def validate_arguments(self, tool: Tool, arguments: dict) -&gt; list[str]:
        &quot;&quot;&quot;基础参数验证（生产环境建议使用 jsonschema 库）&quot;&quot;&quot;
        errors = []
        schema = tool.parameters
        required = schema.get(&quot;required&quot;, [])
        properties = schema.get(&quot;properties&quot;, {})

        # 检查必填参数
        for param in required:
            if param not in arguments:
                errors.append(f&quot;缺少必填参数: {param}&quot;)

        # 检查参数类型和枚举
        for param, value in arguments.items():
            if param not in properties:
                errors.append(f&quot;未知参数: {param}&quot;)
                continue
            prop_schema = properties[param]
            if &quot;enum&quot; in prop_schema and value not in prop_schema[&quot;enum&quot;]:
                errors.append(
                    f&quot;参数 &#39;{param}&#39; 的值 &#39;{value}&#39; &quot;
                    f&quot;不在允许范围内: {prop_schema[&#39;enum&#39;]}&quot;
                )

        return errors

    def execute_single(self, tool_call: dict) -&gt; dict:
        &quot;&quot;&quot;执行单个工具调用&quot;&quot;&quot;
        name = tool_call[&quot;function&quot;][&quot;name&quot;]
        raw_args = tool_call[&quot;function&quot;][&quot;arguments&quot;]
        call_id = tool_call.get(&quot;id&quot;, &quot;unknown&quot;)

        # 1. 查找工具
        tool = self.registry.get_tool(name)
        if not tool:
            return {
                &quot;tool_call_id&quot;: call_id,
                &quot;role&quot;: &quot;tool&quot;,
                &quot;content&quot;: json.dumps({&quot;error&quot;: f&quot;工具 &#39;{name}&#39; 不存在&quot;}),
            }

        # 2. 解析参数
        try:
            arguments = json.loads(raw_args) if isinstance(raw_args, str) else raw_args
        except json.JSONDecodeError as e:
            return {
                &quot;tool_call_id&quot;: call_id,
                &quot;role&quot;: &quot;tool&quot;,
                &quot;content&quot;: json.dumps({&quot;error&quot;: f&quot;参数 JSON 解析失败: {e}&quot;}),
            }

        # 3. 验证参数
        errors = self.validate_arguments(tool, arguments)
        if errors:
            return {
                &quot;tool_call_id&quot;: call_id,
                &quot;role&quot;: &quot;tool&quot;,
                &quot;content&quot;: json.dumps({&quot;error&quot;: &quot;参数验证失败&quot;, &quot;details&quot;: errors}),
            }

        # 4. 执行工具
        try:
            result = tool.function(**arguments)
            return {
                &quot;tool_call_id&quot;: call_id,
                &quot;role&quot;: &quot;tool&quot;,
                &quot;content&quot;: json.dumps(result, ensure_ascii=False),
            }
        except Exception as e:
            return {
                &quot;tool_call_id&quot;: call_id,
                &quot;role&quot;: &quot;tool&quot;,
                &quot;content&quot;: json.dumps({
                    &quot;error&quot;: f&quot;工具执行失败: {type(e).__name__}: {e}&quot;,
                    &quot;traceback&quot;: traceback.format_exc()[-500:],  # 截断过长的堆栈
                }),
            }

    def execute_parallel(self, tool_calls: list[dict]) -&gt; list[dict]:
        &quot;&quot;&quot;并行执行多个工具调用&quot;&quot;&quot;
        if len(tool_calls) == 1:
            return [self.execute_single(tool_calls[0])]

        results = []
        with ThreadPoolExecutor(max_workers=self.max_parallel) as executor:
            future_to_call = {
                executor.submit(self.execute_single, tc): tc
                for tc in tool_calls
            }
            for future in as_completed(future_to_call):
                results.append(future.result())

        # 按原始顺序排列结果
        id_to_result = {r[&quot;tool_call_id&quot;]: r for r in results}
        ordered = []
        for tc in tool_calls:
            call_id = tc.get(&quot;id&quot;, &quot;unknown&quot;)
            ordered.append(id_to_result.get(call_id, results.pop(0)))
        return ordered


dispatcher = ToolDispatcher(registry)
</code></pre>
<h3>6.4 完整对话循环</h3>
<pre><code class="language-python">from openai import OpenAI

def run_agent_loop(
    client: OpenAI,
    user_message: str,
    registry: ToolRegistry,
    dispatcher: ToolDispatcher,
    max_iterations: int = 10,
) -&gt; str:
    &quot;&quot;&quot;
    完整的 Agent 对话循环，支持多轮 Tool Calling。
    &quot;&quot;&quot;
    messages = [
        {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;你是一个有用的助手，可以使用工具来回答用户的问题。&quot;},
        {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_message},
    ]
    tools = registry.get_definitions()

    for i in range(max_iterations):
        response = client.chat.completions.create(
            model=&quot;gpt-4&quot;,
            messages=messages,
            tools=tools if tools else None,
        )
        choice = response.choices[0]
        message = choice.message

        # 如果 LLM 没有调用工具，直接返回文本回答
        if not message.tool_calls:
            return message.content

        # 将 LLM 的回复（含 tool_calls）加入消息历史
        messages.append(message.model_dump())

        # 执行所有工具调用（支持并行）
        tool_calls = [tc.model_dump() for tc in message.tool_calls]
        results = dispatcher.execute_parallel(tool_calls)

        # 将工具执行结果加入消息历史
        for result in results:
            messages.append(result)

        # 继续循环，让 LLM 基于工具结果做下一步决策

    return &quot;达到最大迭代次数，对话终止。&quot;


# 使用示例
# client = OpenAI()
# answer = run_agent_loop(client, &quot;北京今天天气怎么样？然后帮我算一下 28 * 9/5 + 32&quot;, registry, dispatcher)
# print(answer)
</code></pre>
<hr>
<h2>7. 错误处理与验证</h2>
<p>Tool Calling 中的错误来源比常规 API 调用更多，因为链条更长：用户输入 → LLM 推理 → 参数生成 → 参数验证 → 工具执行 → 结果回传 → LLM 再推理。每一环都可能出错。</p>
<h3>7.1 参数验证</h3>
<p>LLM 生成的参数并不总是合法的。常见问题：</p>
<pre><code class="language-python"># LLM 可能生成的&quot;有问题&quot;的参数

# 1. 类型错误：期望 string，给了 number
{&quot;city&quot;: 123}

# 2. 枚举越界：给了不在 enum 中的值
{&quot;unit&quot;: &quot;kelvin&quot;}      # enum 里只有 celsius / fahrenheit

# 3. 格式错误：JSON 语法不对
&#39;{&quot;city&quot;: &quot;北京&quot;,}&#39;      # 尾部多余逗号（严格 JSON 不允许）

# 4. 幻觉参数：编造了不存在的参数
{&quot;city&quot;: &quot;北京&quot;, &quot;forecast_days&quot;: 7}  # 工具根本没有这个参数

# 5. 语义错误：参数值表面合法但语义错误
{&quot;sql&quot;: &quot;DROP TABLE users&quot;}  # 传了一条 DELETE 语句给 SELECT-only 工具
</code></pre>
<p>应对策略是 <strong>分层验证</strong>：</p>
<pre><code class="language-python">def validate_and_execute(tool: Tool, raw_arguments: str) -&gt; dict:
    # 第一层：JSON 语法
    try:
        args = json.loads(raw_arguments)
    except json.JSONDecodeError:
        return {&quot;error&quot;: &quot;参数不是合法的 JSON&quot;}

    # 第二层：Schema 验证（使用 jsonschema 库）
    from jsonschema import validate, ValidationError
    try:
        validate(instance=args, schema=tool.parameters)
    except ValidationError as e:
        return {&quot;error&quot;: f&quot;参数验证失败: {e.message}&quot;}

    # 第三层：业务规则验证
    if tool.name == &quot;query_database&quot;:
        sql = args.get(&quot;sql&quot;, &quot;&quot;).strip().upper()
        if not sql.startswith(&quot;SELECT&quot;):
            return {&quot;error&quot;: &quot;仅支持 SELECT 查询&quot;}

    # 执行
    return tool.function(**args)
</code></pre>
<h3>7.2 工具执行失败的反馈</h3>
<p>当工具执行失败时，最重要的原则是：<strong>将错误信息回传给 LLM，让它决定下一步</strong>。</p>
<pre><code class="language-python"># 不要这样做 —— 对用户抛出原始异常
raise RuntimeError(&quot;Connection timeout to weather API&quot;)

# 应该这样做 —— 将错误包装为工具结果，回传给 LLM
{
    &quot;tool_call_id&quot;: &quot;call_abc123&quot;,
    &quot;role&quot;: &quot;tool&quot;,
    &quot;content&quot;: json.dumps({
        &quot;error&quot;: &quot;天气 API 连接超时，请稍后重试或尝试查询其他城市&quot;,
        &quot;error_type&quot;: &quot;timeout&quot;,
        &quot;retryable&quot;: True
    })
}
</code></pre>
<p>LLM 拿到这个错误信息后，可能会：</p>
<ul>
<li>换一种方式重试（比如换个参数）</li>
<li>告知用户当前无法完成</li>
<li>尝试用其他工具达成目标</li>
</ul>
<h3>7.3 重试策略</h3>
<pre><code>                  ┌──────────────────────────┐
                  │    Tool Call 失败         │
                  └──────────┬───────────────┘
                             │
                   ┌─────────▼─────────┐
                   │  错误类型判断       │
                   └─────────┬─────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
        ┌─────▼─────┐ ┌─────▼─────┐ ┌─────▼─────┐
        │ 可重试     │ │ 参数错误   │ │ 不可恢复   │
        │(超时/限流) │ │(类型/格式) │ │(权限/404) │
        └─────┬─────┘ └─────┬─────┘ └─────┬─────┘
              │              │              │
        ┌─────▼─────┐ ┌─────▼─────┐ ┌─────▼─────┐
        │ Runtime    │ │ 回传 LLM  │ │ 回传 LLM  │
        │ 自动重试   │ │ 让它修正   │ │ 让它放弃   │
        │ (指数退避) │ │ 参数       │ │ 或换方案   │
        └───────────┘ └───────────┘ └───────────┘
</code></pre>
<p>核心原则：<strong>可重试的错误由 Runtime 处理，不可重试的错误交给 LLM 决策</strong>。</p>
<ul>
<li><strong>瞬时错误</strong>（网络超时、限流）：Runtime 自动重试，设置退避策略和最大重试次数，不需要浪费 LLM 的 token。</li>
<li><strong>参数错误</strong>：回传给 LLM，它可能会修正参数重新调用。</li>
<li><strong>永久错误</strong>（权限不足、资源不存在）：回传给 LLM，让它换一种方案或如实告知用户。</li>
</ul>
<h3>7.4 幂等性考量</h3>
<p>当重试机制存在时，幂等性就变得至关重要。</p>
<pre><code class="language-python"># 幂等操作 —— 重试安全
get_weather(&quot;北京&quot;)           # 多次调用结果相同
query_database(&quot;SELECT ...&quot;)  # 只读查询，天然幂等

# 非幂等操作 —— 重试危险
send_email(to=&quot;a@b.com&quot;, ...)  # 重试 = 发两封邮件
create_order(item=&quot;iPhone&quot;)    # 重试 = 创建两个订单
</code></pre>
<p>对于非幂等操作，要么禁止自动重试，要么引入幂等 key：</p>
<pre><code class="language-python">def send_email_idempotent(to: str, subject: str, body: str, idempotency_key: str) -&gt; dict:
    &quot;&quot;&quot;带幂等 key 的邮件发送&quot;&quot;&quot;
    if is_already_sent(idempotency_key):
        return {&quot;status&quot;: &quot;already_sent&quot;, &quot;message&quot;: &quot;该请求已处理，跳过重复发送&quot;}
    result = _do_send_email(to, subject, body)
    mark_as_sent(idempotency_key)
    return result
</code></pre>
<hr>
<h2>8. 安全性</h2>
<p>Tool Calling 打开了 LLM 与外部世界的通道，也同时打开了攻击面。</p>
<h3>8.1 工具权限控制</h3>
<p>不是所有工具都应该对所有用户开放。一个合理的权限模型：</p>
<pre><code class="language-python">from enum import Enum

class ToolPermission(Enum):
    READ = &quot;read&quot;        # 只读操作：查询天气、读文件
    WRITE = &quot;write&quot;      # 写操作：发邮件、创建记录
    ADMIN = &quot;admin&quot;      # 管理操作：删除数据、修改配置

class SecureToolRegistry(ToolRegistry):
    &quot;&quot;&quot;带权限控制的工具注册中心&quot;&quot;&quot;

    def __init__(self):
        super().__init__()
        self._permissions: dict[str, ToolPermission] = {}

    def register(self, tool: Tool, permission: ToolPermission = ToolPermission.READ):
        super().register(tool)
        self._permissions[tool.name] = permission

    def get_definitions(
        self,
        names: list[str] | None = None,
        max_permission: ToolPermission = ToolPermission.READ,
    ) -&gt; list[dict]:
        &quot;&quot;&quot;只返回用户权限范围内的工具&quot;&quot;&quot;
        permission_levels = {
            ToolPermission.READ: 0,
            ToolPermission.WRITE: 1,
            ToolPermission.ADMIN: 2,
        }
        max_level = permission_levels[max_permission]
        allowed = [
            t for t in self._tools.values()
            if permission_levels[self._permissions.get(t.name, ToolPermission.ADMIN)] &lt;= max_level
        ]
        if names:
            allowed = [t for t in allowed if t.name in names]
        return [t.to_openai_schema() for t in allowed]
</code></pre>
<h3>8.2 参数注入风险</h3>
<p>LLM 的参数生成可以被 Prompt Injection 操纵。考虑以下场景：</p>
<pre><code>用户输入: &quot;帮我查一下订单，user_id 是 U00012345; DROP TABLE orders; --&quot;
</code></pre>
<p>如果 <code>query_database</code> 工具直接拼接 SQL，这就变成了一次经典的 SQL 注入。防护措施：</p>
<ol>
<li><strong>参数化查询</strong>：工具内部必须使用参数化 SQL，绝不拼接。</li>
<li><strong>白名单校验</strong>：用正则或枚举限制参数值的格式。</li>
<li><strong>最小权限原则</strong>：数据库连接使用只读账号。</li>
</ol>
<h3>8.3 Sandbox 执行</h3>
<p>对于高风险工具（如代码执行、文件操作），应在隔离环境中执行：</p>
<pre><code>┌──────────────────────────────────────────────┐
│  Host Runtime                                 │
│                                              │
│   ┌─────────────┐     ┌──────────────────┐   │
│   │  Safe Tools  │     │    Sandbox       │   │
│   │  (天气/计算) │     │  ┌────────────┐  │   │
│   │  直接执行    │     │  │ Risky Tools│  │   │
│   └─────────────┘     │  │ (代码/文件) │  │   │
│                       │  │ 隔离执行    │  │   │
│                       │  └────────────┘  │   │
│                       │  - 网络受限      │   │
│                       │  - 文件系统隔离  │   │
│                       │  - 执行时间限制  │   │
│                       │  - 资源配额      │   │
│                       └──────────────────┘   │
└──────────────────────────────────────────────┘
</code></pre>
<p>Sandbox 的实现方式取决于部署环境：</p>
<ul>
<li><strong>Docker 容器</strong>：最常见，隔离性好</li>
<li><strong>gVisor / Firecracker</strong>：更强的隔离，适合多租户</li>
<li><strong>WASM</strong>：轻量级沙箱，启动快</li>
<li><strong>子进程 + seccomp</strong>：Linux 下的轻量方案</li>
</ul>
<hr>
<h2>9. Trade-off 分析</h2>
<h3>9.1 工具数量 vs 选择准确率</h3>
<pre><code>选择准确率
  100% │ ****
       │     ****
   90% │         ****
       │             ****
   80% │                 ****
       │                     ****
   70% │                         ****
       │                             ****
   60% │                                 ****
       ├───┬───┬───┬───┬───┬───┬───┬───┬───── 工具数量
       0   5  10  15  20  25  30  35  40

       |&lt;-- 全量传递 --&gt;|&lt;- 需要过滤策略 -&gt;|
</code></pre>
<ul>
<li><strong>&lt; 10 个工具</strong>：全量传递，不需要过滤。</li>
<li><strong>10-20 个工具</strong>：准确率开始下降，可通过优化 description 缓解。</li>
<li><strong>&gt; 20 个工具</strong>：必须引入 Tool Selection 策略（语义过滤或两阶段选择）。</li>
<li><strong>&gt; 50 个工具</strong>：两阶段选择几乎是唯一可行方案，或者按领域拆分为多个 Agent。</li>
</ul>
<h3>9.2 工具描述详细度 vs Token 消耗</h3>
<p>每个工具定义大约占用 100-500 token（取决于描述长度和参数数量）。20 个工具就是 2000-10000 token 的系统开销，这是每次 API 调用都要付出的 <strong>固定成本</strong>。</p>
<pre><code>                        描述详细度
                  低 ◄──────────────► 高
                  │                    │
  Token 消耗   低 │  ⚡ 省钱但模糊     │
                  │  LLM 可能误选工具  │
                  │                    │
              高 │                    │  📖 精确但昂贵
                  │                    │  LLM 选择更准确
                  │                    │
</code></pre>
<p>实践建议：</p>
<ul>
<li>工具 <code>name</code> 起好名字（零额外 token 成本，但信息量大）</li>
<li><code>description</code> 控制在 2-3 句话</li>
<li>参数的 <code>description</code> 控制在 1 句话 + 1 个示例</li>
<li>用 <code>enum</code> 和 <code>required</code> 代替冗长的文字约束</li>
</ul>
<h3>9.3 确定性执行 vs LLM 灵活性</h3>
<pre><code>确定性                                          灵活性
  │                                              │
  │  硬编码工作流           Agent Tool Calling     │
  │  if/else 分支            LLM 自由选择工具     │
  │  规则引擎                自动组合工具链        │
  │                                              │
  │  ✅ 可预测              ✅ 处理模糊意图        │
  │  ✅ 可审计              ✅ 适应新场景          │
  │  ✅ 低延迟              ✅ 用户体验自然        │
  │  ❌ 不灵活              ❌ 不可预测            │
  │  ❌ 维护成本高          ❌ 调试困难            │
  │  ❌ 无法处理长尾        ❌ 成本高              │
</code></pre>
<p>决策框架：</p>
<table>
<thead>
<tr>
<th>场景特征</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody><tr>
<td>流程固定、合规要求高</td>
<td>硬编码工作流 + Tool Calling 作为执行层</td>
</tr>
<tr>
<td>意图模糊、工具组合多变</td>
<td>完全由 LLM 驱动的 Tool Calling</td>
</tr>
<tr>
<td>核心路径固定、边缘场景多</td>
<td>混合方案：主流程硬编码，长尾交给 LLM</td>
</tr>
</tbody></table>
<p>关键洞察：Tool Calling 不是非此即彼的选择。你可以让 LLM 决定 <strong>是否</strong> 调用工具，但用代码控制 <strong>调用后的流程</strong>。比如 LLM 决定&quot;需要查天气&quot;，但查完天气后的处理逻辑是确定性的代码。</p>
<hr>
<h2>10. 常见陷阱</h2>
<p>在实际工程中，以下几个坑值得提前规避：</p>
<p><strong>1. 工具描述与实际行为不一致</strong></p>
<p>工具描述说&quot;返回最近 30 天的订单&quot;，但实际实现返回所有订单。LLM 会基于描述做出错误假设，导致下游逻辑出错。<strong>描述就是契约，必须与实现严格一致</strong>。</p>
<p><strong>2. 忽略工具结果的 Token 消耗</strong></p>
<p>工具返回的结果会作为下一轮消息传给 LLM。如果一个数据库查询返回了 1000 行数据，这些数据全部变成 input token。务必在工具层面限制返回数据量。</p>
<pre><code class="language-python">def query_database(sql: str, database: str = &quot;default&quot;) -&gt; dict:
    results = _execute_query(sql, database)
    # 限制返回行数，避免 token 爆炸
    if len(results) &gt; 50:
        return {
            &quot;rows&quot;: results[:50],
            &quot;total_count&quot;: len(results),
            &quot;truncated&quot;: True,
            &quot;message&quot;: f&quot;结果共 {len(results)} 行，仅返回前 50 行&quot;
        }
    return {&quot;rows&quot;: results, &quot;total_count&quot;: len(results)}
</code></pre>
<p><strong>3. 缺少 stop condition</strong></p>
<p>如果 LLM 反复调用同一个工具（比如因为错误一直重试），而没有最大迭代次数限制，系统会陷入无限循环。前面代码中的 <code>max_iterations</code> 参数就是为此设计的。</p>
<p><strong>4. 并行调用的顺序依赖</strong></p>
<p>LLM 可能在一次回复中请求并行调用两个工具，但这两个工具之间有隐含的顺序依赖（比如先查用户 ID，再用这个 ID 查订单）。Runtime 需要能识别这种情况，或者在工具描述中引导 LLM 分步调用。</p>
<hr>
<h2>11. 总结与展望</h2>
<p>Tool Calling 的本质是一个精心设计的 <strong>协议</strong>：</p>
<pre><code>┌───────────┐    JSON Schema    ┌───────────┐    Function    ┌───────────┐
│           │    (契约)          │           │    (执行)      │           │
│    LLM    │ ◄───────────────► │  Runtime  │ ◄────────────► │   Tools   │
│  (决策层) │   Tool Call JSON   │  (调度层) │   Function     │  (能力层) │
│           │   Tool Result      │           │   Call/Return  │           │
└───────────┘                   └───────────┘                └───────────┘
</code></pre>
<ul>
<li><strong>LLM</strong> 负责理解意图、选择工具、生成参数——它是决策者。</li>
<li><strong>Runtime</strong> 负责验证、路由、执行、错误处理——它是执行者。</li>
<li><strong>Tools</strong> 是具体的能力——它们是能力的载体。</li>
<li><strong>JSON Schema</strong> 是三者之间的契约——它定义了什么可以做、怎么做。</li>
</ul>
<p>理解了这个架构，你就能在任何框架（LangChain、LlamaIndex、Semantic Kernel，或者自己写的 Runtime）上实现 Tool Calling，因为底层原理是相同的。</p>
<p>但 Tool Calling 只是让 Agent 有了&quot;手&quot;。要让 Agent 真正好用，还需要精心设计的 Prompt 来引导 LLM 的决策——什么时候该调工具、什么时候该直接回答、遇到错误该怎么处理、多个工具之间如何协调。这就是下一篇 <strong>Prompt Engineering for Agents</strong> 要深入讨论的主题。</p>
<hr>
<blockquote>
<p><strong>系列导航</strong>：本文是 Agentic 系列的第 05 篇。</p>
<ul>
<li>上一篇：<a href="/blog/engineering/agentic/04-The%20Agent%20Control%20Loop">04 | The Agent Control Loop</a></li>
<li>下一篇：<a href="/blog/engineering/agentic/06-Prompt%20Engineering%20for%20Agents">06 | Prompt Engineering for Agents</a></li>
<li>完整目录：<a href="/blog/engineering/agentic/01-From%20LLM%20to%20Agent">01 | From LLM to Agent</a></li>
</ul>
</blockquote>
1a:T9c80,<h1>Agent Runtime from Scratch: 不依赖框架构建 Agent</h1>
<blockquote>
<p>框架是加速器，不是知识的替代品。</p>
<p>本文是 Agentic 系列第 07 篇，也是 Phase 2 的收官之作。我们将抛开所有框架，用纯 Python 从零构建一个功能完整的 Agent Runtime。这是系列中代码量最大的一篇——每一行代码都指向同一个目标：让你彻底理解 Agent 的运行本质。</p>
</blockquote>
<hr>
<h2>1. 为什么要自己写 Agent Runtime？</h2>
<p>前几篇我们理解了控制循环（第 04 篇）、Tool Calling（第 05 篇）、Prompt 工程（第 06 篇）。但这些还停留在概念层面。现在的问题是：<strong>不用 LangChain、不用 LangGraph——你能写出一个 Agent 吗？</strong></p>
<p>自建 Runtime 的价值：</p>
<ul>
<li><strong>透明性</strong>：每一行代码你都清楚，出了问题知道往哪里看</li>
<li><strong>可控性</strong>：精确控制重试策略、超时机制、消息压缩、工具调度，而不被框架的默认行为绑架</li>
<li><strong>本质理解</strong>：理解了 Runtime 本质，用任何框架时都能一眼看出它在做什么、哪里做得不好</li>
</ul>
<p>更现实的原因：<strong>生产环境中很多 Agent 系统最终都走向了自研</strong>。框架在 PoC 阶段很方便，但到了需要精细控制 Token 成本、自定义 Observability、与内部基础设施深度集成时，框架往往成为障碍。</p>
<hr>
<h2>2. 架构设计</h2>
<pre><code>┌───────────────────────────────────────────────────┐
│                   AgentRuntime                     │
│                (Core Control Loop)                 │
│                                                    │
│  ┌────────────┐  ┌──────────────┐  ┌───────────┐ │
│  │ LLMClient  │  │MessageManager│  │ StateStore │ │
│  │ chat()     │  │ append()     │  │ save()     │ │
│  │ stream()   │  │ compress()   │  │ load()     │ │
│  │ retry()    │  │ count_tokens │  │ clear()    │ │
│  └─────┬──────┘  └──────┬───────┘  └───────────┘ │
│        │                │                          │
│        ▼                ▼                          │
│  ┌────────────────────────────────────┐            │
│  │          Runtime Loop              │            │
│  │  while not done and turns &lt; max:   │            │
│  │    response = llm.chat(messages)   │            │
│  │    if tool_calls:                  │            │
│  │      results = executor.run()      │            │
│  │    else: done = True               │            │
│  └──────────┬─────────────────────────┘            │
│       ┌─────┴──────┐                               │
│       ▼            ▼                                │
│  ┌──────────┐ ┌────────────┐                       │
│  │ToolRegist│ │ToolExecutor│                       │
│  │ register │ │ execute()  │                       │
│  │ schema() │ │ parallel() │                       │
│  └──────────┘ └────────────┘                       │
└───────────────────────────────────────────────────┘
</code></pre>
<p><strong>核心设计原则——职责分离</strong>：</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>职责</th>
<th>边界</th>
</tr>
</thead>
<tbody><tr>
<td><code>LLMClient</code></td>
<td>封装模型调用，处理重试</td>
<td>只管&quot;调 API&quot;，不管消息历史</td>
</tr>
<tr>
<td><code>ToolRegistry</code></td>
<td>注册工具，生成 JSON Schema</td>
<td>只管&quot;有哪些工具&quot;，不管怎么调</td>
</tr>
<tr>
<td><code>ToolExecutor</code></td>
<td>解析 tool_calls，分发执行</td>
<td>只管&quot;执行工具&quot;，不管谁触发的</td>
</tr>
<tr>
<td><code>MessageManager</code></td>
<td>管理消息列表，Token 计数和压缩</td>
<td>只管&quot;消息&quot;，不管消息从哪来</td>
</tr>
<tr>
<td><code>AgentRuntime</code></td>
<td>组装一切，驱动控制循环</td>
<td>只管&quot;编排&quot;，不自己做具体事</td>
</tr>
</tbody></table>
<p>任何模块可独立替换。换 Anthropic API？只改 <code>LLMClient</code>。状态存 Redis？只改 <code>StateStore</code>。Runtime 本身不需要变动。</p>
<hr>
<h2>3. 逐步构建</h2>
<h3>Step 1: LLMClient — 封装模型调用</h3>
<p>封装 OpenAI 兼容接口，支持 <code>tools</code> / <code>tool_choice</code>，处理流式/非流式，实现指数退避重试。</p>
<pre><code class="language-python"># llm_client.py
import time, json, logging
from dataclasses import dataclass, field
from typing import Optional, Generator
from openai import OpenAI, APIError, RateLimitError, APITimeoutError

logger = logging.getLogger(__name__)

@dataclass
class ToolCall:
    id: str
    name: str
    arguments: dict

@dataclass
class LLMResponse:
    content: Optional[str] = None
    tool_calls: list[ToolCall] = field(default_factory=list)
    usage: dict = field(default_factory=dict)
    finish_reason: str = &quot;&quot;

    @property
    def has_tool_calls(self) -&gt; bool:
        return len(self.tool_calls) &gt; 0

class LLMClient:
    RETRYABLE_ERRORS = (RateLimitError, APITimeoutError, APIError)

    def __init__(self, model=&quot;gpt-4o&quot;, base_url=None, api_key=None,
                 max_retries=3, retry_base_delay=1.0, timeout=60.0):
        self.model = model
        self.max_retries = max_retries
        self.retry_base_delay = retry_base_delay
        self.client = OpenAI(base_url=base_url, api_key=api_key, timeout=timeout)

    def chat(self, messages, tools=None, tool_choice=&quot;auto&quot;, temperature=0.0):
        kwargs = {&quot;model&quot;: self.model, &quot;messages&quot;: messages,
                  &quot;temperature&quot;: temperature}
        if tools:
            kwargs[&quot;tools&quot;] = tools
            kwargs[&quot;tool_choice&quot;] = tool_choice
        raw = self._call_with_retry(**kwargs)
        return self._parse_response(raw)

    def stream(self, messages, tools=None, tool_choice=&quot;auto&quot;,
               temperature=0.0) -&gt; Generator[LLMResponse, None, None]:
        kwargs = {&quot;model&quot;: self.model, &quot;messages&quot;: messages,
                  &quot;temperature&quot;: temperature, &quot;stream&quot;: True}
        if tools:
            kwargs[&quot;tools&quot;] = tools
            kwargs[&quot;tool_choice&quot;] = tool_choice

        accumulated_tool_calls: dict[int, dict] = {}
        for chunk in self._call_with_retry(**kwargs):
            delta = chunk.choices[0].delta if chunk.choices else None
            if not delta:
                continue
            if delta.content:
                yield LLMResponse(content=delta.content)
            # 流式下 tool_calls 分片到达，需要累积拼装
            if delta.tool_calls:
                for tc in delta.tool_calls:
                    idx = tc.index
                    if idx not in accumulated_tool_calls:
                        accumulated_tool_calls[idx] = {
                            &quot;id&quot;: &quot;&quot;, &quot;name&quot;: &quot;&quot;, &quot;arguments&quot;: &quot;&quot;}
                    if tc.id: accumulated_tool_calls[idx][&quot;id&quot;] = tc.id
                    if tc.function.name:
                        accumulated_tool_calls[idx][&quot;name&quot;] = tc.function.name
                    if tc.function.arguments:
                        accumulated_tool_calls[idx][&quot;arguments&quot;] += \
                            tc.function.arguments

        if accumulated_tool_calls:
            tool_calls = []
            for d in accumulated_tool_calls.values():
                args = json.loads(d[&quot;arguments&quot;]) if d[&quot;arguments&quot;] else {}
                tool_calls.append(ToolCall(d[&quot;id&quot;], d[&quot;name&quot;], args))
            yield LLMResponse(tool_calls=tool_calls)

    def _call_with_retry(self, **kwargs):
        last_error = None
        for attempt in range(self.max_retries + 1):
            try:
                return self.client.chat.completions.create(**kwargs)
            except self.RETRYABLE_ERRORS as e:
                last_error = e
                if attempt &lt; self.max_retries:
                    delay = self.retry_base_delay * (2 ** attempt)
                    logger.warning(f&quot;Retry {attempt+1} in {delay}s: {e}&quot;)
                    time.sleep(delay)
        raise last_error

    def _parse_response(self, raw) -&gt; LLMResponse:
        choice = raw.choices[0]
        msg = choice.message
        tool_calls = []
        if msg.tool_calls:
            for tc in msg.tool_calls:
                args = json.loads(tc.function.arguments) \
                    if tc.function.arguments else {}
                tool_calls.append(ToolCall(tc.id, tc.function.name, args))
        return LLMResponse(
            content=msg.content, tool_calls=tool_calls,
            usage={&quot;prompt_tokens&quot;: raw.usage.prompt_tokens,
                   &quot;completion_tokens&quot;: raw.usage.completion_tokens,
                   &quot;total_tokens&quot;: raw.usage.total_tokens},
            finish_reason=choice.finish_reason)
</code></pre>
<p><strong>关键设计决策</strong>：</p>
<ol>
<li><strong>统一 <code>LLMResponse</code></strong>：无论底层用什么模型，Runtime 只看到同一结构——适配器模式。</li>
<li><strong>重试只针对可恢复错误</strong>：<code>RateLimitError</code> 值得重试，<code>AuthenticationError</code> 重试一万次也没用。</li>
<li><strong>流式 tool_calls 累积拼装</strong>：OpenAI 把 tool_calls 拆成多个 chunk（先发 name，再逐步发 arguments），必须在客户端拼装。这是容易踩的坑。</li>
</ol>
<hr>
<h3>Step 2: ToolRegistry — 工具注册与发现</h3>
<p>用装饰器注册函数，通过 type hints 和 docstring 自动生成 OpenAI 格式的 JSON Schema。</p>
<pre><code class="language-python"># tool_registry.py
import inspect, json
from typing import Any, Callable, Optional, get_type_hints

TYPE_MAP = {str: &quot;string&quot;, int: &quot;integer&quot;, float: &quot;number&quot;,
            bool: &quot;boolean&quot;, list: &quot;array&quot;, dict: &quot;object&quot;}

class ToolRegistry:
    def __init__(self):
        self._tools: dict[str, Callable] = {}
        self._schemas: dict[str, dict] = {}

    def tool(self, name=None, description=None):
        &quot;&quot;&quot;装饰器注册工具&quot;&quot;&quot;
        def decorator(func):
            n = name or func.__name__
            d = description or (func.__doc__ or &quot;&quot;).strip().split(&quot;\n&quot;)[0]
            self._tools[n] = func
            self._schemas[n] = self._gen_schema(func, n, d)
            return func
        return decorator

    def register(self, func, name=None, description=None):
        &quot;&quot;&quot;命令式注册（适用于无法加装饰器的场景）&quot;&quot;&quot;
        n = name or func.__name__
        d = description or (func.__doc__ or &quot;&quot;).strip().split(&quot;\n&quot;)[0]
        self._tools[n] = func
        self._schemas[n] = self._gen_schema(func, n, d)

    def get_function(self, name): return self._tools.get(name)
    def get_all_schemas(self): return list(self._schemas.values())
    def list_tools(self): return list(self._tools.keys())

    def _gen_schema(self, func, name, description):
        sig = inspect.signature(func)
        hints = get_type_hints(func)
        properties, required = {}, []
        for pname, param in sig.parameters.items():
            if pname in (&quot;self&quot;, &quot;cls&quot;): continue
            ptype = hints.get(pname, str)
            prop = {&quot;type&quot;: TYPE_MAP.get(ptype, &quot;string&quot;)}
            # 从 Google 风格 docstring 提取参数描述
            pdesc = self._param_desc(func, pname)
            if pdesc: prop[&quot;description&quot;] = pdesc
            properties[pname] = prop
            if param.default is inspect.Parameter.empty:
                required.append(pname)
        return {&quot;type&quot;: &quot;function&quot;, &quot;function&quot;: {
            &quot;name&quot;: name, &quot;description&quot;: description,
            &quot;parameters&quot;: {&quot;type&quot;: &quot;object&quot;,
                           &quot;properties&quot;: properties, &quot;required&quot;: required}}}

    @staticmethod
    def _param_desc(func, param_name):
        doc = func.__doc__ or &quot;&quot;
        in_args = False
        for line in doc.split(&quot;\n&quot;):
            s = line.strip()
            if s.lower().startswith(&quot;args:&quot;): in_args = True; continue
            if in_args and param_name + &quot;:&quot; in s:
                return s.split(&quot;:&quot;, 1)[1].strip()
        return &quot;&quot;
</code></pre>
<p>验证效果：</p>
<pre><code class="language-python">registry = ToolRegistry()

@registry.tool()
def web_search(query: str, max_results: int = 5) -&gt; str:
    &quot;&quot;&quot;搜索网页内容
    Args:
        query: 搜索关键词
        max_results: 最大返回结果数量
    &quot;&quot;&quot;
    return f&quot;Results for: {query}&quot;

# 输出 OpenAI 格式的 tool schema
# {&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;web_search&quot;,&quot;description&quot;:&quot;搜索网页内容&quot;,
#  &quot;parameters&quot;:{&quot;type&quot;:&quot;object&quot;,&quot;properties&quot;:{&quot;query&quot;:{&quot;type&quot;:&quot;string&quot;,
#  &quot;description&quot;:&quot;搜索关键词&quot;},&quot;max_results&quot;:{&quot;type&quot;:&quot;integer&quot;,
#  &quot;description&quot;:&quot;最大返回结果数量&quot;}},&quot;required&quot;:[&quot;query&quot;]}}}
</code></pre>
<hr>
<h3>Step 3: ToolExecutor — 工具执行与结果处理</h3>
<p>接收 LLM 返回的 <code>tool_calls</code>，分发执行，收集结果，处理异常。支持串行和并行两种模式。</p>
<pre><code class="language-python"># tool_executor.py
import json, time, logging, traceback
from concurrent.futures import ThreadPoolExecutor, TimeoutError as FTE
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class ToolResult:
    tool_call_id: str
    name: str
    result: str
    success: bool
    duration_ms: float = 0.0

class ToolExecutor:
    def __init__(self, registry, default_timeout=30.0, max_workers=4):
        self.registry = registry
        self.default_timeout = default_timeout
        self.max_workers = max_workers

    def execute(self, tool_calls) -&gt; list[ToolResult]:
        &quot;&quot;&quot;串行执行&quot;&quot;&quot;
        return [self._run_one(tc) for tc in tool_calls]

    def execute_parallel(self, tool_calls) -&gt; list[ToolResult]:
        &quot;&quot;&quot;并行执行（LLM 一次返回多个 tool_calls 时使用）&quot;&quot;&quot;
        if len(tool_calls) &lt;= 1:
            return self.execute(tool_calls)
        results = []
        with ThreadPoolExecutor(max_workers=self.max_workers) as pool:
            futures = {pool.submit(self._run_one, tc): tc for tc in tool_calls}
            for fut in futures:
                try:
                    results.append(fut.result(timeout=self.default_timeout))
                except FTE:
                    tc = futures[fut]
                    results.append(ToolResult(
                        tc.id, tc.name,
                        f&quot;Error: &#39;{tc.name}&#39; timed out after &quot;
                        f&quot;{self.default_timeout}s&quot;, False))
        return results

    def _run_one(self, tool_call) -&gt; ToolResult:
        start = time.monotonic()
        func = self.registry.get_function(tool_call.name)
        if not func:
            return ToolResult(tool_call.id, tool_call.name,
                f&quot;Error: Unknown tool &#39;{tool_call.name}&#39;. &quot;
                f&quot;Available: {self.registry.list_tools()}&quot;, False)
        try:
            result = func(**tool_call.arguments)
            if not isinstance(result, str):
                result = json.dumps(result, ensure_ascii=False, default=str)
            ms = (time.monotonic() - start) * 1000
            logger.info(f&quot;Tool &#39;{tool_call.name}&#39; OK in {ms:.0f}ms&quot;)
            return ToolResult(tool_call.id, tool_call.name, result, True, ms)
        except Exception as e:
            ms = (time.monotonic() - start) * 1000
            msg = f&quot;Error: {type(e).__name__}: {e}&quot;
            logger.error(f&quot;{msg}\n{traceback.format_exc()}&quot;)
            return ToolResult(tool_call.id, tool_call.name, msg, False, ms)

    @staticmethod
    def results_to_messages(results):
        return [{&quot;role&quot;: &quot;tool&quot;, &quot;tool_call_id&quot;: r.tool_call_id,
                 &quot;content&quot;: r.result} for r in results]
</code></pre>
<p><strong>串行 vs 并行的 Trade-off</strong>：串行简单可调试；并行在 LLM 同时返回多个独立 tool_calls 时显著降低延迟。LLM 在一次响应中返回多个 tool_calls 本身就隐含了&quot;它们之间无依赖&quot;——否则它会分成多轮调用。</p>
<hr>
<h3>Step 4: MessageManager — 消息历史管理与压缩</h3>
<p>解决 Agent 长对话中最常遇到的问题：<strong>消息越来越多，Context Window 不够用了</strong>。</p>
<pre><code class="language-python"># message_manager.py
import json, logging, tiktoken
from typing import Optional
from copy import deepcopy

logger = logging.getLogger(__name__)

class MessageManager:
    def __init__(self, system_prompt=&quot;&quot;, model=&quot;gpt-4o&quot;,
                 max_tokens=120000, compression_threshold=0.75):
        self.system_prompt = system_prompt
        self.max_tokens = max_tokens
        self.compression_threshold = compression_threshold
        try: self.enc = tiktoken.encoding_for_model(model)
        except KeyError: self.enc = tiktoken.get_encoding(&quot;cl100k_base&quot;)
        self._messages: list[dict] = []

    def append(self, msg):
        self._messages.append(msg)
        self._maybe_compress()

    def extend(self, msgs):
        self._messages.extend(msgs)
        self._maybe_compress()

    def get_messages(self):
        out = []
        if self.system_prompt:
            out.append({&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: self.system_prompt})
        out.extend(deepcopy(self._messages))
        return out

    def count_tokens(self, msgs=None):
        msgs = msgs or self.get_messages()
        total = 2  # priming tokens
        for m in msgs:
            total += 4  # per-message overhead
            for v in m.values():
                if isinstance(v, str): total += len(self.enc.encode(v))
                elif isinstance(v, list):
                    total += len(self.enc.encode(json.dumps(v)))
        return total

    def _maybe_compress(self):
        threshold = int(self.max_tokens * self.compression_threshold)
        if self.count_tokens() &lt;= threshold: return
        logger.info(&quot;Token threshold exceeded, compressing...&quot;)
        self._sliding_window_compress(threshold)

    def _sliding_window_compress(self, target):
        &quot;&quot;&quot;从最早的消息移除，保持 tool_call 对完整性。

        关键约束：assistant(tool_calls) 后面的 tool(result) 消息必须
        一起移除，否则 OpenAI API 会报错。
        &quot;&quot;&quot;
        msgs, i = self._messages, 0
        while i &lt; len(msgs):
            remaining = msgs[i:]
            sys_msgs = ([{&quot;role&quot;:&quot;system&quot;,&quot;content&quot;:self.system_prompt}]
                        if self.system_prompt else [])
            if self.count_tokens(sys_msgs + remaining) &lt;= target: break
            i += 1
            # 如果刚移除的是含 tool_calls 的 assistant，连续移除后续 tool 消息
            if (i &gt; 0 and msgs[i-1].get(&quot;role&quot;) == &quot;assistant&quot;
                    and msgs[i-1].get(&quot;tool_calls&quot;)):
                while i &lt; len(msgs) and msgs[i].get(&quot;role&quot;) == &quot;tool&quot;:
                    i += 1
        if i &gt; 0:
            summary = {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;:
                f&quot;[{i} earlier messages removed to fit context window.]&quot;}
            self._messages = [summary] + msgs[i:]
            logger.info(f&quot;Removed {i} msgs, tokens: {self.count_tokens()}&quot;)
</code></pre>
<p><strong>三个关键点</strong>：System Prompt 始终保留不参与压缩；tool_call 对必须保持完整（<code>assistant</code> + 后续 <code>tool</code> 消息一起删或一起留）；在 75% 时就触发压缩，给回复留够空间。</p>
<hr>
<h3>Step 5: StateStore — 状态持久化</h3>
<p>简单的键值存储，生产中替换为 Redis 或数据库即可。</p>
<pre><code class="language-python"># state_store.py
import json
from typing import Any, Optional
from pathlib import Path

class StateStore:
    def __init__(self, store_dir=&quot;.agent_state&quot;):
        self.dir = Path(store_dir)
        self.dir.mkdir(parents=True, exist_ok=True)
        self._cache: dict[str, Any] = {}

    def save(self, key, value):
        self._cache[key] = value
        (self.dir / f&quot;{key}.json&quot;).write_text(
            json.dumps(value, ensure_ascii=False, indent=2, default=str))

    def load(self, key, default=None):
        if key in self._cache: return self._cache[key]
        f = self.dir / f&quot;{key}.json&quot;
        if f.exists():
            v = json.loads(f.read_text())
            self._cache[key] = v
            return v
        return default

    def clear(self, key=None):
        if key:
            self._cache.pop(key, None)
            (self.dir / f&quot;{key}.json&quot;).unlink(missing_ok=True)
        else:
            self._cache.clear()
            for f in self.dir.glob(&quot;*.json&quot;): f.unlink()
</code></pre>
<hr>
<h2>4. 核心 Runtime Loop</h2>
<p>所有模块就绪，组装成完整的 <code>AgentRuntime</code>。这是整篇文章的核心。</p>
<pre><code class="language-python"># agent_runtime.py
import json, time, logging
from dataclasses import dataclass, field
from typing import Optional, Callable
from collections import Counter

from llm_client import LLMClient, LLMResponse
from tool_registry import ToolRegistry
from tool_executor import ToolExecutor
from message_manager import MessageManager
from state_store import StateStore

logger = logging.getLogger(__name__)

@dataclass
class RuntimeConfig:
    max_turns: int = 20               # 最大循环轮次
    max_total_time: float = 300.0     # 最大总执行时间（秒）
    parallel_tool_calls: bool = True  # 是否并行执行工具
    loop_detection_window: int = 4    # 死循环检测窗口
    loop_detection_threshold: int = 3 # 相同调用出现次数阈值

@dataclass
class AgentResult:
    content: str
    turns: int = 0
    total_tokens: int = 0
    tool_calls_made: list[dict] = field(default_factory=list)
    duration_ms: float = 0.0
    stopped_reason: str = &quot;&quot;

class AgentRuntime:
    def __init__(self, llm: LLMClient, registry: ToolRegistry,
                 system_prompt=&quot;You are a helpful assistant.&quot;,
                 config: Optional[RuntimeConfig] = None):
        self.llm = llm
        self.registry = registry
        self.executor = ToolExecutor(registry)
        self.config = config or RuntimeConfig()
        self.messages = MessageManager(system_prompt=system_prompt,
                                       model=llm.model)
        self.state = StateStore()
        self.on_tool_start: Optional[Callable] = None
        self.on_tool_end: Optional[Callable] = None

    def run(self, user_input: str) -&gt; AgentResult:
        start_time = time.monotonic()
        self.messages.append({&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input})
        tools = self.registry.get_all_schemas() or None

        turns, total_tokens, all_tc = 0, 0, []
        tc_history: list[str] = []
        final_content, stopped = &quot;&quot;, &quot;completed&quot;

        while turns &lt; self.config.max_turns:
            turns += 1

            # ── 全局超时检查 ─────────────────────────────
            if time.monotonic() - start_time &gt; self.config.max_total_time:
                stopped = f&quot;timeout ({self.config.max_total_time}s)&quot;
                break

            # ── 调用 LLM ────────────────────────────────
            logger.info(f&quot;Turn {turns}: calling LLM...&quot;)
            resp = self.llm.chat(self.messages.get_messages(), tools=tools)
            total_tokens += resp.usage.get(&quot;total_tokens&quot;, 0)

            # ── 情况 1: 有 tool_calls → 执行工具 ────────
            if resp.has_tool_calls:
                # 构建 assistant 消息（必须包含 tool_calls 字段）
                asst = {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: resp.content,
                        &quot;tool_calls&quot;: [
                    {&quot;id&quot;: tc.id, &quot;type&quot;: &quot;function&quot;,
                     &quot;function&quot;: {&quot;name&quot;: tc.name,
                                  &quot;arguments&quot;: json.dumps(tc.arguments)}}
                    for tc in resp.tool_calls]}
                self.messages.append(asst)

                # 死循环检测
                sig = json.dumps([(tc.name, tc.arguments)
                                  for tc in resp.tool_calls], sort_keys=True)
                tc_history.append(sig)
                if self._detect_loop(tc_history):
                    stopped = &quot;loop_detected&quot;
                    final_content = (&quot;I&#39;m repeating the same actions. &quot;
                                     &quot;Stopping to summarize findings.&quot;)
                    break

                # 执行
                if self.on_tool_start: self.on_tool_start(resp.tool_calls)
                if self.config.parallel_tool_calls and len(resp.tool_calls) &gt; 1:
                    results = self.executor.execute_parallel(resp.tool_calls)
                else:
                    results = self.executor.execute(resp.tool_calls)
                if self.on_tool_end: self.on_tool_end(results)

                for tc, r in zip(resp.tool_calls, results):
                    all_tc.append({&quot;turn&quot;: turns, &quot;name&quot;: tc.name,
                        &quot;arguments&quot;: tc.arguments,
                        &quot;success&quot;: r.success, &quot;duration_ms&quot;: r.duration_ms})

                self.messages.extend(ToolExecutor.results_to_messages(results))

            # ── 情况 2: 纯文本 → 任务完成 ───────────────
            else:
                final_content = resp.content or &quot;&quot;
                self.messages.append(
                    {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: final_content})
                break
        else:
            stopped = f&quot;max_turns ({self.config.max_turns})&quot;

        return AgentResult(
            content=final_content, turns=turns, total_tokens=total_tokens,
            tool_calls_made=all_tc,
            duration_ms=(time.monotonic() - start_time) * 1000,
            stopped_reason=stopped)

    def _detect_loop(self, history):
        &quot;&quot;&quot;滑动窗口 + 频次统计，同时捕获连续重复和交替重复&quot;&quot;&quot;
        w = self.config.loop_detection_window
        t = self.config.loop_detection_threshold
        if len(history) &lt; t: return False
        return any(c &gt;= t for c in Counter(history[-w:]).values())
</code></pre>
<h3>核心循环解读</h3>
<p><strong>两种退出路径</strong>——这是 Agent 与 Workflow 的本质区别：</p>
<pre><code>resp.has_tool_calls == True   → 继续（还有事要做）
resp.has_tool_calls == False  → break（LLM 认为任务完成了）
</code></pre>
<p><strong>为什么 assistant 消息必须包含 tool_calls 字段？</strong> 这是 OpenAI API 的协议约束。消息流必须是：<code>user</code> → <code>assistant(tool_calls)</code> → <code>tool(result)</code> → <code>assistant(final)</code>。打破这个顺序会报错。</p>
<p><strong>死循环检测</strong>用滑动窗口而非简单的&quot;连续 N 次相同&quot;，因为 LLM 有时会在两个工具间交替调用（A→B→A→B→...），这也是死循环，但不是&quot;连续相同&quot;。</p>
<hr>
<h2>5. 高级特性</h2>
<h3>5.1 Streaming 支持</h3>
<p>流式模式下需要边输出文本、边判断是否有 tool_calls：</p>
<pre><code class="language-python"># 添加到 AgentRuntime
def run_stream(self, user_input: str):
    self.messages.append({&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: user_input})
    tools = self.registry.get_all_schemas() or None
    turns = 0

    while turns &lt; self.config.max_turns:
        turns += 1
        content, final_tc = &quot;&quot;, None

        for chunk in self.llm.stream(self.messages.get_messages(), tools=tools):
            if chunk.content:
                content += chunk.content
                yield {&quot;type&quot;: &quot;text&quot;, &quot;content&quot;: chunk.content}
            if chunk.tool_calls:
                final_tc = chunk.tool_calls

        if final_tc:
            yield {&quot;type&quot;: &quot;tool_start&quot;,
                   &quot;calls&quot;: [{&quot;name&quot;:tc.name} for tc in final_tc]}
            asst = {&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: content,
                    &quot;tool_calls&quot;: [
                {&quot;id&quot;:tc.id, &quot;type&quot;:&quot;function&quot;,
                 &quot;function&quot;:{&quot;name&quot;:tc.name,
                             &quot;arguments&quot;:json.dumps(tc.arguments)}}
                for tc in final_tc]}
            self.messages.append(asst)
            results = self.executor.execute(final_tc)
            self.messages.extend(ToolExecutor.results_to_messages(results))
            yield {&quot;type&quot;: &quot;tool_end&quot;,
                   &quot;results&quot;: [{&quot;name&quot;:r.name, &quot;ok&quot;:r.success} for r in results]}
        else:
            self.messages.append({&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:content})
            yield {&quot;type&quot;: &quot;done&quot;, &quot;content&quot;: content}
            break
</code></pre>
<h3>5.2 超时控制的两层设计</h3>
<pre><code>┌──────────────────────────────────────┐
│ 全局超时 (max_total_time = 300s)     │
│  ┌──────┐ ┌──────┐ ┌──────┐        │
│  │Tool 1│ │Tool 2│ │Tool 3│        │
│  │30s   │ │30s   │ │30s   │        │
│  └──────┘ └──────┘ └──────┘        │
│ 单工具超时 (default_timeout = 30s)   │
└──────────────────────────────────────┘
</code></pre>
<p>单工具超时在 <code>ToolExecutor</code> 中通过 <code>ThreadPoolExecutor.result(timeout=30)</code> 控制；全局超时在 Runtime 每轮循环开始时检查 elapsed time。</p>
<hr>
<h2>6. 完整示例：研究助手 Agent</h2>
<pre><code class="language-python"># research_agent.py
import json, os, logging
from agent_runtime import AgentRuntime, RuntimeConfig
from llm_client import LLMClient
from tool_registry import ToolRegistry

logging.basicConfig(level=logging.INFO,
    format=&quot;%(asctime)s [%(levelname)s] %(name)s: %(message)s&quot;)

registry = ToolRegistry()

@registry.tool()
def web_search(query: str, max_results: int = 5) -&gt; str:
    &quot;&quot;&quot;搜索网页内容
    Args:
        query: 搜索关键词
        max_results: 最大返回数量
    &quot;&quot;&quot;
    # 生产环境替换为 SerpAPI / Bing API
    return json.dumps([{&quot;title&quot;: f&quot;Result {i+1} for &#39;{query}&#39;&quot;,
        &quot;url&quot;: f&quot;https://example.com/article-{i+1}&quot;,
        &quot;snippet&quot;: f&quot;Detailed article about {query}, section {i+1}...&quot;}
        for i in range(min(max_results, 3))], ensure_ascii=False)

@registry.tool()
def read_url(url: str) -&gt; str:
    &quot;&quot;&quot;读取网页内容
    Args:
        url: 网页地址
    &quot;&quot;&quot;
    # 生产环境替换为 requests + BeautifulSoup
    return (f&quot;[Content from {url}]\n&quot;
            f&quot;Key points: 1) Fundamental concepts 2) Best practices &quot;
            f&quot;3) Common pitfalls 4) Case studies and benchmarks&quot;)

@registry.tool()
def write_file(filename: str, content: str) -&gt; str:
    &quot;&quot;&quot;写入文件
    Args:
        filename: 文件名
        content: 文本内容
    &quot;&quot;&quot;
    os.makedirs(&quot;output&quot;, exist_ok=True)
    path = os.path.join(&quot;output&quot;, os.path.basename(filename))
    with open(path, &quot;w&quot;) as f: f.write(content)
    return f&quot;Wrote {len(content)} chars to {path}&quot;

@registry.tool()
def ask_user(question: str) -&gt; str:
    &quot;&quot;&quot;向用户提问
    Args:
        question: 问题
    &quot;&quot;&quot;
    print(f&quot;\nAgent asks: {question}&quot;)
    return input(&quot;Your answer: &quot;)

SYSTEM_PROMPT = &quot;&quot;&quot;You are a research assistant. Workflow:
1. Search for information using web_search
2. Read promising articles using read_url (at least 2 sources)
3. Synthesize into a report and save with write_file
4. Present a summary. Use ask_user if the topic is unclear.&quot;&quot;&quot;

agent = AgentRuntime(
    llm=LLMClient(model=&quot;gpt-4o&quot;, api_key=os.environ.get(&quot;OPENAI_API_KEY&quot;)),
    registry=registry,
    system_prompt=SYSTEM_PROMPT,
    config=RuntimeConfig(max_turns=15, max_total_time=120.0))

if __name__ == &quot;__main__&quot;:
    result = agent.run(&quot;研究 Python asyncio 最佳实践，整理成技术报告并保存。&quot;)
    print(f&quot;\n{&#39;=&#39;*50}\nTurns: {result.turns} | Tokens: {result.total_tokens} &quot;
          f&quot;| {result.duration_ms:.0f}ms | {result.stopped_reason}&quot;)
    for tc in result.tool_calls_made:
        print(f&quot;  Turn {tc[&#39;turn&#39;]}: {tc[&#39;name&#39;]}() &quot;
              f&quot;{&#39;OK&#39; if tc[&#39;success&#39;] else &#39;FAIL&#39;} {tc[&#39;duration_ms&#39;]:.0f}ms&quot;)
    print(f&quot;\n{result.content[:300]}&quot;)
</code></pre>
<h3>执行 Trace</h3>
<pre><code>Turn 1: calling LLM...  → web_search(&quot;Python asyncio best practices&quot;)
Turn 2: calling LLM...  → read_url(url1) + read_url(url2)  [parallel]
Turn 3: calling LLM...  → web_search(&quot;asyncio common pitfalls&quot;)
Turn 4: calling LLM...  → read_url(url3)
Turn 5: calling LLM...  → write_file(&quot;asyncio-report.md&quot;, ...)
Turn 6: calling LLM...  → [no tool_calls] → Done

==================================================
Turns: 6 | Tokens: 8432 | 13245ms | completed
  Turn 1: web_search() OK 45ms
  Turn 2: read_url() OK 120ms
  Turn 2: read_url() OK 135ms
  Turn 3: web_search() OK 38ms
  Turn 4: read_url() OK 110ms
  Turn 5: write_file() OK 5ms
</code></pre>
<p>注意 Turn 2：LLM 返回了两个 <code>read_url</code>，Runtime 自动并行执行。</p>
<hr>
<h2>7. 与框架对比</h2>
<h3>自建 vs 框架</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>自建 Runtime</th>
<th>框架（LangChain 等）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>透明性</strong></td>
<td>完全透明</td>
<td>需要读框架源码</td>
</tr>
<tr>
<td><strong>调试</strong></td>
<td>直接 breakpoint</td>
<td>需要理解框架抽象层</td>
</tr>
<tr>
<td><strong>定制</strong></td>
<td>任何行为可改</td>
<td>受 API 设计约束</td>
</tr>
<tr>
<td><strong>依赖</strong></td>
<td><code>openai</code> + <code>tiktoken</code></td>
<td>几十个传递依赖</td>
</tr>
<tr>
<td><strong>边界情况</strong></td>
<td>自己发现和处理</td>
<td>社区帮你踩过坑</td>
</tr>
<tr>
<td><strong>生态集成</strong></td>
<td>每个都要自己写</td>
<td>现成的 VectorStore/Retriever</td>
</tr>
<tr>
<td><strong>开发速度</strong></td>
<td>初期更慢</td>
<td>有模板更快</td>
</tr>
</tbody></table>
<h3>决策建议</h3>
<ul>
<li><strong>学习阶段</strong>：一定要自建一次。不理解原理就用框架，永远无法判断框架是否在坑你。</li>
<li><strong>PoC / Hackathon</strong>：用框架，速度第一。</li>
<li><strong>生产系统</strong>：自建核心 Runtime + 选择性使用框架组件（如只用 LangChain 的 Retriever）。</li>
<li><strong>基础设施团队</strong>：自建。你们的需求框架大概率满足不了。</li>
</ul>
<hr>
<h2>8. 结语：Phase 2 完成</h2>
<p>到这里，Phase 2 四篇文章全部完成：</p>
<ul>
<li><strong>第 04 篇</strong>：理解控制循环 — Observe → Think → Act → Reflect</li>
<li><strong>第 05 篇</strong>：深入 Tool Calling — JSON Schema、Function Calling、Structured Output</li>
<li><strong>第 06 篇</strong>：Prompt Engineering — System Prompt 设计、工具选择引导、Reflection Prompt</li>
<li><strong>第 07 篇（本篇）</strong>：把以上所有知识组装成可运行的 Agent Runtime</li>
</ul>
<p>此刻你有能力<strong>不依赖任何框架，从零构建功能完整的 Agent 系统</strong>。</p>
<p>但如果你运行过这个 Agent，会很快发现几个问题：</p>
<ol>
<li><strong>没有记忆</strong>：每次启动都是白纸，不记得上次的对话</li>
<li><strong>不会计划</strong>：面对复杂任务只是一步步试，没有全局规划</li>
<li><strong>一个不够用</strong>：有些任务需要不同角色的 Agent 协作</li>
</ol>
<p>这就是 Phase 3 要解决的问题：</p>
<ul>
<li><strong>第 08 篇</strong>：Memory Architecture — Agent 的状态与记忆体系</li>
<li><strong>第 09 篇</strong>：RAG as Cognitive Memory — 检索增强生成的工程实践</li>
<li><strong>第 10 篇</strong>：Planning and Reflection — 从 ReAct 到分层规划</li>
<li><strong>第 11 篇</strong>：Multi-Agent Collaboration — 多 Agent 协作</li>
</ul>
<p>Phase 2 给了你造一把锤子的能力。Phase 3 将教你如何造一个工具箱。</p>
<hr>
<blockquote>
<p><strong>系列导航</strong>：本文是 Agentic 系列的第 07 篇。</p>
<ul>
<li>上一篇：<a href="/blog/engineering/agentic/06-Prompt%20Engineering%20for%20Agents">06 | Prompt Engineering for Agents</a></li>
<li>下一篇：<a href="/blog/engineering/agentic/08-Memory%20Architecture">08 | Memory Architecture</a></li>
<li>完整目录：<a href="/blog/engineering/agentic/01-From%20LLM%20to%20Agent">01 | From LLM to Agent</a></li>
</ul>
</blockquote>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/agentic/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"Agentic 系统"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2025-12-23","children":"2025年12月23日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"Prompt Engineering for Agents: 面向 Agent 的提示词工程"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","Agentic",{"href":"/blog/tag/Agentic/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Agentic"}],["$","$L13","AI Engineering",{"href":"/blog/tag/AI%20Engineering/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"AI Engineering"}],["$","$L13","Prompt Engineering",{"href":"/blog/tag/Prompt%20Engineering/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"Prompt Engineering"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/architecture/架构师的认知升级：从技术深度到系统决策能力","title":"架构师的认知升级：从技术深度到系统决策能力","description":"系统梳理架构师的核心能力模型、知识体系全景与成长路径，从架构定义到设计方法论，从分布式理论到架构演进，帮助技术人建立完整的架构认知框架。","pubDate":"2025-12-20","tags":["架构设计","架构师","技术成长","分布式系统","架构方法论"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/middleware/深入理解AQS：Java并发的基石","title":"深入理解AQS：Java并发的基石","description":"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。","pubDate":"2025-12-28","tags":["Java","并发编程","AQS","ReentrantLock","JUC"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"Agentic":{"prev":{"slug":"engineering/agentic/05-Tool Calling Deep Dive","title":"Tool Calling Deep Dive: 让 LLM 成为可编程接口","description":"Tool Calling 是 LLM 从「对话机器」变成「可编程接口」的关键转折点。本文从底层原理出发，系统拆解 Tool Calling 的工作机制、JSON Schema 契约设计、工具注册与发现策略、错误处理、安全性考量及关键 Trade-off，附带完整可运行代码。","pubDate":"2025-12-18","tags":["Agentic","AI Engineering","Tool Calling"],"heroImage":"$undefined","content":"$19"},"next":{"slug":"engineering/agentic/07-Agent Runtime from Scratch","title":"Agent Runtime from Scratch: 不依赖框架构建 Agent","description":"不依赖 LangChain 等框架，从零实现一个功能完整的 Agent Runtime。逐模块构建 LLMClient、ToolRegistry、ToolExecutor、MessageManager 和核心控制循环，包含并行工具调用、Streaming、超时控制、死循环检测等高级特性，附完整可运行代码。","pubDate":"2025-12-28","tags":["Agentic","AI Engineering","Runtime"],"heroImage":"$undefined","content":"$1a"}},"AI Engineering":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:tagNav:Agentic:prev","next":"$5:props:children:props:children:props:children:2:props:children:props:tagNav:Agentic:next"},"Prompt Engineering":{"prev":null,"next":null}}}]}],["$","$L1b",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"Prompt Engineering for Agents: 面向 Agent 的提示词工程 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"Agent 的 Prompt 不是聊天提示词，而是系统接口规范。本文系统拆解 Agent Prompt 的分层架构、四种关键设计模式（Router / Planner / Executor / Reflector）、Chain-of-Thought 的 Agent 化应用、Few-shot vs Zero-shot 的场景选择、Prompt 工程化实践（模板化 / 版本控制 / 测试 / 组合），以及 Context Window 管理策略。"}],["$","meta","2",{"property":"og:title","content":"Prompt Engineering for Agents: 面向 Agent 的提示词工程"}],["$","meta","3",{"property":"og:description","content":"Agent 的 Prompt 不是聊天提示词，而是系统接口规范。本文系统拆解 Agent Prompt 的分层架构、四种关键设计模式（Router / Planner / Executor / Reflector）、Chain-of-Thought 的 Agent 化应用、Few-shot vs Zero-shot 的场景选择、Prompt 工程化实践（模板化 / 版本控制 / 测试 / 组合），以及 Context Window 管理策略。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2025-12-23"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"Prompt Engineering for Agents: 面向 Agent 的提示词工程"}],["$","meta","9",{"name":"twitter:description","content":"Agent 的 Prompt 不是聊天提示词，而是系统接口规范。本文系统拆解 Agent Prompt 的分层架构、四种关键设计模式（Router / Planner / Executor / Reflector）、Chain-of-Thought 的 Agent 化应用、Few-shot vs Zero-shot 的场景选择、Prompt 工程化实践（模板化 / 版本控制 / 测试 / 组合），以及 Context Window 管理策略。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

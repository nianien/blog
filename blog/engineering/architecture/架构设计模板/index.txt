1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/fffdcdb4fb651185.css","style"]
0:{"P":null,"b":"wlOkUxTzHfxl8sQA11M8Z","p":"","c":["","blog","engineering","architecture","%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/architecture/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/fffdcdb4fb651185.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/architecture/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","4qbmtfpRNRovqHk-1BhVXv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1b:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T6ae1,<h1>架构设计模板</h1>
<p>架构设计文档的价值不在于文档本身，而在于写文档的过程——它迫使我们在动手之前系统性地思考。一份好的设计文档能回答三个问题：<strong>为什么要做、怎么做、做到什么程度算完</strong>。</p>
<p>然而实际工作中，设计文档常见两类问题：要么太空——通篇架构图但缺乏落地细节；要么有遗漏——上线后才发现没考虑容灾、没定义回滚方案。根本原因是缺少一个结构化的思考框架。</p>
<p>本文提供一套经过实践验证的架构设计模板，包含 11 个维度。它的设计思路遵循一条主线：</p>
<blockquote>
<p><strong>问题驱动 → 方案设计 → 工程落地</strong></p>
<ul>
<li>问题驱动（第 1 章）：搞清楚为什么要做，边界在哪</li>
<li>方案设计（第 2-9 章）：从架构到细节，把方案想透</li>
<li>工程落地（第 10-11 章）：怎么部署、怎么分期交付</li>
</ul>
</blockquote>
<p>这 11 个维度既可以作为写设计文档的提纲，也可以当作评审时的 Checklist。每个维度给出<strong>要回答的关键问题</strong>和<strong>具体交付物</strong>，文末附可直接复用的 Markdown 模板。</p>
<hr>
<h3>1. 需求介绍</h3>
<p>需求介绍的核心任务是把「为什么要做」讲清楚。它不是产品需求文档（PRD）的复述，而是从技术视角回答：现状有什么问题、我们打算怎么解决、做到什么程度算成功。</p>
<p><strong>要回答的关键问题：</strong></p>
<ul>
<li><strong>现状与痛点</strong>：当前系统/流程存在什么问题？对业务造成了哪些可量化的影响（故障频率、延迟、人工成本等）？</li>
<li><strong>目标与范围</strong>：新方案要解决哪些问题？同样重要的是——不解决哪些问题？明确的边界能防止需求蔓延。</li>
<li><strong>核心场景</strong>：列出 3-5 个最重要的使用场景。场景是连接需求与设计的桥梁——拆得越细，后面的设计越不容易遗漏。</li>
<li><strong>干系人</strong>：谁是用户？谁会被改动影响？谁需要配合？</li>
<li><strong>约束条件</strong>：时间窗口、预算、技术栈限制、合规要求等。</li>
<li><strong>验收标准</strong>：用可量化的指标定义「做完了」，如 P99 延迟 &lt; 200ms、可用性 &gt; 99.95%、数据一致性延迟 &lt; 1s。</li>
</ul>
<p><strong>实践建议：</strong></p>
<p>用「场景走查」来验证需求完整性——把每个核心场景从头到尾走一遍，记录每一步涉及的系统、数据和人员。走查过程中自然会暴露出遗漏的约束和边界条件。</p>
<p><strong>交付物：</strong> 需求背景文档（含场景列表、干系人矩阵、约束条件、验收标准）</p>
<hr>
<h3>2. 架构总览</h3>
<p>架构总览是整个设计文档的「地图」。评审者和后续加入的开发人员，通常最先看的就是这一章。它需要回答：系统长什么样、分几块、各块之间怎么协作。</p>
<p><strong>多视角描述架构：</strong></p>
<p>业界常用 <a href="https://en.wikipedia.org/wiki/4%2B1_architectural_view_model">4+1 视图模型</a> 或 <a href="https://c4model.com/">C4 模型</a> 来组织架构描述。对于多数项目，以下三个视角已经够用：</p>
<ul>
<li><strong>概念模型</strong>：系统中有哪些核心领域概念？它们之间的关系是什么？概念模型是整个设计的骨架。看似简单的概念定义——比如「部署包 = 介质包 + 配置」——往往直接决定了后续的技术设计。建议用 UML 类图或 ER 图表达。</li>
<li><strong>逻辑架构图</strong>：系统分几层？每层有哪些模块？模块之间的依赖方向是什么？建议按能力分层（接入层 → 业务逻辑层 → 领域服务层 → 基础设施层），并标注每个模块的核心职责。</li>
<li><strong>系统上下文图</strong>（System Context）：聚焦系统边界——哪些能力自研，哪些依赖外部系统？与周边系统的交互协议和数据格式是什么？这张图对于跨团队协作尤其关键。</li>
</ul>
<p><strong>画图原则：</strong></p>
<p>架构图的唯一标准是<strong>易懂</strong>。一些实用建议：</p>
<ul>
<li>每张图只表达一个层次的信息，避免在同一张图中混合部署细节和业务逻辑</li>
<li>用颜色/形状区分不同类型的组件（自研服务、外部依赖、中间件、数据存储）</li>
<li>标注关键数据流的方向和协议</li>
<li>推荐工具：Excalidraw（轻量手绘风）、draw.io（标准流程图）、PlantUML（文本生成图）</li>
</ul>
<p><strong>实践建议：</strong></p>
<p>好的架构图是改出来的，不是一次画对的。建议在正式评审前做一次小范围宣讲，一是统一理解，二是通过反馈优化设计。</p>
<p><strong>交付物：</strong> 概念模型图、逻辑架构图、系统上下文图</p>
<hr>
<h3>3. 核心流程</h3>
<p>架构总览展示了系统的静态结构，核心流程则展示系统的动态行为——各组件如何协作完成具体业务场景。<strong>架构图 + 时序图是设计评审中最有价值的两张图</strong>，前者回答「是什么」，后者回答「怎么运转」。</p>
<p><strong>场景驱动的梳理方法：</strong></p>
<ol>
<li><strong>列出核心场景</strong>：从用户/调用方的视角，挑出最重要的 3-5 个场景（通常就是需求介绍中的核心场景）</li>
<li><strong>画出 Happy Path</strong>：每个场景走一遍完整调用链路，用时序图（Sequence Diagram）标注参与方、调用顺序、数据流向</li>
<li><strong>标注关键路径</strong>：在时序图上标记性能瓶颈点、状态变更点、数据持久化点</li>
<li><strong>补充异常流程</strong>：这是最容易被忽略但最重要的部分——下游超时怎么办？重试是否幂等？消息丢了怎么补偿？数据不一致怎么修复？</li>
</ol>
<p><strong>常见陷阱：</strong></p>
<p>很多设计文档只画了「晴天场景」，对异常路径一笔带过。但线上故障绝大多数发生在异常分支。建议对每个核心流程至少补充以下异常场景：</p>
<ul>
<li>依赖服务不可用</li>
<li>网络超时 / 部分失败</li>
<li>数据不一致（如消息乱序、重复投递）</li>
<li>资源耗尽（连接池满、磁盘满、内存 OOM）</li>
</ul>
<p><strong>交付物：</strong> 核心场景的时序图（含 Happy Path 和关键异常流程）</p>
<hr>
<h3>4. 详细设计</h3>
<p>详细设计是对架构中复杂组件的「放大镜」。不需要面面俱到，但对核心模块和高风险模块必须写清楚。</p>
<p><strong>通常涵盖以下几类：</strong></p>
<p><strong>数据模型</strong></p>
<ul>
<li>核心表结构设计（字段、类型、约束）</li>
<li>索引策略（查询模式决定索引设计，而非反过来）</li>
<li>数据生命周期：冷热分离策略、归档/清理规则、数据保留期限</li>
<li>数据量评估：初始数据量、增长速率、单表上限</li>
</ul>
<p><strong>接口契约</strong></p>
<ul>
<li>对外 API 定义：路径、方法、入参、出参、错误码、版本策略</li>
<li>如涉及多系统协作，还需定义 SPI（扩展点接口）——即「我提供框架，你来实现具体逻辑」的扩展机制</li>
<li>接口幂等性设计：哪些接口需要幂等？幂等 Key 怎么生成？</li>
<li>建议遵循 <a href="https://www.openapis.org/">OpenAPI</a> 规范，便于自动生成文档和客户端代码</li>
</ul>
<p><strong>状态机</strong></p>
<ul>
<li>如业务有复杂状态流转（订单、审批、工单等），一张状态机图比大段文字清晰得多</li>
<li>明确每个状态转换的触发条件、执行动作和失败回退</li>
</ul>
<p><strong>关键算法/策略</strong></p>
<ul>
<li>路由策略（一致性 Hash、权重轮询等）</li>
<li>调度算法（优先级队列、公平调度等）</li>
<li>限流算法（令牌桶、滑动窗口等）</li>
</ul>
<p><strong>实践建议：</strong></p>
<p>详细设计不必一次写完，可以在开发过程中迭代补充。但有两样东西必须在写代码之前定好：<strong>接口契约</strong>和<strong>数据模型</strong>——它们的变更成本最高，影响面最广。</p>
<p><strong>交付物：</strong> 数据模型设计、接口文档（API/SPI）、状态机图（如有）、关键算法说明</p>
<hr>
<h3>5. 高可用设计</h3>
<p>高可用设计回答一个核心问题：<strong>系统的某个部分挂了，整体还能不能用？</strong> 这是从「能跑」到「能扛」的关键一步。</p>
<p><strong>冗余与容灾</strong></p>
<ul>
<li>服务层：是否多实例部署？是否跨可用区（AZ）部署？单个 AZ 故障时服务是否仍然可用？</li>
<li>数据层：数据库是否有主从/多副本？故障切换是自动还是手动？RPO（数据丢失量）和 RTO（恢复时间）的目标是多少？</li>
<li>降级方案：核心链路和非核心链路是否隔离？当非核心依赖不可用时，核心功能是否能继续运行？降级是自动触发还是手动开关？</li>
</ul>
<p><strong>故障检测与自愈</strong></p>
<ul>
<li>健康检查：Liveness Probe（进程是否存活）和 Readiness Probe（是否可接收流量）分别怎么设计？</li>
<li>熔断策略：使用什么熔断器（如 Sentinel、Resilience4j）？熔断阈值和恢复策略如何配置？</li>
<li>限流策略：在哪一层限流（网关层 / 应用层）？限流粒度是什么（全局 / 租户 / 接口）？</li>
<li>隔离机制：线程池隔离、信号量隔离还是进程隔离？</li>
</ul>
<p><strong>数据一致性</strong></p>
<ul>
<li>一致性模型选择：强一致（CP）还是最终一致（AP）？在什么场景下可以接受最终一致？</li>
<li>跨服务一致性方案：Saga、TCC、本地消息表、事务消息等，各有适用场景。选择依据是什么？</li>
<li>补偿机制：当一致性被破坏时，如何检测和修复？是否需要对账任务？</li>
</ul>
<p><strong>可观测性</strong></p>
<ul>
<li>监控三支柱：Metrics（指标）、Logging（日志）、Tracing（链路追踪）各自的方案是什么？</li>
<li>关键监控指标按 <a href="https://grafana.com/blog/2018/08/02/the-red-method-how-to-instrument-your-services/">RED 方法</a> 分类：Rate（请求速率）、Errors（错误率）、Duration（延迟分布）</li>
<li>告警规则：分级（P0/P1/P2/P3）、阈值、通知渠道、响应 SLA</li>
<li>故障定位：如何从告警快速定位到根因？是否有 Runbook（故障手册）？</li>
</ul>
<p><strong>交付物：</strong> 高可用方案说明（含冗余策略、故障恢复流程、可观测性方案、告警清单）</p>
<hr>
<h3>6. 高性能设计</h3>
<p>高性能设计的核心原则是<strong>先定目标，再找瓶颈，最后谈优化</strong>。没有量化目标的优化是盲目的。</p>
<p><strong>性能目标</strong></p>
<ul>
<li>QPS/TPS 目标：峰值多少？日常多少？需要预留多少 Buffer？</li>
<li>延迟目标：P50、P95、P99 分别是多少？（只看平均值会掩盖长尾问题）</li>
<li>数据量级：当前数据量多大？未来 1-3 年的增长预期？</li>
</ul>
<p><strong>瓶颈分析</strong></p>
<ul>
<li>识别系统是 CPU 密集型还是 IO 密集型</li>
<li>找出关键路径上的瓶颈点：数据库查询、外部 API 调用、序列化/反序列化、锁竞争等</li>
<li>使用 <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl 定律</a> 评估优化收益——优化非瓶颈环节收效甚微</li>
</ul>
<p><strong>分层优化策略</strong></p>
<table>
<thead>
<tr>
<th>层次</th>
<th>常用手段</th>
</tr>
</thead>
<tbody><tr>
<td>接入层</td>
<td>CDN 加速、负载均衡、连接复用、协议优化（HTTP/2、gRPC）</td>
</tr>
<tr>
<td>应用层</td>
<td>本地缓存（Caffeine）、分布式缓存（Redis）、异步化（MQ）、批量合并、并行调用</td>
</tr>
<tr>
<td>数据层</td>
<td>读写分离、分库分表、索引优化、热点数据隔离、查询结果缓存</td>
</tr>
<tr>
<td>基础设施</td>
<td>水平扩容、弹性伸缩（HPA）、资源池化、JVM/Runtime 调优</td>
</tr>
</tbody></table>
<p><strong>压测验证</strong></p>
<ul>
<li>工具选择：JMeter（全功能）、wrk/hey（轻量 HTTP）、k6（脚本化场景）</li>
<li>压测策略：阶梯加压找出拐点，而非直接打满</li>
<li>压测环境与生产环境的差异要记录清楚（机器规格、数据量、网络拓扑）</li>
<li>压测报告要包含：吞吐量曲线、延迟分布、资源利用率、瓶颈定位</li>
</ul>
<p><strong>交付物：</strong> 性能目标定义、瓶颈分析、分层优化方案、压测计划</p>
<hr>
<h3>7. 可扩展性设计</h3>
<p>可扩展性回答两个问题：<strong>加功能容不容易（业务扩展性）<strong>和</strong>加机器扛不扛得住更多量（容量扩展性）</strong>。</p>
<p><strong>业务扩展性</strong></p>
<p>好的扩展性设计遵循 <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">开闭原则</a>——对扩展开放，对修改关闭。具体评判标准：</p>
<blockquote>
<p>新增一类需求时，是加配置就行，还是要写代码？写代码的话，是新增代码就行，还是要改已有代码？越往前者靠，扩展性越好。</p>
</blockquote>
<p>常见的扩展性手段：</p>
<ul>
<li><strong>插件化 / SPI 机制</strong>：通过接口抽象 + 实现注册，新增场景只需新增实现类</li>
<li><strong>策略模式 + 配置驱动</strong>：将业务规则外化为配置，通过策略分发路由到不同处理逻辑</li>
<li><strong>事件驱动</strong>：核心流程产出事件，扩展功能订阅事件，彼此解耦</li>
<li><strong>合理的领域划分</strong>：按业务能力（而非技术层次）划分模块，模块间通过明确的接口通信</li>
</ul>
<p><strong>容量扩展性</strong></p>
<ul>
<li>服务层：是否无状态？能否直接水平扩容？如果有状态（如本地缓存、WebSocket 长连接），扩容时如何处理？</li>
<li>数据层：数据库如何扩展？是否预留了分片键？分片策略是什么？</li>
<li>消息队列：Partition 数量是否支持后续扩展？Consumer Group 的 Rebalance 策略是什么？</li>
<li>单点瓶颈：系统中是否存在不可水平扩展的单点？如何规避或缓解？</li>
</ul>
<p><strong>交付物：</strong> 扩展点清单、领域划分图、容量扩展方案</p>
<hr>
<h3>8. 安全设计</h3>
<p>安全设计即使当前没有明确需求，也应作为 Checklist 在评审中显式确认。写「经评估，本期暂不涉及」远好过完全不提——前者是有意识的决策，后者是遗漏。</p>
<p><strong>认证与授权</strong></p>
<ul>
<li>认证方案：JWT、OAuth 2.0、Session、OIDC？Token 的签发、刷新和吊销机制？</li>
<li>授权模型：RBAC（基于角色）、ABAC（基于属性）？权限粒度到什么级别（菜单/按钮/数据行）？</li>
<li>服务间认证：内部服务间调用是否需要认证？方案是什么（mTLS、服务账号、JWT 传递）？</li>
</ul>
<p><strong>数据安全</strong></p>
<ul>
<li>敏感数据识别：哪些字段属于 PII（个人可识别信息）？如密码、手机号、身份证号、银行卡号</li>
<li>存储加密：敏感字段是否加密存储？加密算法和密钥管理方案？</li>
<li>数据脱敏：日志、监控、非生产环境中的敏感数据是否脱敏？脱敏规则是什么？</li>
<li>数据合规：是否涉及 GDPR、个人信息保护法等合规要求？数据跨境传输策略？</li>
</ul>
<p><strong>传输安全</strong></p>
<ul>
<li>是否全链路 HTTPS？TLS 版本和加密套件？</li>
<li>内部服务通信是否加密（mTLS）？证书管理方案？</li>
</ul>
<p><strong>审计与防护</strong></p>
<ul>
<li>审计日志：哪些关键操作需要记录？日志包含哪些字段（who/when/what/where）？日志的保留期限？</li>
<li>防攻击：SQL 注入、XSS、CSRF、SSRF 的防护措施？是否使用 WAF？</li>
<li>限流防刷：敏感接口（登录、短信验证码、支付）是否有专门的限流策略？</li>
</ul>
<p><strong>交付物：</strong> 安全设计说明（含认证方案、数据分级与保护策略、审计要求）</p>
<hr>
<h3>9. 技术选型</h3>
<p>技术选型是影响最深远的决策之一——选错了，后续所有人都在还债。好的选型不追求「最先进」，而追求「最合适」。</p>
<p><strong>要回答的关键问题：</strong></p>
<ul>
<li>核心语言和框架的选择依据是什么？</li>
<li>中间件的选择（消息队列、缓存、数据库、搜索引擎等）基于什么考量？</li>
<li>是否做过技术预研或 PoC 验证？结论是什么？</li>
</ul>
<p><strong>选型的评估维度：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>要点</th>
</tr>
</thead>
<tbody><tr>
<td>功能匹配度</td>
<td>能否满足当前和可预见的未来需求？</td>
</tr>
<tr>
<td>生产成熟度</td>
<td>是否有大规模生产验证？社区活跃度和生态完善度？</td>
</tr>
<tr>
<td>团队匹配度</td>
<td>团队是否熟悉？学习曲线和上手成本？——技术再好，团队用不起来也白搭</td>
</tr>
<tr>
<td>运维成本</td>
<td>部署复杂度、监控支持、故障排查难度、升级迁移成本</td>
</tr>
<tr>
<td>许可证合规</td>
<td>开源许可证是否满足商业需求（注意 AGPL、SSPL 等传染性许可证）？</td>
</tr>
</tbody></table>
<p><strong>实践建议：</strong></p>
<ul>
<li>用 <a href="https://adr.github.io/">ADR（Architecture Decision Records）</a> 记录每个关键技术决策的上下文、选项、决策和后果，方便后续团队理解「当初为什么这么选」</li>
<li>如有多个候选方案，列对比表时不要超过 5 个维度，聚焦最关键的差异点</li>
<li>团队编码规范、Git 工作流、Code Review 流程等工程规范也可以写在这一节</li>
</ul>
<p><strong>交付物：</strong> 技术栈清单、关键选型对比表（或 ADR）、工程规范说明</p>
<hr>
<h3>10. 部署方案</h3>
<p>部署方案不只是「怎么把服务跑起来」，更要回答：怎么安全地发布变更、出了问题怎么快速回滚。</p>
<p><strong>环境规划</strong></p>
<ul>
<li>环境定义：开发（Dev）→ 测试（Test/QA）→ 预发（Staging）→ 生产（Production）</li>
<li>环境隔离：各环境之间如何隔离（独立集群 / Namespace 隔离 / 标签路由）？</li>
<li>配置管理：配置与代码是否分离？环境差异（副本数、资源配额、域名、Feature Flag）通过什么机制管理？推荐 ConfigMap + 密钥管理服务（如 Vault）</li>
</ul>
<p><strong>发布策略</strong></p>
<ul>
<li>滚动更新（Rolling Update）：适合大多数无状态服务，K8s 原生支持</li>
<li>蓝绿部署（Blue-Green）：适合需要快速切换和回滚的场景，需双倍资源</li>
<li>灰度发布（Canary）：适合风险较高的变更，按流量比例 / 用户标签 / 地域逐步放量</li>
<li>发布过程中的健康检查（Readiness Gate）和自动回滚（基于错误率 / 延迟的 Rollback 策略）</li>
</ul>
<p><strong>回滚方案</strong></p>
<ul>
<li>代码回滚流程：谁触发？如何执行？回滚后是否需要通知下游？</li>
<li>数据库回滚：Schema 变更是否向下兼容？是否准备了回滚脚本？建议采用 Expand-Contract 模式处理不兼容变更</li>
<li>配置回滚：配置变更是否有版本化和快速回滚能力？</li>
</ul>
<p><strong>资源规划</strong></p>
<ul>
<li>每个服务的 CPU / 内存 Request 和 Limit 如何设定？建议基于压测数据而非经验估算</li>
<li>是否需要 HPA（Horizontal Pod Autoscaler）？扩缩容的指标和阈值？</li>
<li>存储方案：云盘（持久化）、对象存储（文件/图片）、本地盘（临时缓存）分别用在哪里？</li>
</ul>
<p><strong>交付物：</strong> 部署架构图（物理视图）、环境配置清单、发布策略说明、回滚 Runbook</p>
<hr>
<h3>11. 架构演进规划</h3>
<p>大型项目不可能一步到位，分阶段交付是常态。架构演进规划的目标是让团队在每个阶段都知道做什么、为什么先做这个、后面还要做什么。</p>
<p><strong>MVP 定义</strong></p>
<ul>
<li>最小可用版本的范围是什么？用<strong>场景</strong>定义 MVP——用户能跑通哪些核心场景，就是 MVP</li>
<li>建议在 MVP 之前做一次<strong>架构原型验证</strong>（Walking Skeleton）：用最小的端到端场景跑通整个架构，验证核心技术方案的可行性。这一步能在早期暴露架构层面的问题，避免后期大面积返工</li>
</ul>
<p><strong>里程碑规划</strong></p>
<ul>
<li>按阶段拆分：每期交付什么功能？交付标准是什么？</li>
<li>阶段间的技术依赖：前一期没完成是否会阻塞后一期？有没有可以并行的工作？</li>
<li>建议用甘特图或里程碑表格可视化，让进度一目了然</li>
</ul>
<p><strong>技术债务管理</strong></p>
<ul>
<li>当前设计中有哪些已知的妥协和 TODO？为什么现在不做？</li>
<li>每笔技术债务的「利息」是什么——不偿还会导致什么后果？</li>
<li>计划在什么时间点偿还？建议将技术债务纳入迭代计划，而非无限期搁置</li>
</ul>
<p><strong>团队分工</strong></p>
<ul>
<li>各模块由谁负责？模块间的接口由谁定义、谁联调、谁验收？</li>
<li>团队能力与分工是否匹配？是否需要安排技术预研或培训？</li>
<li>再好的架构，如果不考虑团队的实际能力，也未必落得了地</li>
</ul>
<p><strong>交付物：</strong> MVP 范围定义、里程碑计划表、技术债务台账、团队分工矩阵</p>
<hr>
<h2>附：可复用的架构设计文档模板</h2>
<p>以下模板可直接复制使用，按实际情况填写或删除不需要的章节。</p>
<pre><code class="language-markdown"># [系统名称] 架构设计文档

&gt; 作者：xxx | 日期：yyyy-MM-dd | 版本：v1.0 | 状态：Draft / In Review / Approved

---

## 1. 需求介绍

### 1.1 现状与痛点
&lt;!-- 当前系统存在什么问题？可量化的业务影响？ --&gt;

### 1.2 目标与范围
&lt;!-- 要解决什么？不解决什么（明确边界）？ --&gt;

### 1.3 核心场景
| # | 场景名称 | 场景描述 | 优先级 |
|---|----------|----------|--------|
| 1 |          |          |        |

### 1.4 干系人
| 角色 | 人员 | 职责 |
|------|------|------|
|      |      |      |

### 1.5 约束条件
&lt;!-- 时间、预算、技术栈、合规等 --&gt;

### 1.6 验收标准
| 指标 | 目标值 | 度量方式 |
|------|--------|----------|
|      |        |          |

---

## 2. 架构总览

### 2.1 概念模型
&lt;!-- 核心领域概念及其关系（附图） --&gt;

### 2.2 逻辑架构图
&lt;!-- 系统分层、模块划分、依赖关系（附图） --&gt;

### 2.3 系统上下文
&lt;!-- 与周边系统的交互：协议、数据格式、调用方向（附图） --&gt;

---

## 3. 核心流程

### 3.1 场景一：[场景名称]

**Happy Path：**
&lt;!-- 时序图 --&gt;

**异常流程：**
&lt;!-- 超时 / 下游不可用 / 数据不一致 的处理方式 --&gt;

### 3.2 场景二：[场景名称]
&lt;!-- 同上 --&gt;

---

## 4. 详细设计

### 4.1 数据模型
&lt;!-- 核心表结构、索引策略、数据生命周期 --&gt;

### 4.2 接口契约
&lt;!-- API / SPI 定义：路径、方法、入参、出参、错误码 --&gt;

### 4.3 状态机
&lt;!-- 状态流转图（如有） --&gt;

### 4.4 关键算法
&lt;!-- 核心算法/策略的描述 --&gt;

---

## 5. 高可用设计

### 5.1 冗余与容灾
&lt;!-- 多实例 / 跨 AZ / 主从切换 / 降级方案 --&gt;

### 5.2 故障检测与自愈
&lt;!-- 健康检查 / 熔断 / 限流 / 隔离 --&gt;

### 5.3 数据一致性
&lt;!-- CP vs AP 选择 / 跨服务一致性方案 / 补偿机制 --&gt;

### 5.4 可观测性
| 类型 | 指标/工具 | 告警阈值 | 响应 SLA |
|------|-----------|----------|----------|
| Metrics |        |          |          |
| Logging |        |          |          |
| Tracing |        |          |          |

---

## 6. 高性能设计

### 6.1 性能目标
| 指标 | 目标值 |
|------|--------|
| QPS  |        |
| P99  |        |
| 数据量级 |    |

### 6.2 瓶颈分析
&lt;!-- 关键路径上的瓶颈点及根因分析 --&gt;

### 6.3 优化方案
&lt;!-- 按接入层 / 应用层 / 数据层 / 基础设施分层说明 --&gt;

### 6.4 压测计划
&lt;!-- 工具、场景、环境差异、通过标准 --&gt;

---

## 7. 可扩展性设计

### 7.1 业务扩展性
&lt;!-- 扩展点清单 / SPI 机制 / 领域划分 --&gt;

### 7.2 容量扩展性
&lt;!-- 无状态服务扩容 / 有状态组件扩展 / 单点瓶颈规避 --&gt;

---

## 8. 安全设计

- **认证与授权**：
- **数据安全**：
- **传输安全**：
- **审计日志**：
- **防攻击**：

&lt;!-- 如本期不涉及，请注明「经评估，本期暂不涉及」并说明原因 --&gt;

---

## 9. 技术选型

| 类别 | 选型 | 备选方案 | 选择依据 |
|------|------|----------|----------|
|      |      |          |          |

### 关键决策记录（ADR）
&lt;!-- 对于有争议的选型，记录上下文、选项、决策和后果 --&gt;

---

## 10. 部署方案

### 10.1 环境规划
| 环境 | 集群/NS | 副本数 | 资源配额 | 域名 |
|------|---------|--------|----------|------|
| Dev  |         |        |          |      |
| Test |         |        |          |      |
| Staging |      |        |          |      |
| Prod |         |        |          |      |

### 10.2 发布策略
&lt;!-- 滚动更新 / 蓝绿 / 灰度，以及健康检查和自动回滚机制 --&gt;

### 10.3 回滚方案
&lt;!-- 代码回滚流程 / 数据库兼容性 / 配置回滚 --&gt;

---

## 11. 架构演进规划

### 11.1 MVP 定义
&lt;!-- 第一个版本的最小可用范围（用场景定义） --&gt;

### 11.2 里程碑
| 阶段 | 时间 | 交付内容 | 验收标准 | 依赖 |
|------|------|----------|----------|------|
|      |      |          |          |      |

### 11.3 技术债务
| 债务 | 产生原因 | 影响（利息） | 计划偿还时间 |
|------|----------|--------------|--------------|
|      |          |              |              |

### 11.4 团队分工
| 模块 | 负责人/团队 | 上下游依赖 |
|------|-------------|------------|
|      |             |            |

---

## 附录

### 术语表
| 术语 | 定义 |
|------|------|
|      |      |

### 参考文档
&lt;!-- 相关 PRD、技术预研报告、竞品分析等 --&gt;

### 变更记录
| 版本 | 日期 | 变更人 | 变更内容 |
|------|------|--------|----------|
| v1.0 |      |        | 初稿     |
</code></pre>
17:T72c6,<h1>SET化架构：从单元化原理到大规模落地实践</h1>
<blockquote>
<p>当系统规模突破单机房、单集群的承载极限，当一次机房故障就可能导致全站不可用时，SET 化架构就成为了必然选择。它不是一种特定的技术方案，而是一种<strong>将系统划分为独立自治单元，实现水平扩展和故障隔离</strong>的架构思想。</p>
</blockquote>
<p>互联网业务的高速增长给架构带来了两个根本性挑战：<strong>容量的天花板</strong>和<strong>可用性的脆弱性</strong>。传统的垂直扩展（Scale-up）终有极限，而简单的水平扩展（Scale-out）在数据一致性、服务依赖、运维复杂度等方面又面临诸多困难。</p>
<p>SET 化架构（也称为单元化架构、Cell-based Architecture）正是为了系统性地解决这些问题而诞生的。本文将从原理到实践，全面解析 SET 化架构的设计与落地。</p>
<h2>什么是 SET 化架构？</h2>
<h3>概念定义</h3>
<p>SET（Scalable Elastic Topology，可扩展弹性拓扑）化架构是一种<strong>将系统按照某个维度（通常是用户 ID）划分为多个独立、自包含的部署单元</strong>的架构模式。每个 SET 都是一个&quot;小型完整系统&quot;，拥有独立的应用服务、缓存、数据库等全套基础设施，能够独立处理分配给它的流量。</p>
<pre><code>SET 化的核心思想：

传统架构：         所有用户 → 一套系统
                    （纵向扩展，存在单点瓶颈）

SET 化架构：       用户按规则分组 → 每组对应一个 SET
                    SET-1: 用户 0~999W    → 独立的一套完整系统
                    SET-2: 用户 1000W~1999W → 独立的一套完整系统
                    SET-3: 用户 2000W~2999W → 独立的一套完整系统
                    （水平扩展，理论上无上限）
</code></pre>
<h3>SET 的核心特征</h3>
<table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>自包含</strong></td>
<td>每个 SET 拥有完整的服务栈（应用、缓存、DB），能独立处理请求</td>
</tr>
<tr>
<td><strong>对等部署</strong></td>
<td>所有 SET 的架构相同，只是处理的数据分片不同</td>
</tr>
<tr>
<td><strong>故障隔离</strong></td>
<td>单个 SET 的故障不会影响其他 SET</td>
</tr>
<tr>
<td><strong>水平扩展</strong></td>
<td>通过增加 SET 数量实现容量扩展</td>
</tr>
<tr>
<td><strong>流量可调度</strong></td>
<td>通过路由规则灵活调度流量在 SET 间的分配</td>
</tr>
</tbody></table>
<h3>SET 化与传统分布式的区别</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统分布式架构</th>
<th>SET 化架构</th>
</tr>
</thead>
<tbody><tr>
<td>扩展方式</td>
<td>各层独立扩展（加应用节点、加 DB 从库）</td>
<td>整体作为一个单元扩展</td>
</tr>
<tr>
<td>故障影响</td>
<td>某一层故障影响全局</td>
<td>故障隔离在单个 SET 内</td>
</tr>
<tr>
<td>数据分片</td>
<td>数据库层分片，应用层无感知</td>
<td>从入口到数据库全链路分片</td>
</tr>
<tr>
<td>部署单元</td>
<td>按服务部署</td>
<td>按 SET（单元）部署</td>
</tr>
<tr>
<td>容量规划</td>
<td>各组件独立评估</td>
<td>按 SET 整体评估</td>
</tr>
</tbody></table>
<h2>SET 化架构演进历程</h2>
<p>SET 化不是一步到位的设计，而是随着业务规模增长逐步演化的结果。</p>
<h3>阶段一：单体架构</h3>
<pre><code>用户 → 应用服务器 → 数据库
</code></pre>
<p>所有功能在一个应用中，单库单表。适用于初创期，简单高效。</p>
<p><strong>瓶颈</strong>：单机容量有限，数据库成为瓶颈。</p>
<h3>阶段二：读写分离 + 缓存</h3>
<pre><code>用户 → 应用集群 → 缓存 → 主库（写）/ 从库（读）
</code></pre>
<p>通过读写分离缓解数据库压力，引入缓存降低 DB 负载。</p>
<p><strong>瓶颈</strong>：写入瓶颈无法解决，主库仍是单点。</p>
<h3>阶段三：分库分表</h3>
<pre><code>用户 → 应用集群 → 数据库中间件 → DB 分片 1 / DB 分片 2 / DB 分片 N
</code></pre>
<p>数据库水平拆分，解决写入瓶颈。但分片逻辑散落在各处，跨分片查询复杂。</p>
<p><strong>瓶颈</strong>：应用层无分片感知，缓存与 DB 分片不对齐，运维复杂。</p>
<h3>阶段四：服务化（微服务）</h3>
<pre><code>用户 → API 网关 → 微服务 A / 微服务 B / ... → 各自的 DB
</code></pre>
<p>按业务域拆分为独立服务，各服务独立部署和扩展。</p>
<p><strong>瓶颈</strong>：服务间调用复杂，全链路缺乏统一的分片和隔离机制。</p>
<h3>阶段五：SET 化（单元化）</h3>
<pre><code>用户 → 统一路由层 → SET-1（完整服务栈）/ SET-2 / SET-N
                       ↕ 数据同步
</code></pre>
<p>全链路按统一维度分片，每个 SET 自包含完整服务栈，实现真正的水平扩展和故障隔离。</p>
<p><strong>这就是 SET 化架构的终态。</strong> 下面详细介绍每个核心组件的设计。</p>
<h2>核心设计一：流量路由</h2>
<p>流量路由是 SET 化架构的&quot;大脑&quot;，它决定了每个请求应该被路由到哪个 SET。</p>
<h3>路由键的选择</h3>
<p>路由键（Sharding Key）是 SET 化的核心决策之一，选择不当会导致严重的跨 SET 调用问题。</p>
<table>
<thead>
<tr>
<th>路由键</th>
<th>优点</th>
<th>缺点</th>
<th>适用业务</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用户 ID</strong></td>
<td>用户维度天然隔离，覆盖面广</td>
<td>用户间交互需跨 SET</td>
<td>电商、社交、O2O</td>
</tr>
<tr>
<td><strong>商户 ID</strong></td>
<td>商户维度隔离</td>
<td>用户下单需跨 SET</td>
<td>B 端平台</td>
</tr>
<tr>
<td><strong>地理区域</strong></td>
<td>天然的流量隔离</td>
<td>跨区域业务需特殊处理</td>
<td>本地生活、物流</td>
</tr>
<tr>
<td><strong>订单 ID</strong></td>
<td>订单维度隔离</td>
<td>需要提前生成带路由信息的 ID</td>
<td>交易系统</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>实践经验</strong>：绝大多数 C 端业务选择<strong>用户 ID</strong> 作为路由键，因为用户是最核心的业务实体，以用户为维度分片可以最大程度地减少跨 SET 调用。</p>
</blockquote>
<h3>路由架构设计</h3>
<p>SET 化的路由通常分为三层：</p>
<p><strong>第一层：接入路由（DNS / LB 层）</strong></p>
<p>在最外层通过 DNS 或负载均衡器将流量分配到对应的 SET。</p>
<pre><code>用户请求 → DNS 解析 → 全局负载均衡（GSLB）
                            ↓
                    根据用户 ID 哈希路由
                    ↓           ↓           ↓
                 SET-1 LB    SET-2 LB    SET-3 LB
</code></pre>
<p><strong>第二层：网关路由（API Gateway 层）</strong></p>
<p>API 网关根据请求中的路由键（如 Header、Cookie、Token 中的用户 ID）将请求路由到正确的 SET。</p>
<pre><code>请求 → API Gateway → 提取路由键 → 查询路由表 → 转发到目标 SET
</code></pre>
<p><strong>第三层：服务路由（RPC 层）</strong></p>
<p>服务间调用时，RPC 框架自动根据上下文中的路由键将请求路由到同 SET 的服务实例。</p>
<pre><code>Service A (SET-1) → RPC Framework → 自动路由到 → Service B (SET-1)
                    （通过上下文传递 SET 标识）
</code></pre>
<h3>路由表设计</h3>
<p>路由表是映射用户到 SET 的核心数据结构：</p>
<pre><code>路由表结构：
┌──────────────┬──────────┬──────────┐
│  分片范围      │  SET ID  │  状态     │
├──────────────┼──────────┼──────────┤
│  0 ~ 999      │  SET-1   │  Active  │
│  1000 ~ 1999  │  SET-2   │  Active  │
│  2000 ~ 2999  │  SET-3   │  Active  │
│  3000 ~ 3999  │  SET-1   │  Active  │  ← 同一个 SET 可承载多个分片
└──────────────┴──────────┴──────────┘
</code></pre>
<p>路由策略的关键设计要点：</p>
<ol>
<li><strong>虚拟分片</strong>：不直接将用户映射到物理 SET，而是先映射到虚拟分片（如 1024 个），再将虚拟分片映射到物理 SET。这样扩容时只需调整虚拟分片的映射关系</li>
<li><strong>路由缓存</strong>：路由表在网关和服务端本地缓存，避免每次请求都查询路由服务</li>
<li><strong>路由一致性</strong>：路由表变更时需要保证全链路一致性，避免请求被路由到错误的 SET</li>
</ol>
<h2>核心设计二：数据分片与同步</h2>
<p>数据层是 SET 化最复杂的部分，需要解决数据分片、跨 SET 数据访问、数据同步等问题。</p>
<h3>数据分类</h3>
<p>SET 化架构中的数据按照与路由键的关系分为三类：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>存储方式</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SET 内数据</strong></td>
<td>与路由键强绑定的数据</td>
<td>仅存储在对应 SET</td>
<td>用户订单、用户资产、购物车</td>
</tr>
<tr>
<td><strong>全局数据</strong></td>
<td>所有 SET 共享的数据</td>
<td>全局存储 + 各 SET 只读副本</td>
<td>商品信息、配置数据、类目</td>
</tr>
<tr>
<td><strong>跨 SET 数据</strong></td>
<td>涉及多个路由键的数据</td>
<td>全局存储或冗余存储</td>
<td>商户维度的聚合数据、排行榜</td>
</tr>
</tbody></table>
<h3>SET 内数据</h3>
<p>SET 内数据遵循&quot;谁的数据谁存储&quot;原则，每个 SET 只处理和存储自己分片内的数据：</p>
<pre><code>SET-1 数据库：只存储 UserID 0~999 的数据
SET-2 数据库：只存储 UserID 1000~1999 的数据

用户 A (ID=500) 下单 → 请求路由到 SET-1 → 订单写入 SET-1 DB
用户 B (ID=1500) 下单 → 请求路由到 SET-2 → 订单写入 SET-2 DB
</code></pre>
<h3>全局数据</h3>
<p>全局数据（如商品信息）需要所有 SET 都能访问，通常采用以下方案：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>全局服务</strong></td>
<td>独立部署的全局服务 + 数据库</td>
<td>数据一致性好</td>
<td>全局服务成为依赖瓶颈</td>
</tr>
<tr>
<td><strong>数据广播</strong></td>
<td>写入全局库后异步同步到各 SET</td>
<td>本地读取性能好</td>
<td>数据有延迟，存储冗余</td>
</tr>
<tr>
<td><strong>缓存分发</strong></td>
<td>全局数据写入后推送到各 SET 缓存</td>
<td>读取极快</td>
<td>缓存一致性需要保障</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>实践建议</strong>：高频读取的全局数据（如商品详情）采用&quot;数据广播 + 本地缓存&quot;方案；低频但要求强一致的全局数据（如配置变更）采用&quot;全局服务&quot;方案。</p>
</blockquote>
<h3>数据同步机制</h3>
<p>SET 间的数据同步是保证业务连续性的关键，特别是在故障切换场景下：</p>
<pre><code>                     主 SET                          备 SET
                 ┌──────────┐                    ┌──────────┐
                 │  应用层    │                    │  应用层    │
                 │  缓存层    │                    │  缓存层    │
                 │  数据库    │ ── Binlog 同步 ──→ │  数据库    │
                 └──────────┘                    └──────────┘

        同步方式：MySQL Binlog → Canal/DTS → 目标 SET 数据库
        同步延迟：通常 &lt; 1s，需要监控告警
</code></pre>
<p>数据同步的关键指标：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>目标值</th>
<th>监控方式</th>
</tr>
</thead>
<tbody><tr>
<td>同步延迟</td>
<td>&lt; 1 秒</td>
<td>Binlog 位点差监控</td>
</tr>
<tr>
<td>数据一致性</td>
<td>99.99%</td>
<td>定期全量对账</td>
</tr>
<tr>
<td>同步可用性</td>
<td>99.99%</td>
<td>同步链路健康检查</td>
</tr>
</tbody></table>
<h2>核心设计三：全局服务</h2>
<p>有些服务天然不能被 SET 化，它们需要作为全局服务为所有 SET 提供能力。</p>
<h3>全局 ID 生成</h3>
<p>在 SET 化架构中，ID 生成必须保证全局唯一且带有路由信息：</p>
<pre><code>ID 结构设计：
┌────────────┬──────────┬───────────┬──────────┐
│  时间戳      │  SET ID  │  机器 ID   │  序列号   │
│  41 bits    │  5 bits  │  5 bits   │  12 bits │
└────────────┴──────────┴───────────┴──────────┘

总长度：63 bits（Long 类型）
</code></pre>
<table>
<thead>
<tr>
<th>生成方案</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>全局 ID 服务</strong></td>
<td>全局唯一性保证最强</td>
<td>依赖外部服务，存在可用性风险</td>
<td>核心业务（订单、支付）</td>
</tr>
<tr>
<td><strong>本地 Snowflake</strong></td>
<td>无外部依赖，性能最高</td>
<td>需要解决时钟回拨问题</td>
<td>非核心业务</td>
</tr>
<tr>
<td><strong>号段模式</strong></td>
<td>批量获取减少调用</td>
<td>号段用尽时有短暂延迟</td>
<td>通用场景</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>兜底策略</strong>：本地 ID 生成作为兜底方案，当全局 ID 服务不可用时自动降级为本地生成，确保业务不中断。</p>
</blockquote>
<h3>全局配置中心</h3>
<p>配置中心负责管理所有 SET 的路由规则、业务配置和开关：</p>
<pre><code>配置中心架构：
                  ┌─────────────────┐
                  │   配置中心集群     │
                  │  (ZK/Nacos/etcd) │
                  └────────┬────────┘
                     ↙     ↓     ↘
            SET-1 Agent  SET-2 Agent  SET-3 Agent
               ↓            ↓            ↓
            本地缓存      本地缓存      本地缓存

推送机制：配置变更 → 配置中心 → 推送给各 SET Agent → 更新本地缓存
</code></pre>
<h3>全局调度中心</h3>
<p>负责 SET 的健康监控、故障检测和流量调度：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>健康检查</td>
<td>定期探测各 SET 的健康状态</td>
</tr>
<tr>
<td>故障检测</td>
<td>发现 SET 异常时触发告警</td>
</tr>
<tr>
<td>流量切换</td>
<td>故障 SET 的流量自动切换到备用 SET</td>
</tr>
<tr>
<td>容量管理</td>
<td>监控各 SET 的容量使用率</td>
</tr>
<tr>
<td>扩缩容编排</td>
<td>新增或下线 SET 时的流量编排</td>
</tr>
</tbody></table>
<h2>核心设计四：故障隔离与切换</h2>
<p>故障隔离是 SET 化架构最核心的价值之一。</p>
<h3>故障域划分</h3>
<p>SET 化架构将故障影响范围从&quot;全站&quot;缩小到&quot;单个 SET&quot;：</p>
<pre><code>传统架构故障：
  DB 主库宕机 → 全站不可用 → 影响 100% 用户

SET 化架构故障：
  SET-2 DB 宕机 → 仅 SET-2 不可用 → 影响约 33% 用户（假设 3 个 SET）
                    ↓ 自动切换
                 SET-2 流量切换到备用 → 影响时间 &lt; 分钟级
</code></pre>
<h3>故障切换策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>切换速度</th>
<th>数据风险</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主备切换</strong></td>
<td>秒级~分钟级</td>
<td>可能丢失未同步数据</td>
<td>SET 内部 DB 主备切换</td>
</tr>
<tr>
<td><strong>SET 间切换</strong></td>
<td>分钟级</td>
<td>依赖数据同步延迟</td>
<td>整个 SET 故障</td>
</tr>
<tr>
<td><strong>跨机房切换</strong></td>
<td>分钟级~小时级</td>
<td>需要全量数据同步</td>
<td>机房级故障</td>
</tr>
</tbody></table>
<h3>故障切换流程</h3>
<pre><code>正常状态：
  用户流量 → 路由层 → SET-2（主）

故障检测：
  健康检查失败 → 确认 SET-2 不可用 → 触发切换流程

切换执行：
  1. 停止 SET-2 的流量接入（路由层摘除）
  2. 等待 SET-2 → SET-2-备 的数据同步完成（或接受部分数据丢失）
  3. 更新路由表：SET-2 的分片 → SET-2-备
  4. 开放 SET-2-备 的流量接入
  5. 验证切换后的业务正确性

恢复状态：
  用户流量 → 路由层 → SET-2-备（新主）
</code></pre>
<h3>容灾等级</h3>
<table>
<thead>
<tr>
<th>等级</th>
<th>容灾范围</th>
<th>实现方式</th>
<th>RTO</th>
</tr>
</thead>
<tbody><tr>
<td><strong>L1</strong></td>
<td>单机故障</td>
<td>应用集群 + DB 主备</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>L2</strong></td>
<td>机架故障</td>
<td>跨机架部署</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>L3</strong></td>
<td>机房故障</td>
<td>同城双机房 SET 互备</td>
<td>分钟级</td>
</tr>
<tr>
<td><strong>L4</strong></td>
<td>城市故障</td>
<td>异地 SET 互备</td>
<td>分钟级~小时级</td>
</tr>
</tbody></table>
<h2>核心设计五：SET 扩缩容</h2>
<p>SET 化架构的一个重要优势是可以通过增减 SET 数量来调整系统容量。</p>
<h3>扩容流程</h3>
<pre><code>扩容场景：当前 3 个 SET 容量不足，需要扩容到 4 个 SET

Step 1: 部署新 SET（SET-4）
  - 部署完整的应用服务、缓存、数据库
  - 从现有 SET 同步全局数据

Step 2: 数据迁移
  - 将 SET-1 的部分虚拟分片的数据迁移到 SET-4
  - 采用双写方案保证迁移过程不中断服务

Step 3: 路由切换
  - 更新路由表：迁移的虚拟分片指向 SET-4
  - 灰度切换流量，逐步验证

Step 4: 清理
  - 验证完成后，清理 SET-1 中已迁移的数据
  - 回收空闲资源
</code></pre>
<h3>虚拟分片的价值</h3>
<p>虚拟分片是实现平滑扩缩容的关键：</p>
<pre><code>初始状态（3 个 SET，1024 个虚拟分片）：
  SET-1: 虚拟分片 0~341
  SET-2: 虚拟分片 342~682
  SET-3: 虚拟分片 683~1023

扩容到 4 个 SET（只需调整虚拟分片映射）：
  SET-1: 虚拟分片 0~255
  SET-2: 虚拟分片 256~511
  SET-3: 虚拟分片 512~767
  SET-4: 虚拟分片 768~1023

优势：用户 → 虚拟分片的映射不变，只调整虚拟分片 → 物理 SET 的映射
</code></pre>
<h2>实践案例：电商交易系统 SET 化</h2>
<p>以一个典型的电商交易系统为例，展示 SET 化的具体落地方案。</p>
<h3>业务分析</h3>
<table>
<thead>
<tr>
<th>服务</th>
<th>路由键关系</th>
<th>SET 化策略</th>
</tr>
</thead>
<tbody><tr>
<td>用户服务</td>
<td>用户 ID（强绑定）</td>
<td>SET 内部署</td>
</tr>
<tr>
<td>订单服务</td>
<td>用户 ID（强绑定）</td>
<td>SET 内部署</td>
</tr>
<tr>
<td>支付服务</td>
<td>用户 ID（强绑定）</td>
<td>SET 内部署</td>
</tr>
<tr>
<td>商品服务</td>
<td>无关（全局数据）</td>
<td>全局部署 + 数据广播</td>
</tr>
<tr>
<td>库存服务</td>
<td>商品维度（跨 SET）</td>
<td>全局部署</td>
</tr>
<tr>
<td>搜索服务</td>
<td>无关（全局数据）</td>
<td>全局部署</td>
</tr>
<tr>
<td>营销服务</td>
<td>活动维度（跨 SET）</td>
<td>全局部署</td>
</tr>
</tbody></table>
<h3>整体架构</h3>
<pre><code>                        ┌──────────────────────────────────┐
                        │          统一接入层（GSLB）         │
                        └───────────────┬──────────────────┘
                                        ↓
                        ┌──────────────────────────────────┐
                        │         API Gateway（路由层）       │
                        │    提取 UserID → 查询路由表 → 转发   │
                        └──┬──────────────┬────────────┬───┘
                           ↓              ↓            ↓
                    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
                    │   SET-1     │ │   SET-2     │ │   SET-3     │
                    │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────┐ │
                    │ │用户服务  │ │ │ │用户服务  │ │ │ │用户服务  │ │
                    │ │订单服务  │ │ │ │订单服务  │ │ │ │订单服务  │ │
                    │ │支付服务  │ │ │ │支付服务  │ │ │ │支付服务  │ │
                    │ │Redis    │ │ │ │Redis    │ │ │ │Redis    │ │
                    │ │MySQL    │ │ │ │MySQL    │ │ │ │MySQL    │ │
                    │ └─────────┘ │ │ └─────────┘ │ │ └─────────┘ │
                    └─────────────┘ └─────────────┘ └─────────────┘
                           ↕              ↕            ↕
                    ┌──────────────────────────────────────────┐
                    │              全局服务层                     │
                    │  商品服务 │ 库存服务 │ 搜索服务 │ 营销服务    │
                    │         全局 ID 服务 │ 配置中心              │
                    └──────────────────────────────────────────┘
</code></pre>
<h3>下单流程的 SET 化处理</h3>
<pre><code>用户 A（ID=500）下单购买商品 X：

1. 请求到达 API Gateway
2. Gateway 提取 UserID=500，查路由表 → SET-1
3. 请求转发到 SET-1 的订单服务
4. 订单服务调用全局商品服务查询商品信息
5. 订单服务调用全局库存服务扣减库存
6. 订单服务在 SET-1 本地 DB 创建订单
7. 订单服务调用 SET-1 本地的支付服务发起支付
8. 支付完成后，SET-1 的订单服务更新本地订单状态
</code></pre>
<p>关键点：</p>
<ul>
<li>用户维度的数据操作（创建订单、支付）在 SET 内完成，无跨 SET 调用</li>
<li>商品、库存等全局数据通过全局服务访问</li>
<li>RPC 框架自动将 SET 标识通过上下文传递，保证 SET 内调用的正确性</li>
</ul>
<h2>SET 化实施路线</h2>
<p>SET 化是一个渐进式的过程，不应该一步到位。</p>
<h3>阶段规划</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>关键动作</th>
<th>周期</th>
</tr>
</thead>
<tbody><tr>
<td><strong>P0：基础设施准备</strong></td>
<td>具备 SET 化的基础能力</td>
<td>统一 RPC 框架、引入路由组件、改造 ID 生成</td>
<td>1~2 月</td>
</tr>
<tr>
<td><strong>P1：核心链路 SET 化</strong></td>
<td>交易核心链路实现 SET 化</td>
<td>订单、支付、用户服务 SET 化部署</td>
<td>2~3 月</td>
</tr>
<tr>
<td><strong>P2：全链路 SET 化</strong></td>
<td>所有服务完成 SET 化改造</td>
<td>非核心服务 SET 化、全局服务治理</td>
<td>3~6 月</td>
</tr>
<tr>
<td><strong>P3：异地 SET</strong></td>
<td>实现异地多活能力</td>
<td>跨机房 SET 部署、数据同步、故障切换</td>
<td>3~6 月</td>
</tr>
</tbody></table>
<h3>改造清单</h3>
<p><strong>应用层改造</strong>：</p>
<ul>
<li>所有服务支持从请求上下文中提取和传递路由键</li>
<li>RPC 框架支持基于路由键的服务路由</li>
<li>消息队列的生产和消费支持 SET 路由</li>
<li>定时任务支持按 SET 分片执行</li>
</ul>
<p><strong>数据层改造</strong>：</p>
<ul>
<li>数据库按 SET 进行物理隔离</li>
<li>缓存按 SET 进行 namespace 隔离</li>
<li>全局数据的同步机制建设</li>
<li>数据对账和修复工具</li>
</ul>
<p><strong>基础设施改造</strong>：</p>
<ul>
<li>统一路由服务建设</li>
<li>全局 ID 生成服务建设</li>
<li>监控体系支持 SET 维度</li>
<li>发布系统支持按 SET 灰度</li>
</ul>
<h2>SET 化与异地多活的关系</h2>
<p>SET 化架构是异地多活的基础。两者的关系可以这样理解：</p>
<pre><code>SET 化 = 单元化部署 + 流量路由 + 数据分片
异地多活 = SET 化 + 跨地域部署 + 数据同步 + 故障切换
</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>同城 SET 化</th>
<th>异地多活 SET 化</th>
</tr>
</thead>
<tbody><tr>
<td>部署范围</td>
<td>同城多机房</td>
<td>跨城市多机房</td>
</tr>
<tr>
<td>网络延迟</td>
<td>&lt; 1ms</td>
<td>10~50ms</td>
</tr>
<tr>
<td>数据同步</td>
<td>同步/半同步复制</td>
<td>异步复制（最终一致性）</td>
</tr>
<tr>
<td>故障切换</td>
<td>自动秒级切换</td>
<td>手动/半自动分钟级切换</td>
</tr>
<tr>
<td>核心挑战</td>
<td>路由准确性</td>
<td>数据一致性 + 切换决策</td>
</tr>
</tbody></table>
<blockquote>
<p>SET 化架构天然具备&quot;每个 SET 独立自治&quot;的特性，这为异地多活提供了完美的基础。只需将不同的 SET 部署到不同的地域，配合数据同步和流量调度，就能实现异地多活。</p>
</blockquote>
<h2>常见问题与解决方案</h2>
<h3>跨 SET 调用问题</h3>
<p><strong>问题</strong>：部分业务场景不可避免需要跨 SET 访问数据。</p>
<p><strong>解决方案</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>用户查看商户信息</td>
<td>商户数据作为全局数据广播</td>
</tr>
<tr>
<td>商户查看所有订单</td>
<td>聚合服务从各 SET 并行查询后合并</td>
</tr>
<tr>
<td>全站排行榜</td>
<td>各 SET 本地计算后汇总到全局服务</td>
</tr>
<tr>
<td>跨用户转账</td>
<td>通过消息队列异步通知目标 SET</td>
</tr>
</tbody></table>
<h3>数据迁移问题</h3>
<p><strong>问题</strong>：扩容时需要在 SET 间迁移数据。</p>
<p><strong>解决方案</strong>：双写方案</p>
<pre><code>Phase 1: 新 SET 开始从旧 SET 同步增量数据（Binlog 订阅）
Phase 2: 同步追上后，开启双写模式（新请求同时写入新旧 SET）
Phase 3: 路由切换，新请求全部路由到新 SET
Phase 4: 验证无误后，停止双写，清理旧数据
</code></pre>
<h3>全局服务瓶颈</h3>
<p><strong>问题</strong>：全局服务成为所有 SET 的共同依赖，可能成为瓶颈。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>数据本地化</strong>：全局数据尽可能广播到各 SET 本地，减少全局服务调用</li>
<li><strong>缓存优先</strong>：全局数据走多级缓存，降低对全局 DB 的访问</li>
<li><strong>异步化</strong>：非实时性要求的全局操作通过消息队列异步处理</li>
<li><strong>弹性扩展</strong>：全局服务本身也需要集群化部署和弹性扩展</li>
</ol>
<h2>总结</h2>
<p>SET 化架构是应对互联网业务规模化增长的系统性解决方案。它的核心思想并不复杂——<strong>把一个大系统拆分成多个独立自治的小系统</strong>——但真正的挑战在于落地过程中的每一个细节。</p>
<p>回顾 SET 化的关键设计决策：</p>
<ol>
<li><strong>路由键选择决定了架构的天花板</strong>。选错路由键会导致大量跨 SET 调用，抵消 SET 化的优势</li>
<li><strong>数据分类是 SET 化的基础</strong>。明确哪些是 SET 内数据、哪些是全局数据，才能设计合理的数据架构</li>
<li><strong>虚拟分片是弹性扩展的关键</strong>。不要将用户直接映射到物理 SET，虚拟分片层带来的灵活性至关重要</li>
<li><strong>全局服务的治理不能忽视</strong>。全局服务是所有 SET 的共同依赖，必须做到高可用和高性能</li>
<li><strong>渐进式实施是务实的选择</strong>。从核心链路开始，逐步扩展，而不是试图一步到位</li>
</ol>
<blockquote>
<p><strong>SET 化不是目的，而是手段。</strong> 它服务于两个根本目标：让系统能够水平扩展以承载业务增长，让故障影响可控以保障用户体验。在实施 SET 化之前，先问自己：当前的业务规模真的需要 SET 化吗？</p>
</blockquote>
18:T3749,<p>记得很久之前，去面试过<strong>字节跳动</strong>。被三面的面试官问了一道场景设计题目：<strong>如何设计一个高并发系统</strong>。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。</p>
<p><img src="/images/blog/engineering/system-image_3_1.png" alt="image_3_1.png"></p>
<h3>如何理解高并发系统 <a href="#item-0-1" id="item-0-1"></a></h3>
<p>所谓设计<strong>高并发</strong>系统，就是设计一个系统，保证它<strong>整体可用</strong>的同时，能够<strong>处理很高的并发用户请求</strong>，能够承受<strong>很大的流量冲击</strong>。</p>
<p>我们要设计高并发的系统，那就需要处理好一些常见的系统瓶颈问题，如<strong>内存不足、磁盘空间不足，连接数不够，网络宽带不够</strong>等等，以应对突发的流量洪峰。</p>
<h3>1. 分而治之，横向扩展 <a href="#item-0-2" id="item-0-2"></a></h3>
<p>如果你<strong>只部署一个应用，只部署一台服务器</strong>，那抗住的流量请求是非常有限的。并且，单体的应用，有单点的风险，如果它挂了，那服务就不可用了。</p>
<p>因此，设计一个高并发系统，我们可以<strong>分而治之，横向扩展</strong>。也就是说，采用分布式部署的方式，部署多台服务器，把流量分流开，让每个服务器都承担一部分的并发和流量，提升<strong>整体系统的并发能力</strong>。</p>
<h3>2. 微服务拆分（系统拆分） <a href="#item-0-3" id="item-0-3"></a></h3>
<p>要提高系统的吞吐，提高系统的处理并发请求的能力。除了采用<strong>分布式部署的方式</strong>外，还可以做<strong>微服务拆分</strong>，这样就可以达到分摊请求流量的目的，提高了并发能力。</p>
<p>所谓的<strong>微服务拆分</strong>，其实就是把一个单体的应用，按功能单一性，拆分为多个服务模块。<strong>比如一个电商系统，拆分为用户系统、订单系统、商品系统等等</strong>。</p>
<p><img src="/images/blog/engineering/system-image_3_2.png" alt="image_3_2.png"></p>
<h3>3. 分库分表 <a href="#item-0-4" id="item-0-4"></a></h3>
<p>当业务量暴增的话，MySQL单机<strong>磁盘容量会撑爆</strong>。并且，我们知道数据库连接数是有限的。<strong>在高并发的场景下</strong>，大量请求访问数据库，<code>MySQL</code>单机是扛不住的！高并发场景下，会出现<code>too many connections</code>报错。</p>
<p>所以高并发的系统，<strong>需要考虑拆分为多个数据库，来抗住高并发的毒打</strong>。而假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做<strong>分表</strong>了。一般千万级别数据量，就需要<strong>分表</strong>，每个表的数据量少一点，提升SQL查询性能。</p>
<p>当面试官问要求你设计一个高并发系统的时候，一般都要说到<strong>分库分表</strong>这个点。</p>
<h3>4. 池化技术 <a href="#item-0-5" id="item-0-5"></a></h3>
<p>在高并发的场景下，<strong>数据库连接数</strong>可能成为瓶颈，因为连接数是有限的。</p>
<p>我们的请求调用数据库时，都会先获取数据库的连接，然后依靠这个连接来查询数据，搞完收工，最后关闭连接，释放资源。如果我们不用数据库连接池的话，每次执行<code>SQL</code>，都要创建连接和销毁连接，这就会导致每个查询请求都变得更慢了，相应的，系统处理用户请求的能力就降低了。</p>
<p>因此，需要使用池化技术，即<strong>数据库连接池、HTTP 连接池、Redis 连接池</strong>等等。使用数据库连接池，可以避免每次查询都新建连接，减少不必要的资源开销，通过复用连接池，<strong>提高系统处理高并发请求的能力</strong>。</p>
<p>同理，我们使用线程池，也能<strong>让任务并行处理，更高效地完成任务</strong>。</p>
<h3>5. 主从分离 <a href="#item-0-6" id="item-0-6"></a></h3>
<p>通常来说，一台单机的MySQL服务器，可以支持<code>500</code>左右的<code>TPS</code>和<code>10000</code>左右的<code>QPS</code>，即单机支撑的<strong>请求访问是有限</strong>的。因此你做了分布式部署，部署了多台机器，部署了主数据库、从数据库。</p>
<p>但是，如果双十一搞活动，流量肯定会猛增的。如果所有的查询请求，都走主库的话，主库肯定扛不住，因为查询请求量是非常非常大的。因此一般都要求做<strong>主从分离</strong>，然后实时性要求不高的读请求，都去读从库，<strong>写的请求或者实时性要求高的请求，才走主库</strong>。这样就很好保护了主库，也提高了系统的吞吐。</p>
<p>当然，如果回答了主从分离，面试官可能扩展开问你<strong>主从复制原理，问你主从延迟问题</strong>等等，这块大家需要<strong>全方位复习好</strong>哈。</p>
<h3>6. 使用缓存 <a href="#item-0-7" id="item-0-7"></a></h3>
<p>无论是操作系统，浏览器，还是一些复杂的中间件，你都可以看到缓存的影子。我们使用缓存，主要是提升系统接口的性能，这样高并发场景，你的系统就可以支持更多的用户同时访问。</p>
<p>常用的缓存包括：<code>Redis</code>缓存，<code>JVM</code>本地缓存，<code>memcached</code>等等。就拿<code>Redis</code>来说，它单机就能轻轻松松应对几万的并发，你读场景的业务，可以用缓存来抗高并发。</p>
<p>缓存虽然用得爽，但是要<strong>注意缓存使用的一些问题</strong>：</p>
<ul>
<li>缓存与数据库的一致性问题</li>
<li>缓存雪崩</li>
<li>缓存穿透</li>
<li>缓存击穿</li>
</ul>
<h3>7. CDN，加速静态资源访问 <a href="#item-0-8" id="item-0-8"></a></h3>
<p>商品图片，<code>icon</code>等等静态资源，可以对页面做<strong>静态化处理，减少访问服务端的请求</strong>。如果用户分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到页面，可以使用<code>CDN</code>。<code>CDN</code>可以让用户就近获取所需内容。</p>
<p>什么是CDN？</p>
<blockquote>
<p>Content Delivery Network/Content Distribution Network,翻译过来就是内容分发网络，它表示将静态资源分发到位于多个地理位置机房的服务器，可以做到数据就近访问，加速了静态资源的访问速度，因此让系统更好处理正常别的动态请求。</p>
</blockquote>
<h3>8. 消息队列，削锋 <a href="#item-0-9" id="item-0-9"></a></h3>
<p>我们搞一些双十一、双十二等运营活动时，需要<strong>避免流量暴涨，打垮应用系统的风险</strong>。因此一般会引入消息队列，来应对<strong>高并发的场景</strong>。</p>
<p><img src="/images/blog/engineering/system-image_3_3.png" alt="image_3_3.png"></p>
<p>假设你的应用系统每秒最多可以处理<code>2k</code>个请求，每秒却有<code>5k</code>的请求过来，可以引入消息队列，应用系统每秒从消息队列拉<code>2k</code>请求处理得了。</p>
<p>有些伙伴担心这样可能会出现<strong>消息积压</strong>的问题：</p>
<ul>
<li>首先，搞一些运营活动，不会每时每刻都那么多请求过来你的系统（<strong>除非有人恶意攻击</strong>），高峰期过去后，积压的请求可以慢慢处理；</li>
<li>其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；</li>
</ul>
<h3>9. ElasticSearch <a href="#item-0-10" id="item-0-10"></a></h3>
<p><code>Elasticsearch</code>，大家都使用得比较多了吧，<strong>一般搜索功能都会用到它</strong>。它是一个分布式、高扩展、高实时的搜索与数据分析引擎，简称为<code>ES</code>。</p>
<p>我们在聊高并发，为啥聊到<code>ES</code>呢？因为<code>ES</code>可以扩容方便，天然支撑高并发。<strong>当数据量大的时候，不用动不动就加机器扩容，分库等等</strong>，可以考虑用<code>ES</code>来支持简单的查询搜索、统计类的操作。</p>
<h3>10. 降级熔断 <a href="#item-0-11" id="item-0-11"></a></h3>
<p><strong>熔断降级</strong>是保护系统的一种手段。当前互联网系统一般都是分布式部署的。而分布式系统中偶尔会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为<strong>服务雪崩效应</strong>。</p>
<p>比如分布式调用链路<code>A-&gt;B-&gt;C....</code>，下图所示：</p>
<p><img src="/images/blog/engineering/system-image_3_4.png" alt="image_3_4.png"></p>
<blockquote>
<p>如果服务<code>C</code>出现问题，比如是因为慢<code>SQL</code>导致调用缓慢，那将导致<code>B</code>也会延迟，从而<code>A</code>也会延迟。堵住的<code>A</code>请求会消耗占用系统的线程、IO、CPU等资源。当请求<code>A</code>的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。</p>
</blockquote>
<p>为了应对服务雪崩, 常见的做法是<strong>熔断和降级</strong>。最简单是加开关控制，当下游系统出问题时，开关打开降级，不再调用下游系统。还可以选用开源组件<code>Hystrix</code>来支持。</p>
<p>你要保证设计的系统能应对<strong>高并发场景</strong>，那肯定要考虑<strong>熔断降级</strong>逻辑进来。</p>
<h3>11. 限流 <a href="#item-0-12" id="item-0-12"></a></h3>
<p>限流也是我们应对高并发的一种方案。我们当然希望，在高并发大流量过来时，系统能全部请求都正常处理。但是有时候没办法，系统的CPU、网络带宽、内存、线程等资源都是有限的。因此，我们要考虑限流。</p>
<p>如果你的系统每秒扛住的请求是一千，<strong>如果一秒钟来了十万请求呢</strong>？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？</p>
<p>这时候，我们可以采取限流方案。就是为了保护系统，多余的请求，直接丢弃。</p>
<blockquote>
<p><strong>什么是限流</strong>：在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。</p>
</blockquote>
<p>可以使用<code>Guava</code>的<code>RateLimiter</code>单机版限流，也可以使用<code>Redis</code>分布式限流，还可以使用阿里开源组件<code>sentinel</code>限流。</p>
<p>面试的时候，你说到限流这块的话？面试官很大概率会问你限流的算法，因此，大家在准备面试的时候，需要复习一下这几种经典的限流算法哈</p>
<h3>12. 异步 <a href="#item-0-13" id="item-0-13"></a></h3>
<blockquote>
<p>回忆一下什么是同步，什么是异步呢？以<strong>方法调用</strong>为例，它代表<strong>调用方要阻塞等待被调用方法中的逻辑执行完成</strong>。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。</p>
</blockquote>
<p>因此，设计一个高并发的系统，<strong>需要在恰当的场景使用异步</strong>。如何使用异步呢？后端可以借用消息队列实现。比如在海量秒杀请求过来时，先放到消息队列中，快速响应用户，告诉用户请求正在处理中，这样就可以释放资源来处理更多的请求。秒杀请求处理完后，通知用户秒杀抢购成功或者失败。</p>
<h3>13. 接口的常规优化 <a href="#item-0-14" id="item-0-14"></a></h3>
<p>设计一个高并发的系统，需要设计接口的性能足够好，这样系统在相同时间，就可以处理更多的请求。当说到这里的话，可以跟面试官说说接口优化的一些方案了。</p>
<p><img src="/images/blog/engineering/system-image_3_5.png" alt="image_3_5.png"></p>
<h3>14. 压力测试确定系统瓶颈 <a href="#item-0-15" id="item-0-15"></a></h3>
<p>设计高并发系统，离不开最重要的一环，<strong>就是压力测试</strong>。就是在系统上线前，需要对系统进行压力测试，测清楚你的系统支撑的最大并发是多少，确定系统的瓶颈点，让自己心里有底，最好预防措施。</p>
<p>压测完要分析整个调用链路，性能可能出现问题是网络层（如带宽）、Nginx层、服务层、还是数据路缓存等中间件等等。</p>
<p><code>loadrunner</code>是一款不错的压力测试工具，<code>jmeter</code>则是接口性能测试工具，都可以来做下压测。</p>
<h3>15. 应对突发流量峰值：扩容+切流量 <a href="#item-0-16" id="item-0-16"></a></h3>
<p>如果是突发的流量高峰，除了降级、限流保证系统不跨，我们可以采用这两种方案，保证系统尽可能服务用户请求：</p>
<ul>
<li>扩容：<strong>比如增加从库、提升配置的方式</strong>，提升系统/组件的流量承载能力。比如增加<code>MySQL、Redis</code>从库来处理查询请求。</li>
<li>切流量：<strong>服务多机房部署</strong>，如果高并发流量来了，把流量从一个机房切换到另一个机房。</li>
</ul>
19:T5c64,<blockquote>
<p>微服务架构已经成为互联网后端系统的主流架构范式。然而，从单体架构迁移到微服务，绝不仅仅是把代码拆成几个服务那么简单——它涉及服务如何注册与发现、如何通信与容错、如何部署与监控等一系列基础设施问题。本文从架构设计的核心关注点出发，结合业界最佳实践，系统性地梳理微服务架构落地所需的技术体系。</p>
</blockquote>
<h2>微服务架构概览</h2>
<h3>什么是微服务架构？</h3>
<p>与单体（Monolithic）架构不同，微服务架构是由一系列<strong>职责单一的细粒度服务</strong>构成的分布式网状结构，服务之间通过轻量级机制进行通信。这种架构带来了独立部署、技术异构、弹性伸缩等优势，但同时也引入了一系列新的技术挑战。</p>
<h3>核心技术关注点</h3>
<p>一个完整的微服务架构需要关注以下层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>关注点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信</strong></td>
<td>服务注册与发现、负载均衡、RPC 框架、API 网关</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>服务容错（熔断、隔离、限流、降级）</td>
</tr>
<tr>
<td><strong>基础设施</strong></td>
<td>配置中心、缓存、消息队列、数据库</td>
</tr>
<tr>
<td><strong>交付</strong></td>
<td>CI/CD 流水线、自动化测试、灰度发布</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>日志系统、监控告警、链路追踪</td>
</tr>
<tr>
<td><strong>部署</strong></td>
<td>负载均衡、DNS、CDN</td>
</tr>
</tbody></table>
<p>接下来，我们逐一展开讨论。</p>
<h2>服务注册、发现与负载均衡</h2>
<p>微服务架构下，服务提供方需要注册通告服务地址，服务调用方需要发现目标服务，同时服务提供方一般以集群方式提供服务，这就引入了负载均衡和健康检查问题。</p>
<p>根据负载均衡器（LB）所在位置的不同，目前主要有三种方案：</p>
<h3>方案一：集中式 LB</h3>
<p>在服务消费者和服务提供者之间设置独立的 LB（如 F5 硬件或 LVS/HAProxy 软件），LB 上有所有服务的地址映射表，由运维配置注册。服务消费方通过 DNS 域名指向 LB。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>实现简单，当前业界主流</td>
<td>单点问题，LB 容易成为瓶颈</td>
</tr>
<tr>
<td>易于做集中式访问控制</td>
<td>增加一跳（hop），有性能开销</td>
</tr>
<tr>
<td></td>
<td>一旦 LB 故障，影响是灾难性的</td>
</tr>
</tbody></table>
<h3>方案二：进程内 LB（客户端负载）</h3>
<p>将 LB 功能以库的形式集成到服务消费方进程内，也称为<strong>软负载（Soft Load Balancing）</strong>。需要配合服务注册表（Service Registry）支持服务自注册和自发现。</p>
<p>工作原理：</p>
<ol>
<li>服务提供方启动时，将地址注册到服务注册表，并定期发送心跳</li>
<li>服务消费方通过内置 LB 组件查询注册表，缓存并定期刷新目标地址列表</li>
<li>以某种负载均衡策略选择目标地址，直接发起请求</li>
</ol>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分布式方案，无单点问题</td>
<td>多语言栈需开发多种客户端库</td>
</tr>
<tr>
<td>服务间直接调用，性能好</td>
<td>客户端库升级需服务方重新发布</td>
</tr>
</tbody></table>
<p>典型案例：Netflix OSS（Eureka + Ribbon + Karyon）、阿里 Dubbo。</p>
<h3>方案三：主机独立 LB 进程（Sidecar 模式）</h3>
<p>将 LB 和服务发现功能从进程内移出，变成主机上的独立进程。同一主机上的多个服务共享该 LB 进程完成服务发现和负载均衡。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>无单点，一个 LB 挂只影响该主机</td>
<td>部署较复杂，环节多</td>
</tr>
<tr>
<td>不需要为不同语言开发客户端库</td>
<td>出错调试排查不方便</td>
</tr>
<tr>
<td>LB 升级不需要服务方改代码</td>
<td></td>
</tr>
</tbody></table>
<p>典型案例：Airbnb SmartStack（Zookeeper + Nerve + Synapse/HAProxy）、Kubernetes 内部服务发现。</p>
<blockquote>
<p>三种方案各有取舍，选择时需要综合考虑团队技术栈的多样性、运维能力和性能要求。当前趋势是方案三（Sidecar 模式）逐渐演化为 Service Mesh（服务网格），如 Istio + Envoy。</p>
</blockquote>
<h2>API 网关（Service Gateway）</h2>
<p>微服务最终需要以某种方式暴露给外部系统访问，这就需要<strong>服务网关</strong>。网关是连接企业内部和外部系统的一道门，承担以下关键职责：</p>
<table>
<thead>
<tr>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>反向路由</strong></td>
<td>将外部请求路由到内部具体的微服务，对外呈现统一入口</td>
</tr>
<tr>
<td><strong>安全认证</strong></td>
<td>集中处理用户认证、授权和防爬虫</td>
</tr>
<tr>
<td><strong>限流容错</strong></td>
<td>流量高峰期限流保护后台，内部故障时集中容错</td>
</tr>
<tr>
<td><strong>监控</strong></td>
<td>集中监控访问量、调用延迟、错误计数</td>
</tr>
<tr>
<td><strong>日志</strong></td>
<td>收集所有访问日志，为后续分析提供数据</td>
</tr>
</tbody></table>
<p>除此之外，网关还可以实现<strong>线上引流、线上压测、金丝雀发布（Canary Testing）、数据中心双活</strong>等高级功能。</p>
<h3>微服务的分层架构</h3>
<p>引入网关和服务注册表之后，微服务可以简化为两层结构：</p>
<ul>
<li><strong>后端通用服务（Middle Tier Service）</strong>：启动时注册地址到注册表</li>
<li><strong>前端边缘服务（Edge Service）</strong>：查询注册表发现后端服务，对后端服务做聚合和裁剪后暴露给外部设备</li>
</ul>
<p>网关通过查询注册表将外部请求路由到前端服务，整个微服务体系的自注册、自发现和软路由就此串联起来。如果用设计模式的视角看——<strong>网关类似 Proxy/Facade 模式，服务注册表类似 IoC 依赖注入模式</strong>。</p>
<p>常见的网关组件：Netflix Zuul、Kong、APISIX、Spring Cloud Gateway。</p>
<h2>服务容错</h2>
<p>当企业微服务化后，服务之间存在错综复杂的依赖关系。一个前端请求一般依赖多个后端服务（1→N 扇出）。在生产环境中，如果一个应用不能对其依赖的故障进行容错和隔离，就面临被拖垮的风险。在高流量场景下，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源（线程、队列等）被耗尽，造成<strong>雪崩效应（Cascading Failure）</strong>。</p>
<p>业界总结出以下核心容错模式：</p>
<h3>熔断器模式（Circuit Breaker）</h3>
<p>原理类似家用电路熔断器。当目标服务慢或大量超时时，调用方主动熔断，防止服务被进一步拖垮。</p>
<p>熔断器有三种状态：</p>
<pre><code>Closed（正常）→ Open（熔断）→ Half-Open（半熔断）→ Closed/Open
</code></pre>
<ul>
<li><strong>Closed</strong>：正常状态，请求正常通过</li>
<li><strong>Open</strong>：调用持续出错或超时，进入熔断状态，后续请求直接拒绝（Fail Fast）</li>
<li><strong>Half-Open</strong>：一段时间后允许少量请求尝试，成功则恢复，失败则继续熔断</li>
</ul>
<h3>舱壁隔离模式（Bulkhead Isolation）</h3>
<p>像船舱一样对资源进行隔离。典型实现是<strong>线程隔离</strong>：假定应用 A 调用 Svc1/Svc2/Svc3 三个服务，容器共有 120 个工作线程，可以给每个服务各分配 40 个线程。当 Svc2 变慢时，只有分配给 Svc2 的 40 个线程被耗尽，Svc1 和 Svc3 的 80 个线程不受影响。</p>
<h3>限流（Rate Limiting）</h3>
<p>对服务限定并发访问量，比如单位时间只允许 100 个并发调用，超过限制的请求拒绝并回退。没有限流机制的服务在突发流量（秒杀、大促）时极易被冲垮。</p>
<h3>降级回退（Fallback）</h3>
<p>当熔断或限流发生时的后续处理策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Fail Fast</td>
<td>直接抛出异常</td>
</tr>
<tr>
<td>返回缺省值</td>
<td>返回空值或默认数据</td>
</tr>
<tr>
<td>备份服务</td>
<td>从备份数据源获取数据</td>
</tr>
</tbody></table>
<blockquote>
<p>Netflix 将上述容错模式集成到 Hystrix 开源组件中（现已进入维护模式，社区推荐 Resilience4j 或 Sentinel 作为替代）。Spring Cloud Circuit Breaker 提供了统一的抽象层。</p>
</blockquote>
<h2>服务框架的核心能力</h2>
<p>微服务化后，为了让业务开发人员专注于业务逻辑，避免冗余和重复劳动，需要将公共关注点推到框架层面。一个成熟的服务框架应当封装以下能力：</p>
<table>
<thead>
<tr>
<th>能力</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册发现</td>
<td>服务端自注册，客户端自发现和负载均衡</td>
</tr>
<tr>
<td>监控日志</td>
<td>框架层日志、Metrics、调用链数据的记录和暴露</td>
</tr>
<tr>
<td>REST/RPC 与序列化</td>
<td>支持 HTTP/REST 和 Binary/RPC，可定制序列化（JSON/Protobuf 等）</td>
</tr>
<tr>
<td>动态配置</td>
<td>运行时动态调整参数和配置</td>
</tr>
<tr>
<td>限流容错</td>
<td>集成限流和熔断组件，结合动态配置实现动态限流</td>
</tr>
<tr>
<td>管理接口</td>
<td>在线查看和动态调整框架及服务内部状态（如 Spring Boot Actuator）</td>
</tr>
<tr>
<td>统一错误处理</td>
<td>框架层统一处理异常并记录日志</td>
</tr>
<tr>
<td>安全</td>
<td>访问控制逻辑的插件化封装</td>
</tr>
<tr>
<td>文档自动生成</td>
<td>如 Swagger/OpenAPI 的自动化文档方案</td>
</tr>
</tbody></table>
<p>当前业界成熟的微服务框架有：Spring Cloud/Spring Boot、Apache Dubbo、Go-Micro、gRPC 等。</p>
<h2>基础设施选型</h2>
<h3>RPC 框架选型</h3>
<p>RPC（Remote Procedure Call）框架大致分为两大流派：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表框架</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>跨语言调用型</strong></td>
<td>gRPC、Thrift、Hprose</td>
<td>支持多语言调用，无服务治理机制</td>
<td>多语言调用场景</td>
</tr>
<tr>
<td><strong>服务治理型</strong></td>
<td>Dubbo、Motan、rpcx</td>
<td>功能丰富，含服务发现和治理能力</td>
<td>大型服务的解耦和治理</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：如果是 Java 为主的团队，推荐 <strong>Dubbo</strong>（高性能，性能测试中比 Feign 强约 10 倍）。如果需要跨语言支持，Dubbo 也支持通过 Dubbo-Go 实现 Java + Go 双语言微服务架构。如果是纯粹的跨语言场景，<strong>gRPC</strong> 基于 HTTP/2 + Protobuf，是业界标准选择。</p>
<h3>注册中心选型</h3>
<p>所有的服务发现都依赖于一个高可用的服务注册表。主流选择：</p>
<table>
<thead>
<tr>
<th>注册中心</th>
<th>特点</th>
<th>一致性模型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nacos</strong></td>
<td>同时支持注册中心和配置中心，功能全面</td>
<td>AP/CP 可切换</td>
</tr>
<tr>
<td><strong>ZooKeeper</strong></td>
<td>最早的分布式协调服务，生态成熟</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Etcd</strong></td>
<td>Kubernetes 默认存储，高可用和一致性</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Consul</strong></td>
<td>支持多数据中心，内置健康检查</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Eureka</strong></td>
<td>Netflix 开源，AP 模型，已停止维护</td>
<td>AP</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：推荐 <strong>Nacos</strong>（nacos + MySQL 高可用部署），一站式解决注册中心和配置中心的需求。</p>
<h3>配置中心选型</h3>
<p>随着系统复杂度增长，配置管理面临越来越高的要求：配置修改实时生效、灰度发布、分环境/分集群管理、完善的权限审核机制。传统的配置文件方式已经无法满足需求。</p>
<p>配置中心的核心架构组件：</p>
<ul>
<li><strong>配置服务端</strong>：集中存储和管理所有配置信息</li>
<li><strong>配置客户端</strong>：通过<strong>定期拉取（Pull）</strong> 或 <strong>服务端推送（Push）</strong> 方式获取配置更新</li>
<li><strong>管理界面</strong>：配置的增删改查和审计</li>
</ul>
<table>
<thead>
<tr>
<th>配置中心</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nacos</strong></td>
<td>阿里开源，同时支持注册和配置，生态活跃</td>
</tr>
<tr>
<td><strong>Apollo</strong></td>
<td>携程开源，功能完善，支持灰度发布和权限管理</td>
</tr>
<tr>
<td><strong>Spring Cloud Config</strong></td>
<td>Spring 生态原生支持，基于 Git 存储</td>
</tr>
</tbody></table>
<h3>缓存中间件选型</h3>
<table>
<thead>
<tr>
<th>缓存</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Redis</strong></td>
<td>多数据结构，支持持久化和集群</td>
<td>通用缓存、分布式锁、排行榜等</td>
</tr>
<tr>
<td><strong>Memcached</strong></td>
<td>纯内存 KV，简单高效</td>
<td>简单的对象缓存</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：推荐 <strong>Redis Cluster</strong> 高可用集群部署。</p>
<blockquote>
<p>需要特别关注 Redis 的 Big Key 问题。在高并发场景下，Big Key 会导致单个节点内存和网络带宽瓶颈，严重时可造成系统瘫痪。建议制定 Key 规范并定期扫描。</p>
</blockquote>
<h3>消息中间件选型</h3>
<p>消息中间件的三大核心场景：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
<th>典型案例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步处理</strong></td>
<td>减少主流程等待时间，非核心逻辑异步执行</td>
<td>注册后发送邮件、异步更新缓存</td>
</tr>
<tr>
<td><strong>系统解耦</strong></td>
<td>上下游系统通过消息通信，不需要强一致</td>
<td>支付成功后通知 ERP/WMS/推荐等系统</td>
</tr>
<tr>
<td><strong>削峰填谷</strong></td>
<td>大流量请求放入队列，消费者按能力消化</td>
<td>秒杀系统的下单排队</td>
</tr>
</tbody></table>
<p>主流消息中间件对比：</p>
<table>
<thead>
<tr>
<th>中间件</th>
<th>吞吐量</th>
<th>延迟</th>
<th>可靠性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Kafka</strong></td>
<td>极高</td>
<td>毫秒级</td>
<td>高（可配置）</td>
<td>日志收集、大数据流处理、事件溯源</td>
</tr>
<tr>
<td><strong>RocketMQ</strong></td>
<td>高</td>
<td>毫秒级</td>
<td>极高（事务消息）</td>
<td>电商交易、金融场景</td>
</tr>
<tr>
<td><strong>RabbitMQ</strong></td>
<td>中等</td>
<td>微秒级</td>
<td>高</td>
<td>实时性要求高、路由复杂的场景</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：<strong>Kafka</strong> 用于日志采集和大数据场景，<strong>RocketMQ</strong> 用于业务消息和交易场景，二者搭配使用。</p>
<h3>数据库选型</h3>
<h4>关系型数据库</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>代表</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>传统 RDBMS</strong></td>
<td>MySQL、PostgreSQL</td>
<td>成熟稳定，生态丰富，百万级 PV 搭配主从 + 缓存可满足</td>
</tr>
<tr>
<td><strong>NewSQL</strong></td>
<td>TiDB、CockroachDB</td>
<td>完整 SQL 支持 + ACID 事务 + 弹性伸缩 + 高可用 + 大数据分析能力</td>
</tr>
</tbody></table>
<p>当 MySQL 需要分库分表且逻辑复杂度高、扩展性不足时，可以考虑 TiDB。</p>
<h4>NoSQL 数据库</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>键值型</strong></td>
<td>Redis、Memcache</td>
<td>缓存、会话管理</td>
</tr>
<tr>
<td><strong>列式</strong></td>
<td>HBase、Cassandra</td>
<td>写多读少、时序数据</td>
</tr>
<tr>
<td><strong>文档型</strong></td>
<td>MongoDB、CouchDB</td>
<td>非结构化数据、灵活 Schema</td>
</tr>
<tr>
<td><strong>图数据库</strong></td>
<td>Neo4J</td>
<td>社交网络、推荐系统</td>
</tr>
</tbody></table>
<h2>CI/CD 流水线</h2>
<p>从代码到最终服务用户，可以分为三个阶段：</p>
<pre><code>Code → Artifact（制品库）→ Running Service → Production
</code></pre>
<ol>
<li><strong>代码到制品</strong>：持续构建，制品集中管理</li>
<li><strong>制品到服务</strong>：部署到指定环境</li>
<li><strong>开发到生产</strong>：变更在不同环境间的迁移和灰度发布</li>
</ol>
<h3>工具链推荐</h3>
<table>
<thead>
<tr>
<th>环节</th>
<th>推荐工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码管理</strong></td>
<td>GitLab</td>
<td>社区版功能丰富，结合 Gerrit 做 Code Review</td>
</tr>
<tr>
<td><strong>持续集成</strong></td>
<td>Jenkins / GitLab CI</td>
<td>Jenkins 插件生态强大；GitLab CI 与 GitLab 深度集成</td>
</tr>
<tr>
<td><strong>制品仓库</strong></td>
<td>Harbor</td>
<td>开源的 Docker 镜像仓库，支持镜像签名和漏洞扫描</td>
</tr>
<tr>
<td><strong>部署编排</strong></td>
<td>Kubernetes</td>
<td>容器编排的事实标准，支持声明式部署和自动伸缩</td>
</tr>
<tr>
<td><strong>项目管理</strong></td>
<td>Jira + Confluence</td>
<td>项目管理、任务跟踪和知识管理的行业标配</td>
</tr>
</tbody></table>
<p><strong>初期建议</strong>：Jenkins + GitLab + Harbor 的组合，可以覆盖制品管理、发布流程、权限控制、版本变更和服务回滚。</p>
<h3>自动化测试</h3>
<p>自动化测试平台是 CI/CD 流水线的重要一环：</p>
<ul>
<li><strong>单元测试</strong>：JUnit / TestNG，覆盖核心业务逻辑</li>
<li><strong>接口测试</strong>：可基于开源框架（如 SpringBoot + TestNG）搭建</li>
<li><strong>性能测试</strong>：JMeter / Gatling</li>
<li><strong>端到端测试</strong>：Selenium / Cypress</li>
</ul>
<h2>可观测性体系</h2>
<h3>日志系统</h3>
<p>日志系统涵盖日志打印、采集、中转、存储、分析、搜索和分发。日志系统的建设不仅是工具建设，还包括规范和组件建设——基本的日志（如全链路追踪 ID）应在框架和组件层面统一注入。</p>
<p><strong>常规方案：ELK Stack</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Filebeat</strong></td>
<td>轻量级日志采集器，替代 Logstash-Forwarder</td>
</tr>
<tr>
<td><strong>Logstash</strong></td>
<td>日志收集、过滤和转换</td>
</tr>
<tr>
<td><strong>Elasticsearch</strong></td>
<td>分布式搜索引擎，存储和索引日志</td>
</tr>
<tr>
<td><strong>Kibana</strong></td>
<td>可视化界面，日志搜索和分析</td>
</tr>
</tbody></table>
<blockquote>
<p>免费版 ELK 没有安全机制，建议前置 Nginx 做反向代理和简单用户认证。</p>
</blockquote>
<p><strong>实时计算方案</strong>：对于需要实时分析的场景，可以采用 Flume + Kafka + Flink（或 Storm）的架构。Kafka 负责高吞吐的消息缓冲，Flume 负责多样化的数据采集，Flink 负责实时流计算。</p>
<h3>监控系统</h3>
<p>监控系统主要覆盖两个层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>监控指标</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础设施</strong></td>
<td>机器负载、IO、网络流量、CPU、内存</td>
</tr>
<tr>
<td><strong>服务质量</strong></td>
<td>可用性、成功率、失败率、QPS、延迟</td>
</tr>
</tbody></table>
<p><strong>推荐方案：Prometheus + Grafana</strong></p>
<p>Prometheus 是 Google BorgMon 的开源版本，使用 Go 开发，采用 <strong>Pull</strong> 模式主动拉取指标数据。其核心组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Prometheus Server</strong></td>
<td>数据采集和存储，提供 PromQL 查询</td>
</tr>
<tr>
<td><strong>Exporter</strong></td>
<td>各类数据采集组件（数据库、硬件、MQ、HTTP 服务器等）</td>
</tr>
<tr>
<td><strong>Push Gateway</strong></td>
<td>支持短生命周期 Job 主动推送指标</td>
</tr>
<tr>
<td><strong>Alertmanager</strong></td>
<td>灵活的报警规则和通知管理</td>
</tr>
<tr>
<td><strong>Grafana</strong></td>
<td>高度定制化的可视化监控面板</td>
</tr>
</tbody></table>
<p>Prometheus + Grafana 搭配统一的服务框架，可以满足绝大部分中小团队的监控需求。</p>
<h2>生产环境部署架构</h2>
<h3>DNS</h3>
<p>DNS 是基础服务，一般直接选择云厂商：</p>
<ul>
<li><strong>国内</strong>：阿里云 DNS 或腾讯 DNSPod，线上产品建议使用付费版</li>
<li><strong>海外</strong>：优先选择 AWS Route 53</li>
<li><strong>国内外互通</strong>：建议在 APP 层实现容灾逻辑或智能调度，因为没有单一 DNS 服务能同时很好地覆盖国内外</li>
</ul>
<h3>负载均衡（LB）</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>云服务环境</td>
<td>直接使用云厂商 LB（阿里云 SLB / 腾讯云 CLB / AWS ELB）</td>
</tr>
<tr>
<td>自建机房</td>
<td>LVS（四层）+ Nginx（七层）</td>
</tr>
</tbody></table>
<p>云厂商 LB 通常支持四层（TCP/UDP）和七层（HTTP/HTTPS）协议、集中化证书管理和健康检查。</p>
<h3>CDN</h3>
<p>CDN 的选型主要看业务覆盖区域：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td>国内</td>
<td>阿里云 CDN、腾讯云 CDN</td>
</tr>
<tr>
<td>海外</td>
<td>AWS CloudFront、Akamai</td>
</tr>
</tbody></table>
<h2>总结</h2>
<p>微服务架构的落地是一个系统工程，核心技术关注点可以归纳为以下几个层面：</p>
<ol>
<li><strong>服务通信</strong>：通过注册中心 + 负载均衡 + API 网关，构建服务间和内外部的通信体系</li>
<li><strong>服务可靠性</strong>：通过熔断、隔离、限流和降级四大模式，保障系统在故障和高峰期的稳定性</li>
<li><strong>服务框架</strong>：将公共关注点下沉到框架层，让业务开发专注于业务逻辑</li>
<li><strong>基础设施</strong>：根据业务需求和团队技术栈，选择合适的 RPC、注册中心、缓存、消息队列和数据库</li>
<li><strong>持续交付</strong>：通过 CI/CD 流水线实现代码到生产环境的自动化、可重复的发布流程</li>
<li><strong>可观测性</strong>：通过日志、监控和链路追踪构建系统的透明度，为问题排查和性能优化提供数据支撑</li>
</ol>
<p>好的架构不是设计出来的，而是演进出来的。架构师需要在不同阶段做出合适的判断——既不过度设计，也不欠缺考虑。关键是保持对技术的敏锐度，在实践中不断验证和调整。</p>
<blockquote>
<p>路漫漫其修远兮，架构求索无止尽也。</p>
</blockquote>
1a:T2521,<h1>到底啥叫懂业务？业务的三重视角</h1>
<p>**“有分析，没结论”**是数据分析师很容易出现的问题。</p>
<p>数据分析汇报的时候，经常会出现这样的汇报内容：“活动整体的销售额是XX万，同比去年增长X%；用户数XX万，其中新增用户数XX万；转化率XX%……”吧啦吧啦说了一堆，但一般业务方并不买账。</p>
<p>因为这些数据不用你汇报，你给个excel表是个人都会看，<strong>看的还比你念得快</strong>。</p>
<p><strong>数据分析的核心能力是能够业务落地。</strong></p>
<p>落地就是你的分析结论很明确地指向一些业务问题甚至指出优化方向，业务人员听了你的分析结论后很清楚自己要做什么。</p>
<p><strong>要想得出能落地的分析结论，我们必须懂业务。</strong></p>
<h2>一、到底什么叫业务</h2>
<p>分析师要懂业务，但<strong>什么是业务？</strong></p>
<p><strong>关于业务的问题很多，以下哪些属于业务呢？</strong></p>
<ul>
<li>这个业务是做什么的？提供了什么产品和服务？</li>
<li>这个业务怎么赚钱？收入和成本分别是什么？</li>
<li>驱动这个业务的运转，需要做哪些事情？</li>
<li>具体业务动作的执行操作步骤是什么？</li>
</ul>
<p>上述这些问题有的很宏观，抽象到业务的盈利模式；有的很微观，具体到操作步骤。<strong>虽然差别很大，但以上问题其实这些都是业务问题。</strong></p>
<p>业务这个词在不同的人眼中含义是不一样的。</p>
<p><strong>以打车APP为例：</strong></p>
<ul>
<li>在CEO眼中的业务，是撮合司机和用户的需求并从中抽取佣金的平台型业务。</li>
<li>在用户端运营总监眼中的业务，是构建拉新用户策略、用户精细化运营方案。</li>
<li>在用户运营专员眼中的业务，是渠道投放文案设计、优惠券金额设置、沉默用户召回短信发送。</li>
</ul>
<p>可以看出，不同的人看业务的视角不同。但这不妨碍我们给业务下一个统一的定义。</p>
<h3>1、业务到底是什么？</h3>
<p><strong>业务是输入特定的资源，能够给出具有商家价值的确定性输出的经营单元。</strong></p>
<p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TYNVslY6nnEoVm~noop.image?_iz=58558&from=article.pc_detail&x-expires=1688555642&x-signature=%2BbKXk%2B5RsI996vzsFf2VF8cIpTc%3D" alt=""></p>
<p>这个定义有几个核心的要素 ：</p>
<p>可能还是不太好理解，我举几个例子：</p>
<p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TYNVsn01wwDf6L~noop.image?_iz=58558&from=article.pc_detail&x-expires=1688555642&x-signature=xGo3VhuDacVf8P7xAerV68OOW28%3D" alt=""></p>
<p>比如<strong>在CEO眼里</strong>，<strong>整个APP都是一个业务</strong>。因为输入资金和人力，经过打车APP的经营，最终能够获得利润。</p>
<p>在<strong>用户端运营总监眼里，用户端的拉新、促活、召回都是业务</strong>，因为拉新业务是输入资金和人力，输出新用户。促活是输入流量，输出更高活跃度的流量；召回是输入沉默用户，输出回流用户。</p>
<p>在<strong>用户运营转眼的眼里，编写召回短信是一个业务</strong>，输入的是人力，输出的是短信的内容。</p>
<p>这样似乎就清楚一点了，业务就是创造商业价值的一系列过程。</p>
<p>接下去的问题是，不同的人观察的视角不同，那么这个<strong>不同究竟差别在哪</strong>？</p>
<h2>二、业务的三重视角</h2>
<p><strong>业务有三层视角，分别是高层的商业模式视角、中层的业务模型视角、基层的执行策略视角。</strong></p>
<h3>1、高层视角：商业模式</h3>
<p><strong>高层关心的问题是</strong>：</p>
<ul>
<li>这个业务是做什么的，面向哪些群体提供什么样的产品和服务？</li>
<li>为了提供这些产品和服务，需要哪些资源和合作伙伴？</li>
<li>需要做哪些事，才能保证产品和服务的稳定供给。</li>
<li>如何找到目标用户？</li>
<li>如何赚钱？</li>
</ul>
<p><strong>高层思考的这几件事，其实就是这个业务的商业模式</strong>。商业模式的思考工具推荐商业模式画布。</p>
<p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TYNVsnZ93IZI1x~noop.image?_iz=58558&from=article.pc_detail&x-expires=1688555642&x-signature=OS5%2Bv4XVgnmHk5NxsSrpre%2FxJWw%3D" alt=""></p>
<p>商业模式画布一共有9个维度，<strong>其中最重要是中间的价值主张</strong>，即你怎么样帮助别人，提供了什么样的价值。</p>
<p><strong>画布左边是成本的部分</strong>，为了带来这些价值需要的<strong>资源、合作和工作内容</strong>。</p>
<p><strong>画布右边是收入的部分</strong>，为了把这些价值带给客户，需要<strong>什么样的用户</strong>、<strong>什么样的渠道</strong>以及和用户保持一种<strong>什么样的关系</strong>。</p>
<p>了解了商业模式画布，就能搞清楚高层视角下的业务究竟是什么样的。</p>
<p>本篇内容作为“懂业务”的第一篇，主要用来说明各个模型的关系，<strong>对商业模式画布的细节暂时不详细展开</strong>，<strong>欢迎关注，下一篇奉上详细说明。</strong></p>
<p>想清楚商业模式之后，高层就基本上清楚需要重点运营哪些模块，然后会把一些工作安排给中层。比如保证产品和服务的供给、保证流量持续稳定增长、品牌营销等等。</p>
<h3>2、中层视角：业务模型</h3>
<p><strong>中层拿到高层安排的任务后，关心的问题是：</strong></p>
<ul>
<li>需要保障的问题有哪些环节？比如新流量的获取需要渠道投放、落地页承接、新用户注册等环节。</li>
<li>上述环节应该如何保障？比如需要有专门的渠道专员负责定期投放。</li>
<li>提高产品供给能力的核心因素是什么？比如提升新流量的核心因素是自传播能力。</li>
<li>如何驱动和改善这个核心因素？比如提升自传播能力可以通过裂变奖励。</li>
</ul>
<p>中层思考的这几件事，是为了<strong>设计一个业务模型</strong>。**业务模型是由工作流组成的。**比如营销转化漏斗模型就是一种业务模型：</p>
<p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TYNVsoA4YH4121~noop.image?_iz=58558&from=article.pc_detail&x-expires=1688555642&x-signature=xoI7DNVWuyjUe9aqkcP9SetjDaY%3D" alt=""></p>
<p>再比如在线教育行业的教学流程也是一个业务流程，可以保证课程的正常开展：</p>
<p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TYNVtZlDokN5qt~noop.image?_iz=58558&from=article.pc_detail&x-expires=1688555642&x-signature=JiZ2VK2%2FWOC%2Bo5X63hTAdCxMVU0%3D" alt=""></p>
<p>其他所有的能够给出确定性的有商业价值交付物的过程都可以成为业务模型，比如：</p>
<ul>
<li>采购管理，输入资金，输出货物；</li>
<li>产品设计，输入人力，输出产品原型；</li>
<li>品类运营，输入所有运营品类，输出运营效率更高的分层后的品类。</li>
<li>……</li>
</ul>
<p>中层思考清楚业务模型后，基本能搞清楚要找什么样的人才，组织一个什么样的团队，分别处理什么样的工作。</p>
<p>然后<strong>把具体的工作安排给基层员工</strong>，比如具体的渠道投放、落地页设计、开展裂变活动等等执行动作。</p>
<h3>3、基层视角：执行策略</h3>
<p>基层拿到中层安排的具体任务，关心的问题是：</p>
<ul>
<li>渠道投放的操作流程是什么样的？</li>
<li>什么样的渠道更好？什么样的文案转化率更高？什么时间投放更好？</li>
<li>为了完成目标，本周需要完成多少工作量？</li>
<li>操作SOP还有什么可以改进的地方？</li>
</ul>
<p>基层的工作被中层下发的任务限定在某一个范围内，<strong>一般就是纯执行岗位</strong>。<strong>稍微有点自由度的是交付的形式</strong>，比如文案、图片、渠道的选择。</p>
<p>基层有很多不同的业务模块，产品设计、用户运营、渠道运营、品类运营、店铺运营等等。</p>
<p><strong>不同的工作五花八门，所以没有统一的模型。</strong></p>
<p>比如就算是同样是营销岗，也有AIDMA、AISAS、fogg模型等不同的方法论模型；再比如产品设计的用户体验五要素、价值公式、MVP等。</p>
<p><img src="https://p3-sign.toutiaoimg.com/tos-cn-i-tjoges91tu/TYNVtaVCgdC8cn~noop.image?_iz=58558&from=article.pc_detail&x-expires=1688555642&x-signature=uR3k0N%2BH1yJM48Bp2tvBceRAWnM%3D" alt=""></p>
<p><strong>这部分牵扯到的模型比较杂，之后的文章再单独展开聊。</strong></p>
<h2>三、小结</h2>
<p><strong>业务这个概念一直含糊不清</strong>，偏偏很多面试官又特别喜欢问你懂不懂业务，搞得很多人对这个问题一直很纠结。</p>
<p>了解了这个业务的概念后（输入特定的资源给出具有商家价值的确定性输出的经营单元）这个概念之后，再问你懂不懂业务，就容易回答得多了。</p>
<p>你可以回答，你懂的业务究竟是商业模式、业务模型还是具体的执行策略？</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/architecture/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"架构设计"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-03-16","children":"2024年03月16日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"架构设计模板"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","架构设计",{"href":"/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"架构设计"}],["$","$L13","设计模板",{"href":"/blog/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"设计模板"}],["$","$L13","方法论",{"href":"/blog/tag/%E6%96%B9%E6%B3%95%E8%AE%BA/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"方法论"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/architecture/SET化架构：从单元化原理到大规模落地实践","title":"SET化架构：从单元化原理到大规模落地实践","description":"深入剖析SET化（单元化）架构的核心原理与设计实践，涵盖流量路由、数据分片、全局服务、故障隔离等关键环节，结合美团、阿里等大厂实践经验，构建可水平扩展的弹性架构体系。","pubDate":"2024-03-15","tags":["架构设计","SET化架构","单元化","异地多活","高可用"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/architecture/高并发系统设计的15个锦囊","title":"高并发系统设计的15个锦囊","description":"记得很久之前，去面试过**字节跳动**。被三面的面试官问了一道场景设计题目：**如何设计一个高并发系统**。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。 所谓设计**高并发**系统，就是设计一个系统，保证它**整体可用**的同时，能够**处理很高...","pubDate":"2024-03-17","tags":["高并发","系统架构","性能优化"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"架构设计":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":{"slug":"engineering/architecture/微服务架构落地指南：从核心模式到技术选型","title":"微服务架构落地指南：从核心模式到技术选型","description":"系统性地探讨微服务架构设计的核心关注点，包括服务注册发现、API 网关、服务容错、基础设施选型、CI/CD 流水线和可观测性体系，帮助你从 0 到 1 构建一套完整的微服务技术栈。","pubDate":"2024-03-18","tags":["架构设计","微服务","分布式系统","技术选型"],"heroImage":"$undefined","content":"$19"}},"设计模板":{"prev":null,"next":null},"方法论":{"prev":{"slug":"engineering/domain/业务的三重视角——怎样算懂业务","title":"业务的三重视角——怎样算懂业务","description":"数据分析的核心能力是为了能够让业务落地，而数据分析师常常容易出现“有分析，没结论”的问题。数据分析师要想得出能落地的分析结论，就需要明确地指向一些业务问题甚至优化方向。这篇文章详细解释了业务的概念和三角视角，推荐数据分析师们来阅读和学习。...","pubDate":"2024-03-07","tags":["业务架构","业务分析","方法论"],"heroImage":"$undefined","content":"$1a"},"next":null}}}]}],["$","$L1b",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"架构设计模板 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"一套可落地的架构设计文档模板，涵盖需求分析、架构总览、核心流程、详细设计等 11 个关键维度，附可直接复用的 Markdown 模板。"}],["$","meta","2",{"property":"og:title","content":"架构设计模板"}],["$","meta","3",{"property":"og:description","content":"一套可落地的架构设计文档模板，涵盖需求分析、架构总览、核心流程、详细设计等 11 个关键维度，附可直接复用的 Markdown 模板。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-03-16"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"架构设计模板"}],["$","meta","9",{"name":"twitter:description","content":"一套可落地的架构设计文档模板，涵盖需求分析、架构总览、核心流程、详细设计等 11 个关键维度，附可直接复用的 Markdown 模板。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

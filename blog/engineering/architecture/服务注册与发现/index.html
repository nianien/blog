<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/fffdcdb4fb651185.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>服务注册与发现 - Skyfalling Blog</title><meta name="description" content="我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。"/><meta property="og:title" content="服务注册与发现"/><meta property="og:description" content="我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-03-23"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="服务注册与发现"/><meta name="twitter:description" content="我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/architecture/page/1/">架构设计</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-03-23">2024年03月23日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">服务注册与发现</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/">微服务</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/page/1/">服务发现</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/">架构设计</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h2>1 微服务的注册与发现 <a href="#scroller-1" id="scroller-1"></a></h2>
<p>我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。</p>
<p>微服务注册与发现类似于生活中的&quot;电话通讯录&quot;的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。</p>
<p>步骤如下：</p>
<p>1、你先要把&quot;好友某某&quot;记录在通讯录中。</p>
<p>2、拨打电话的时候通过通讯录中找到&quot;好友某某&quot;，并拨通回电话。</p>
<p>3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。</p>
<p>从这个过程中我们看到了一些特点：</p>
<p>1、把 &quot;好友某某&quot; 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。</p>
<p>2、后续我们通过&quot;好友某某&quot;就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。</p>
<p>而我们微服务架构中的服务注册与发现结构如下图所示：</p>
<p><img src="/images/blog/engineering/microservice-image_6_1.png" alt="image_6_1.png"></p>
<p>图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：</p>
<p>provider - 服务提供者</p>
<p>consumer - 服务消费者</p>
<p>register center - 注册中心</p>
<p>它们之间的关系大致如下：</p>
<p>1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。</p>
<p>2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。</p>
<p>3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。</p>
<p>优点如下：</p>
<p>1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响</p>
<p>2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响</p>
<p>3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。</p>
<p>从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。</p>
<h3>1.1 服务注册 <a href="#scroller-2" id="scroller-2"></a></h3>
<p>如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。</p>
<p><img src="/images/blog/engineering/microservice-image_6_2.png" alt="image_6_2.png"></p>
<p>服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：</p>
<p>1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。</p>
<p>2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。</p>
<p>3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。</p>
<p>可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。</p>
<p><img src="/images/blog/engineering/microservice-image_6_3.png" alt="image_6_3.png"></p>
<h3>1.2 服务发现 <a href="#scroller-3" id="scroller-3"></a></h3>
<p>服务发现实际就是我们查询已经注册好的服务提供者，比如 p-&gt;p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，</p>
<p>返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。</p>
<p>这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。</p>
<p>服务发现的方式一般有两种：</p>
<p>1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。</p>
<p>2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。</p>
<h3>1.3 注册中心 <a href="#scroller-4" id="scroller-4"></a></h3>
<p>注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。</p>
<p>服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。</p>
<p>主要的检查方式包括：</p>
<p>1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。</p>
<p>2、注册中心主动检查服务Provider接口。</p>
<p>综合我们前面的内容，可以总结下注册中心有如下几种能力：</p>
<p>1、高可用</p>
<p>这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的</p>
<p>2、可视化操作</p>
<p>常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。</p>
<p>3、高效运维</p>
<p>注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。</p>
<p>4、权限控制</p>
<p>数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求</p>
<p>5、服务注册推、拉能力</p>
<p>这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。</p>
<p><img src="/images/blog/engineering/microservice-image_6_4.png" alt="image_6_4.png"></p>
<h2>2 现下的主流注册中心 <a href="#scroller-5" id="scroller-5"></a></h2>
<h3>2.1 Eureka <a href="#scroller-6" id="scroller-6"></a></h3>
<h4>2.1.1 介绍 <a href="#scroller-7" id="scroller-7"></a></h4>
<p>Eureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。</p>
<p>目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 <a href="https://github.com/Netflix/eureka/wiki">Eureka 2.0已经停止维护</a>，所以新的微服务架构设计中，不再建议使用。</p>
<p>Spring Cloud Netflix主要分为两个部分：</p>
<p>1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。</p>
<p>2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。</p>
<p><img src="/images/blog/engineering/microservice-image_6_5.png" alt="image_6_5.png"></p>
<p>Eureka有比较友好的管理界面，如上图所示：</p>
<p>1、System Status：显示当前Eureka Server信息。</p>
<p>2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。</p>
<p>3、General Info：基本信息，如cpu、内存、环境等。</p>
<h4>2.1.2 整体架构 <a href="#scroller-8" id="scroller-8"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_6.png" alt="image_6_6.png"></p>
<p>Eureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。</p>
<p>所以他有如下特点：</p>
<p>1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>
<p>2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。</p>
<p>3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p>
<p>同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。</p>
<p>4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。</p>
<h4>2.1.3 接入Spring Cloud <a href="#scroller-9" id="scroller-9"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_7.png" alt="image_6_7.png"></p>
<p>如上图所示：</p>
<p>1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -&gt; 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。</p>
<p>所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。</p>
<p>2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。</p>
<p>3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。</p>
<h3>2.2 ZooKeeper <a href="#scroller-10" id="scroller-10"></a></h3>
<h4>2.2.1 介绍 <a href="#scroller-11" id="scroller-11"></a></h4>
<p>作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。</p>
<p>这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。</p>
<p><img src="/images/blog/engineering/microservice-image_6_8.png" alt="image_6_8.png"></p>
<p>在数据模型上，类似于传统的文件系统，节点类型分为：</p>
<p>1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。</p>
<p>2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。</p>
<p>在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。</p>
<p><img src="/images/blog/engineering/microservice-image_6_9.png" alt="image_6_9.png"></p>
<p>Zookeeper有如下特点：</p>
<p>1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。</p>
<h4>2.2.2 整体架构 <a href="#scroller-12" id="scroller-12"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_10.png" alt="image_6_10.png"></p>
<p>上图是Zookeeper 的服务架构，他有如下流程：</p>
<p>1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；</p>
<p>2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。</p>
<p>3、Leader负责处理数据更新等操作（Zab协议）；</p>
<h4>2.2.3 接入Dubbo生态 <a href="#scroller-13" id="scroller-13"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_11.png" alt="image_6_11.png"></p>
<p>上图中的角色如下：</p>
<p>Provider：提供者,服务发布方</p>
<p>Consumer：消费者, 调用服务方</p>
<p>Container：Dubbo容器.依赖于Spring容器</p>
<p>Registry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置</p>
<p>Monitor:监听器</p>
<p>说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。</p>
<p>服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。</p>
<p>这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。</p>
<h3>2.3 Consul <a href="#scroller-14" id="scroller-14"></a></h3>
<h4>2.3.1 介绍 <a href="#scroller-15" id="scroller-15"></a></h4>
<p>Consul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：</p>
<p>1、Service Discovery（服务发现）</p>
<p>2、Configuration（配置化）</p>
<p>3、Segmentation Functionality</p>
<p>这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。</p>
<p>Consul提供的关键功能如下：</p>
<p>1、Service Discovery：服务注册/发现功能。</p>
<p>2、Health Checking：健康检查，丰富的健康检查方式；</p>
<p>3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。</p>
<p>4、Multi DataCenter：多数据中心。</p>
<h4>2.3.2 整体架构 <a href="#scroller-16" id="scroller-16"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_12.png" alt="image_6_12.png"></p>
<p>如上图为Consul的架构，这边对技术点做一下说明：</p>
<p>1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式</p>
<p>2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。</p>
<p>3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。</p>
<p>4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。</p>
<p>5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。</p>
<p>6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。</p>
<p>7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。</p>
<p>8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。</p>
<p>9、RPC: 远程过程调用，用于服务之间的通信。</p>
<p>10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。</p>
<p>所以是典型的CP模式。</p>
<p><img src="/images/blog/engineering/microservice-image_6_13.png" alt="image_6_13.png"></p>
<p>根据Consul 的选举机制和服务原理，我们有两个注意点 ：</p>
<p>1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。</p>
<p>2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。</p>
<p>有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。</p>
<h4>2.3.3 生态对接 <a href="#scroller-17" id="scroller-17"></a></h4>
<p><strong>对接Spring Cloud生态</strong></p>
<p><img src="/images/blog/engineering/microservice-image_6_14.png" alt="image_6_14.png"></p>
<p>Consul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。</p>
<p>但是这边的健康检查更丰富，可以有多种不同的的Check方式：</p>
<ul>
<li>Script check（Script+ Interval）</li>
<li>基于HTTP请求</li>
<li>基于tcp请求</li>
<li>基于grpc请求</li>
</ul>
<h3>2.4 总结对比 <a href="#scroller-19" id="scroller-19"></a></h3>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>Eureka</strong></th>
<th><strong>Zookeeper</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Etcd</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一致性协议</td>
<td>AP</td>
<td>CP（Paxos算法）</td>
<td>CP（Raft算法）</td>
<td>CP（Raft算法）</td>
</tr>
<tr>
<td>健康检查</td>
<td>TTL(Time To Live)</td>
<td>TCP Keep Alive</td>
<td>TTL\HTTP\TCP\Script</td>
<td>Lease TTL KeepAlive</td>
</tr>
<tr>
<td>watch/long polling</td>
<td>不支持</td>
<td>watch</td>
<td>long polling</td>
<td>watch</td>
</tr>
<tr>
<td>雪崩保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>安全与权限</td>
<td>不支持</td>
<td>ACL</td>
<td>ACL</td>
<td>RBAC</td>
</tr>
<tr>
<td>是否支持多数据中心</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有管理界面</td>
<td>是</td>
<td>否（可用第三方ZkTools）</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Spring Cloud 集成</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Dubbo 集成</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>K8S 集成</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。</p>
<p>当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。</p>
<p>如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/fffdcdb4fb651185.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"wlOkUxTzHfxl8sQA11M8Z\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"architecture\",\"%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/architecture/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fffdcdb4fb651185.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/architecture/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"x9Am-glu8PBirFcIUG1osv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1b:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T5070,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e1 微服务的注册与发现 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。\u003c/p\u003e\n\u003cp\u003e微服务注册与发现类似于生活中的\u0026quot;电话通讯录\u0026quot;的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。\u003c/p\u003e\n\u003cp\u003e步骤如下：\u003c/p\u003e\n\u003cp\u003e1、你先要把\u0026quot;好友某某\u0026quot;记录在通讯录中。\u003c/p\u003e\n\u003cp\u003e2、拨打电话的时候通过通讯录中找到\u0026quot;好友某某\u0026quot;，并拨通回电话。\u003c/p\u003e\n\u003cp\u003e3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。\u003c/p\u003e\n\u003cp\u003e从这个过程中我们看到了一些特点：\u003c/p\u003e\n\u003cp\u003e1、把 \u0026quot;好友某某\u0026quot; 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。\u003c/p\u003e\n\u003cp\u003e2、后续我们通过\u0026quot;好友某某\u0026quot;就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。\u003c/p\u003e\n\u003cp\u003e而我们微服务架构中的服务注册与发现结构如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_1.png\" alt=\"image_6_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：\u003c/p\u003e\n\u003cp\u003eprovider - 服务提供者\u003c/p\u003e\n\u003cp\u003econsumer - 服务消费者\u003c/p\u003e\n\u003cp\u003eregister center - 注册中心\u003c/p\u003e\n\u003cp\u003e它们之间的关系大致如下：\u003c/p\u003e\n\u003cp\u003e1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。\u003c/p\u003e\n\u003cp\u003e2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。\u003c/p\u003e\n\u003cp\u003e3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。\u003c/p\u003e\n\u003cp\u003e优点如下：\u003c/p\u003e\n\u003cp\u003e1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响\u003c/p\u003e\n\u003cp\u003e2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响\u003c/p\u003e\n\u003cp\u003e3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。\u003c/p\u003e\n\u003cp\u003e从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。\u003c/p\u003e\n\u003ch3\u003e1.1 服务注册 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_2.png\" alt=\"image_6_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：\u003c/p\u003e\n\u003cp\u003e1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。\u003c/p\u003e\n\u003cp\u003e2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。\u003c/p\u003e\n\u003cp\u003e3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。\u003c/p\u003e\n\u003cp\u003e可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_3.png\" alt=\"image_6_3.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 服务发现 \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e服务发现实际就是我们查询已经注册好的服务提供者，比如 p-\u0026gt;p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，\u003c/p\u003e\n\u003cp\u003e返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。\u003c/p\u003e\n\u003cp\u003e这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。\u003c/p\u003e\n\u003cp\u003e服务发现的方式一般有两种：\u003c/p\u003e\n\u003cp\u003e1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。\u003c/p\u003e\n\u003cp\u003e2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。\u003c/p\u003e\n\u003ch3\u003e1.3 注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。\u003c/p\u003e\n\u003cp\u003e服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。\u003c/p\u003e\n\u003cp\u003e主要的检查方式包括：\u003c/p\u003e\n\u003cp\u003e1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。\u003c/p\u003e\n\u003cp\u003e2、注册中心主动检查服务Provider接口。\u003c/p\u003e\n\u003cp\u003e综合我们前面的内容，可以总结下注册中心有如下几种能力：\u003c/p\u003e\n\u003cp\u003e1、高可用\u003c/p\u003e\n\u003cp\u003e这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的\u003c/p\u003e\n\u003cp\u003e2、可视化操作\u003c/p\u003e\n\u003cp\u003e常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。\u003c/p\u003e\n\u003cp\u003e3、高效运维\u003c/p\u003e\n\u003cp\u003e注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。\u003c/p\u003e\n\u003cp\u003e4、权限控制\u003c/p\u003e\n\u003cp\u003e数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求\u003c/p\u003e\n\u003cp\u003e5、服务注册推、拉能力\u003c/p\u003e\n\u003cp\u003e这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_4.png\" alt=\"image_6_4.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e2 现下的主流注册中心 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e2.1 Eureka \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.1.1 介绍 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eEureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。\u003c/p\u003e\n\u003cp\u003e目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 \u003ca href=\"https://github.com/Netflix/eureka/wiki\"\u003eEureka 2.0已经停止维护\u003c/a\u003e，所以新的微服务架构设计中，不再建议使用。\u003c/p\u003e\n\u003cp\u003eSpring Cloud Netflix主要分为两个部分：\u003c/p\u003e\n\u003cp\u003e1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。\u003c/p\u003e\n\u003cp\u003e2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_5.png\" alt=\"image_6_5.png\"\u003e\u003c/p\u003e\n\u003cp\u003eEureka有比较友好的管理界面，如上图所示：\u003c/p\u003e\n\u003cp\u003e1、System Status：显示当前Eureka Server信息。\u003c/p\u003e\n\u003cp\u003e2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。\u003c/p\u003e\n\u003cp\u003e3、General Info：基本信息，如cpu、内存、环境等。\u003c/p\u003e\n\u003ch4\u003e2.1.2 整体架构 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_6.png\" alt=\"image_6_6.png\"\u003e\u003c/p\u003e\n\u003cp\u003eEureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。\u003c/p\u003e\n\u003cp\u003e所以他有如下特点：\u003c/p\u003e\n\u003cp\u003e1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。\u003c/p\u003e\n\u003cp\u003e2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。\u003c/p\u003e\n\u003cp\u003e3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。\u003c/p\u003e\n\u003cp\u003e同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。\u003c/p\u003e\n\u003cp\u003e4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。\u003c/p\u003e\n\u003ch4\u003e2.1.3 接入Spring Cloud \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_7.png\" alt=\"image_6_7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示：\u003c/p\u003e\n\u003cp\u003e1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -\u0026gt; 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。\u003c/p\u003e\n\u003cp\u003e所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。\u003c/p\u003e\n\u003cp\u003e2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。\u003c/p\u003e\n\u003cp\u003e3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。\u003c/p\u003e\n\u003ch3\u003e2.2 ZooKeeper \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.2.1 介绍 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。\u003c/p\u003e\n\u003cp\u003e这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_8.png\" alt=\"image_6_8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在数据模型上，类似于传统的文件系统，节点类型分为：\u003c/p\u003e\n\u003cp\u003e1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。\u003c/p\u003e\n\u003cp\u003e2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。\u003c/p\u003e\n\u003cp\u003e在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_9.png\" alt=\"image_6_9.png\"\u003e\u003c/p\u003e\n\u003cp\u003eZookeeper有如下特点：\u003c/p\u003e\n\u003cp\u003e1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。\u003c/p\u003e\n\u003ch4\u003e2.2.2 整体架构 \u003ca href=\"#scroller-12\" id=\"scroller-12\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_10.png\" alt=\"image_6_10.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图是Zookeeper 的服务架构，他有如下流程：\u003c/p\u003e\n\u003cp\u003e1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；\u003c/p\u003e\n\u003cp\u003e2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。\u003c/p\u003e\n\u003cp\u003e3、Leader负责处理数据更新等操作（Zab协议）；\u003c/p\u003e\n\u003ch4\u003e2.2.3 接入Dubbo生态 \u003ca href=\"#scroller-13\" id=\"scroller-13\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_11.png\" alt=\"image_6_11.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图中的角色如下：\u003c/p\u003e\n\u003cp\u003eProvider：提供者,服务发布方\u003c/p\u003e\n\u003cp\u003eConsumer：消费者, 调用服务方\u003c/p\u003e\n\u003cp\u003eContainer：Dubbo容器.依赖于Spring容器\u003c/p\u003e\n\u003cp\u003eRegistry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置\u003c/p\u003e\n\u003cp\u003eMonitor:监听器\u003c/p\u003e\n\u003cp\u003e说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。\u003c/p\u003e\n\u003cp\u003e服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。\u003c/p\u003e\n\u003cp\u003e这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。\u003c/p\u003e\n\u003ch3\u003e2.3 Consul \u003ca href=\"#scroller-14\" id=\"scroller-14\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.3.1 介绍 \u003ca href=\"#scroller-15\" id=\"scroller-15\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eConsul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：\u003c/p\u003e\n\u003cp\u003e1、Service Discovery（服务发现）\u003c/p\u003e\n\u003cp\u003e2、Configuration（配置化）\u003c/p\u003e\n\u003cp\u003e3、Segmentation Functionality\u003c/p\u003e\n\u003cp\u003e这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。\u003c/p\u003e\n\u003cp\u003eConsul提供的关键功能如下：\u003c/p\u003e\n\u003cp\u003e1、Service Discovery：服务注册/发现功能。\u003c/p\u003e\n\u003cp\u003e2、Health Checking：健康检查，丰富的健康检查方式；\u003c/p\u003e\n\u003cp\u003e3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。\u003c/p\u003e\n\u003cp\u003e4、Multi DataCenter：多数据中心。\u003c/p\u003e\n\u003ch4\u003e2.3.2 整体架构 \u003ca href=\"#scroller-16\" id=\"scroller-16\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_12.png\" alt=\"image_6_12.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图为Consul的架构，这边对技术点做一下说明：\u003c/p\u003e\n\u003cp\u003e1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式\u003c/p\u003e\n\u003cp\u003e2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。\u003c/p\u003e\n\u003cp\u003e3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。\u003c/p\u003e\n\u003cp\u003e4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。\u003c/p\u003e\n\u003cp\u003e5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。\u003c/p\u003e\n\u003cp\u003e6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。\u003c/p\u003e\n\u003cp\u003e7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。\u003c/p\u003e\n\u003cp\u003e8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。\u003c/p\u003e\n\u003cp\u003e9、RPC: 远程过程调用，用于服务之间的通信。\u003c/p\u003e\n\u003cp\u003e10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。\u003c/p\u003e\n\u003cp\u003e所以是典型的CP模式。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_13.png\" alt=\"image_6_13.png\"\u003e\u003c/p\u003e\n\u003cp\u003e根据Consul 的选举机制和服务原理，我们有两个注意点 ：\u003c/p\u003e\n\u003cp\u003e1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。\u003c/p\u003e\n\u003cp\u003e2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。\u003c/p\u003e\n\u003cp\u003e有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。\u003c/p\u003e\n\u003ch4\u003e2.3.3 生态对接 \u003ca href=\"#scroller-17\" id=\"scroller-17\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e对接Spring Cloud生态\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_14.png\" alt=\"image_6_14.png\"\u003e\u003c/p\u003e\n\u003cp\u003eConsul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。\u003c/p\u003e\n\u003cp\u003e但是这边的健康检查更丰富，可以有多种不同的的Check方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScript check（Script+ Interval）\u003c/li\u003e\n\u003cli\u003e基于HTTP请求\u003c/li\u003e\n\u003cli\u003e基于tcp请求\u003c/li\u003e\n\u003cli\u003e基于grpc请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2.4 总结对比 \u003ca href=\"#scroller-19\" id=\"scroller-19\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e指标\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEureka\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eZookeeper\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eConsul\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEtcd\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e一致性协议\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003ctd\u003eCP（Paxos算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e健康检查\u003c/td\u003e\n\u003ctd\u003eTTL(Time To Live)\u003c/td\u003e\n\u003ctd\u003eTCP Keep Alive\u003c/td\u003e\n\u003ctd\u003eTTL\\HTTP\\TCP\\Script\u003c/td\u003e\n\u003ctd\u003eLease TTL KeepAlive\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewatch/long polling\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003ctd\u003elong polling\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e雪崩保护\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全与权限\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eRBAC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持多数据中心\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否有管理界面\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否（可用第三方ZkTools）\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud 集成\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDubbo 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eK8S 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。\u003c/p\u003e\n\u003cp\u003e当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。\u003c/p\u003e\n\u003cp\u003e如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T148b,"])</script><script>self.__next_f.push([1,"\u003cp\u003e关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。\u003c/p\u003e\n\u003cp\u003e1. AKF扩展立方体\u003c/p\u003e\n\u003cp\u003eAKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度（见下图），分别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eX轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eY轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关注应用中职责的划分，比如数据类型、交易执行类型的划分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eZ轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关注服务和数据的优先级划分，如分地域划\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_5_1.png\" alt=\"image_5_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e以上X、Y和Z轴的划分可以概括为X 轴关注水平复制，Z 轴类似数据分区，而Y 轴则强调基于不同的业务拆分。理论上按照这三个扩展维度，可以将一个单体系统进行无限扩展。举例来说，比如用户预约挂号应用，一个集群撑不住时，分了多个集群，后来用户激增还是不够用，经过分析发现是用户和医生访问量很大，就将预约挂号应用拆成了患者服务、医生服务、支付服务等三个服务。三个服务的业务特点各不相同，独立维护，各自都可以再次按需扩展。\u003c/p\u003e\n\u003cp\u003e在上图中，Y轴就是我们所说的微服务的拆分模式，即基于不同的业务进行拆分。但在进行业务拆分过程中，我们发现业务往往与数据有较大耦合性，所以接下去我们把业务和数据结合起来对服务拆分的维度展开讨论。\u003c/p\u003e\n\u003cp\u003e2. 业务与数据\u003c/p\u003e\n\u003cp\u003e服务拆分存在两大维度，即业务与数据。业务体现在各种功能代码中，通过确定业务的边界，并使用领域与界限上下文、领域事件等技术手段可以实现拆分。而数据的拆分则体现在如何将集中式的中心化数据转变为各个微服务各自拥有的独立数据，这部分工作同样十分具有挑战性。\u003c/p\u003e\n\u003cp\u003e关于业务和数据谁应该先拆分的问题，可以是先数据库后业务代码，也可以是先业务代码后数据库。然而在拆分中遇到的最大挑战可能会是数据层的拆分，因为在数据库中，可能会存在各种跨表连接查询、跨库连接查询以及不同业务模块的代码与数据耦合得非常紧密的场景，这会导致服务的拆分非常的困难。因此在拆分步骤上我们更多的推荐数据库先行。数据模型能否彻底分开，很大程度上决定了微服务的边界功能是否彻底划清。\u003c/p\u003e\n\u003cp\u003e服务拆分的方法需要根据系统自身的特点和运行状态，通常分为绞杀者与修缮者两种模式。\u003c/p\u003e\n\u003cp\u003e1. 绞杀者模式\u003c/p\u003e\n\u003cp\u003e绞杀者模式（Strangler Pattern）最早由\u003ca href=\"https://www.martinfowler.com/\"\u003eMartin Fowler\u003c/a\u003e提出，指的是在现有系统外围将新功能用新的方式构建为新的服务的策略，通过将新功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。采用这种策略，随着时间的推移，新的服务就会逐渐“绞杀”老的系统。对于那些规模很大而又难以对现有架构进行修改的遗留系统，推荐采用绞杀者模式。\u003c/p\u003e\n\u003cp\u003e绞杀者模式的示意图如下图所示，我们可以看到随着功能演进和时间的不断推移，老的遗留系统功能被逐步削弱，而采用微服务架构的新功能越积越多，最终会形成从量变到质变的过程。绞杀者模式在具体实施过程中，所需要把握的最主要一点原则就是对于任何需要开发的功能一定要完整的采用微服务架构，对于完全独立的新功能这点比较容易把握，而对于涉及到老业务变更的新功能则需要通过重构达到这一目标。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_5_2.png\" alt=\"image_5_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e2. 修缮者模式\u003c/p\u003e\n\u003cp\u003e修缮者模式就如修房或修路一样，将老旧待修缮的部分进行隔离，用新的方式对其进行单独修复。修复的同时，需保证与其他部分仍能协同功能。从这种思路出发，修缮者模式更多表现为一种重构技术。修缮者模式在具体实现上可以参考Martine Fowler的BranchByAbstraction重构方法，该重构方法的示意图如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_5_3.png\" alt=\"image_5_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e从上图中，可以看到这种模式的实现方式可以分成三个主要步骤。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层提取\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先通过识别内部的待拆分功能，对其增加抽象接口层，同时对原有代码进行改造，确保其同样实现该抽象层。这样在依赖关系上就添加了一个中间层。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为抽象层提供新的实现，新的实现采用微服务方式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层替换\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e采用新的实现对原有的各个抽象层实现进行逐步替换，直至原有实现被完全废弃，从而完成新老实现方式之间的替换。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"18:T4849,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e服务注册中心 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。\u003c/p\u003e\n\u003cp\u003e并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景下做正确的技术选型。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e指标\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEureka\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eZookeeper\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eConsul\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEtcd\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e一致性协议\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003ctd\u003eCP（Paxos算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e健康检查\u003c/td\u003e\n\u003ctd\u003eTTL(Time To Live)\u003c/td\u003e\n\u003ctd\u003eTCP Keep Alive\u003c/td\u003e\n\u003ctd\u003eTTL\\HTTP\\TCP\\Script\u003c/td\u003e\n\u003ctd\u003eLease TTL KeepAlive\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewatch/long polling\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003ctd\u003elong polling\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e雪崩保护\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全与权限\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eRBAC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持多数据中心\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否有管理界面\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否（可用第三方ZkTools）\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud 集成\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDubbo 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eK8S 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e我们可以看出，四种技术类型对Spring Cloud的支持度都很高。Spring Cloud是微服务架构的一站式解决方案，我们平时构建微服务的过程中需要做的的如 配置管理、服务发现、负载均衡、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作。Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。\u003c/p\u003e\n\u003cp\u003eSpring Cloud包含了多个不同开源产品，来保证一站式的微服务解决方案，如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。\u003c/p\u003e\n\u003ch2\u003eSpring Cloud 框架下实现 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSpring Cloud为服务治理做了一层抽象，这样能够支持多种不同的服务治理框架，比如：Netflix Eureka、Consul。我们这边就以这两个为例子，看看服务治理是如何实现。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e在Spring Cloud服务治理抽象层的作用下，可以无缝地切换服务治理实现，且不影响任何其他的服务注册、发现、调用逻辑。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e所以，下面我们通过介绍这两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e2.Spring Cloud Eureka \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSpring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。\u003c/p\u003e\n\u003cp\u003e通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。\u003c/p\u003e\n\u003cp\u003e下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。\u003c/p\u003e\n\u003ch4\u003e2.1.创建注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e创建一个Spring Cloud项目，我们命名为micro-service-center，并在\u003ccode\u003epom.xml\u003c/code\u003e中引入需要的依赖内容：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e表明这个项目中可以没有Java代码，也不执行任何代码，只是为了聚合工程或者传递依赖，所以可以把src文件夹删了。这是一个父级项目，因为我们还要在下面建立Eureka的注册中心、客户端等多个子项目 。\u003c/p\u003e\n\u003cp\u003e在micro-service-center下，新建一个命名为 eureka-service 的Module，依旧是Spring Cloud 项目，建完之后，pom.xml做如下改动：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n    \u0026lt;!--在子工程中添加父工程名称--\u0026gt;\n    \u0026lt;parent\u0026gt;\n        \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n        \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;/parent\u0026gt;\n    \u0026lt;dependencies\u0026gt;\n        \u0026lt;!--加入 eureka 服务 --\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;spring-cloud-netflix-eureka-server\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n    \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e改完之后，回到父项目micro-service-center，修改pom中的信息：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n    \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n    \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;name\u0026gt;center\u0026lt;/name\u0026gt;\n    \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt;\n    \u0026lt;!--在父工程添加子工程名称--\u0026gt;\n    \u0026lt;modules\u0026gt;\n        \u0026lt;module\u0026gt;eureka-service\u0026lt;/module\u0026gt;\n        \u0026lt;module\u0026gt;eureka-client\u0026lt;/module\u0026gt;\n    \u0026lt;/modules\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对两个项目进行clean + install，应该是成功的。\u003c/p\u003e\n\u003cp\u003eeureka-service我们是作为注册中心来用的，所以在它的主类Application中加入\u003ccode\u003e@EnableEurekaServer\u003c/code\u003e注解，就能开启注册中心功能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableEurekaServer\npublic class ServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceApplication.class, args);\n        System.out.println(\u0026quot;Start Eureka Service\u0026quot;);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是默认情况下，该注册中心也会把自己当做客户端，那就变成自己注册自己了，这个是可以剔除的，我们看一下它的YAML中的详细配置，注释比较清楚：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e  server:\n    port: 1000\n  spring:\n    application:\n      name: eureka-server\n  eureka:\n    instance:\n      hostname: localhost\n    client:\n    register-with-eureka: false  # 不作为客户端进行注册\n    fetch-registry: false  # 不获取注册列表\n    service-url:  # 注册地址，客户端需要注册到该地址中\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e文中的注释还是比较清楚的。 这边可以看到，端口号是1000，所以当工程启动之后，访问 \u003ca href=\"http://localhost:1000/\"\u003ehttp://localhost:1000/\u003c/a\u003e 是可以看到Eureka注册中心页面的。其中还没有发现任何服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_7_1.png\" alt=\"image_7_1.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.1.创建客户端 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e目前服务中心还是空的，所以我们创建一个能够提供服务的客户端，并将其注册到注册中心去。\u003c/p\u003e\n\u003cp\u003e同样的，我们创建一个Spring Cloud的子项目，命名为\u003ccode\u003eeureka-client\u003c/code\u003e，\u003ccode\u003epom.xml\u003c/code\u003e中的配置如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e  \n\u0026lt;xml\u0026gt;\n    \u0026lt;!--在子工程中添加父工程名称--\u0026gt;\n    \u0026lt;parent\u0026gt;\n        \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n        \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;/parent\u0026gt;\n    \u0026lt;dependencies\u0026gt;\n        \u0026lt;!--加入 eureka 服务 --\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;spring-cloud-netflix-eureka-server\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n    \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在应用主类Application文件中通过加上\u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e注解，该注解保证当前服务被Eureka当成provider发现。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ClientApplication.class, args);\n        System.out.println(\u0026quot;start client!\u0026quot;);\n    }\n}jC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在YAML文件上加上如下配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eserver:\n  port: 1001\nspring:\n  application:\n    name: eureka-client\neureka:\n  client:\n    service-url:  # 这边就保证了注册到 eureka-service 这个注册中心去\n      defaultZone: http://localhost:1000/eureka/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003espring.application.name\u003c/code\u003e属性，指定了微服务的名称，在调用的时候可以通过该名称进行服务访问。\u003ccode\u003eeureka.client.serviceUrl.defaultZone\u003c/code\u003e属性对应服务注册中心的配置内容，指定服务注册中心的位置。\u003c/p\u003e\n\u003cp\u003e大家看到，这边端口设置为1001，那是因为要在本机上测试 服务提供方 和 服务注册中心，所以\u003ccode\u003eserver的port\u003c/code\u003e属性需设置不同的端口。\u003c/p\u003e\n\u003cp\u003e最后，我们再写一个接口，通过DiscoveryClient对象，在客户端中获取注册中心的所有服务信息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  @Controller\n  @RequestMapping(\u0026quot;/eurekacenter\u0026quot;)\n  public class EuServiceController {\n  \n    @Autowired\n    DiscoveryClient discoveryClient;\n    \n    @RequestMapping(value = \u0026quot;/service\u0026quot;, method = {RequestMethod.GET})\n    @ResponseBody\n    public String getServiceInfo() {\n       return  \u0026quot;service:\u0026quot;+discoveryClient.getServices()+\u0026quot; , memo:\u0026quot;+discoveryClient.description();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时候跑一下试试看，继续访问之前的地址：\u003ca href=\"http://localhost:1000/\"\u003ehttp://localhost:1000/\u003c/a\u003e ，可以看到Eureka注册中心页面已经包含一个我们定义的服务了，就是上面新建的 100端口的服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_7_2.png\" alt=\"image_7_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同样，我们可以调用上面的那个获取注册服务信息的接口，从服务发现的角度看看有多少个服务被注册到注册中心去。 \u003ca href=\"http://localhost:1001/eurekacenter/service\"\u003ehttp://localhost:1001/eurekacenter/service\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_7_3.png\" alt=\"image_7_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示，方括号中的\u003ccode\u003eeureka-client\u003c/code\u003e通过Spring Cloud定义的 getServiceInfo 接口在eureka的实现中获取到的所有服务清单，他是一个String的List，如果注册了多个提供者，就会全部显示。\u003c/p\u003e\n\u003ch3\u003e2.Spring Cloud Consul \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eConsul 用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更具“一站式”特征，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 之类的）。\u003c/p\u003e\n\u003cp\u003e而Spring Cloud Consul ，是将其作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。\u003c/p\u003e\n\u003ch4\u003e2.2.Consul 的优势 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接。\u003c/p\u003e\n\u003cp\u003e2、支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持，上面表格中有体现。\u003c/p\u003e\n\u003cp\u003e3、支持健康检查。\u003c/p\u003e\n\u003cp\u003e4、支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。\u003c/p\u003e\n\u003cp\u003e5、官方提供 web 管理界面, etcd 无此功能。\u003c/p\u003e\n\u003ch4\u003e2.2.Consul的特性 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、服务发现\u003c/p\u003e\n\u003cp\u003e2、健康检查\u003c/p\u003e\n\u003cp\u003e3、Key/Value存储\u003c/p\u003e\n\u003cp\u003e4、多数据中心\u003c/p\u003e\n\u003ch4\u003e2.2.安装Consul注册中心 \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、官方下载64版本 ：\u003ca href=\"https://www.consul.io/downloads.html\"\u003ehttps://www.consul.io/downloads.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e2、解压后复制到目录 /usr/local/bin 下\u003c/p\u003e\n\u003cp\u003e3、启动终端，先看下啥版本的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eliyifei@MacPro ~ % consul --version\nConsul v1.10.4\nRevision 7bbad6fe\nProtocol spoken by default, understands to (agent will automatically use protocol \u0026gt;when speaking to compatible agents)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e4、执行安装命令，可以看到他的 Client Addr 的端口为8500。所以访问 8500端口站点，\u003ca href=\"http://127.0.0.1:8500/ui/dc1/services\"\u003ehttp://127.0.0.1:8500/ui/dc1/services\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e  liyifei@MacPro ~ % consul agent -dev\n  ==\u0026gt; Starting Consul agent...\n             Version: \u0026#39;1.10.4\u0026#39;\n             Node ID: \u0026#39;6db154b4-62ff-e67d-e745-1a7270fa1ce8\u0026#39;\n           Node name: \u0026#39;B000000147796DS\u0026#39;\n          Datacenter: \u0026#39;dc1\u0026#39; (Segment: \u0026#39;\u0026lt;all\u0026gt;\u0026#39;)\n              Server: true (Bootstrap: false)\n         Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)\n        Cluster Addr: 127.0.0.(LAN: 8301, WAN: 8302)\n           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_7_4.png\" alt=\"image_7_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我们可以看到，现在没有客户端注册上来，只有一个自身的实例。\u003c/p\u003e\n\u003ch4\u003e2.2.创建服务提供者 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。\u003c/p\u003e\n\u003cp\u003e我们在micro-service-center下新建一个cloud项目consul-client，该项目pom文件添加如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n  \u0026lt;!--    在子工程中添加父工程名称--\u0026gt;\n  \u0026lt;parent\u0026gt;\n    \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n  \u0026lt;/parent\u0026gt;\n  \n  \u0026lt;dependencies\u0026gt;\n    \u0026lt;!--        Consul服务发现--\u0026gt;\n    \u0026lt;dependency\u0026gt;\n        \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt;\n    \u0026lt;/dependency\u0026gt;\n    \u0026lt;!--        Consul健康检查--\u0026gt;\n    \u0026lt;dependency\u0026gt;\n        \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt;\n    \u0026lt;/dependency\u0026gt;\n  \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后修改一下\u003ccode\u003eapplication.yml的配置信息\u003c/code\u003e，将consul配置写入，注释应该很清楚了，如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003espring:\n  application:\n    name: consul-producer # 当前服务的名称\n  cloud:\n    consul: # 以下为Consuk注册中心的地址，如果安装的不是这个host和port，这边可以调整\n      host: localhost\n      port: 8500\nserver:\n  port: 850# 当前服务的端口\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同样的，我们要在应用主类Application文件中通过加上\u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e注解，该注解保证当前服务被Consul当成provider发现。\u003c/p\u003e\n\u003cp\u003e大家看到这个做法跟Eureka一样，因为Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，\u003c/p\u003e\n\u003cp\u003e程序上不需要做改变，只需要引入不同的服务治理依赖，并配置相关的配置属性 就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ClientApplication.class, args);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改完成之后，我们就可以把这个服务提供者启动了，然后再去注册中心查看服务的注册情况，就可以看到被注册进来的Provider（consul-producer）：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_7_5.png\" alt=\"image_7_5.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e总结 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e除了 Eureka、Consul，还有其他的的注册中心技术，如Zookeeper、Nocas等。但无论何种注册中心技术，本质上都是为了解决微服务中的如下问题：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解耦服务之间相互依赖的细节\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们知道服务之间的远程调用必须要知道对方的IP、端口信息。我们可以在调用方直接配置被调用方的IP、端口，这种调用方直接依赖IP、端口的方式存在明显的问题，如被调用的IP、端口变化后，调用方法也要同步修改。\u003c/p\u003e\n\u003cp\u003e通过服务发现，将服务之间IP与端口的依赖转化为服务名的依赖，服务名可以根据具微服务业务来做标识，因此，屏蔽、解耦服务之间的依赖细节是服务发现与注册解决的第一个问题。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对微服务进行动态管理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构中，服务众多，服务之间的相互依赖也错综复杂，无论是服务主动停止，意外挂掉，还是因为流量增加对服务实现进行扩容，这些服务数据或状态上的动态变化，都需要尽快的通知到被调用方，被调用方才采取相应的措施。因此，对于服务注册与发现要实时管理者服务的数据与状态，包括服务的注册上线、服务主动下线，异常服务的剔除。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"19:T22ab,"])</script><script>self.__next_f.push([1,"\u003cp\u003e前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。\u003c/p\u003e\n\u003cp\u003e对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移。\u003c/p\u003e\n\u003ch3\u003e1 微服务迁移准备  \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e1、需对业务充分了解，这是服务拆分，通信设计，资源整合的必要前提。\u003c/p\u003e\n\u003cp\u003e2、适应微服务架构设计原则：小版本，高速迭代。\u003c/p\u003e\n\u003cp\u003e3、快速的环境提供能力：依赖于云计算、容器技术，快速交付环境。\u003c/p\u003e\n\u003cp\u003e4、服务合理拆分：需符合团队结构或能逆向影响，能对组织架构进行微调并划分职责。（康威定律和逆康威定律）\u003c/p\u003e\n\u003cp\u003e5、基本的监控能力：包括基础的技术监控和业务监控。\u003c/p\u003e\n\u003cp\u003e6、快速的应用部署能力：需要部署管道提供快速的部署能力。\u003c/p\u003e\n\u003cp\u003e7、DevOps 自动化运维能力：需要具有良好的持续集成和持续交付能力，还需要对问题、故障的快速响应能力，开发、测试和运维能协同工作。\u003c/p\u003e\n\u003ch3\u003e2 微服务颗粒的拆分策略 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e前面两篇文章我们学习了What \u0026amp; Why（什么是微服务和为什么需要做微服务架构），这一章我们就来探讨如何做微服务架构的拆分（How）。\u003c/p\u003e\n\u003cp\u003e微服务拆分没有一个绝对的标准答案，服务拆分的粒度需要根据业务场景来规划，而随着业务的发展，原先的架构方案也需要做调整。\u003c/p\u003e\n\u003cp\u003e虽然没有固定的套路，但是我们在业务实践过程中总结的一些经验，以做参考。\u003c/p\u003e\n\u003ch4\u003e2.1 基于业务逻辑拆分 \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e基于业务逻辑拆分相对好理解一点，典型的单一职责原则，我们将功能相近的业务整合到一个服务颗粒上。比如一个办公领域系统，考勤、工作流、音视频会议是是三个截然不同的业务领域，这可能就是我们拆分的一个入手点。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.1.1 领域模型拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e领域驱动设计DDD（Domain-Driven Design 领域驱动设计）是一个很简单的概念，表示我们对系统的划分是基于领域的，也即是基于业务方向去思考的。\u003c/p\u003e\n\u003cp\u003e举一个典型的电商业务例子。电商的业务体系庞大，涉及各方面的细节。但是我们大概能够根据业务的职能做一个拆分，比如阿里的电商中台业务，包含 用户账号子系统、商品子系统、订单子系统、客户子系统、物流子系统 等。\u003c/p\u003e\n\u003cp\u003e因为职能不同，这些领域之间包含清晰的界限，所以我们可以按照这个方向将服务于不同领域（商品域和订单域）的子系统拆成独立的服务颗粒。如下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_7.png\" alt=\"image_6_7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.1.2 用户群体拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e根据用户群体做拆分，我们首先要了解自己的系统业务里的用户角色领域是否没有功能耦合，有清晰的领域界限。\u003c/p\u003e\n\u003cp\u003e比如教育信息化系统，教师的业务场景和学生的业务场景，基本比较独立，而且拆分后流量上有明显的削弱，这时候结合具体的业务分析，看是否有价值。如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_2.png\" alt=\"image_4_2.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.2 基于可扩展拆分  \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这个需要区分系统中变与不变的部分，不变的部分一般是成熟的、通用的服务功能，变的部分一般是改动比较多、满足业务迭代扩展性需要的功能，我们可以将不变的部分拆分出来，作为共用的服务，将变的部分独立出来满足个性化扩展需要。同时根据二八原则，系统中经常变动的部分大约只占 20%，而剩下的 80% 基本不变或极少变化，这样的拆分也解决了发布频率过多而影响成熟服务稳定性的问题。比如一个电商领域的系统，用户信息、基本商品信息、物流信息 等模块的管理能力和视图界面，一般是比较稳定的；而类似运营活动的功能和页面一般是经常变化的（520、618、双11），会有不同的活动策略和视图界面，需要经常迭代发布。如下图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_3.png\" alt=\"image_4_3.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.3 基于可靠性拆分 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e2.3.1 核心模块拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们团队在做MySQL数据库和Redis集群拆分的时候，总会把一些重要的模块独立放在一个集群上，不与其他模块混用，而这个独立的集群，服务机性能要是最好的。这样做的目的是，当重要度较低的模块发生故障时，不会影响重要度高的模块。\u003c/p\u003e\n\u003cp\u003e同要的道理，我们会将  账号信息、登录信息、服务中心等重要度最高的要害模块单独拆分在一个服务颗粒上（因为这类模块不可用之后，整个系统基本完全瘫痪），再做成服务集群，来保障它的高可用。 如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_4.png\" alt=\"image_4_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.3.2 主次链路拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在各个业务系统中，其实都会有主次业务链路。主业务链条，完成了业务系统中最核心的那部分工作。而次链路是保证其他基础功能的稳定运行。\u003c/p\u003e\n\u003cp\u003e以电商为例子：商品搜索-\u0026gt;商品详情页-\u0026gt;购物车模块-\u0026gt;订单结算-\u0026gt;支付业务，就是一条最简单的主链路。主链路是整个系统的核心主战场，最好的资源跟火力都要放在这里，保证不失守。\u003c/p\u003e\n\u003cp\u003e一个系统一般有多条核心链路和多条次链路，互相支持构成一个完整的系统。而我们将主次链路进行拆分，主要为了以下几个目标。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e异常容错\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e为主链路建立层次化的降级策略（多级降级），以及合理的熔断策略，这部分我们将在Hystrix服务容错降级的文章中详细解释。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e计算资源分配\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e主链路通常来讲都是高频场景，自然需要更多的计算资源，最主要的体现就是集群里分配的虚机数量多。比如电商场景中特惠专场抢购等。\u003c/p\u003e\n\u003cp\u003e但是无论是虚机的分配，还是kubernetes的动态扩缩容，应该都需要单独优待，如资源分配倾斜，独立治理等。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e服务隔离\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e主链路是高频且核心的主业务模块，把主链路的服务与其他起辅助作用的业务服务隔离开来，避免次链路服务的异常情况影响到主链路服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_5.png\" alt=\"image_4_5.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.4 基于性能需求拆分 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e根据性能需求来进行拆分。简单来说就是访问量特别大，访问频率特别高的业务，又要保证高效的响应能力，这些业务对性能的要求特别高。比如积分竞拍、低价秒杀、限量抢购。\u003c/p\u003e\n\u003cp\u003e我们要识别出某些超高并发量的业务，尽可能把这部分业务独立拆分出来。这么做的原因非常简单，一个保证满足高性能业务需求，另一个保证业务的独立性，不互相影响。\u003c/p\u003e\n\u003cp\u003e类似积分竞拍、超低价秒杀、限量抢购，对瞬间峰值和计算性能要求是非常高的。这部分的业务如果跟其他通用业务放在一块，一个是可能互相影响，比如某个链路阻塞，会导致雪崩沿调用链向上传递。\u003c/p\u003e\n\u003cp\u003e另外一个是如果多个业务耦合在一块，发布频率变高、服务扩缩容变难、维护复杂度变高。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_6.png\" alt=\"image_4_6.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e3 总结拆分原则 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e先少后多（微服务数量）、先粗后细(粒度)\u003c/li\u003e\n\u003cli\u003e基于业务逻辑进行拆分（用户群体、业务领域等模型）\u003c/li\u003e\n\u003cli\u003e基于可靠性（核心模块独立化、主次链路隔离）\u003c/li\u003e\n\u003cli\u003e基于性能拆分（独立拆分高性能场景）\u003c/li\u003e\n\u003cli\u003e接口需保证幂等\u003c/li\u003e\n\u003cli\u003e接口数据定义严禁内嵌，透传\u003c/li\u003e\n\u003cli\u003e规范化工程结构，符合微服务风格\u003c/li\u003e\n\u003cli\u003e不止对计算服务记性拆分，服务层 -\u0026gt; 缓存层 -\u0026gt; 数据层 的逐步拆解，才能发挥最大功效。\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"1a:T5b1d,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e多地多机房部署是互联网系统的必然发展方向。一个系统要走到这一步，必然要面对流量调配、数据拆分、网络延时、架构升级等一系列问题。本文从最简单的单机架构出发，沿着可用性不断提升的脉络，逐步推演出异地多活架构的完整面貌，并结合阿里单元化方案解析工业级落地实践。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e为什么需要异地多活？\u003c/h2\u003e\n\u003cp\u003e一个好的软件架构应当遵循三个核心原则：\u003cstrong\u003e高性能、高可用、易扩展\u003c/strong\u003e。其中，高可用通常用两个指标来衡量：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e指标\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eMTBF\u003c/strong\u003e（Mean Time Between Failure）\u003c/td\u003e\n\u003ctd\u003e两次故障的间隔时间，越长说明系统越稳定\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eMTTR\u003c/strong\u003e（Mean Time To Repair）\u003c/td\u003e\n\u003ctd\u003e故障恢复时间，越短说明对用户影响越小\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e可用性的计算公式为：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e可用性（Availability）= MTBF / (MTBF + MTTR) × 100%\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通常用\u0026quot;N 个 9\u0026quot;来描述系统的可用性等级：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e可用性\u003c/th\u003e\n\u003cth\u003e年故障时间\u003c/th\u003e\n\u003cth\u003e日均故障时间\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e99%（2 个 9）\u003c/td\u003e\n\u003ctd\u003e3.65 天\u003c/td\u003e\n\u003ctd\u003e~14.4 分钟\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e99.9%（3 个 9）\u003c/td\u003e\n\u003ctd\u003e8.76 小时\u003c/td\u003e\n\u003ctd\u003e~86.4 秒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e99.99%（4 个 9）\u003c/td\u003e\n\u003ctd\u003e52.6 分钟\u003c/td\u003e\n\u003ctd\u003e~8.6 秒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e99.999%（5 个 9）\u003c/td\u003e\n\u003ctd\u003e5.26 分钟\u003c/td\u003e\n\u003ctd\u003e~0.86 秒\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e要达到 4 个 9 以上的可用性，平均每天的故障时间必须控制在 10 秒以内。每提升 1 个 9，都对系统设计提出更高的要求。\u003c/p\u003e\n\u003cp\u003e然而故障是不可避免的，主要来自三个方面：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e硬件故障\u003c/strong\u003e：交换机、路由器、磁盘等硬件损坏\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e软件问题\u003c/strong\u003e：代码 Bug、配置错误、依赖服务异常\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不可抗力\u003c/strong\u003e：地震、水灾、火灾、停电、光缆被挖断\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e历史上不乏惨痛的教训：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e时间\u003c/th\u003e\n\u003cth\u003e事件\u003c/th\u003e\n\u003cth\u003e影响\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e2013.07\u003c/td\u003e\n\u003ctd\u003e微信因市政施工导致光缆被挖断\u003c/td\u003e\n\u003ctd\u003e宕机数小时\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2015.05\u003c/td\u003e\n\u003ctd\u003e杭州光纤被挖断\u003c/td\u003e\n\u003ctd\u003e近 3 亿用户约 5 小时无法访问支付宝\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2021.07\u003c/td\u003e\n\u003ctd\u003eB站部分服务器机房故障\u003c/td\u003e\n\u003ctd\u003e整站持续 3 小时无法访问\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2021.10\u003c/td\u003e\n\u003ctd\u003e富途证券机房电力闪断\u003c/td\u003e\n\u003ctd\u003e用户 2 小时无法登录和交易\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e不同体量的系统关注的重点不同\u003c/strong\u003e：体量小时关注用户增长，体量上来后关注性能体验，体量再大到一定规模后，可用性就变得尤为重要。对于全民级应用而言，再小概率的风险也不能忽视——这就是异地多活存在的根本原因。\u003c/p\u003e\n\u003ch2\u003e部署架构的演进历程\u003c/h2\u003e\n\u003ch3\u003e第一阶段：单机架构\u003c/h3\u003e\n\u003cp\u003e最简单的模型：客户端请求 → 业务应用 → 单机数据库 → 返回结果。\u003c/p\u003e\n\u003cp\u003e数据库单机部署，一旦遭遇意外，所有数据全部丢失。即使做了定期备份，也存在两个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e恢复需要时间\u003c/strong\u003e：停机恢复，时间取决于数据量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据不完整\u003c/strong\u003e：备份存在时间差，不是最新数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e数据库越大，故障恢复时间越长，这种方案可能连 1 个 9 都达不到。\u003c/p\u003e\n\u003ch3\u003e第二阶段：主从副本\u003c/h3\u003e\n\u003cp\u003e在另一台机器上部署数据库从库（slave），与主库（master）保持实时同步。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e优势\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e数据完整性高\u003c/td\u003e\n\u003ctd\u003e主从实时同步，数据差异极小\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e抗故障能力提升\u003c/td\u003e\n\u003ctd\u003e主库异常时从库可切换为主库\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e读性能提升\u003c/td\u003e\n\u003ctd\u003e业务可直接读从库，分担主库压力\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e提升系统可用性的关键就是\u003cstrong\u003e冗余\u003c/strong\u003e——担心一个实例故障就部署多个实例，担心一台机器宕机就部署多台机器。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e第三阶段：同城灾备\u003c/h3\u003e\n\u003cp\u003e机房级别的风险虽然概率小，但一旦发生影响巨大。应对方案就不能局限在一个机房内了——需要在同城再搭建一个机房，用专线网络连通。\u003c/p\u003e\n\u003ch4\u003e冷备\u003c/h4\u003e\n\u003cp\u003eB 机房只做数据备份，不提供实时服务，只在 A 机房故障时才启用。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e优点：数据有异地备份\u003c/li\u003e\n\u003cli\u003e缺点：数据不完整、恢复期间业务不可用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e热备\u003c/h4\u003e\n\u003cp\u003eB 机房完整镜像 A 机房：接入层、业务应用、数据存储（从库）全部部署就位，处于待命状态。\u003c/p\u003e\n\u003cp\u003eA 机房故障时只需做两件事：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eB 机房所有从库提升为主库\u003c/li\u003e\n\u003cli\u003eDNS 指向 B 机房，接入流量\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e热备相比冷备最大的优点是：随时可切换。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e无论冷备还是热备，B 机房都处于备用状态，统称为\u003cstrong\u003e同城灾备\u003c/strong\u003e。它解决了机房级别的故障问题，可用性再次提升，但有一个隐患——B 机房从未经历过真实流量的考验，切换时不敢百分百保证能正常工作。\u003c/p\u003e\n\u003ch3\u003e第四阶段：同城双活\u003c/h3\u003e\n\u003cp\u003e让 B 机房也接入流量、实时提供服务，好处有二：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e实时训练后备军\u003c/strong\u003e：让 B 机房达到与 A 机房相同的\u0026quot;作战水平\u0026quot;，随时可切换\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分担流量压力\u003c/strong\u003e：B 机房接入流量后，减轻 A 机房的负载\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但 B 机房的存储是 A 机房的从库，默认不可写。解决方案是在\u003cstrong\u003e业务应用层做读写分离改造\u003c/strong\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e操作\u003c/th\u003e\n\u003cth\u003e路由策略\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e读请求\u003c/td\u003e\n\u003ctd\u003e可读任意机房的存储\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e写请求\u003c/td\u003e\n\u003ctd\u003e只允许写 A 机房（主库所在）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e所有存储（MySQL、Redis 等）都需要区分读写请求，有一定的业务改造成本。A 机房为\u003cstrong\u003e主机房\u003c/strong\u003e，B 机房为\u003cstrong\u003e从机房\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e两个机房部署在同城，物理距离近，专线网络延迟可接受。B 机房可以从 10% → 30% → 50% → 100% 逐步接入流量，持续验证其工作能力。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e同城双活\u003c/strong\u003e比灾备更进一步：B 机房实时接入流量，且能应对随时的故障切换，系统弹性大大增强。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e但两个机房在物理上仍处于同一城市。如果整个城市发生自然灾害（如 2021 年河南水灾），两个机房依旧存在全局覆没的风险。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e第五阶段：两地三中心\u003c/h3\u003e\n\u003cp\u003e为了应对城市级别的灾难，需要在\u003cstrong\u003e异地\u003c/strong\u003e（通常建议距离 1000 公里以上）再部署一个机房。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA、B 机房在同一城市，同时提供服务（同城双活）\u003c/li\u003e\n\u003cli\u003eC 机房部署在异地，只做数据灾备\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这就是\u003cstrong\u003e两地三中心\u003c/strong\u003e架构，常用于银行、金融、政企项目。但问题依旧：启用灾备机房需要时间，且启用后的服务不确定能否如期工作。\u003c/p\u003e\n\u003ch2\u003e异地双活：跨越延迟的鸿沟\u003c/h2\u003e\n\u003ch3\u003e为什么\u0026quot;简单异地部署\u0026quot;行不通？\u003c/h3\u003e\n\u003cp\u003e如果把同城双活的架构直接搬到异地（例如 A 在北京、B 在上海），会遇到一个致命问题——\u003cstrong\u003e网络延迟\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e北京到上海约 1300 公里，即使光纤以光速传输，一个来回也需要近 10ms。加上路由器、交换机等设备，实际延迟可达 \u003cstrong\u003e30ms 左右\u003c/strong\u003e。更关键的是，远距离专线的质量远不如机房内网——延迟波动、丢包、甚至中断都是常态。\u003c/p\u003e\n\u003cp\u003e一个页面可能访问后端几十个 API，如果每次都跨机房访问，整个页面的响应延迟可能达到\u003cstrong\u003e秒级\u003c/strong\u003e——这是不可接受的。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e虽然机房按同城双活的模型部署在了异地，但这本质上是一种\u003cstrong\u003e伪异地双活\u003c/strong\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e真正的异地双活：机房内闭环\u003c/h3\u003e\n\u003cp\u003e既然跨机房延迟是客观存在的物理限制，核心思路就是\u003cstrong\u003e尽量避免跨机房调用\u003c/strong\u003e——每个机房的请求在本机房内完成闭环。\u003c/p\u003e\n\u003cp\u003e这意味着每个机房都需要拥有独立的读写能力：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e改造项\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e数据库双主\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e两个机房的数据库都是主库，支持本地读写\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e双向数据同步\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e任一机房写入的数据，自动同步到另一个机房\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e全量数据\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e两个机房都拥有全量数据，支持任意切换\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4\u003e数据双向同步\u003c/h4\u003e\n\u003cp\u003eMySQL 本身支持双主架构和双向复制。但 Redis、消息队列（Kafka、RocketMQ 等）这些有状态服务并不原生支持，需要\u003cstrong\u003e开发专用的数据同步中间件\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e数据同步中间件的核心作用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e北京机房写入 order=AAAAA → 中间件同步到上海\n上海机房写入 order=BBBBB → 中间件同步到北京\n最终：两个机房都有 order=AAAAA 和 order=BBBBB\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用中间件同步数据可以容忍专线的不稳定——专线出问题时中间件自动重试直到成功，达到\u003cstrong\u003e数据最终一致性\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003e数据冲突问题\u003c/h4\u003e\n\u003cp\u003e两个机房都可写，如果修改的是\u003cstrong\u003e同一条数据\u003c/strong\u003e，就会发生冲突：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e用户短时间内发起两个修改请求：\n  → 请求 A 落在北京机房，修改 order=AAAAA（尚未同步到上海）\n  → 请求 B 落在上海机房，修改 order=BBBBB（尚未同步到北京）\n  → 两个机房以谁为准？\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e系统发生故障并不可怕，可怕的是\u003cstrong\u003e数据发生错误\u003c/strong\u003e，因为修正数据的成本极高。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e解决数据冲突：路由分片\u003c/h3\u003e\n\u003cp\u003e核心思想是：\u003cstrong\u003e同一个用户的所有请求，只在一个机房内完成业务闭环\u003c/strong\u003e，从根源上避免冲突。\u003c/p\u003e\n\u003cp\u003e需要在接入层之上部署\u003cstrong\u003e路由层\u003c/strong\u003e，根据规则将用户分流到不同机房。常见的分片策略有两种：\u003c/p\u003e\n\u003ch4\u003e策略一：哈希分片\u003c/h4\u003e\n\u003cp\u003e根据用户 userId 计算哈希值取模，从路由表中找到对应机房。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e用户 0~700   → 北京机房\n用户 701~999 → 上海机房\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对于未登录用户：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案 A：全部路由到固定机房\u003c/li\u003e\n\u003cli\u003e方案 B：根据设备 ID 进行哈希取模\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e策略二：地理位置分片\u003c/h4\u003e\n\u003cp\u003e非常适合与地理位置密切相关的业务（打车、外卖等）。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e北京、河北、内蒙古 → 北京机房\n上海、浙江、江苏   → 上海机房\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以外卖为例，商家、用户、骑手都在相同的地理范围内，天然适合按地域分片。\u003c/p\u003e\n\u003ch4\u003e全局数据的特殊处理\u003c/h4\u003e\n\u003cp\u003e有一类数据无法做分片——\u003cstrong\u003e全局强一致数据\u003c/strong\u003e，典型如商品库存。这类数据只能采用\u0026quot;写主机房、读从机房\u0026quot;的方案，无法真正双活。\u003c/p\u003e\n\u003cp\u003e这意味着在交易链路中，虽然全链路都做了机房内闭环，到了库存扣减这一步又回到了中心机房，单元化闭环被打破了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e一种解决思路是库存分摊\u003c/strong\u003e：将一个商品的库存拆分到不同机房，每个机房独立扣减本地库存，再通过\u003cstrong\u003e库存调拨程序\u003c/strong\u003e在机房间进行库存共享和再平衡。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e场景\u003c/th\u003e\n\u003cth\u003e方案\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e普通交易\u003c/td\u003e\n\u003ctd\u003e库存分摊 + 库存调拨程序保证机房间库存共享\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e秒杀场景\u003c/td\u003e\n\u003ctd\u003e各机房独立扣减，无需调拨（库存本就要被快速消耗完）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e异地多活：从双活到 N 活\u003c/h2\u003e\n\u003cp\u003e按照单元化的方式，每个机房可以部署在任意地区，随时扩展新机房，只需在最上层定义好分片规则。但随着机房数量增多，数据同步的复杂度急剧上升——每个机房写入数据后需要同步到所有其他机房，网状拓扑的复杂度为 O(N²)。\u003c/p\u003e\n\u003ch3\u003e从网状到星状\u003c/h3\u003e\n\u003cp\u003e业界的优化方案是将\u003cstrong\u003e网状架构升级为星状\u003c/strong\u003e：确立一个\u003cstrong\u003e中心机房\u003c/strong\u003e，所有数据同步都以中心机房为枢纽。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   ┌──────────┐\n   │ 单元机房A │──┐\n   └──────────┘  │\n   ┌──────────┐  │  ┌──────────┐\n   │ 单元机房B │──┼──│ 中心机房  │\n   └──────────┘  │  └──────────┘\n   ┌──────────┐  │\n   │ 单元机房C │──┘\n   └──────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e对比项\u003c/th\u003e\n\u003cth\u003e网状同步\u003c/th\u003e\n\u003cth\u003e星状同步\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e同步复杂度\u003c/td\u003e\n\u003ctd\u003eO(N²)，每增一个机房所有机房都需改造\u003c/td\u003e\n\u003ctd\u003eO(N)，只需同步到中心机房\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e扩展性\u003c/td\u003e\n\u003ctd\u003e差\u003c/td\u003e\n\u003ctd\u003e好，新机房只需和中心建立同步关系\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e中心依赖\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003e中心机房稳定性要求高\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e容灾\u003c/td\u003e\n\u003ctd\u003e任一机房可接管\u003c/td\u003e\n\u003ctd\u003e中心故障时可提升任一机房为新中心\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e星状架构的优势\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个机房写入数据只需同步到中心机房，中心再同步至其他机房\u003c/li\u003e\n\u003cli\u003e不需要关心一共部署了多少机房，扩展新机房的成本极低\u003c/li\u003e\n\u003cli\u003e中心机房故障时，可将任一单元机房提升为新中心，继续服务\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e至此，系统真正实现了\u003cstrong\u003e异地多活\u003c/strong\u003e——多个机房同时对外提供服务，任意机房故障可快速切换，系统具备极强的扩展能力。\u003c/p\u003e\n\u003ch2\u003e阿里单元化实践\u003c/h2\u003e\n\u003cp\u003e阿里在实施单元化时，根据业务特点采用了两种模式：\u003c/p\u003e\n\u003ch3\u003e交易单元化 vs 导购单元化\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e对比维度\u003c/th\u003e\n\u003cth\u003e交易单元化\u003c/th\u003e\n\u003cth\u003e导购单元化\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e入口流量\u003c/td\u003e\n\u003ctd\u003e入口清晰（商品详情→购物车→下单→支付）\u003c/td\u003e\n\u003ctd\u003e入口分散，大促时增加各种场景和玩法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e链路特征\u003c/td\u003e\n\u003ctd\u003e以\u003cstrong\u003e写\u003c/strong\u003e为主\u003c/td\u003e\n\u003ctd\u003e大部分是\u003cstrong\u003e读\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据库模式\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eWRITE 模式\u003c/strong\u003e（本地读写，双向同步）\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eCOPY 模式\u003c/strong\u003e（中心写入，单元只读）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e单元化范围\u003c/td\u003e\n\u003ctd\u003e全链路必须做单元化（对用户下单有直接影响）\u003c/td\u003e\n\u003ctd\u003e仅 C 端服务做单元化，商家后台中心化部署\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e资源成本\u003c/td\u003e\n\u003ctd\u003e较高（每个单元完整部署）\u003c/td\u003e\n\u003ctd\u003e较低（商家后台等只部署在中心）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e导购单元化采用 COPY 模式的原因：商家后台服务的可用性要求相对较低，故障恢复后继续操作即可，对大盘交易影响不大。中心化部署能\u003cstrong\u003e大幅节省资源成本和维护成本\u003c/strong\u003e，也能降低开发人员的开发成本。\u003c/p\u003e\n\u003ch3\u003e单元化路由透传机制\u003c/h3\u003e\n\u003cp\u003e单元化的核心在于路由信息的全链路透传——从接入层到最底层的数据层，每一层都需要能够正确识别和传递路由参数。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e层次\u003c/th\u003e\n\u003cth\u003e路由机制\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e接入层\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e解析 HTTP 请求中的路由参数（cookie/header/body），路由到正确的应用 SLB\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e应用层\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e中间件从 HTTP 请求中提取路由参数保存到上下文，供后续 RPC 和消息使用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRPC 层\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eRPC 客户端从上下文取出路由参数，随 RPC 请求传递到远程 Provider\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e消息层\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eMQ 客户端发送消息时从上下文获取路由参数添加到消息属性，消费时还原到上下文\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e数据层\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e保证数据落库到正确单元的 DB，防止数据脏写\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e单元协同与单元保护\u003c/h3\u003e\n\u003cp\u003e在单元化演进过程中，有两个关键问题需要解决：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e单元协同\u003c/strong\u003e：某些特定业务场景需要保证数据强一致性（如库存扣减），这类服务只能在中心单元提供服务。所有对中心服务的调用都会直接路由到中心单元完成。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e单元保护\u003c/strong\u003e：系统自上而下各层都要具备\u003cstrong\u003e纠错保护能力\u003c/strong\u003e，保证业务按单元化规则正确流转：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e保护层\u003c/th\u003e\n\u003cth\u003e纠错机制\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e接入层纠偏\u003c/td\u003e\n\u003ctd\u003e流量进入接入层后，通过路由参数判断归属单元，非本单元流量代理到正确的目标单元\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eRPC 纠偏\u003c/td\u003e\n\u003ctd\u003eRPC Consumer 端根据请求的单元信息进行路由选址，错误流量会被重定向到正确单元\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据层保护\u003c/td\u003e\n\u003ctd\u003e数据库层面的最后防线，防止数据写入错误的单元\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e异地多活落地的关键挑战\u003c/h2\u003e\n\u003cp\u003e落地异地多活远不止架构设计，还需要在多个维度做好准备：\u003c/p\u003e\n\u003ch3\u003e数据一致性保障\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e挑战\u003c/th\u003e\n\u003cth\u003e应对策略\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e同步延迟导致的数据不一致\u003c/td\u003e\n\u003ctd\u003e接受最终一致性，业务层做好容错设计\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据冲突（双写同一条数据）\u003c/td\u003e\n\u003ctd\u003e通过路由分片从源头避免，辅以冲突检测和仲裁机制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e同步中断（专线故障）\u003c/td\u003e\n\u003ctd\u003e中间件自动重试 + 断点续传，恢复后自动追数据\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据校验\u003c/td\u003e\n\u003ctd\u003e定期对账程序比对两地数据，发现差异自动修复\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e机房切换策略\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e切换类型\u003c/th\u003e\n\u003cth\u003e触发条件\u003c/th\u003e\n\u003cth\u003e操作\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e计划内切换\u003c/td\u003e\n\u003ctd\u003e机房维护、演练\u003c/td\u003e\n\u003ctd\u003e逐步调整路由权重，平滑迁移流量\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e故障切换\u003c/td\u003e\n\u003ctd\u003e机房故障\u003c/td\u003e\n\u003ctd\u003eDNS 切换 + 路由规则调整，将故障机房流量转移到其他机房\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e回切\u003c/td\u003e\n\u003ctd\u003e故障恢复\u003c/td\u003e\n\u003ctd\u003e先同步恢复期间的增量数据，再逐步回切流量\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e业务分级与取舍\u003c/h3\u003e\n\u003cp\u003e并非所有业务都需要做异地多活，需要根据业务重要程度进行分级：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e级别\u003c/th\u003e\n\u003cth\u003e业务类型\u003c/th\u003e\n\u003cth\u003e多活策略\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eP0\u003c/td\u003e\n\u003ctd\u003e核心交易链路（下单、支付）\u003c/td\u003e\n\u003ctd\u003e必须做单元化，机房内完全闭环\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP1\u003c/td\u003e\n\u003ctd\u003e重要辅助（购物车、搜索）\u003c/td\u003e\n\u003ctd\u003e做单元化部署，允许短时降级\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP2\u003c/td\u003e\n\u003ctd\u003e一般功能（商家后台、运营工具）\u003c/td\u003e\n\u003ctd\u003e中心化部署，故障时暂时不可用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eP3\u003c/td\u003e\n\u003ctd\u003e非核心（日志、统计）\u003c/td\u003e\n\u003ctd\u003e不做多活，故障后补数据\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e配套基础设施\u003c/h3\u003e\n\u003cp\u003e异地多活的落地还依赖一系列配套设施：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e全局流量调度\u003c/strong\u003e：DNS + HTTP DNS + 接入层路由，支持按规则精细分流\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据同步中间件\u003c/strong\u003e：覆盖 MySQL、Redis、MQ 等所有有状态服务\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e统一配置中心\u003c/strong\u003e：支持多机房配置的统一管理和快速下发\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e全链路监控\u003c/strong\u003e：跨机房的调用链追踪、数据同步延迟监控、一致性校验报告\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e演练平台\u003c/strong\u003e：定期进行故障演练，验证切换流程的有效性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e架构演进全景对比\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e阶段\u003c/th\u003e\n\u003cth\u003e方案\u003c/th\u003e\n\u003cth\u003e机房数\u003c/th\u003e\n\u003cth\u003e可用性\u003c/th\u003e\n\u003cth\u003e核心特点\u003c/th\u003e\n\u003cth\u003e主要局限\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e单机架构\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e\u0026lt; 99%\u003c/td\u003e\n\u003ctd\u003e最简单\u003c/td\u003e\n\u003ctd\u003e单点故障，数据丢失\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e主从副本\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e~99.9%\u003c/td\u003e\n\u003ctd\u003e数据冗余\u003c/td\u003e\n\u003ctd\u003e机房级故障无法应对\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e同城灾备\u003c/td\u003e\n\u003ctd\u003e2（同城）\u003c/td\u003e\n\u003ctd\u003e~99.95%\u003c/td\u003e\n\u003ctd\u003e机房级冗余\u003c/td\u003e\n\u003ctd\u003e备用机房未经验证\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003e同城双活\u003c/td\u003e\n\u003ctd\u003e2（同城）\u003c/td\u003e\n\u003ctd\u003e~99.99%\u003c/td\u003e\n\u003ctd\u003e双机房实时服务\u003c/td\u003e\n\u003ctd\u003e无法应对城市级灾难\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e两地三中心\u003c/td\u003e\n\u003ctd\u003e3（两城）\u003c/td\u003e\n\u003ctd\u003e~99.99%\u003c/td\u003e\n\u003ctd\u003e异地数据备份\u003c/td\u003e\n\u003ctd\u003e灾备机房启用慢\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e异地双活\u003c/td\u003e\n\u003ctd\u003e2（异地）\u003c/td\u003e\n\u003ctd\u003e~99.99%+\u003c/td\u003e\n\u003ctd\u003e机房内闭环，双主同步\u003c/td\u003e\n\u003ctd\u003e需要大量中间件和业务改造\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003e异地多活\u003c/td\u003e\n\u003ctd\u003eN（多地）\u003c/td\u003e\n\u003ctd\u003e~99.999%\u003c/td\u003e\n\u003ctd\u003e星状同步，任意扩展\u003c/td\u003e\n\u003ctd\u003e实施复杂度高，需要强大的基础设施支撑\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e异地多活的演进，本质上是一部\u003cstrong\u003e用冗余换可用性\u003c/strong\u003e的发展史。从中可以提炼出以下核心认知：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e冗余是高可用的基石\u003c/strong\u003e：从主从副本到多机房部署，每一次演进都是在更大的维度上做冗余\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e延迟是异地部署的核心矛盾\u003c/strong\u003e：跨城网络延迟是客观物理限制，必须通过\u0026quot;机房内闭环\u0026quot;来规避\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据一致性是最大的技术挑战\u003c/strong\u003e：双向同步、冲突避免、最终一致性保障，每一环都需要精心设计\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e路由分片是解决冲突的根本手段\u003c/strong\u003e：通过哈希分片或地理分片，确保同一用户的请求在同一机房内闭环\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e星状拓扑是多活扩展的最优解\u003c/strong\u003e：相比网状同步的 O(N²) 复杂度，星状拓扑将复杂度降为 O(N)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不是所有业务都需要多活\u003c/strong\u003e：根据业务重要程度分级，P0 核心链路做完整单元化，非核心业务中心化部署节省成本\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e架构设计是技术与成本的平衡\u003c/strong\u003e：异地多活需要路由层、数据同步中间件、监控体系、演练平台等大量基础设施支撑，没有足够的人力物力很难落地\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003e好的架构不是一步到位的，而是随着业务体量的增长逐步演进的。理解每一步演进背后的驱动力和技术挑战，比直接套用某个方案更加重要。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/architecture/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"架构设计\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-03-23\",\"children\":\"2024年03月23日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"服务注册与发现\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"微服务\",{\"href\":\"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"微服务\"}],[\"$\",\"$L13\",\"服务发现\",{\"href\":\"/blog/tag/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"服务发现\"}],[\"$\",\"$L13\",\"架构设计\",{\"href\":\"/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"架构设计\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/architecture/微服务拆分策略（附加篇）\",\"title\":\"微服务拆分策略（附加篇）\",\"description\":\"关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。 1. AKF扩展立方体 AKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一...\",\"pubDate\":\"2024-03-22\",\"tags\":[\"微服务\",\"服务拆分\",\"领域驱动\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/architecture/服务注册与发现（实践篇）\",\"title\":\"服务注册与发现（实践篇）\",\"description\":\"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景...\",\"pubDate\":\"2024-03-24\",\"tags\":[\"微服务\",\"服务发现\",\"工程实践\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"微服务\":{\"prev\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"服务发现\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"架构设计\":{\"prev\":{\"slug\":\"engineering/architecture/微服务拆分策略\",\"title\":\"微服务拆分策略\",\"description\":\"前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移...\",\"pubDate\":\"2024-03-21\",\"tags\":[\"微服务\",\"服务拆分\",\"架构设计\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"},\"next\":{\"slug\":\"engineering/architecture/异地多活架构：从原理到实践的演进之路\",\"title\":\"异地多活架构：从原理到实践的演进之路\",\"description\":\"从单机架构到异地多活，系统性梳理多机房部署架构的演进历程。深入剖析同城灾备、同城双活、异地双活、异地多活的核心原理与技术挑战，并结合阿里单元化方案解析工业级落地实践。\",\"pubDate\":\"2024-04-08\",\"tags\":[\"架构设计\",\"异地多活\",\"高可用\",\"容灾\",\"单元化\"],\"heroImage\":\"$undefined\",\"content\":\"$1a\"}}}}]}],[\"$\",\"$L1b\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"服务注册与发现 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"服务注册与发现\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-03-23\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"服务注册与发现\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
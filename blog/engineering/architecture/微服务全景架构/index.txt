1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-51baccc14cf1da9e.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
5:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
7:I[59665,[],"OutletBoundary"]
a:I[74911,[],"AsyncMetadataOutlet"]
c:I[59665,[],"ViewportBoundary"]
e:I[59665,[],"MetadataBoundary"]
10:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/76f43fb31ba279a4.css","style"]
0:{"P":null,"b":"Hm7D1JIm439NqQmcolrnv","p":"","c":["","blog","engineering","architecture","%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%9E%B6%E6%9E%84",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%9E%B6%E6%9E%84","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/76f43fb31ba279a4.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8","children":[["$","div",null,{"className":"flex justify-center space-x-6 md:order-2","children":[["$","$L5",null,{"href":"/about","className":"text-gray-600 hover:text-gray-800","children":"关于"}],["$","$L5",null,{"href":"/blog","className":"text-gray-600 hover:text-gray-800","children":"博客"}],["$","$L5",null,{"href":"/contact","className":"text-gray-600 hover:text-gray-800","children":"联系"}]]}],["$","div",null,{"className":"mt-8 md:order-1 md:mt-0","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-600","children":"© 2024 Skyfalling Blog. All rights reserved."}]}]]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%9E%B6%E6%9E%84","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","_oSmF4wEZX0Nbv83L9AUgv",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Le",null,{"children":"$Lf"}]]}],false]],"m":"$undefined","G":["$10","$undefined"],"s":false,"S":true}
11:"$Sreact.suspense"
12:I[74911,[],"AsyncMetadata"]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1a:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
f:["$","div",null,{"hidden":true,"children":["$","$11",null,{"fallback":null,"children":["$","$L12",null,{"promise":"$@13"}]}]}]
15:T4fc2,<h3>1 微服务优势与挑战 <a href="#scroller-1" id="scroller-1"></a></h3>
<h4>1.1 微服务的优势 <a href="#scroller-2" id="scroller-2"></a></h4>
<p><strong>1.1.1 单一职责</strong></p>
<p>微服务架构中的每个节点高度服务化，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，包括数据库和数据模型；不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</p>
<p><strong>1.1.2 轻量级通信</strong></p>
<p>通过REST API模式或者RPC框架，事件流和消息代理的组合相互通信，实现服务间互相协作的轻量级通信机制。</p>
<p><strong>1.1.3 独立性</strong></p>
<p>在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试、部署、运维。</p>
<p><strong>1.1.4 进程隔离</strong></p>
<p>在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上，实现高度自治和高度隔离。进程的隔离，还能保证服务达到动态扩缩容的能力，业务高峰期自动增加服务资源以提升并发能力，业务低谷期则可自动释放服务资源以节省开销。</p>
<p><strong>1.1.5 混合技术栈和混合部署方式</strong></p>
<p>团队可以为不同的服务组件使用不同的技术栈和不同的部署方式（公有云、私有云、混合云）。</p>
<p><strong>1.1.6 简化治理</strong></p>
<p>组件可以彼此独立地进行缩放，从而减少了因必须缩放整个应用程序而产生的浪费和成本，独立的发布、服务治理。</p>
<p><strong>1.1.7 安全可靠，可维护。</strong></p>
<p>从架构上对运维提供友好的支撑，在安全、可维护的基础上规范化发布流程，支持数据存储容灾、业务模块隔离、访问权限控制、编码安全检测等。</p>
<h4>1.2 面临的挑战 <a href="#scroller-10" id="scroller-10"></a></h4>
<p><strong>1.2.1 分布式固有复杂性</strong></p>
<p>微服务架构是基于分布式的系统，而构建分布式系统必然会带来额外的开销。</p>
<ul>
<li>性能： 分布式系统是跨进程、跨网络的调用，受网络延迟和带宽的影响。</li>
<li>可靠性： 由于高度依赖于网络状况，任何一次的远程调用都有可能失败，随着服务的增多还会出现更多的潜在故障点。因此，如何提高系统的可靠性、降低因网络引起的故障率，是系统构建的一大挑战。</li>
<li>分布式通信： 分布式通信大大增加了功能实现的复杂度，并且伴随着定位难、调试难等问题。</li>
<li>数据一致性： 需要保证分布式系统的数据强一致性，即在 C（一致性）A（可用性）P（分区容错性） 三者之间做出权衡。这块可以参考我的这篇《<a href="https://www.cnblogs.com/wzh2010/p/15311142.html">分布式事务</a>》。</li>
</ul>
<p><strong>1.2.2 服务的依赖管理和测试</strong></p>
<p>在单体应用中，通常使用集成测试来验证依赖是否正常。而在微服务架构中，服务数量众多，每个服务都是独立的业务单元，服务主要通过接口进行交互，如何保证它的正常，是测试面临的主要挑战。</p>
<p>所以单元测试和单个服务链路的可用性非常重要。</p>
<p><strong>1.2.3 有效的配置版本管理</strong></p>
<p>在单体系统中，配置可以写在yaml文件，分布式系统中需要统一进行配置管理，同一个服务在不同的场景下对配置的值要求还可能不一样，所以需要引入配置的版本管理、环境管理。</p>
<p><strong>1.2.4 自动化的部署流程</strong></p>
<p>在微服务架构中，每个服务都独立部署，交付周期短且频率高，人工部署已经无法适应业务的快速变化。有效地构建自动化部署体系，配合服务网格、容器技术，是微服务面临的另一个挑战。</p>
<p><strong>1.2.5 对于DevOps更高的要求</strong></p>
<p>在微服务架构的实施过程中，开发人员和运维人员的角色发生了变化，开发者也将承担起整个服务的生命周期的责任，包括部署、链路追踪、监控；因此，按需调整组织架构、构建全功能的团队，也是一个不小的挑战。</p>
<p><strong>1.2.6 运维成本</strong></p>
<p>运维主要包括配置、部署、监控与告警和日志收集四大方面。微服务架构中，每个服务都需要独立地配置、部署、监控和收集日志，成本呈指数级增长。</p>
<p>服务化粒度越细，运维成本越高。</p>
<p>怎样去解决这些问题，是微服务架构必须面临的挑战。</p>
<h3>2 微服务全景架构 <a href="#scroller-17" id="scroller-17"></a></h3>
<p><img src="/images/blog/engineering/microservice-image_1_1.png" alt="image_1_1.png"></p>
<h3>3 微服务核心组件 <a href="#scroller-19" id="scroller-19"></a></h3>
<p>微服务架构核心组件包括：</p>
<table>
<thead>
<tr>
<th><strong>组件名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>服务注册与发现</td>
</tr>
<tr>
<td>API 网关服务</td>
</tr>
<tr>
<td>分布式配置中心</td>
</tr>
<tr>
<td>服务通信</td>
</tr>
<tr>
<td>服务治理</td>
</tr>
<tr>
<td>服务监控</td>
</tr>
<tr>
<td>分布式服务追踪</td>
</tr>
</tbody></table>
<h4>3.1 服务注册与发现 <a href="#scroller-20" id="scroller-20"></a></h4>
<p><strong>3.1.1 原理图</strong></p>
<p><img src="/images/blog/engineering/microservice-image_1_2.png" alt="image_1_2.png"></p>
<p>服务注册与发现三要素：</p>
<ul>
<li>Provider：服务的提供方</li>
<li>Consumer：调用远程服务的服务消费方</li>
<li>Registry：服务注册和发现的注册中心</li>
</ul>
<p><strong>3.1.2 注册中心的原理、流程</strong></p>
<p>1、 Provider(服务提供者)绑定指定端口并启动服务</p>
<p>2、提供者连接注册中心，并发本机 IP、端口、应用信息和服务信息发送至注册中心存储</p>
<p>3、Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</p>
<p>4、注册中心根据消费者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。</p>
<p>5、Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</p>
<p>6、Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer设计的原因：</p>
<p>Consumer 与 Provider 解偶，双方都可以横向增减节点数。注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</p>
<p>7、去中心化，双方不直接依赖注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用（Consumer应用缓存中保留提供者 Provider 列表）</p>
<p>8、服务提供者无状态，任意一台宕掉后，不影响使用</p>
<p>注册中心包含如下功能：注册中心、服务注册和反注册、心跳监测与汇报、服务订阅、服务变更查询、集群部署、服务健康状态检测、服务状态变更通知 等</p>
<p>我们有很多种注册中心的技术，Zookeeper、Etcd、Consul、Eureka 4种比较常用，如下</p>
<table>
<thead>
<tr>
<th></th>
<th>Zookeeper</th>
<th>Etcd</th>
<th>Consul</th>
<th>Eureka</th>
</tr>
</thead>
<tbody><tr>
<td>CAP模型</td>
<td>CP</td>
<td>CP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>数据一致性算法</td>
<td>ZAB</td>
<td>Raft</td>
<td>Raft</td>
<td>❌</td>
</tr>
<tr>
<td>多数据中心</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>多语言支持</td>
<td>客户端</td>
<td>Http/gRPC</td>
<td>Http/DNS</td>
<td>Http</td>
</tr>
<tr>
<td>Watch</td>
<td>TCP</td>
<td>Long Polling</td>
<td>Long Polling</td>
<td>Long Polling</td>
</tr>
<tr>
<td>KV存储</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>服务健康检查</td>
<td>心跳</td>
<td>心跳</td>
<td><p>服务状态，<br>内存，硬盘等</p></td>
<td>自定义</td>
</tr>
<tr>
<td>自身监控</td>
<td>❌</td>
<td>metrics</td>
<td>metrics</td>
<td>metrics</td>
</tr>
<tr>
<td>SpringCloud 支持</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>自身开发语言</td>
<td>Java</td>
<td>Go</td>
<td>Go</td>
<td>Java</td>
</tr>
</tbody></table>
<p>分布式系统中CAP模型3者不可兼得。由于网络的原因，分布式系统中P是必备的，意味着只能选择 AP 或者 CP。CP 代表数据一致性是第一位的，AP 代表可用性是第一位的。</p>
<p>Zookeeper、Etcd、Consul 是 CP 型注册中心，牺牲可用性来保证数据强一致性</p>
<p>Eureka 是 AP 型注册中心，牺牲一致性来保证可用性</p>
<h4>3.2 API 网关服务 <a href="#scroller-23" id="scroller-23"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_1_3.png" alt="image_1_3.png"></p>
<p>上面是Api网关服务的基本架构：用户的请求经过统一的Api网关来访问微服务里具体的服务颗粒，并且可能产生串联的链路服务调用。</p>
<p>有很多耳熟能详的API网关技术，比如 Zuul、Kong、Tyk等，提供了服务路由在内的很多通用功能，后面会有专门的章节来说这个。</p>
<p>Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。</p>
<p>Kong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。</p>
<p>Netflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>
<p>除了路由之外，Api网关服务还包含：认证和授权，重试、熔断、降级，负载均衡，日志、监控、链路追踪，灰度发布，ABTesting 等功能。</p>
<h4>3.3 配置中心 <a href="#scroller-24" id="scroller-24"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_1_4.png" alt="image_1_4.png"></p>
<p>上面这个是携程的开源配置中心Apollo系统的架构设计，我们从下往上进行分析：</p>
<p>1、Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端</p>
<p>2、Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）</p>
<p>3、Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳，支持注册、更新、删除能力</p>
<p>4、在Eureka之上我们架了一层Meta Server用于封装Eureka的服务发现接口</p>
<p>5、Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试</p>
<p>6、Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试</p>
<p>7、为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</p>
<p>上面的架构体现了如下特点：</p>
<p>•高可用：配置服务为多实例部署，访问层保证 load balance、错误重试 •弱依赖：使用了Eureka来做配置中心的服务注册，如果出现问题或者网络出现问题的时候，服务应该可以依赖于它本身所缓存的配置来提供正常的服务</p>
<h4>3.4 服务通信 <a href="#scroller-25" id="scroller-25"></a></h4>
<p>分布式系统一般是由多个微服务颗粒组成的，微服务与微服务之前存在互相调用，甚至多个链路访问的情况。所以他们之间是需要通信的，通信方式继承于SOA，包含同步与异步两种模式。</p>
<p><strong>3.4.1 同步访问方式</strong></p>
<p>1、RPC 访问模式</p>
<p>Remote Procedure Call Protocol，远程过程调用协议，一般使用在分布式业务或者微服务架构风格中。像调用本地函数一样，去调用一个远端服务。本质上是请求链的底层，维护同一个端口，进行socket通信。常见的RPC技术包含 gRPC、Dubbo、Thrift 等。</p>
<p><img src="/images/blog/engineering/microservice-image_1_5.png" alt="image_1_5.png"></p>
<p>2、REST 访问模式</p>
<p>这个应该大家最常用，可以通过一套统一风格的接口模式，为Web，iOS和Android等提供接口服务。</p>
<p><strong>3.4.2 异步访问方式</strong></p>
<p>消息中间件：RabbitMQ、Kafka、RocketMQ之类，对于实时性要求不那么严格的服务请求和计算。</p>
<h4>3.5 服务治理 <a href="#scroller-28" id="scroller-28"></a></h4>
<p>常见的服务治理手段有如下几种：</p>
<p><strong>3.5.1 节点管理</strong></p>
<p>服务调用失败时可能是服务提供者自身出现，也可能是网络发生故障，我们一般有两种处理手段。</p>
<p>1. 注册中心主动摘除机制 这种机制要求服务提供者定时向注册中心汇报心跳，如果超时，就认为服务提供者出现问题，并将节点从服务列表中摘除。</p>
<p>2. 服务消费者摘除机制 当服务提供者网络出现异常，服务消费者调用就会失败，如果持续错误就可以将它从服务提供者节点列表中移除。</p>
<p><strong>3.5.2 负载均衡</strong></p>
<p>服务消费者在从服务列表中选取可用节点时，如果能让性能较好的服务机多承担一些流量的话，就能充分利用机器的性能。这就需要对负载均衡算法做一些调整。</p>
<p>常用的负载均衡算法主要包括以下几种：</p>
<p>1. Radom 随机算法 从可用的服务节点中随机选取一个节点。一般情况下，随机算法是均匀的，也就是说后端服务节点无论配置好坏，最终得到的调用量都差不多。</p>
<p>2. Round Robin 轮询算法（加权重） 就是按照固定的权重，对可用服务节点进行轮询。如果所有服务节点的权重都是相同的，则每个节点的调用量也是差不多的。但可以给性能较好的节点的权重调大些，充分发挥其性能优势，提高整体调用的平均性能。</p>
<p>3. Least Conn 最少活跃调用算法 这种算法是在服务消费者这一端的内存里动态维护着同每一个服务节点之间的连接数，选择连接数最小的节点发起调用，也就是选择了调用量最小的服务节点，性能理论上也是最优的。</p>
<p>4. 一致性 Hash 算法 指相同参数的请求总是发到同一服务节点。当某一个服务节点出现故障时，原本发往该节点的请求，基于虚拟节点机制，平摊到其他节点上，不会引起剧烈变动。</p>
<p><strong>3.5.3 服务路由</strong></p>
<p>所谓的路由规则，就是通过一定的规则如条件表达式或者正则表达式来限定服务节点的选择范围。</p>
<p>制定路由规则主要有两个原因。</p>
<p>1. 业务存在灰度发布、多版本ABTesting的需求</p>
<p>功能逐步开放发布或者灰度测试的场景。</p>
<p>2. 多机房就近访问的需求</p>
<p>一般可以通过 IP 段规则来控制访问，在选择服务节点时，优先选择同一 IP 段的节点。这个也是算力靠近的优先原则。</p>
<p><strong>3.5.4 服务容错</strong></p>
<p>在分布式系统中，分区容错性是很重要的一个话题，要知道，服务间的调用调用并不总是成功，服务提供者程序bug、异常退出 或者 消费者与提供者之间的网络故障。而服务调用失败之后，我们需要一些方法来保证调用的正常。</p>
<p>常用的方式有以下几种：</p>
<p>FailOver 失败自动切换。就是服务消费者发现调用失败或者超时后，自动从可用的服务节点列表中选择下一个节点重新发起调用，也可以设置重试的次数。</p>
<p>FailBack 失败通知。就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。</p>
<p>FailCache 失败缓存。就是服务消费者调用失败或者超时后，不立即发起重试，而是隔一段时间后再次尝试发起调用。</p>
<p>FailFast 快速失败。就是服务消费者调用一次失败后，不再重试。</p>
<p>服务治理的手段是从不同角度来确保服务调用的成功率。节点管理是从服务节点健康状态角度来考虑，负载均衡和服务路由是从服务节点访问优先级角度来考虑，而服务容错是从调用的健康状态角度来考虑。</p>
<h4>3.6 服务监控 <a href="#scroller-33" id="scroller-33"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_1_6.png" alt="image_1_6.png"></p>
<p>常见的开发监控报警技术有 ELK、InfluxData的TICK、Promethues 等。</p>
<p>在分布式系统中，微服务一般都具有复杂的链路调用，对于链路之间的状态、服务可用性、调用情况的监控，是需要一套完整的服务监控系统去保障的。</p>
<p>如我们上面的那个图所示， 服务系统主要由哪几部分构成：</p>
<p>1、数据采集部分，包含性能指标信息、日志信息（一般是服务埋点日志或者sidecar的inbound、outbound信息）、端到端的Trace信息。</p>
<p>2、采集上来的监控数据通过传输系统，或者使用消息中间件来异步传输，或者调用服务端接口推送监控数据。并把这些数据持久化到我们的数据服务层中。</p>
<p>3、制定一套规则，对于采集到的数据进行清理、计算、分级等，处理好的数据，通过提前设置好的报警策略，来判断它是否触发了这些报警。</p>
<p>4、梳理完的数据可以进行查询展示（有一个日志查询界面）、分级报警、分析趋势报表推送等。</p>
<h4>3.7 服务追踪 <a href="#scroller-34" id="scroller-34"></a></h4>
<p>服务追踪的原理主要包括下面两个关键点。</p>
<p>1、为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。</p>
<p>通过 Trace ID 的记录，我们就能将所有请求过程的日志关联起来。</p>
<p>2、为了统计各处理单元的时间延迟，当请求到达各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是前文中提到的 Span ID。对于每个 Span 来说，它必须有开始和结束两个节点，</p>
<p>通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如事件名称、请求信息等。</p>
<p><img src="/images/blog/engineering/microservice-image_1_7.png" alt="image_1_7.png"></p>
<p>上图显示了Trace ID 和 Spand ID 在链路中的传输过程，它把服务调用的一个时序结构给展现出来了。</p>
<p>常见的服务链路追踪的技术有Zipkin、Pinpoint、SkyWalking 等。后面讲到Service Mesh的时候会详细说下Zipkin的x-b3 header头传递，以及流量染色的使用，非常给力。</p>
<h3>4 总结 <a href="#scroller-35" id="scroller-35"></a></h3>
<p>微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。</p>
<p>后续我们围绕它的核心模块：服务注册与发现、API 网关服务、分布式配置中心、服务通信、服务治理、分布式服务追踪与监控等，从原理到实践，一步步展开来研究。</p>
17:T3ba4,<h3>1 传统单体系统介绍 <a href="#scroller-1" id="scroller-1"></a></h3>
<p>在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增，</p>
<p>发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。</p>
<p>但是物理服务器的CPU、内存、存储器、连接数等资源有限，单体系统能够承受的的QPS也是有限的，某个时段大量连接同时执行操作，会导致web服务和数据库服务在处理上遇到性能瓶颈。</p>
<p>为了解决这个问题，伟大的前辈们发扬了分而治之的思想，对大数据库、大表进行分割，可以参考我的《<a href="https://www.cnblogs.com/wzh2010/p/15049878.html">分库分表</a>》，以便实施更好的控制和管理。</p>
<p>同时创建多个服务实例，使用多台服务机进行CPU、内存、存储的分摊，提供更好的性能。</p>
<h4>1.1 单体系统的问题 <a href="#scroller-2" id="scroller-2"></a></h4>
<p>1、复杂性高：由于是一个单体的系统，所以整个系统的模块是耦合在一起的，模块的边界比较模糊、依赖关系错综复杂。功能的调整，容易带来不可知的影响和潜在的bug风险。</p>
<p>2、服务性能问题：单体系统遇到性能瓶颈问题，只能横向扩展，增加服务实例，进行负载均衡分担压力。无法纵向扩展，做模块拆分。</p>
<p>3、扩缩容能力受限：单体应用只能作为一个整体进行扩展，影响范围大，无法根据业务模块的需要进行单个模块的伸缩。</p>
<p>4、无法做故障隔离：当所有的业务功能模块都聚集在一个程序集当中，如果其中的某一个小的功能模块出现问题（如某个请求堵塞），那么都有可能会造成整个系统的崩溃。</p>
<p>5、发布的影响范围较大：每次发布都是整个系统进行发布，发布会导致整个系统的重启，对于大型的综合系统挑战比较大，如果将各个模块拆分，哪个部分做了修改，只发布哪个部分所在的模块即可。</p>
<h4>&#x20;<a href="#scroller-3" id="scroller-3"></a></h4>
<h4>1.2 单体系统的优点 <a href="#scroller-4" id="scroller-4"></a></h4>
<p>1、系统的简易性：系统语言风格、业务结构，接口格式均具有一致性，服务都是耦合在一起的，不存在各个业务通信问题。</p>
<p>2、易于测试：单体应用一旦部署，所有的服务或特性就都可以使用了，简化了测试过程，无需额外测试服务间的依赖，测试均可在部署完成后开始。</p>
<p>3、易于部署与升级：相对于微服务架构中的每个服务独立部署，单体系统只需将单个目录下的服务程序统一部署和升级。</p>
<p>4、较低的维护成本：只需维护单个系统即可。运维主要包括配置、部署、监控与告警和日志收集四大方面。相对于单体系统，微服务架构中的每个服务都需要独立地配置、部署、监控和日志收集，成本呈指数级增长。</p>
<h4>&#x20;<a href="#scroller-5" id="scroller-5"></a></h4>
<h4>1.3 单体服务到微服务的发展过程 <a href="#scroller-6" id="scroller-6"></a></h4>
<p>EUREKA的注册中心逐渐被ZooKeeper和Nacos等替代了。</p>
<p><img src="/images/blog/engineering/microservice-image_2_1.png" alt="image_2_1.png"></p>
<h3>2 关于微服务 <a href="#scroller-7" id="scroller-7"></a></h3>
<p>微服务是一种架构模式，是面向服务的体系结构（SOA）软件架构模式的一种演变，它提倡将单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，为用户提供最终价值。所以，微服务（或微服务架构）是一种云原生架构方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成。这些服务通常包含如下特点：</p>
<h4>2.1 单一职责 <a href="#scroller-8" id="scroller-8"></a></h4>
<p>微服务架构中的每个节点高度服务化，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，包括数据库和数据模型；不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</p>
<h4>2.2 轻量级通信 <a href="#scroller-9" id="scroller-9"></a></h4>
<p>通过REST API模式或者RPC框架，实现服务间互相协作的轻量级通信机制。</p>
<h4>2.3 独立性 <a href="#scroller-10" id="scroller-10"></a></h4>
<p>在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试、部署、运维。</p>
<h4>2.4 进程隔离 <a href="#scroller-11" id="scroller-11"></a></h4>
<p>在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上，实现高度自治和高度隔离。进程的隔离，还能保证服务达到动态扩缩容的能力，业务高峰期自动增加服务资源以提升并发能力，业务低谷期则可自动释放服务资源以节省开销。</p>
<h4>2.5 混合技术栈和混合部署方式 <a href="#scroller-12" id="scroller-12"></a></h4>
<p>团队可以为不同的服务组件使用不同的技术栈和不同的部署方式（公有云、私有云、混合云）。</p>
<h4>2.6 简化治理 <a href="#scroller-13" id="scroller-13"></a></h4>
<p>组件可以彼此独立地进行扩缩容和治理，从而减少了因必须缩放整个应用程序而产生的浪费和成本，因为单个功能可能面临过多的负载。</p>
<h4>2.7 安全可靠，可维护。 <a href="#scroller-14" id="scroller-14"></a></h4>
<p>从架构上对运维提供友好的支撑，在安全、可维护的基础上规范化发布流程，支持数据存储容灾、业务模块隔离、访问权限控制、编码安全检测等。</p>
<h3>3 微服务演进史 <a href="#scroller-15" id="scroller-15"></a></h3>
<p>我们前面已经了解了微服务的概念，通过百度指数可以看出，从2012年之后，微服务的发展有显著的发展趋势。</p>
<p><img src="/images/blog/engineering/microservice-image_2_2.png" alt="image_2_2.png"></p>
<p>目前业内的微服务相关开发平台和框架还是比较多的，比如较早的Spring Cloud（使用Eureke做服务注册与发现，Ribbon做服务间负载均衡，Hystrix做服务容错保护），</p>
<p>阿里的Dubbo，微软的.Net体系微服务框架 Service Fabric，再到后来进阶的服务网格(Service Mesh,如 Istio、Linkerd）。</p>
<p>那从12年开始到现在，微服务到底发展到哪个阶段了，在各个阶段的进阶过程中，又有哪些的变化。所以我们需要了解微服务技术的历史发展脉络。</p>
<p>下面的内容参考了 <a href="https://philcalcado.com/">Phil Calçado</a>的文章<a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">《Pattern: Service Mesh》</a>，从开发者的视角，详细分析了从微服务到Service Mesh技术的演进过程，这边做了进一步的整理和总结。</p>
<h4>3.1 第一阶：简单服务通信模块 <a href="#scroller-16" id="scroller-16"></a></h4>
<p>这是最初的模样，开发人员最开始的时候想象的两个服务间简单的通信模式，抽象表示如下，两个服务之间直接进行通信：</p>
<p><img src="/images/blog/engineering/microservice-image_2_3.png" alt="image_2_3.png"></p>
<p>3.2 第二阶：原始通信时代</p>
<p>上面的方式非常简单，但实际情况远比想象的复杂很多，通信需要底层字节码传输和电子信号的物理层来完成，在TCP协议出现之前，</p>
<p>服务需要自己处理网络通信所面临的丢包、错误、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还包含对网络传输问题的处理逻辑。</p>
<p><img src="/images/blog/engineering/microservice-image_2_4.png" alt="image_2_4.png"></p>
<h4>3.3 第三阶：TCP时代 <a href="#scroller-18" id="scroller-18"></a></h4>
<p>TCP协议的出现，避免了每个服务自己实现一套相似的网络传输处理逻辑，解决网络传输中通用的流量控制问题。</p>
<p>这时候我们把处理网络传输的能力下沉，从服务的实现中抽离出来，成为操作系统网络层的一部分。</p>
<p><img src="/images/blog/engineering/microservice-image_2_5.png" alt="image_2_5.png"></p>
<h4>3.4 第四阶：第一代微服务（Spring Cloud/RPC） <a href="#scroller-19" id="scroller-19"></a></h4>
<p>TCP出现之后，服务间的网络通信已经不是一个难题了，所以 GFS/BigTable/MapReduce 为代表的分布式系统得到了蓬勃的发展。</p>
<p>这时，分布式系统特有的通信语义又出现了，如服务注册与发现、负载均衡、熔断降级策略、认证和授权、端到端trace、日志与监控等，因此根据业务需求,完成一些通信语义的实现。</p>
<p><img src="/images/blog/engineering/microservice-image_2_6.png" alt="image_2_6.png"></p>
<h4>3.5 第五阶：第二代微服务 <a href="#scroller-20" id="scroller-20"></a></h4>
<p>为了避免每个服务都需要自己实现一套分布式系统通信的语义功能，随着技术的发展，一些面向微服务架构的通用开发框架出现了，如Twitter的<a href="https://finagle.github.io/">Finagle</a>、Facebook的<a href="https://code.facebook.com/posts/1503205539947302">Proxygen</a>以及Spring Cloud等，</p>
<p>这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。</p>
<p><img src="/images/blog/engineering/microservice-image_2_7.png" alt="image_2_7.png"></p>
<h4>3.6 第六阶：第一代Service Mesh <a href="#scroller-21" id="scroller-21"></a></h4>
<p>上面的第二代微服务框架目前看着挺完美了，但整套微服务框架其实是很复杂的，比如Spring Cloud，聚合了很多组件。所以在实践过程中，会发现有如下诸多问题：</p>
<ul>
<li>**侵入性强。**想要集成SDK的能力，除了需要添加相关依赖，业务层中入侵的代码、注解、配置，与治理层界限不清晰。</li>
<li>**升级成本高。**每次升级都需要业务应用修改SDK版本，重新进行功能回归测试，并对每一台服务进行部署上线，与快速迭代开发相悖。</li>
<li>**版本碎片化严重。**由于升级成本高，而中间件版本更新快，导致线上不同服务引用的SDK版本不统一、能力参差不齐，造成很难统一治理。</li>
<li>**中间件演变困难。**由于版本碎片化严重，导致中间件向前演进的过程中就需要在代码中兼容各种各样的老版本逻辑，带着&quot;枷锁”前行，无法实现快速迭代。</li>
<li>**内容多、门槛高。**依赖组件多，学习成本高，即使通用分布式系统屏蔽了很多的实现细节，我们引入微服务框架并熟练使用也是要花费巨大的精力的。</li>
<li>**治理功能不全。**不同于RPC框架，SpringCloud作为治理全家桶的典型，也不是万能的，诸如协议转换支持、多重授权机制、动态请求路由、故障注入、灰度发布等高级功能并没有覆盖到。</li>
<li>**无法实现真正意义上的语言无关性。**提供的框架一般只支持一种或几种语言，要将框架不支持的语言研发的服务也纳入微服务架构中，是比较有难度的。</li>
</ul>
<p>所以，第一代微服务架构 Service Mesh就产生了，它作为一个基础设施层，能够与业务解耦，主要解决复杂网络拓扑下微服务与微服务之间的通信，其实现形态一般为轻量级网络代理，并与应用以边车代理（SideCar）模式部署，同时对业务应用透明。</p>
<p><img src="/images/blog/engineering/microservice-image_2_8.png" alt="image_2_8.png"></p>
<p>SideCar将分布式服务的通信抽象为单独一层，需要和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求。</p>
<p>所以在这一层中它能够实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能。</p>
<p><img src="/images/blog/engineering/microservice-image_2_9.png" alt="image_2_9.png"></p>
<p>如果我们从一个全局视角来看，绿色的为应用服务，蓝色的为SideCar，就会得到如下部署图：</p>
<p><img src="/images/blog/engineering/microservice-image_2_10.png" alt="image_2_10.png"></p>
<p>如果我们省略去服务，只看Service Mesh的代理边车的网格应该是这样的：</p>
<p><img src="/images/blog/engineering/microservice-image_2_11.png" alt="image_2_11.png"></p>
<p>流量经过的时候，会先被代理边车所劫持，然后再进入服务，所以它就是一个由若干服务代理所组成的错综复杂的网格。</p>
<h4>3.7 第七阶：第二代Service Mesh <a href="#scroller-22" id="scroller-22"></a></h4>
<p>第一代Service Mesh由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的控制面板，我们称之为控制面（control plane）。</p>
<p>控制面和所有的数据面（data plane，即代理边车）进行交互，比如策略下发、数据采集等。这就是以Istio为代表的第二代Service Mesh。</p>
<p><img src="/images/blog/engineering/microservice-image_2_12.png" alt="image_2_12.png"></p>
<p>只包含控制面和数据面的 Service Mesh 服务网格全局结构图 如下：</p>
<p><img src="/images/blog/engineering/microservice-image_2_13.png" alt="image_2_13.png"></p>
<p>从上面的结构图可以看出，Service Mesh 的基础设施层主要分为两部分：控制平面与数据平面。当前流行的开源服务网格 Istio 和 Linkerd 都是这种构造。</p>
<p>控制平面的特点：</p>
<ul>
<li>不直接解析数据包。</li>
<li>与控制平面中的代理通信，下发策略和配置。</li>
<li>负责网络行为的可视化。</li>
<li>通常提供 API 或者命令行工具可用于配置版本化管理，便于持续集成和部署。</li>
</ul>
<p>数据平面的特点：</p>
<ul>
<li>通常是按照无状态目标设计的，但实际上为了提高流量转发性能，需要缓存一些数据，因此无状态也是有争议的。</li>
<li>直接处理入站和出站数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据等。</li>
<li>对应用来说透明，即可以做到无感知部署。</li>
</ul>
<p>到这一步我们大概了解了微服务架构的演进过程，也初步了解Service Mesh技术比较于传统的微服务架构有哪些优势。</p>
18:T22ab,<p>前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。</p>
<p>对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移。</p>
<h3>1 微服务迁移准备  <a href="#scroller-1" id="scroller-1"></a></h3>
<p>1、需对业务充分了解，这是服务拆分，通信设计，资源整合的必要前提。</p>
<p>2、适应微服务架构设计原则：小版本，高速迭代。</p>
<p>3、快速的环境提供能力：依赖于云计算、容器技术，快速交付环境。</p>
<p>4、服务合理拆分：需符合团队结构或能逆向影响，能对组织架构进行微调并划分职责。（康威定律和逆康威定律）</p>
<p>5、基本的监控能力：包括基础的技术监控和业务监控。</p>
<p>6、快速的应用部署能力：需要部署管道提供快速的部署能力。</p>
<p>7、DevOps 自动化运维能力：需要具有良好的持续集成和持续交付能力，还需要对问题、故障的快速响应能力，开发、测试和运维能协同工作。</p>
<h3>2 微服务颗粒的拆分策略 <a href="#scroller-2" id="scroller-2"></a></h3>
<p>前面两篇文章我们学习了What &amp; Why（什么是微服务和为什么需要做微服务架构），这一章我们就来探讨如何做微服务架构的拆分（How）。</p>
<p>微服务拆分没有一个绝对的标准答案，服务拆分的粒度需要根据业务场景来规划，而随着业务的发展，原先的架构方案也需要做调整。</p>
<p>虽然没有固定的套路，但是我们在业务实践过程中总结的一些经验，以做参考。</p>
<h4>2.1 基于业务逻辑拆分 <a href="#scroller-3" id="scroller-3"></a></h4>
<p>基于业务逻辑拆分相对好理解一点，典型的单一职责原则，我们将功能相近的业务整合到一个服务颗粒上。比如一个办公领域系统，考勤、工作流、音视频会议是是三个截然不同的业务领域，这可能就是我们拆分的一个入手点。</p>
<p><strong>2.1.1 领域模型拆分</strong></p>
<p>领域驱动设计DDD（Domain-Driven Design 领域驱动设计）是一个很简单的概念，表示我们对系统的划分是基于领域的，也即是基于业务方向去思考的。</p>
<p>举一个典型的电商业务例子。电商的业务体系庞大，涉及各方面的细节。但是我们大概能够根据业务的职能做一个拆分，比如阿里的电商中台业务，包含 用户账号子系统、商品子系统、订单子系统、客户子系统、物流子系统 等。</p>
<p>因为职能不同，这些领域之间包含清晰的界限，所以我们可以按照这个方向将服务于不同领域（商品域和订单域）的子系统拆成独立的服务颗粒。如下图：</p>
<p><img src="/images/blog/engineering/microservice-image_6_7.png" alt="image_6_7.png"></p>
<p><strong>2.1.2 用户群体拆分</strong></p>
<p>根据用户群体做拆分，我们首先要了解自己的系统业务里的用户角色领域是否没有功能耦合，有清晰的领域界限。</p>
<p>比如教育信息化系统，教师的业务场景和学生的业务场景，基本比较独立，而且拆分后流量上有明显的削弱，这时候结合具体的业务分析，看是否有价值。如下图所示：</p>
<p><img src="/images/blog/engineering/microservice-image_4_2.png" alt="image_4_2.png"></p>
<h4>2.2 基于可扩展拆分  <a href="#scroller-6" id="scroller-6"></a></h4>
<p>这个需要区分系统中变与不变的部分，不变的部分一般是成熟的、通用的服务功能，变的部分一般是改动比较多、满足业务迭代扩展性需要的功能，我们可以将不变的部分拆分出来，作为共用的服务，将变的部分独立出来满足个性化扩展需要。同时根据二八原则，系统中经常变动的部分大约只占 20%，而剩下的 80% 基本不变或极少变化，这样的拆分也解决了发布频率过多而影响成熟服务稳定性的问题。比如一个电商领域的系统，用户信息、基本商品信息、物流信息 等模块的管理能力和视图界面，一般是比较稳定的；而类似运营活动的功能和页面一般是经常变化的（520、618、双11），会有不同的活动策略和视图界面，需要经常迭代发布。如下图所示</p>
<p><img src="/images/blog/engineering/microservice-image_4_3.png" alt="image_4_3.png"></p>
<h4>2.3 基于可靠性拆分 <a href="#scroller-7" id="scroller-7"></a></h4>
<p><strong>2.3.1 核心模块拆分</strong></p>
<p>我们团队在做MySQL数据库和Redis集群拆分的时候，总会把一些重要的模块独立放在一个集群上，不与其他模块混用，而这个独立的集群，服务机性能要是最好的。这样做的目的是，当重要度较低的模块发生故障时，不会影响重要度高的模块。</p>
<p>同要的道理，我们会将  账号信息、登录信息、服务中心等重要度最高的要害模块单独拆分在一个服务颗粒上（因为这类模块不可用之后，整个系统基本完全瘫痪），再做成服务集群，来保障它的高可用。 如下图所示：</p>
<p><img src="/images/blog/engineering/microservice-image_4_4.png" alt="image_4_4.png"></p>
<p><strong>2.3.2 主次链路拆分</strong></p>
<p>在各个业务系统中，其实都会有主次业务链路。主业务链条，完成了业务系统中最核心的那部分工作。而次链路是保证其他基础功能的稳定运行。</p>
<p>以电商为例子：商品搜索-&gt;商品详情页-&gt;购物车模块-&gt;订单结算-&gt;支付业务，就是一条最简单的主链路。主链路是整个系统的核心主战场，最好的资源跟火力都要放在这里，保证不失守。</p>
<p>一个系统一般有多条核心链路和多条次链路，互相支持构成一个完整的系统。而我们将主次链路进行拆分，主要为了以下几个目标。</p>
<p><strong>异常容错</strong></p>
<p>为主链路建立层次化的降级策略（多级降级），以及合理的熔断策略，这部分我们将在Hystrix服务容错降级的文章中详细解释。</p>
<p><strong>计算资源分配</strong></p>
<p>主链路通常来讲都是高频场景，自然需要更多的计算资源，最主要的体现就是集群里分配的虚机数量多。比如电商场景中特惠专场抢购等。</p>
<p>但是无论是虚机的分配，还是kubernetes的动态扩缩容，应该都需要单独优待，如资源分配倾斜，独立治理等。</p>
<p><strong>服务隔离</strong></p>
<p>主链路是高频且核心的主业务模块，把主链路的服务与其他起辅助作用的业务服务隔离开来，避免次链路服务的异常情况影响到主链路服务。</p>
<p><img src="/images/blog/engineering/microservice-image_4_5.png" alt="image_4_5.png"></p>
<h4>2.4 基于性能需求拆分 <a href="#scroller-10" id="scroller-10"></a></h4>
<p>根据性能需求来进行拆分。简单来说就是访问量特别大，访问频率特别高的业务，又要保证高效的响应能力，这些业务对性能的要求特别高。比如积分竞拍、低价秒杀、限量抢购。</p>
<p>我们要识别出某些超高并发量的业务，尽可能把这部分业务独立拆分出来。这么做的原因非常简单，一个保证满足高性能业务需求，另一个保证业务的独立性，不互相影响。</p>
<p>类似积分竞拍、超低价秒杀、限量抢购，对瞬间峰值和计算性能要求是非常高的。这部分的业务如果跟其他通用业务放在一块，一个是可能互相影响，比如某个链路阻塞，会导致雪崩沿调用链向上传递。</p>
<p>另外一个是如果多个业务耦合在一块，发布频率变高、服务扩缩容变难、维护复杂度变高。</p>
<p><img src="/images/blog/engineering/microservice-image_4_6.png" alt="image_4_6.png"></p>
<h3>3 总结拆分原则 <a href="#scroller-11" id="scroller-11"></a></h3>
<ul>
<li>先少后多（微服务数量）、先粗后细(粒度)</li>
<li>基于业务逻辑进行拆分（用户群体、业务领域等模型）</li>
<li>基于可靠性（核心模块独立化、主次链路隔离）</li>
<li>基于性能拆分（独立拆分高性能场景）</li>
<li>接口需保证幂等</li>
<li>接口数据定义严禁内嵌，透传</li>
<li>规范化工程结构，符合微服务风格</li>
<li>不止对计算服务记性拆分，服务层 -&gt; 缓存层 -&gt; 数据层 的逐步拆解，才能发挥最大功效。</li>
</ul>
19:Td71a,<h1>分布式系统与事务：从基础到实践</h1>
<blockquote>
<p>当一个操作需要跨越多个服务、多个数据库才能完成时，如何保证&quot;要么全部成功，要么全部回滚&quot;？这就是分布式事务要解决的核心问题。</p>
<p>本文从分布式系统的基本概念出发，逐步深入到一致性理论和事务解决方案，力求构建一个完整的知识框架：<strong>为什么需要分布式 → 分布式带来了什么问题 → 理论上如何权衡 → 工程上如何解决</strong>。</p>
</blockquote>
<h3>阅读指南</h3>
<ul>
<li><strong>建立基础概念</strong>：第 1–2 章（约 5 分钟）</li>
<li><strong>理解理论框架</strong>：第 3–4 章（约 10 分钟）</li>
<li><strong>掌握事务方案</strong>：第 5–8 章（约 25 分钟）</li>
<li><strong>方案选型参考</strong>：第 9 章（约 5 分钟）</li>
</ul>
<hr>
<h2>1. 从集中式到分布式</h2>
<h3>1.1 集中式系统</h3>
<p>集中式系统的特点是：<strong>一个主机承担所有计算和存储</strong>，终端仅负责数据的输入和输出。早期的银行系统、大型企业的核心业务系统大多采用这种架构——从 IBM、HP 等厂商购买昂贵的大型主机，所有业务逻辑集中部署。</p>
<p>优点是部署简单，无需考虑节点间协调。但问题也很明显：</p>
<ul>
<li><strong>单点故障</strong>：主机宕机 = 整个系统瘫痪</li>
<li><strong>扩展性差</strong>：纵向扩展（加 CPU/内存）有物理上限，且成本指数增长</li>
<li><strong>维护困难</strong>：系统越来越大，所有逻辑耦合在一起</li>
</ul>
<h3>1.2 分布式系统</h3>
<p>《分布式系统概念与设计》中的定义：</p>
<blockquote>
<p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</blockquote>
<p>简单说就是：<strong>多台普通计算机通过网络协作，对外表现得像一台计算机</strong>。分布式意味着可以采用更多的普通计算机（相对于昂贵的大型主机）组成集群对外提供服务。计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问量也就越大。</p>
<p>分布式系统的四个基本特征：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分布性</strong></td>
<td>多台计算机在空间上可以随意分布——同一机柜、不同机房甚至不同城市。系统中没有控制整个系统的主机，也没有受控的从机</td>
</tr>
<tr>
<td><strong>透明性</strong></td>
<td>系统资源被所有计算机共享，每台计算机的用户不仅可以使用本机的资源，还可以使用系统中其他计算机的资源（包括 CPU、文件、存储等）。用户感知不到背后有多少台机器在提供服务</td>
</tr>
<tr>
<td><strong>协同性</strong></td>
<td>多台计算机可以互相协作来完成一个共同的任务，一个程序可以分布在几台计算机上并行运行</td>
</tr>
<tr>
<td><strong>通信性</strong></td>
<td>系统中任意两台计算机都可以通过网络通信来交换信息</td>
</tr>
</tbody></table>
<h3>1.3 常见的分布式方案</h3>
<p>分布式不是一种单一的技术，而是一种架构理念。在实际应用中，分布式思想体现在多个层面：</p>
<table>
<thead>
<tr>
<th>分布式方案</th>
<th>说明</th>
<th>典型技术</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分布式应用和服务</strong></td>
<td>将应用进行分层和分割，各模块独立部署。提高并发能力，减少资源竞争，使业务易于扩展</td>
<td>微服务架构、Spring Cloud、Dubbo</td>
</tr>
<tr>
<td><strong>分布式静态资源</strong></td>
<td>将 JS、CSS、图片等静态资源分布式部署，减轻应用服务器负载</td>
<td>CDN、对象存储（OSS/S3）</td>
</tr>
<tr>
<td><strong>分布式数据和存储</strong></td>
<td>海量数据单机无法容纳，分布到多台机器存储</td>
<td>分库分表（ShardingSphere）、HBase、Cassandra</td>
</tr>
<tr>
<td><strong>分布式计算</strong></td>
<td>将大型计算任务拆分为多个子任务，分配给多台机器并行处理</td>
<td>MapReduce、Spark、Flink</td>
</tr>
<tr>
<td><strong>分布式锁</strong></td>
<td>跨进程的互斥访问控制</td>
<td>Redis（RedLock）、ZooKeeper、etcd</td>
</tr>
<tr>
<td><strong>分布式缓存</strong></td>
<td>数据缓存分布在多个节点上，提高读取性能</td>
<td>Redis Cluster、Memcached</td>
</tr>
</tbody></table>
<h3>1.4 分布式 vs 集群</h3>
<p>这两个概念经常混淆，区别其实很简单：</p>
<pre><code>分布式（Distributed）：不同的服务器部署不同的服务模块，协作对外提供服务
    ┌──────────┐   ┌──────────┐   ┌──────────┐
    │ 用户服务  │   │ 订单服务  │   │ 支付服务  │
    └──────────┘   └──────────┘   └──────────┘

集群（Cluster）：不同的服务器部署相同的服务，通过负载均衡对外提供服务
    ┌──────────┐   ┌──────────┐   ┌──────────┐
    │ 订单服务A │   │ 订单服务B │   │ 订单服务C │
    └──────────┘   └──────────┘   └──────────┘
          │              │              │
          └──────────────┼──────────────┘
                   负载均衡器
</code></pre>
<p>实际系统往往是两者结合：每个分布式服务都以集群方式部署。</p>
<h3>1.5 分布式带来的新问题</h3>
<p>和集中式系统相比，分布式系统的性价比更高、处理能力更强、可靠性更高、也有更好的扩展性。但是，分布式在解决高并发问题的同时也带来了一些其他问题：</p>
<ul>
<li><strong>网络不可靠</strong>：分布式的必要条件是网络。延迟、丢包、分区随时可能发生，这对性能甚至服务能力都会造成影响</li>
<li><strong>时钟不同步</strong>：不同机器的系统时钟存在偏差（时钟漂移），无法依赖本地时间戳判定分布式事件的全局先后顺序</li>
<li><strong>节点故障</strong>：集群中的服务器数量越多，某台服务器宕机的概率也就越大</li>
<li><strong>数据一致性</strong>：由于服务分布式部署，用户的请求只会落到其中一台机器上。一旦处理不好就很容易产生数据一致性问题。这是分布式系统中最核心也最困难的问题</li>
</ul>
<blockquote>
<p>Leslie Lamport（Paxos 算法发明者，2013 年图灵奖得主）对分布式系统有一个著名的定义：&quot;A distributed system is one in which the failure of a computer you didn&#39;t even know existed can render your own computer unusable.&quot;——<strong>在分布式系统中，一台你甚至不知道其存在的计算机的故障，就可能让你自己的计算机变得不可用。</strong> 这句话精确地概括了分布式系统的根本复杂性。</p>
</blockquote>
<hr>
<h2>2. 数据一致性问题</h2>
<h3>2.1 从 ACID 说起</h3>
<p>在理解分布式一致性之前，先回顾单机数据库是如何保证一致性的。数据库通过<strong>事务</strong>（Transaction）机制来保证数据的 ACID 特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>含义</th>
<th>保障手段</th>
</tr>
</thead>
<tbody><tr>
<td><strong>A</strong>tomicity（原子性）</td>
<td>事务中的操作要么全部成功，要么全部回滚</td>
<td>undo log</td>
</tr>
<tr>
<td><strong>C</strong>onsistency（一致性）</td>
<td>事务执行前后，数据从一个一致状态转到另一个一致状态</td>
<td>由 A、I、D 共同保证</td>
</tr>
<tr>
<td><strong>I</strong>solation（隔离性）</td>
<td>并发事务之间互不干扰</td>
<td>锁 + MVCC</td>
</tr>
<tr>
<td><strong>D</strong>urability（持久性）</td>
<td>事务提交后数据不会丢失</td>
<td>redo log + WAL</td>
</tr>
</tbody></table>
<p>在集中式系统中，所有数据在一台机器上，一个数据库事务就能保证多个操作的原子性。但在分布式系统中，数据分散在多台机器上，<strong>本地事务的边界无法跨越网络</strong>——这就是分布式一致性问题的根源。</p>
<h3>2.2 分布式中的两种一致性</h3>
<p>在分布式系统中，&quot;一致性&quot;有两层含义，对应两类不同的问题：</p>
<p><strong>副本一致性</strong>（Replica Consistency）：同一份数据的多个副本之间是否相同。例如数据库主从复制中，主库写入后从库是否能立即读到最新值。再如配置中心的配置信息如何保证所有节点保持同步。</p>
<p><strong>事务一致性</strong>（Transactional Consistency）：一个跨多个服务的业务操作，所有步骤要么全部成功，要么全部回滚。例如电商下单需要同时扣库存、扣红包、扣优惠券——任何一步失败，已执行的步骤都应该回滚。</p>
<h3>2.3 为什么会出现一致性问题</h3>
<p>分布式系统的数据复制需求主要来源于两个原因：</p>
<p><strong>可用性</strong>：将数据复制到多台机器上，可以消除单点故障。当某台机器宕机时，其他机器上的副本仍然可以提供服务。</p>
<p><strong>性能</strong>：通过负载均衡技术，让分布在不同地方的数据副本都对外提供读服务，有效提高系统的吞吐量和响应速度。</p>
<p>但数据复制面临的主要难题就是<strong>如何保证多个副本之间的数据一致性</strong>。在引入复制机制后，不同数据节点之间由于网络延迟、节点故障等原因很容易产生数据不一致。</p>
<p>根源在于<strong>数据复制</strong>和<strong>服务拆分</strong>两个场景：</p>
<pre><code>场景一：数据副本同步延迟

  客户端写入 → 主库（成功）→ 同步 → 从库（延迟）
  客户端读取 → 从库 → 读到旧数据 ❌

场景二：跨服务调用部分失败

  下单服务
    ├── 调用库存服务：扣减库存 ✅
    ├── 调用红包服务：扣减红包 ✅
    └── 调用优惠券服务：扣减优惠券 ❌（超时）

  此时库存和红包已扣减，但优惠券未知 → 数据不一致
</code></pre>
<p>用一个具体的代码场景说明：</p>
<pre><code class="language-java">// 电商下单伪代码 —— 跨三个服务的操作
public OrderResult createOrder(OrderRequest request) {
    // 步骤1：扣减库存（调用库存服务）
    inventoryService.deduct(request.getSkuId(), request.getQuantity());

    // 步骤2：扣减红包（调用营销服务）
    couponService.deduct(request.getUserId(), request.getCouponId());

    // 步骤3：创建订单（本地数据库）
    orderDao.insert(request.toOrder());

    return OrderResult.success();
}
</code></pre>
<p>如果步骤 2 执行成功但步骤 3 失败了怎么办？库存和红包已经扣了，但订单没有创建——用户扣了钱却看不到订单。这就是分布式事务要解决的问题。</p>
<hr>
<h2>3. 理论基础：CAP 与 BASE</h2>
<h3>3.1 CAP 定理</h3>
<p>2000 年，Eric Brewer 在 ACM PODC 会议上提出了 CAP 猜想，2002 年由 Seth Gilbert 和 Nancy Lynch 正式证明为定理：<strong>一个分布式系统最多只能同时满足以下三项中的两项</strong>——</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>C</strong>onsistency（一致性）</td>
<td>所有节点在同一时刻看到相同的数据。更准确地说，对于任何读操作，要么返回最近一次写操作的结果，要么返回错误</td>
<td>写入主库后，所有从库立即可读到新值</td>
</tr>
<tr>
<td><strong>A</strong>vailability（可用性）</td>
<td>每个请求都能在合理时间内收到<strong>非错误</strong>响应（注意：不保证是最新数据）</td>
<td>任意时刻发送请求，系统都能正常响应</td>
</tr>
<tr>
<td><strong>P</strong>artition tolerance（分区容错性）</td>
<td>网络分区（节点之间的通信中断或延迟）发生时，系统仍能继续运作</td>
<td>机房之间的网络断了，各机房仍能独立提供服务</td>
</tr>
</tbody></table>
<h4>为什么 P 不可放弃</h4>
<p>在实际的分布式系统中，网络分区（P）是不可避免的——网络硬件会故障、光纤会被挖断、交换机会宕机。你不能假设网络永远不会出问题。正如 2012 年 Coda Hale 在其文章中论证的：&quot;you cannot choose CA&quot;——一旦系统部署在多台机器上，网络分区就是物理现实而非可选项。</p>
<p>因此，<strong>CAP 的核心不是&quot;三选二&quot;，而是在发生网络分区时，你选择一致性还是可用性</strong>：</p>
<pre><code>                        CAP 三角
                          C
                         / \
                        /   \
                       /     \
                   CP /       \ CA（理论上存在，
                     /         \   实际不可行，
                    /           \  因为 P 不可避免）
                   P ─────────── A
                        AP
</code></pre>
<h4>CP 与 AP 的工程实践</h4>
<table>
<thead>
<tr>
<th>策略</th>
<th>取舍</th>
<th>典型系统</th>
<th>工程表现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP</strong></td>
<td>保证一致性，牺牲部分可用性</td>
<td>ZooKeeper、etcd、HBase</td>
<td>网络分区时，少数派节点拒绝服务（返回错误），直到分区恢复后才重新提供服务。适用于对数据正确性要求极高的场景：分布式锁、配置管理、leader 选举</td>
</tr>
<tr>
<td><strong>AP</strong></td>
<td>保证可用性，允许短暂不一致</td>
<td>Cassandra、DynamoDB、DNS、Eureka</td>
<td>网络分区时，所有节点继续提供服务，但不同节点可能返回不同版本的数据。分区恢复后通过反熵协议（anti-entropy）或读修复（read repair）等机制达到一致。适用于对可用性要求极高的场景：用户信息缓存、社交动态</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>重要澄清</strong>：CAP 中的&quot;放弃一致性&quot;不是说数据可以永远不一致，而是放弃<strong>强一致性</strong>，允许数据在短时间内不一致，但最终会达到一致。分布式系统无论在 CAP 三者之间如何权衡，都<strong>无法彻底放弃一致性</strong>——如果真的放弃一致性，系统中的数据就不可信，那么这个系统也就没有任何价值可言。所以，我们常说的&quot;放弃一致性&quot;实际指的是放弃<strong>强一致性</strong>，而不是完全不保证一致性。这就引出了 BASE 理论。</p>
</blockquote>
<h3>3.2 BASE 理论</h3>
<p>BASE 是对 CAP 中 AP 策略的延伸，它的核心思想是：<strong>即使无法做到强一致性，也可以通过适当的方式达到最终一致性</strong>。</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>BA</strong></td>
<td>Basically Available</td>
<td>基本可用——出现故障时允许损失<strong>部分非核心功能</strong>（如降级、限流），但核心功能可用</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>Soft State</td>
<td>软状态——允许系统中的数据存在中间状态，即允许不同节点之间的数据副本在同步过程中暂时不一致</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>Eventually Consistent</td>
<td>最终一致——软状态不会一直持续，经过一段时间后，所有副本最终会达到一致状态</td>
</tr>
</tbody></table>
<h4>&quot;基本可用&quot;的两种典型表现</h4>
<ul>
<li><strong>响应时间上的损失</strong>：正常情况下搜索引擎在 0.5 秒内返回结果，故障时可以延长到 1-2 秒</li>
<li><strong>功能上的损失</strong>：电商大促时，为了保护核心的购买流程，暂时关闭评论、推荐等非核心功能</li>
</ul>
<h4>BASE vs ACID</h4>
<p>BASE 理论是对 ACID 的妥协和补充。ACID 追求强一致性模型，BASE 追求的则是通过牺牲强一致性来获得可用性：</p>
<pre><code>ACID（强一致性，悲观策略）      BASE（最终一致性，乐观策略）
──────────────────────        ──────────────────────────
Atomicity   原子性             Basically Available  基本可用
Consistency 一致性             Soft State           软状态
Isolation   隔离性             Eventually Consistent 最终一致
Durability  持久性

ACID 适用于：银行转账、库存扣减等对一致性要求极高的场景
BASE 适用于：社交动态、搜索索引等可以容忍短暂不一致的场景
</code></pre>
<p>在实际系统中，ACID 和 BASE 不是非此即彼的选择，很多系统会<strong>混合使用</strong>——核心链路用 ACID，非核心链路用 BASE。</p>
<hr>
<h2>4. 一致性模型</h2>
<p>一致性模型定义了&quot;数据写入后，读取方能看到什么&quot;的约定。不同的模型在<strong>一致性强度</strong>和<strong>系统性能</strong>之间做出不同的取舍。如何能既保证数据一致性，又保证系统的性能，是每一个分布式系统都需要重点考虑和权衡的。一致性模型可以在做这些权衡的时候给我们很多借鉴和思考。</p>
<h3>4.1 强一致性（Linearizability）</h3>
<p>当更新操作完成之后，任何多个后续进程或线程的访问都会返回最新的更新过的值。这种是对用户最友好的——用户上一次写什么，下一次就保证能读到什么。</p>
<pre><code>时间线 →

Writer:     Write(x=1) ──── 完成
Reader A:                         Read(x) → 1 ✅
Reader B:                         Read(x) → 1 ✅
</code></pre>
<p>但这种实现对性能影响较大，因为这意味着<strong>只要上次的操作没有处理完，就不能让用户读取数据</strong>。所有读取都必须等待写入完成并同步到所有副本。单机数据库的事务就是强一致性的典型实现；在分布式环境中，Raft/Paxos 等共识算法可以实现强一致性，但代价是更高的延迟和更低的吞吐量。</p>
<h3>4.2 弱一致性</h3>
<p>系统并不保证后续进程或线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，<strong>不承诺立即可以读到最新写入的值，也不会具体地承诺多久之后可以读到</strong>。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。</p>
<p>从写入到最终所有读取都能看到新值的这段时间，被称为**&quot;不一致窗口&quot;（inconsistency window）**。弱一致性不对这个窗口的大小做任何承诺。</p>
<h3>4.3 最终一致性</h3>
<p>弱一致性的特定形式。系统保证：<strong>在没有后续更新的前提下，系统最终返回上一次更新操作的值</strong>。在没有故障发生的前提下，不一致窗口的时间主要受<strong>通信延迟</strong>、<strong>系统负载</strong>和<strong>复制副本的个数</strong>影响。</p>
<p>DNS 是最典型的最终一致性系统——你修改了域名解析记录，全球各地的 DNS 服务器不会立即更新，但经过 TTL 时间后，所有节点都会拿到新值。</p>
<h3>4.4 最终一致性的变体</h3>
<p>最终一致性有几种重要的变体，它们在&quot;最终一致&quot;的基础上提供了更具体的保证：</p>
<p><strong>因果一致性（Causal Consistency）</strong></p>
<p>如果进程 A 在更新之后通知了进程 B，那么进程 B 的后续访问将返回更新后的值。与进程 A 没有因果关系的进程 C，则遵循最终一致性的规则。例如：A 发了一条微博，B 对该微博进行了评论。其他用户看到 B 的评论时，一定能看到 A 的原始微博——因为评论和原微博之间存在因果关系。</p>
<p><strong>读己所写一致性（Read-your-writes Consistency）</strong></p>
<p>因果一致性的特定形式。一个进程总可以读到自己更新的数据。例如：用户更新了头像后刷新页面，一定能看到新头像——即使这个更新还没有同步到所有从库。</p>
<p><strong>会话一致性（Session Consistency）</strong></p>
<p>读己所写一致性的特定形式。进程在访问存储系统的同一个会话内，系统保证该进程读己之所写。会话结束后，新的会话可能读到旧值。实现方式通常是将同一会话的读写请求路由到同一个节点（session stickiness）。</p>
<p><strong>单调读一致性（Monotonic Read Consistency）</strong></p>
<p>如果一个进程已经读取到一个特定值，那么该进程不会再读取到该值以前的任何值。也就是说，读到的数据版本只会前进，不会后退。例如：用户刷新页面看到了 10 条评论，再次刷新不应该看到只有 8 条——这在请求被负载均衡到不同从库时容易出现。</p>
<p><strong>单调写一致性（Monotonic Write Consistency）</strong></p>
<p>系统保证来自同一个进程的写操作被串行化执行。例如：用户先修改了用户名，再修改了头像，系统不会出现头像先于用户名更新的情况。</p>
<h4>变体的组合</h4>
<p>上述最终一致性的不同变体可以进行<strong>组合</strong>使用。从实践的角度来看，<strong>读己所写 + 单调读</strong>的组合是最实用的——用户总能读取到自己更新的数据，并且一旦读取到最新的版本就不会再读取到旧版本。这个组合对于分布式架构上的程序开发来说，会减少很多额外的复杂性。大部分互联网应用的最终一致性方案都在追求这个组合。</p>
<pre><code>一致性模型强度排序（由强到弱）：

强一致性 &gt; 因果一致性 &gt; 读己所写 &gt; 会话一致性 &gt; 单调读/单调写 &gt; 最终一致性 &gt; 弱一致性
   ↑                                                                    ↑
   │                                                                    │
 性能最差，一致性最强                                            性能最好，一致性最弱
</code></pre>
<hr>
<h2>5. 分布式事务：2PC</h2>
<h3>5.1 什么是分布式事务</h3>
<p>分布式事务是将单库事务的概念扩展到多库/多服务——<strong>跨越多个独立节点的操作，要么全部提交，要么全部回滚</strong>。</p>
<p>核心困难在于：每个节点只知道自己的事务执行结果，不知道其他节点的情况。因此需要引入一个**协调者（Coordinator）**来统一决策。</p>
<h3>5.2 XA 规范</h3>
<p>X/Open 组织定义的分布式事务处理模型（DTP），包含四个角色：</p>
<pre><code>┌──────────────────────────────────────────────────────┐
│                    应用程序（AP）                       │
│                  发起全局事务                           │
└──────────┬───────────────────────────┬───────────────┘
           │                           │
           ▼                           ▼
┌──────────────────┐        ┌──────────────────┐
│  事务管理器（TM）  │        │ 通信资源管理器(CRM)│
│  协调全局事务      │        │  消息中间件        │
│  （交易中间件）    │        │                   │
└────────┬─────────┘        └──────────────────┘
         │
    ┌────┴────┐
    ▼         ▼
┌───────┐ ┌───────┐
│RM（DB1）│ │RM（DB2）│
│资源管理器│ │资源管理器│
└───────┘ └───────┘
</code></pre>
<p>XA 是 TM 与 RM 之间的接口规范——定义了 <code>xa_start</code>、<code>xa_end</code>、<code>xa_prepare</code>、<code>xa_commit</code>、<code>xa_rollback</code> 等接口函数，由数据库厂商实现。<strong>2PC 和 3PC 就是基于 XA 规范的具体协议实现</strong>。</p>
<h3>5.3 两阶段提交（2PC）</h3>
<p>2PC 是最经典的分布式事务协议，核心思想：<strong>先投票，再执行</strong>。</p>
<h4>第一阶段：准备（Prepare / Vote）</h4>
<pre><code>          协调者（TM）
            │
    ┌───────┼───────┐
    │ Prepare       │ Prepare
    ▼               ▼
 参与者A          参与者B
 执行本地事务      执行本地事务
 写 redo/undo     写 redo/undo
 但不提交         但不提交
    │               │
    │  Yes/No       │  Yes/No
    └───────┬───────┘
            ▼
          协调者
</code></pre>
<p>每个参与者执行本地事务，写入 redo 和 undo 日志，但<strong>不提交</strong>，然后向协调者报告&quot;我准备好了（Yes）&quot;或&quot;我执行失败了（No）&quot;。</p>
<h4>第二阶段：提交 / 回滚（Commit / Rollback）</h4>
<p><strong>情况一：所有参与者都返回 Yes → 提交</strong></p>
<pre><code>          协调者
            │
    ┌───────┼───────┐
    │ Commit        │ Commit
    ▼               ▼
 参与者A          参与者B
 正式提交事务      正式提交事务
 释放锁资源        释放锁资源
    │               │
    │  ACK          │  ACK
    └───────┬───────┘
            ▼
       事务完成 ✅
</code></pre>
<p><strong>情况二：任一参与者返回 No 或超时 → 回滚</strong></p>
<pre><code>          协调者
            │
    ┌───────┼───────┐
    │ Rollback      │ Rollback
    ▼               ▼
 参与者A          参与者B
 利用 undo 回滚   利用 undo 回滚
 释放锁资源        释放锁资源
    │               │
    │  ACK          │  ACK
    └───────┬───────┘
            ▼
       事务回滚 ❌
</code></pre>
<h4>Java 中的 XA 事务示例</h4>
<pre><code class="language-java">// 使用 JTA（Java Transaction API）实现 2PC
import javax.transaction.UserTransaction;
import javax.sql.XADataSource;

public class XATransactionExample {

    public void transfer(BigDecimal amount) throws Exception {
        UserTransaction utx = (UserTransaction) ctx.lookup(&quot;java:comp/UserTransaction&quot;);

        // XA 数据源（两个不同的数据库）
        Connection connA = xaDataSourceA.getConnection();  // 账户库
        Connection connB = xaDataSourceB.getConnection();  // 积分库

        try {
            utx.begin();  // 开启全局事务

            // 操作数据库 A：扣减账户余额
            PreparedStatement psA = connA.prepareStatement(
                &quot;UPDATE account SET balance = balance - ? WHERE user_id = ?&quot;);
            psA.setBigDecimal(1, amount);
            psA.setLong(2, userId);
            psA.executeUpdate();

            // 操作数据库 B：增加积分
            PreparedStatement psB = connB.prepareStatement(
                &quot;UPDATE points SET total = total + ? WHERE user_id = ?&quot;);
            psB.setInt(1, amount.intValue());
            psB.setLong(2, userId);
            psB.executeUpdate();

            utx.commit();  // 两阶段提交：TM 协调两个 RM 一起提交
        } catch (Exception e) {
            utx.rollback();  // 两个数据库一起回滚
            throw e;
        }
    }
}
</code></pre>
<h4>2PC 的问题</h4>
<p>二阶段提交看起来确实能够提供原子性的操作，但不幸的是，它存在几个严重的缺陷：</p>
<p><strong>问题一：同步阻塞</strong></p>
<p>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问这些公共资源将不得不处于阻塞状态。从准备阶段开始，参与者就持有了锁资源（写入了 redo/undo 日志，锁定了相关行），这些锁一直要到提交阶段完成才能释放。在高并发场景下，这种长时间持锁会严重影响系统吞吐量。</p>
<p><strong>问题二：单点故障</strong></p>
<p>由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，如果协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。虽然可以通过选举协议重新选出一个协调者，但这<strong>无法解决因为协调者宕机导致的参与者已经处于阻塞状态的问题</strong>——新协调者并不知道上一个协调者在宕机前做出了什么决定。</p>
<p><strong>问题三：数据不一致</strong></p>
<p>在二阶段提交的第二阶段中，当协调者向参与者发送 Commit 请求之后，发生了局部网络异常，或者在发送 Commit 请求过程中协调者发生了故障，这会导致<strong>只有一部分参与者接收到了 Commit 请求</strong>。收到 Commit 请求的参与者会执行提交操作，而其他未收到的参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的现象。</p>
<pre><code>协调者发送 Commit 后宕机：

协调者 ──→ Commit ──→ 参与者A（收到，执行提交 ✅）
       ──→ Commit ──✗  参与者B（未收到，仍在等待 ⏳）
       ──→ Commit ──✗  参与者C（未收到，仍在等待 ⏳）

结果：A 已提交，B 和 C 仍在阻塞 → 数据不一致
</code></pre>
<p><strong>问题四：二阶段无法解决的问题</strong></p>
<p>协调者在发出 Commit 消息之后宕机，而<strong>唯一接收到这条消息的参与者同时也宕机了</strong>。那么即使通过选举协议产生了新的协调者，这条事务的状态也是不确定的——没有人知道事务是否已经被提交。新协调者无法从其他存活的参与者那里获取足够信息来做出正确的决定。</p>
<hr>
<h2>6. 分布式事务：3PC</h2>
<h3>6.1 3PC 对 2PC 的改进</h3>
<p>由于二阶段提交存在着同步阻塞、单点故障、数据不一致等缺陷，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。与两阶段提交不同的是，三阶段提交有两个核心改动：</p>
<ol>
<li><strong>引入超时机制</strong>：同时在协调者和参与者中都引入超时机制。2PC 中只有协调者有超时机制，参与者在等待协调者指令时会无限阻塞。3PC 的参与者在超时后可以自行做出决定，避免了无限阻塞</li>
<li><strong>增加预提交阶段</strong>：在第一阶段和第二阶段之间插入一个准备阶段（将 2PC 的准备阶段一分为二），保证了在最后提交阶段之前各参与节点的状态是一致的</li>
</ol>
<h3>6.2 三个阶段</h3>
<pre><code>阶段1: CanCommit         阶段2: PreCommit         阶段3: DoCommit
(轻量级询问)             (预执行 + 写日志)         (正式提交)

  协调者 ──→ 参与者       协调者 ──→ 参与者        协调者 ──→ 参与者
  &quot;能提交吗?&quot;            &quot;预提交&quot;                 &quot;正式提交&quot;
  参与者 ──→ 协调者       参与者 ──→ 协调者        参与者 ──→ 协调者
  &quot;Yes / No&quot;            &quot;ACK&quot;(执行事务,写日志)    &quot;ACK&quot;(提交,释放锁)
</code></pre>
<h4>阶段一：CanCommit（询问）</h4>
<p>协调者向参与者发送 CanCommit 请求，询问是否可以执行事务提交操作，然后开始等待参与者的响应。参与者接到请求后，评估自身能否顺利执行事务（检查资源、权限等），如果认为可以则返回 Yes 响应并进入预备状态，否则返回 No。</p>
<p><strong>注意：此阶段参与者不执行任何事务操作</strong>——这是与 2PC 准备阶段的关键区别。2PC 的第一阶段参与者就要执行事务并持有锁，而 3PC 的 CanCommit 只是一个轻量级的&quot;询问&quot;，不占用任何资源。</p>
<h4>阶段二：PreCommit（预执行）</h4>
<p>协调者根据参与者的反应来决定是否可以进行事务的预执行。根据响应情况，有两种可能：</p>
<p><strong>所有参与者返回 Yes → 预执行事务</strong></p>
<ol>
<li>协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段</li>
<li>参与者接收到 PreCommit 请求后，执行事务操作，将 undo 和 redo 信息记录到事务日志中（但不提交）</li>
<li>如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令</li>
</ol>
<p><strong>任一参与者返回 No 或超时 → 中断事务</strong></p>
<ol>
<li>协调者向所有参与者发送 Abort 请求</li>
<li>参与者收到 Abort 请求之后（或超时之后仍未收到协调者请求），执行事务中断</li>
</ol>
<h4>阶段三：DoCommit（正式提交）</h4>
<p>该阶段进行真正的事务提交，同样分为两种情况：</p>
<p><strong>正常提交</strong></p>
<ol>
<li>协调者接收到所有参与者发送的 ACK 响应，从预提交状态进入提交状态，向所有参与者发送 DoCommit 请求</li>
<li>参与者接收到 DoCommit 请求后，执行正式的事务提交，并在完成后释放所有事务资源</li>
<li>参与者向协调者发送 ACK 响应</li>
<li>协调者接收到所有参与者的 ACK 后，完成事务</li>
</ol>
<p><strong>中断事务</strong></p>
<ol>
<li>协调者没有接收到参与者发送的 ACK 响应（可能参与者发送的不是 ACK，也可能响应超时），向所有参与者发送 Abort 请求</li>
<li>参与者接收到 Abort 请求后，利用阶段二记录的 undo 信息执行事务回滚，并在完成后释放所有事务资源</li>
<li>参与者完成回滚后，向协调者发送 ACK 消息</li>
<li>协调者接收到参与者反馈的 ACK 消息后，中断事务</li>
</ol>
<h4>超时默认提交的设计推理</h4>
<p><strong>关键设计</strong>：如果参与者在阶段三等待超时（没收到 DoCommit 也没收到 Abort），它会<strong>默认提交</strong>。</p>
<p>这个设计是基于概率推理的：当进入第三阶段时，说明参与者在第二阶段已经收到了 PreCommit 请求。而协调者产生 PreCommit 请求的前提条件是——它在第二阶段开始之前，收到了<strong>所有参与者</strong>的 CanCommit 响应都是 Yes。换句话说，<strong>一旦参与者收到了 PreCommit，就意味着它知道大家其实都同意修改了</strong>。所以，当进入第三阶段时，虽然参与者由于网络超时没有收到 Commit 或 Abort 响应，但它有理由相信：成功提交的概率远大于需要回滚的概率。</p>
<h3>6.3 2PC vs 3PC 对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>2PC</th>
<th>3PC</th>
</tr>
</thead>
<tbody><tr>
<td>阶段数</td>
<td>2（准备 + 提交）</td>
<td>3（询问 + 预提交 + 提交）</td>
</tr>
<tr>
<td>超时机制</td>
<td>仅协调者有</td>
<td>协调者和参与者都有</td>
</tr>
<tr>
<td>阻塞风险</td>
<td>高（协调者宕机 → 参与者永久阻塞）</td>
<td>低（参与者超时后默认提交）</td>
</tr>
<tr>
<td>一致性</td>
<td>可能不一致（部分提交）</td>
<td>仍可能不一致（见下文）</td>
</tr>
<tr>
<td>网络开销</td>
<td>较低</td>
<td>多一轮通信</td>
</tr>
</tbody></table>
<p>相对于 2PC，3PC 主要解决的是单点故障问题，并减少了阻塞——因为一旦参与者无法及时收到来自协调者的信息之后，它会默认执行 Commit，而不会一直持有事务资源并处于阻塞状态。</p>
<p>但是这种机制也会导致数据一致性问题：由于网络原因，协调者发送的 Abort 响应没有及时被参与者接收到，那么参与者在等待超时之后执行了 Commit 操作。这样就和其他接到 Abort 命令并执行了回滚的参与者之间存在数据不一致。</p>
<blockquote>
<p>无论 2PC 还是 3PC 都无法彻底解决分布式一致性问题。Google Chubby 的作者 Mike Burrows 说过：&quot;there is only one consensus protocol, and that&#39;s Paxos&quot; — all other approaches are just broken versions of Paxos. 意即<strong>世上只有一种一致性算法，那就是 Paxos</strong>，所有其他一致性算法都是 Paxos 算法的不完整版。但在工程实践中，我们更多使用的是下面介绍的几种<strong>柔性事务</strong>方案。</p>
</blockquote>
<hr>
<h2>7. 柔性事务方案</h2>
<p>2PC/3PC 是<strong>刚性事务</strong>——追求强一致性，代价是性能和可用性。在互联网业务中，更常用的是<strong>柔性事务</strong>——基于 BASE 理论，接受短暂的不一致，保证最终一致性。</p>
<h3>7.1 TCC（Try-Confirm-Cancel）</h3>
<p>TCC 将每个业务操作拆分为三个步骤：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Try</strong></td>
<td>资源预留</td>
<td>冻结库存、冻结余额，但不真正扣减</td>
</tr>
<tr>
<td><strong>Confirm</strong></td>
<td>确认执行</td>
<td>将冻结的资源正式扣减（幂等）</td>
</tr>
<tr>
<td><strong>Cancel</strong></td>
<td>取消释放</td>
<td>将冻结的资源释放回去（幂等）</td>
</tr>
</tbody></table>
<pre><code>┌─────────────────────────────────────────────────────────┐
│                    TCC 执行流程                           │
│                                                          │
│  业务发起方                                               │
│    │                                                     │
│    ├── Try(库存服务): 冻结 10 件库存                       │
│    ├── Try(余额服务): 冻结 100 元                          │
│    ├── Try(优惠券服务): 冻结优惠券                          │
│    │                                                     │
│    ├─ 全部 Try 成功 ──→ Confirm 所有服务 ──→ 事务完成 ✅    │
│    │                                                     │
│    └─ 任一 Try 失败 ──→ Cancel 已 Try 的服务 ──→ 事务回滚 ❌│
└─────────────────────────────────────────────────────────┘
</code></pre>
<h4>代码示例</h4>
<pre><code class="language-java">// 库存服务的 TCC 实现
public class InventoryTccService {

    // Try：冻结库存（不真正扣减）
    public boolean tryDeduct(String skuId, int quantity) {
        int updated = jdbcTemplate.update(
            &quot;UPDATE inventory SET available = available - ?, frozen = frozen + ? &quot; +
            &quot;WHERE sku_id = ? AND available &gt;= ?&quot;,
            quantity, quantity, skuId, quantity);
        return updated &gt; 0;
    }

    // Confirm：将冻结的库存正式扣减
    public boolean confirm(String skuId, int quantity) {
        jdbcTemplate.update(
            &quot;UPDATE inventory SET frozen = frozen - ? WHERE sku_id = ? AND frozen &gt;= ?&quot;,
            quantity, skuId, quantity);
        return true;
    }

    // Cancel：释放冻结的库存
    public boolean cancel(String skuId, int quantity) {
        jdbcTemplate.update(
            &quot;UPDATE inventory SET available = available + ?, frozen = frozen - ? &quot; +
            &quot;WHERE sku_id = ? AND frozen &gt;= ?&quot;,
            quantity, quantity, skuId, quantity);
        return true;
    }
}
</code></pre>
<h4>TCC 的关键要求</h4>
<ul>
<li><strong>Confirm 和 Cancel 必须幂等</strong>：网络重试可能导致重复调用</li>
<li><strong>Cancel 必须能处理 Try 未执行的情况</strong>（空回滚）：如果 Try 因为超时未到达，TCC 框架可能直接调 Cancel</li>
<li><strong>防悬挂</strong>：Cancel 执行后，迟到的 Try 不能再执行</li>
</ul>
<h4>适用场景</h4>
<p>适合对一致性要求较高、资源可以预留的场景：资金转账、库存预扣、票务预订等。</p>
<h3>7.2 Saga 模式</h3>
<p>Saga 将一个长事务拆分为一系列<strong>本地事务</strong>，每个本地事务都有对应的<strong>补偿操作</strong>。如果某个步骤失败，按反方向依次执行补偿操作。</p>
<pre><code>正向执行：T1 → T2 → T3 → T4 → 完成 ✅

异常回滚：T1 → T2 → T3(失败) → C2 → C1 → 回滚完成 ❌
                                 ↑补偿T2  ↑补偿T1
</code></pre>
<p>Saga 有两种实现方式：</p>
<p><strong>编排式（Choreography）</strong>：每个服务完成本地事务后发布事件，下游服务监听事件执行自己的操作。去中心化，但流程难以追踪。</p>
<pre><code>订单服务         库存服务         支付服务
  │                │                │
  ├─ 创建订单 ────→│                │
  │  发布事件       ├─ 扣减库存 ────→│
  │               │  发布事件       ├─ 执行支付
  │               │               │  发布事件
  │←───────────── │←───────────── │
  │  （如果失败，反向发布补偿事件）     │
</code></pre>
<p><strong>协调式（Orchestration）</strong>：引入一个 Saga 协调器，集中控制每个步骤的执行和补偿。流程清晰，便于监控。</p>
<pre><code class="language-java">// Saga 协调器伪代码
public class OrderSagaOrchestrator {

    public void execute(OrderRequest request) {
        SagaContext context = new SagaContext(request);

        try {
            // 正向执行
            context.execute(&quot;创建订单&quot;,
                () -&gt; orderService.create(request),
                () -&gt; orderService.cancel(request));       // 补偿操作

            context.execute(&quot;扣减库存&quot;,
                () -&gt; inventoryService.deduct(request),
                () -&gt; inventoryService.restore(request));   // 补偿操作

            context.execute(&quot;执行支付&quot;,
                () -&gt; paymentService.charge(request),
                () -&gt; paymentService.refund(request));      // 补偿操作

        } catch (Exception e) {
            // 任一步骤失败 → 反向执行已完成步骤的补偿操作
            context.compensate();
        }
    }
}
</code></pre>
<h4>TCC vs Saga 对比</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>TCC</th>
<th>Saga</th>
</tr>
</thead>
<tbody><tr>
<td>隔离性</td>
<td>较强（Try 阶段锁定资源）</td>
<td>较弱（无资源预留，中间状态可见）</td>
</tr>
<tr>
<td>业务侵入</td>
<td>高（需实现 Try/Confirm/Cancel 三个接口）</td>
<td>中（需实现业务操作 + 补偿操作）</td>
</tr>
<tr>
<td>适用场景</td>
<td>短事务、需要资源预留</td>
<td>长事务、跨多个服务的业务流程</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>高（空回滚、悬挂、幂等）</td>
<td>中等（补偿逻辑、幂等）</td>
</tr>
</tbody></table>
<h3>7.3 本地消息表</h3>
<p>通过<strong>本地数据库事务</strong>保证业务操作和消息写入的原子性，再通过<strong>异步消息</strong>驱动下游操作，最终达到一致。</p>
<pre><code>┌────────────────────────────────────────────────────────────┐
│                    本地消息表流程                             │
│                                                             │
│  上游服务（同一个数据库事务内）                                │
│    ├── 执行业务操作（如创建订单）                              │
│    └── 写入消息表（status = PENDING）                        │
│         │                                                   │
│  定时任务 ──→ 扫描 PENDING 消息 ──→ 发送到 MQ               │
│         │                                                   │
│  发送成功 ──→ 更新 status = SENT                            │
│         │                                                   │
│  下游服务 ←── 消费 MQ 消息 ──→ 执行业务操作（幂等）           │
│         │                                                   │
│  消费成功 ──→ 回调上游 ──→ 更新 status = DONE               │
└────────────────────────────────────────────────────────────┘
</code></pre>
<h4>代码示例</h4>
<pre><code class="language-java">// 上游服务：业务操作 + 消息写入在同一个本地事务中
@Transactional
public void createOrder(OrderRequest request) {
    // 1. 执行业务操作
    orderDao.insert(request.toOrder());

    // 2. 写入消息表（同一个数据库，同一个事务）
    localMessageDao.insert(new LocalMessage(
        UUID.randomUUID().toString(),
        &quot;ORDER_CREATED&quot;,
        JsonUtils.toJson(request),
        &quot;PENDING&quot;
    ));
    // 事务提交后，两条记录要么都写入，要么都不写入
}

// 定时任务：扫描并发送未处理的消息
@Scheduled(fixedDelay = 5000)
public void sendPendingMessages() {
    List&lt;LocalMessage&gt; messages = localMessageDao.queryByStatus(&quot;PENDING&quot;);
    for (LocalMessage msg : messages) {
        try {
            mqProducer.send(msg.getTopic(), msg.getBody());
            localMessageDao.updateStatus(msg.getId(), &quot;SENT&quot;);
        } catch (Exception e) {
            // 发送失败不更新状态，下次定时任务重试
            log.warn(&quot;send message failed, will retry: {}&quot;, msg.getId());
        }
    }
}
</code></pre>
<p>优点是实现简单、不依赖特殊中间件。缺点是需要定时轮询，实时性取决于轮询间隔。</p>
<h3>7.4 事务消息（RocketMQ）</h3>
<p>RocketMQ 原生支持事务消息，相当于<strong>中间件级别的本地消息表</strong>——将&quot;本地事务 + 消息发送&quot;的原子性保证从应用层下沉到了消息中间件。</p>
<pre><code>┌──────────────────────────────────────────────────────────┐
│                  RocketMQ 事务消息流程                      │
│                                                           │
│  Producer                  RocketMQ               Consumer│
│    │                          │                       │   │
│    ├── 1.发送半消息(Half) ────→│                       │   │
│    │                          ├── 半消息对消费者不可见   │   │
│    │←── 2.半消息发送成功 ──────┤                       │   │
│    │                          │                       │   │
│    ├── 3.执行本地事务          │                       │   │
│    │    (如写数据库)           │                       │   │
│    │                          │                       │   │
│    ├── 4a.本地事务成功         │                       │   │
│    │   发送 Commit ──────────→├── 消息对消费者可见 ───→│   │
│    │                          │                       │   │
│    ├── 4b.本地事务失败         │                       │   │
│    │   发送 Rollback ────────→├── 删除半消息           │   │
│    │                          │                       │   │
│    │── 4c.超时未响应           │                       │   │
│    │                          ├── 5.回查本地事务状态    │   │
│    │←─────────────────────────┤                       │   │
│    ├── 返回 Commit/Rollback ─→│                       │   │
└──────────────────────────────────────────────────────────┘
</code></pre>
<h4>代码示例</h4>
<pre><code class="language-java">// RocketMQ 事务消息 Producer
public class OrderTransactionProducer {

    private TransactionMQProducer producer;

    public void sendOrderMessage(OrderRequest request) {
        Message msg = new Message(&quot;ORDER_TOPIC&quot;, JsonUtils.toJson(request).getBytes());

        // 发送事务消息
        producer.sendMessageInTransaction(msg, new TransactionListener() {

            @Override
            public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
                try {
                    // 执行本地事务（如写数据库）
                    orderService.createOrder(request);
                    return LocalTransactionState.COMMIT_MESSAGE;
                } catch (Exception e) {
                    return LocalTransactionState.ROLLBACK_MESSAGE;
                }
            }

            @Override
            public LocalTransactionState checkLocalTransaction(MessageExt msg) {
                // 回查：检查本地事务是否已执行成功
                Order order = orderDao.queryByOrderId(request.getOrderId());
                if (order != null) {
                    return LocalTransactionState.COMMIT_MESSAGE;
                }
                return LocalTransactionState.UNKNOW;  // 继续等待回查
            }
        }, null);
    }
}
</code></pre>
<p>事务消息的优势在于：<strong>半消息 + 回查机制</strong>天然解决了&quot;本地事务成功但消息发送失败&quot;和&quot;消息发送成功但本地事务失败&quot;两种不一致场景。</p>
<hr>
<h2>8. 最大努力通知</h2>
<p>最大努力通知是最简单的最终一致性方案：上游系统<strong>尽最大努力</strong>通知下游系统，如果通知失败则重试若干次，最终仍然失败则需要人工介入或下游主动查询。</p>
<pre><code>上游系统 ──→ 通知下游（第1次）──→ 失败
         ──→ 通知下游（第2次）──→ 失败（间隔递增）
         ──→ 通知下游（第3次）──→ 成功 ✅
         ──→ ...
         ──→ 通知下游（第N次）──→ 仍然失败 → 放弃，记录日志，等待人工处理
                                              或下游主动查询上游接口
</code></pre>
<p>典型应用场景：<strong>支付回调</strong>。支付宝、微信支付完成扣款后，会多次回调商户的通知地址。如果商户系统一直没有返回成功，支付平台会按递增间隔重试（如 1s、5s、30s、5min、30min），超过最大次数后停止。商户可以通过主动调用支付查询接口来获取最终结果。</p>
<hr>
<h2>9. 方案选型</h2>
<table>
<thead>
<tr>
<th>方案</th>
<th>一致性</th>
<th>性能</th>
<th>复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2PC/XA</strong></td>
<td>强一致</td>
<td>低（同步阻塞）</td>
<td>低（数据库/中间件原生支持）</td>
<td>数据库层面的跨库事务，对一致性要求极高的场景</td>
</tr>
<tr>
<td><strong>3PC</strong></td>
<td>强一致（仍有缺陷）</td>
<td>低（多一轮通信）</td>
<td>中</td>
<td>理论意义大于实践，工程中较少直接使用</td>
</tr>
<tr>
<td><strong>TCC</strong></td>
<td>最终一致</td>
<td>高</td>
<td>高（三个接口 + 幂等 + 空回滚 + 防悬挂）</td>
<td>资金交易、库存预扣等需要资源预留的场景</td>
</tr>
<tr>
<td><strong>Saga</strong></td>
<td>最终一致</td>
<td>高</td>
<td>中</td>
<td>长事务、跨多服务的业务编排</td>
</tr>
<tr>
<td><strong>本地消息表</strong></td>
<td>最终一致</td>
<td>中（依赖轮询间隔）</td>
<td>低</td>
<td>对实时性要求不高的异步场景</td>
</tr>
<tr>
<td><strong>事务消息</strong></td>
<td>最终一致</td>
<td>高</td>
<td>低（中间件原生支持）</td>
<td>基于消息驱动的异步业务，如订单 → 物流 → 通知</td>
</tr>
<tr>
<td><strong>最大努力通知</strong></td>
<td>最终一致（弱保证）</td>
<td>高</td>
<td>最低</td>
<td>跨平台/跨企业的通知场景，如支付回调</td>
</tr>
</tbody></table>
<h3>选型建议</h3>
<pre><code>                    一致性要求高？
                    ┌── 是 ──→ 能接受性能损失？
                    │          ├── 是 ──→ 2PC/XA
                    │          └── 否 ──→ TCC
                    │
                    └── 否 ──→ 涉及多步骤编排？
                               ├── 是 ──→ Saga
                               └── 否 ──→ 事务消息 / 本地消息表
</code></pre>
<p>实际项目中的经验法则：</p>
<ul>
<li><strong>能用单库事务解决就不要用分布式事务</strong>——分布式事务的复杂度远超想象</li>
<li><strong>大部分互联网业务用最终一致性就够了</strong>——用户能接受几秒的延迟</li>
<li><strong>资金相关用 TCC</strong>，<strong>业务流程编排用 Saga</strong>，<strong>异步通知用事务消息</strong></li>
<li>无论哪种方案，<strong>幂等性设计</strong>都是基础——网络重试无处不在</li>
</ul>
6:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L5",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L5",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L5",null,{"href":"/blog/category/engineering/architecture/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"架构设计"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-03-20","children":"2024年03月20日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"微服务全景架构"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L5","微服务",{"href":"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"微服务"}],["$","$L5","全景架构",{"href":"/blog/tag/%E5%85%A8%E6%99%AF%E6%9E%B6%E6%9E%84/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"全景架构"}],["$","$L5","分布式系统",{"href":"/blog/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"分布式系统"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$11",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/architecture/微服务及其演进史","title":"微服务及其演进史","description":"在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增， 发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。 但是物理服务器的CPU、内存、存储器、连接...","pubDate":"2024-03-19","tags":["微服务","架构演进","分布式系统"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/architecture/微服务拆分策略","title":"微服务拆分策略","description":"前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移...","pubDate":"2024-03-21","tags":["微服务","服务拆分","架构设计"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"微服务":{"prev":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:next"},"全景架构":{"prev":null,"next":null},"分布式系统":{"prev":"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":{"slug":"engineering/middleware/分布式系统与事务：从基础到实践","title":"分布式系统与事务：从基础到实践","description":"本文系统梳理分布式系统的核心问题与解决方案：从集中式到分布式的演进动机，CAP/BASE 理论的工程权衡，一致性模型的层次划分，到 2PC、3PC、TCC、Saga、本地消息表、事务消息等分布式事务方案的原理、流程与代码示例。适合希望建立分布式事务知识体系的工程师阅读。","pubDate":"2025-07-23","tags":["分布式事务","一致性","分布式系统"],"heroImage":"$undefined","content":"$19"}}}}]}],["$","$L1a",null,{}]]}]}]}]
9:null
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
b:{"metadata":[["$","title","0",{"children":"微服务全景架构 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。"}],["$","meta","2",{"property":"og:title","content":"微服务全景架构"}],["$","meta","3",{"property":"og:description","content":"微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-03-20"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"微服务全景架构"}],["$","meta","9",{"name":"twitter:description","content":"微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
13:{"metadata":"$b:metadata","error":null,"digest":"$undefined"}

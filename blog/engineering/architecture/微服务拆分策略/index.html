<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/232416e7c3a1ca7e.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>微服务拆分策略 - Skyfalling Blog</title><meta name="description" content="前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移..."/><meta property="og:title" content="微服务拆分策略"/><meta property="og:description" content="前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移..."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-03-21"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="微服务拆分策略"/><meta name="twitter:description" content="前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移..."/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/architecture/page/1/">架构设计</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-03-21">2024年03月21日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">微服务拆分策略</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/">微服务</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/page/1/">服务拆分</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/">架构设计</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><p>前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。</p>
<p>对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移。</p>
<h3>1 微服务迁移准备  <a href="#scroller-1" id="scroller-1"></a></h3>
<p>1、需对业务充分了解，这是服务拆分，通信设计，资源整合的必要前提。</p>
<p>2、适应微服务架构设计原则：小版本，高速迭代。</p>
<p>3、快速的环境提供能力：依赖于云计算、容器技术，快速交付环境。</p>
<p>4、服务合理拆分：需符合团队结构或能逆向影响，能对组织架构进行微调并划分职责。（康威定律和逆康威定律）</p>
<p>5、基本的监控能力：包括基础的技术监控和业务监控。</p>
<p>6、快速的应用部署能力：需要部署管道提供快速的部署能力。</p>
<p>7、DevOps 自动化运维能力：需要具有良好的持续集成和持续交付能力，还需要对问题、故障的快速响应能力，开发、测试和运维能协同工作。</p>
<h3>2 微服务颗粒的拆分策略 <a href="#scroller-2" id="scroller-2"></a></h3>
<p>前面两篇文章我们学习了What &amp; Why（什么是微服务和为什么需要做微服务架构），这一章我们就来探讨如何做微服务架构的拆分（How）。</p>
<p>微服务拆分没有一个绝对的标准答案，服务拆分的粒度需要根据业务场景来规划，而随着业务的发展，原先的架构方案也需要做调整。</p>
<p>虽然没有固定的套路，但是我们在业务实践过程中总结的一些经验，以做参考。</p>
<h4>2.1 基于业务逻辑拆分 <a href="#scroller-3" id="scroller-3"></a></h4>
<p>基于业务逻辑拆分相对好理解一点，典型的单一职责原则，我们将功能相近的业务整合到一个服务颗粒上。比如一个办公领域系统，考勤、工作流、音视频会议是是三个截然不同的业务领域，这可能就是我们拆分的一个入手点。</p>
<p><strong>2.1.1 领域模型拆分</strong></p>
<p>领域驱动设计DDD（Domain-Driven Design 领域驱动设计）是一个很简单的概念，表示我们对系统的划分是基于领域的，也即是基于业务方向去思考的。</p>
<p>举一个典型的电商业务例子。电商的业务体系庞大，涉及各方面的细节。但是我们大概能够根据业务的职能做一个拆分，比如阿里的电商中台业务，包含 用户账号子系统、商品子系统、订单子系统、客户子系统、物流子系统 等。</p>
<p>因为职能不同，这些领域之间包含清晰的界限，所以我们可以按照这个方向将服务于不同领域（商品域和订单域）的子系统拆成独立的服务颗粒。如下图：</p>
<p><img src="/images/blog/engineering/microservice-image_6_7.png" alt="image_6_7.png"></p>
<p><strong>2.1.2 用户群体拆分</strong></p>
<p>根据用户群体做拆分，我们首先要了解自己的系统业务里的用户角色领域是否没有功能耦合，有清晰的领域界限。</p>
<p>比如教育信息化系统，教师的业务场景和学生的业务场景，基本比较独立，而且拆分后流量上有明显的削弱，这时候结合具体的业务分析，看是否有价值。如下图所示：</p>
<p><img src="/images/blog/engineering/microservice-image_4_2.png" alt="image_4_2.png"></p>
<h4>2.2 基于可扩展拆分  <a href="#scroller-6" id="scroller-6"></a></h4>
<p>这个需要区分系统中变与不变的部分，不变的部分一般是成熟的、通用的服务功能，变的部分一般是改动比较多、满足业务迭代扩展性需要的功能，我们可以将不变的部分拆分出来，作为共用的服务，将变的部分独立出来满足个性化扩展需要。同时根据二八原则，系统中经常变动的部分大约只占 20%，而剩下的 80% 基本不变或极少变化，这样的拆分也解决了发布频率过多而影响成熟服务稳定性的问题。比如一个电商领域的系统，用户信息、基本商品信息、物流信息 等模块的管理能力和视图界面，一般是比较稳定的；而类似运营活动的功能和页面一般是经常变化的（520、618、双11），会有不同的活动策略和视图界面，需要经常迭代发布。如下图所示</p>
<p><img src="/images/blog/engineering/microservice-image_4_3.png" alt="image_4_3.png"></p>
<h4>2.3 基于可靠性拆分 <a href="#scroller-7" id="scroller-7"></a></h4>
<p><strong>2.3.1 核心模块拆分</strong></p>
<p>我们团队在做MySQL数据库和Redis集群拆分的时候，总会把一些重要的模块独立放在一个集群上，不与其他模块混用，而这个独立的集群，服务机性能要是最好的。这样做的目的是，当重要度较低的模块发生故障时，不会影响重要度高的模块。</p>
<p>同要的道理，我们会将  账号信息、登录信息、服务中心等重要度最高的要害模块单独拆分在一个服务颗粒上（因为这类模块不可用之后，整个系统基本完全瘫痪），再做成服务集群，来保障它的高可用。 如下图所示：</p>
<p><img src="/images/blog/engineering/microservice-image_4_4.png" alt="image_4_4.png"></p>
<p><strong>2.3.2 主次链路拆分</strong></p>
<p>在各个业务系统中，其实都会有主次业务链路。主业务链条，完成了业务系统中最核心的那部分工作。而次链路是保证其他基础功能的稳定运行。</p>
<p>以电商为例子：商品搜索-&gt;商品详情页-&gt;购物车模块-&gt;订单结算-&gt;支付业务，就是一条最简单的主链路。主链路是整个系统的核心主战场，最好的资源跟火力都要放在这里，保证不失守。</p>
<p>一个系统一般有多条核心链路和多条次链路，互相支持构成一个完整的系统。而我们将主次链路进行拆分，主要为了以下几个目标。</p>
<p><strong>异常容错</strong></p>
<p>为主链路建立层次化的降级策略（多级降级），以及合理的熔断策略，这部分我们将在Hystrix服务容错降级的文章中详细解释。</p>
<p><strong>计算资源分配</strong></p>
<p>主链路通常来讲都是高频场景，自然需要更多的计算资源，最主要的体现就是集群里分配的虚机数量多。比如电商场景中特惠专场抢购等。</p>
<p>但是无论是虚机的分配，还是kubernetes的动态扩缩容，应该都需要单独优待，如资源分配倾斜，独立治理等。</p>
<p><strong>服务隔离</strong></p>
<p>主链路是高频且核心的主业务模块，把主链路的服务与其他起辅助作用的业务服务隔离开来，避免次链路服务的异常情况影响到主链路服务。</p>
<p><img src="/images/blog/engineering/microservice-image_4_5.png" alt="image_4_5.png"></p>
<h4>2.4 基于性能需求拆分 <a href="#scroller-10" id="scroller-10"></a></h4>
<p>根据性能需求来进行拆分。简单来说就是访问量特别大，访问频率特别高的业务，又要保证高效的响应能力，这些业务对性能的要求特别高。比如积分竞拍、低价秒杀、限量抢购。</p>
<p>我们要识别出某些超高并发量的业务，尽可能把这部分业务独立拆分出来。这么做的原因非常简单，一个保证满足高性能业务需求，另一个保证业务的独立性，不互相影响。</p>
<p>类似积分竞拍、超低价秒杀、限量抢购，对瞬间峰值和计算性能要求是非常高的。这部分的业务如果跟其他通用业务放在一块，一个是可能互相影响，比如某个链路阻塞，会导致雪崩沿调用链向上传递。</p>
<p>另外一个是如果多个业务耦合在一块，发布频率变高、服务扩缩容变难、维护复杂度变高。</p>
<p><img src="/images/blog/engineering/microservice-image_4_6.png" alt="image_4_6.png"></p>
<h3>3 总结拆分原则 <a href="#scroller-11" id="scroller-11"></a></h3>
<ul>
<li>先少后多（微服务数量）、先粗后细(粒度)</li>
<li>基于业务逻辑进行拆分（用户群体、业务领域等模型）</li>
<li>基于可靠性（核心模块独立化、主次链路隔离）</li>
<li>基于性能拆分（独立拆分高性能场景）</li>
<li>接口需保证幂等</li>
<li>接口数据定义严禁内嵌，透传</li>
<li>规范化工程结构，符合微服务风格</li>
<li>不止对计算服务记性拆分，服务层 -&gt; 缓存层 -&gt; 数据层 的逐步拆解，才能发挥最大功效。</li>
</ul>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/232416e7c3a1ca7e.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"f9Beb70Kzv-MQ4PgQ_Vno\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"architecture\",\"%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/232416e7c3a1ca7e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"b8KGb7FTduAvt9AANdWmIv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1b:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T22ab,"])</script><script>self.__next_f.push([1,"\u003cp\u003e前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。\u003c/p\u003e\n\u003cp\u003e对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移。\u003c/p\u003e\n\u003ch3\u003e1 微服务迁移准备  \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e1、需对业务充分了解，这是服务拆分，通信设计，资源整合的必要前提。\u003c/p\u003e\n\u003cp\u003e2、适应微服务架构设计原则：小版本，高速迭代。\u003c/p\u003e\n\u003cp\u003e3、快速的环境提供能力：依赖于云计算、容器技术，快速交付环境。\u003c/p\u003e\n\u003cp\u003e4、服务合理拆分：需符合团队结构或能逆向影响，能对组织架构进行微调并划分职责。（康威定律和逆康威定律）\u003c/p\u003e\n\u003cp\u003e5、基本的监控能力：包括基础的技术监控和业务监控。\u003c/p\u003e\n\u003cp\u003e6、快速的应用部署能力：需要部署管道提供快速的部署能力。\u003c/p\u003e\n\u003cp\u003e7、DevOps 自动化运维能力：需要具有良好的持续集成和持续交付能力，还需要对问题、故障的快速响应能力，开发、测试和运维能协同工作。\u003c/p\u003e\n\u003ch3\u003e2 微服务颗粒的拆分策略 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e前面两篇文章我们学习了What \u0026amp; Why（什么是微服务和为什么需要做微服务架构），这一章我们就来探讨如何做微服务架构的拆分（How）。\u003c/p\u003e\n\u003cp\u003e微服务拆分没有一个绝对的标准答案，服务拆分的粒度需要根据业务场景来规划，而随着业务的发展，原先的架构方案也需要做调整。\u003c/p\u003e\n\u003cp\u003e虽然没有固定的套路，但是我们在业务实践过程中总结的一些经验，以做参考。\u003c/p\u003e\n\u003ch4\u003e2.1 基于业务逻辑拆分 \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e基于业务逻辑拆分相对好理解一点，典型的单一职责原则，我们将功能相近的业务整合到一个服务颗粒上。比如一个办公领域系统，考勤、工作流、音视频会议是是三个截然不同的业务领域，这可能就是我们拆分的一个入手点。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.1.1 领域模型拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e领域驱动设计DDD（Domain-Driven Design 领域驱动设计）是一个很简单的概念，表示我们对系统的划分是基于领域的，也即是基于业务方向去思考的。\u003c/p\u003e\n\u003cp\u003e举一个典型的电商业务例子。电商的业务体系庞大，涉及各方面的细节。但是我们大概能够根据业务的职能做一个拆分，比如阿里的电商中台业务，包含 用户账号子系统、商品子系统、订单子系统、客户子系统、物流子系统 等。\u003c/p\u003e\n\u003cp\u003e因为职能不同，这些领域之间包含清晰的界限，所以我们可以按照这个方向将服务于不同领域（商品域和订单域）的子系统拆成独立的服务颗粒。如下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_7.png\" alt=\"image_6_7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.1.2 用户群体拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e根据用户群体做拆分，我们首先要了解自己的系统业务里的用户角色领域是否没有功能耦合，有清晰的领域界限。\u003c/p\u003e\n\u003cp\u003e比如教育信息化系统，教师的业务场景和学生的业务场景，基本比较独立，而且拆分后流量上有明显的削弱，这时候结合具体的业务分析，看是否有价值。如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_2.png\" alt=\"image_4_2.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.2 基于可扩展拆分  \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这个需要区分系统中变与不变的部分，不变的部分一般是成熟的、通用的服务功能，变的部分一般是改动比较多、满足业务迭代扩展性需要的功能，我们可以将不变的部分拆分出来，作为共用的服务，将变的部分独立出来满足个性化扩展需要。同时根据二八原则，系统中经常变动的部分大约只占 20%，而剩下的 80% 基本不变或极少变化，这样的拆分也解决了发布频率过多而影响成熟服务稳定性的问题。比如一个电商领域的系统，用户信息、基本商品信息、物流信息 等模块的管理能力和视图界面，一般是比较稳定的；而类似运营活动的功能和页面一般是经常变化的（520、618、双11），会有不同的活动策略和视图界面，需要经常迭代发布。如下图所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_3.png\" alt=\"image_4_3.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.3 基于可靠性拆分 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e2.3.1 核心模块拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们团队在做MySQL数据库和Redis集群拆分的时候，总会把一些重要的模块独立放在一个集群上，不与其他模块混用，而这个独立的集群，服务机性能要是最好的。这样做的目的是，当重要度较低的模块发生故障时，不会影响重要度高的模块。\u003c/p\u003e\n\u003cp\u003e同要的道理，我们会将  账号信息、登录信息、服务中心等重要度最高的要害模块单独拆分在一个服务颗粒上（因为这类模块不可用之后，整个系统基本完全瘫痪），再做成服务集群，来保障它的高可用。 如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_4.png\" alt=\"image_4_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.3.2 主次链路拆分\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在各个业务系统中，其实都会有主次业务链路。主业务链条，完成了业务系统中最核心的那部分工作。而次链路是保证其他基础功能的稳定运行。\u003c/p\u003e\n\u003cp\u003e以电商为例子：商品搜索-\u0026gt;商品详情页-\u0026gt;购物车模块-\u0026gt;订单结算-\u0026gt;支付业务，就是一条最简单的主链路。主链路是整个系统的核心主战场，最好的资源跟火力都要放在这里，保证不失守。\u003c/p\u003e\n\u003cp\u003e一个系统一般有多条核心链路和多条次链路，互相支持构成一个完整的系统。而我们将主次链路进行拆分，主要为了以下几个目标。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e异常容错\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e为主链路建立层次化的降级策略（多级降级），以及合理的熔断策略，这部分我们将在Hystrix服务容错降级的文章中详细解释。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e计算资源分配\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e主链路通常来讲都是高频场景，自然需要更多的计算资源，最主要的体现就是集群里分配的虚机数量多。比如电商场景中特惠专场抢购等。\u003c/p\u003e\n\u003cp\u003e但是无论是虚机的分配，还是kubernetes的动态扩缩容，应该都需要单独优待，如资源分配倾斜，独立治理等。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e服务隔离\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e主链路是高频且核心的主业务模块，把主链路的服务与其他起辅助作用的业务服务隔离开来，避免次链路服务的异常情况影响到主链路服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_5.png\" alt=\"image_4_5.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.4 基于性能需求拆分 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e根据性能需求来进行拆分。简单来说就是访问量特别大，访问频率特别高的业务，又要保证高效的响应能力，这些业务对性能的要求特别高。比如积分竞拍、低价秒杀、限量抢购。\u003c/p\u003e\n\u003cp\u003e我们要识别出某些超高并发量的业务，尽可能把这部分业务独立拆分出来。这么做的原因非常简单，一个保证满足高性能业务需求，另一个保证业务的独立性，不互相影响。\u003c/p\u003e\n\u003cp\u003e类似积分竞拍、超低价秒杀、限量抢购，对瞬间峰值和计算性能要求是非常高的。这部分的业务如果跟其他通用业务放在一块，一个是可能互相影响，比如某个链路阻塞，会导致雪崩沿调用链向上传递。\u003c/p\u003e\n\u003cp\u003e另外一个是如果多个业务耦合在一块，发布频率变高、服务扩缩容变难、维护复杂度变高。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_4_6.png\" alt=\"image_4_6.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e3 总结拆分原则 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e先少后多（微服务数量）、先粗后细(粒度)\u003c/li\u003e\n\u003cli\u003e基于业务逻辑进行拆分（用户群体、业务领域等模型）\u003c/li\u003e\n\u003cli\u003e基于可靠性（核心模块独立化、主次链路隔离）\u003c/li\u003e\n\u003cli\u003e基于性能拆分（独立拆分高性能场景）\u003c/li\u003e\n\u003cli\u003e接口需保证幂等\u003c/li\u003e\n\u003cli\u003e接口数据定义严禁内嵌，透传\u003c/li\u003e\n\u003cli\u003e规范化工程结构，符合微服务风格\u003c/li\u003e\n\u003cli\u003e不止对计算服务记性拆分，服务层 -\u0026gt; 缓存层 -\u0026gt; 数据层 的逐步拆解，才能发挥最大功效。\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"17:T4fc2,"])</script><script>self.__next_f.push([1,"\u003ch3\u003e1 微服务优势与挑战 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e1.1 微服务的优势 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.1 单一职责\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e微服务架构中的每个节点高度服务化，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，包括数据库和数据模型；不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.2 轻量级通信\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e通过REST API模式或者RPC框架，事件流和消息代理的组合相互通信，实现服务间互相协作的轻量级通信机制。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.3 独立性\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试、部署、运维。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.4 进程隔离\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上，实现高度自治和高度隔离。进程的隔离，还能保证服务达到动态扩缩容的能力，业务高峰期自动增加服务资源以提升并发能力，业务低谷期则可自动释放服务资源以节省开销。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.5 混合技术栈和混合部署方式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e团队可以为不同的服务组件使用不同的技术栈和不同的部署方式（公有云、私有云、混合云）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.6 简化治理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e组件可以彼此独立地进行缩放，从而减少了因必须缩放整个应用程序而产生的浪费和成本，独立的发布、服务治理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.1.7 安全可靠，可维护。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e从架构上对运维提供友好的支撑，在安全、可维护的基础上规范化发布流程，支持数据存储容灾、业务模块隔离、访问权限控制、编码安全检测等。\u003c/p\u003e\n\u003ch4\u003e1.2 面临的挑战 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e1.2.1 分布式固有复杂性\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e微服务架构是基于分布式的系统，而构建分布式系统必然会带来额外的开销。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e性能： 分布式系统是跨进程、跨网络的调用，受网络延迟和带宽的影响。\u003c/li\u003e\n\u003cli\u003e可靠性： 由于高度依赖于网络状况，任何一次的远程调用都有可能失败，随着服务的增多还会出现更多的潜在故障点。因此，如何提高系统的可靠性、降低因网络引起的故障率，是系统构建的一大挑战。\u003c/li\u003e\n\u003cli\u003e分布式通信： 分布式通信大大增加了功能实现的复杂度，并且伴随着定位难、调试难等问题。\u003c/li\u003e\n\u003cli\u003e数据一致性： 需要保证分布式系统的数据强一致性，即在 C（一致性）A（可用性）P（分区容错性） 三者之间做出权衡。这块可以参考我的这篇《\u003ca href=\"https://www.cnblogs.com/wzh2010/p/15311142.html\"\u003e分布式事务\u003c/a\u003e》。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e1.2.2 服务的依赖管理和测试\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在单体应用中，通常使用集成测试来验证依赖是否正常。而在微服务架构中，服务数量众多，每个服务都是独立的业务单元，服务主要通过接口进行交互，如何保证它的正常，是测试面临的主要挑战。\u003c/p\u003e\n\u003cp\u003e所以单元测试和单个服务链路的可用性非常重要。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.2.3 有效的配置版本管理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在单体系统中，配置可以写在yaml文件，分布式系统中需要统一进行配置管理，同一个服务在不同的场景下对配置的值要求还可能不一样，所以需要引入配置的版本管理、环境管理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.2.4 自动化的部署流程\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构中，每个服务都独立部署，交付周期短且频率高，人工部署已经无法适应业务的快速变化。有效地构建自动化部署体系，配合服务网格、容器技术，是微服务面临的另一个挑战。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.2.5 对于DevOps更高的要求\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构的实施过程中，开发人员和运维人员的角色发生了变化，开发者也将承担起整个服务的生命周期的责任，包括部署、链路追踪、监控；因此，按需调整组织架构、构建全功能的团队，也是一个不小的挑战。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1.2.6 运维成本\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e运维主要包括配置、部署、监控与告警和日志收集四大方面。微服务架构中，每个服务都需要独立地配置、部署、监控和收集日志，成本呈指数级增长。\u003c/p\u003e\n\u003cp\u003e服务化粒度越细，运维成本越高。\u003c/p\u003e\n\u003cp\u003e怎样去解决这些问题，是微服务架构必须面临的挑战。\u003c/p\u003e\n\u003ch3\u003e2 微服务全景架构 \u003ca href=\"#scroller-17\" id=\"scroller-17\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_1.png\" alt=\"image_1_1.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e3 微服务核心组件 \u003ca href=\"#scroller-19\" id=\"scroller-19\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e微服务架构核心组件包括：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e组件名\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e服务注册与发现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAPI 网关服务\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e分布式配置中心\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e服务通信\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e服务治理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e服务监控\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e分布式服务追踪\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4\u003e3.1 服务注册与发现 \u003ca href=\"#scroller-20\" id=\"scroller-20\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e3.1.1 原理图\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_2.png\" alt=\"image_1_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e服务注册与发现三要素：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProvider：服务的提供方\u003c/li\u003e\n\u003cli\u003eConsumer：调用远程服务的服务消费方\u003c/li\u003e\n\u003cli\u003eRegistry：服务注册和发现的注册中心\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e3.1.2 注册中心的原理、流程\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1、 Provider(服务提供者)绑定指定端口并启动服务\u003c/p\u003e\n\u003cp\u003e2、提供者连接注册中心，并发本机 IP、端口、应用信息和服务信息发送至注册中心存储\u003c/p\u003e\n\u003cp\u003e3、Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心\u003c/p\u003e\n\u003cp\u003e4、注册中心根据消费者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。\u003c/p\u003e\n\u003cp\u003e5、Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。\u003c/p\u003e\n\u003cp\u003e6、Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer设计的原因：\u003c/p\u003e\n\u003cp\u003eConsumer 与 Provider 解偶，双方都可以横向增减节点数。注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台\u003c/p\u003e\n\u003cp\u003e7、去中心化，双方不直接依赖注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用（Consumer应用缓存中保留提供者 Provider 列表）\u003c/p\u003e\n\u003cp\u003e8、服务提供者无状态，任意一台宕掉后，不影响使用\u003c/p\u003e\n\u003cp\u003e注册中心包含如下功能：注册中心、服务注册和反注册、心跳监测与汇报、服务订阅、服务变更查询、集群部署、服务健康状态检测、服务状态变更通知 等\u003c/p\u003e\n\u003cp\u003e我们有很多种注册中心的技术，Zookeeper、Etcd、Consul、Eureka 4种比较常用，如下\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eZookeeper\u003c/th\u003e\n\u003cth\u003eEtcd\u003c/th\u003e\n\u003cth\u003eConsul\u003c/th\u003e\n\u003cth\u003eEureka\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eCAP模型\u003c/td\u003e\n\u003ctd\u003eCP\u003c/td\u003e\n\u003ctd\u003eCP\u003c/td\u003e\n\u003ctd\u003eCP\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e数据一致性算法\u003c/td\u003e\n\u003ctd\u003eZAB\u003c/td\u003e\n\u003ctd\u003eRaft\u003c/td\u003e\n\u003ctd\u003eRaft\u003c/td\u003e\n\u003ctd\u003e❌\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多数据中心\u003c/td\u003e\n\u003ctd\u003e❌\u003c/td\u003e\n\u003ctd\u003e❌\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e❌\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e多语言支持\u003c/td\u003e\n\u003ctd\u003e客户端\u003c/td\u003e\n\u003ctd\u003eHttp/gRPC\u003c/td\u003e\n\u003ctd\u003eHttp/DNS\u003c/td\u003e\n\u003ctd\u003eHttp\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eWatch\u003c/td\u003e\n\u003ctd\u003eTCP\u003c/td\u003e\n\u003ctd\u003eLong Polling\u003c/td\u003e\n\u003ctd\u003eLong Polling\u003c/td\u003e\n\u003ctd\u003eLong Polling\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eKV存储\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e❌\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e服务健康检查\u003c/td\u003e\n\u003ctd\u003e心跳\u003c/td\u003e\n\u003ctd\u003e心跳\u003c/td\u003e\n\u003ctd\u003e\u003cp\u003e服务状态，\u003cbr\u003e内存，硬盘等\u003c/p\u003e\u003c/td\u003e\n\u003ctd\u003e自定义\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e自身监控\u003c/td\u003e\n\u003ctd\u003e❌\u003c/td\u003e\n\u003ctd\u003emetrics\u003c/td\u003e\n\u003ctd\u003emetrics\u003c/td\u003e\n\u003ctd\u003emetrics\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpringCloud 支持\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003ctd\u003e✅\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e自身开发语言\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003ctd\u003eGo\u003c/td\u003e\n\u003ctd\u003eGo\u003c/td\u003e\n\u003ctd\u003eJava\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e分布式系统中CAP模型3者不可兼得。由于网络的原因，分布式系统中P是必备的，意味着只能选择 AP 或者 CP。CP 代表数据一致性是第一位的，AP 代表可用性是第一位的。\u003c/p\u003e\n\u003cp\u003eZookeeper、Etcd、Consul 是 CP 型注册中心，牺牲可用性来保证数据强一致性\u003c/p\u003e\n\u003cp\u003eEureka 是 AP 型注册中心，牺牲一致性来保证可用性\u003c/p\u003e\n\u003ch4\u003e3.2 API 网关服务 \u003ca href=\"#scroller-23\" id=\"scroller-23\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_3.png\" alt=\"image_1_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上面是Api网关服务的基本架构：用户的请求经过统一的Api网关来访问微服务里具体的服务颗粒，并且可能产生串联的链路服务调用。\u003c/p\u003e\n\u003cp\u003e有很多耳熟能详的API网关技术，比如 Zuul、Kong、Tyk等，提供了服务路由在内的很多通用功能，后面会有专门的章节来说这个。\u003c/p\u003e\n\u003cp\u003eTyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。\u003c/p\u003e\n\u003cp\u003eKong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。\u003c/p\u003e\n\u003cp\u003eNetflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\u003c/p\u003e\n\u003cp\u003e除了路由之外，Api网关服务还包含：认证和授权，重试、熔断、降级，负载均衡，日志、监控、链路追踪，灰度发布，ABTesting 等功能。\u003c/p\u003e\n\u003ch4\u003e3.3 配置中心 \u003ca href=\"#scroller-24\" id=\"scroller-24\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_4.png\" alt=\"image_1_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上面这个是携程的开源配置中心Apollo系统的架构设计，我们从下往上进行分析：\u003c/p\u003e\n\u003cp\u003e1、Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端\u003c/p\u003e\n\u003cp\u003e2、Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）\u003c/p\u003e\n\u003cp\u003e3、Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳，支持注册、更新、删除能力\u003c/p\u003e\n\u003cp\u003e4、在Eureka之上我们架了一层Meta Server用于封装Eureka的服务发现接口\u003c/p\u003e\n\u003cp\u003e5、Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试\u003c/p\u003e\n\u003cp\u003e6、Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试\u003c/p\u003e\n\u003cp\u003e7、为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中\u003c/p\u003e\n\u003cp\u003e上面的架构体现了如下特点：\u003c/p\u003e\n\u003cp\u003e•高可用：配置服务为多实例部署，访问层保证 load balance、错误重试 •弱依赖：使用了Eureka来做配置中心的服务注册，如果出现问题或者网络出现问题的时候，服务应该可以依赖于它本身所缓存的配置来提供正常的服务\u003c/p\u003e\n\u003ch4\u003e3.4 服务通信 \u003ca href=\"#scroller-25\" id=\"scroller-25\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e分布式系统一般是由多个微服务颗粒组成的，微服务与微服务之前存在互相调用，甚至多个链路访问的情况。所以他们之间是需要通信的，通信方式继承于SOA，包含同步与异步两种模式。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.4.1 同步访问方式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e1、RPC 访问模式\u003c/p\u003e\n\u003cp\u003eRemote Procedure Call Protocol，远程过程调用协议，一般使用在分布式业务或者微服务架构风格中。像调用本地函数一样，去调用一个远端服务。本质上是请求链的底层，维护同一个端口，进行socket通信。常见的RPC技术包含 gRPC、Dubbo、Thrift 等。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_5.png\" alt=\"image_1_5.png\"\u003e\u003c/p\u003e\n\u003cp\u003e2、REST 访问模式\u003c/p\u003e\n\u003cp\u003e这个应该大家最常用，可以通过一套统一风格的接口模式，为Web，iOS和Android等提供接口服务。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.4.2 异步访问方式\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e消息中间件：RabbitMQ、Kafka、RocketMQ之类，对于实时性要求不那么严格的服务请求和计算。\u003c/p\u003e\n\u003ch4\u003e3.5 服务治理 \u003ca href=\"#scroller-28\" id=\"scroller-28\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e常见的服务治理手段有如下几种：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.5.1 节点管理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e服务调用失败时可能是服务提供者自身出现，也可能是网络发生故障，我们一般有两种处理手段。\u003c/p\u003e\n\u003cp\u003e1. 注册中心主动摘除机制 这种机制要求服务提供者定时向注册中心汇报心跳，如果超时，就认为服务提供者出现问题，并将节点从服务列表中摘除。\u003c/p\u003e\n\u003cp\u003e2. 服务消费者摘除机制 当服务提供者网络出现异常，服务消费者调用就会失败，如果持续错误就可以将它从服务提供者节点列表中移除。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.5.2 负载均衡\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e服务消费者在从服务列表中选取可用节点时，如果能让性能较好的服务机多承担一些流量的话，就能充分利用机器的性能。这就需要对负载均衡算法做一些调整。\u003c/p\u003e\n\u003cp\u003e常用的负载均衡算法主要包括以下几种：\u003c/p\u003e\n\u003cp\u003e1. Radom 随机算法 从可用的服务节点中随机选取一个节点。一般情况下，随机算法是均匀的，也就是说后端服务节点无论配置好坏，最终得到的调用量都差不多。\u003c/p\u003e\n\u003cp\u003e2. Round Robin 轮询算法（加权重） 就是按照固定的权重，对可用服务节点进行轮询。如果所有服务节点的权重都是相同的，则每个节点的调用量也是差不多的。但可以给性能较好的节点的权重调大些，充分发挥其性能优势，提高整体调用的平均性能。\u003c/p\u003e\n\u003cp\u003e3. Least Conn 最少活跃调用算法 这种算法是在服务消费者这一端的内存里动态维护着同每一个服务节点之间的连接数，选择连接数最小的节点发起调用，也就是选择了调用量最小的服务节点，性能理论上也是最优的。\u003c/p\u003e\n\u003cp\u003e4. 一致性 Hash 算法 指相同参数的请求总是发到同一服务节点。当某一个服务节点出现故障时，原本发往该节点的请求，基于虚拟节点机制，平摊到其他节点上，不会引起剧烈变动。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.5.3 服务路由\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e所谓的路由规则，就是通过一定的规则如条件表达式或者正则表达式来限定服务节点的选择范围。\u003c/p\u003e\n\u003cp\u003e制定路由规则主要有两个原因。\u003c/p\u003e\n\u003cp\u003e1. 业务存在灰度发布、多版本ABTesting的需求\u003c/p\u003e\n\u003cp\u003e功能逐步开放发布或者灰度测试的场景。\u003c/p\u003e\n\u003cp\u003e2. 多机房就近访问的需求\u003c/p\u003e\n\u003cp\u003e一般可以通过 IP 段规则来控制访问，在选择服务节点时，优先选择同一 IP 段的节点。这个也是算力靠近的优先原则。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3.5.4 服务容错\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在分布式系统中，分区容错性是很重要的一个话题，要知道，服务间的调用调用并不总是成功，服务提供者程序bug、异常退出 或者 消费者与提供者之间的网络故障。而服务调用失败之后，我们需要一些方法来保证调用的正常。\u003c/p\u003e\n\u003cp\u003e常用的方式有以下几种：\u003c/p\u003e\n\u003cp\u003eFailOver 失败自动切换。就是服务消费者发现调用失败或者超时后，自动从可用的服务节点列表中选择下一个节点重新发起调用，也可以设置重试的次数。\u003c/p\u003e\n\u003cp\u003eFailBack 失败通知。就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。\u003c/p\u003e\n\u003cp\u003eFailCache 失败缓存。就是服务消费者调用失败或者超时后，不立即发起重试，而是隔一段时间后再次尝试发起调用。\u003c/p\u003e\n\u003cp\u003eFailFast 快速失败。就是服务消费者调用一次失败后，不再重试。\u003c/p\u003e\n\u003cp\u003e服务治理的手段是从不同角度来确保服务调用的成功率。节点管理是从服务节点健康状态角度来考虑，负载均衡和服务路由是从服务节点访问优先级角度来考虑，而服务容错是从调用的健康状态角度来考虑。\u003c/p\u003e\n\u003ch4\u003e3.6 服务监控 \u003ca href=\"#scroller-33\" id=\"scroller-33\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_6.png\" alt=\"image_1_6.png\"\u003e\u003c/p\u003e\n\u003cp\u003e常见的开发监控报警技术有 ELK、InfluxData的TICK、Promethues 等。\u003c/p\u003e\n\u003cp\u003e在分布式系统中，微服务一般都具有复杂的链路调用，对于链路之间的状态、服务可用性、调用情况的监控，是需要一套完整的服务监控系统去保障的。\u003c/p\u003e\n\u003cp\u003e如我们上面的那个图所示， 服务系统主要由哪几部分构成：\u003c/p\u003e\n\u003cp\u003e1、数据采集部分，包含性能指标信息、日志信息（一般是服务埋点日志或者sidecar的inbound、outbound信息）、端到端的Trace信息。\u003c/p\u003e\n\u003cp\u003e2、采集上来的监控数据通过传输系统，或者使用消息中间件来异步传输，或者调用服务端接口推送监控数据。并把这些数据持久化到我们的数据服务层中。\u003c/p\u003e\n\u003cp\u003e3、制定一套规则，对于采集到的数据进行清理、计算、分级等，处理好的数据，通过提前设置好的报警策略，来判断它是否触发了这些报警。\u003c/p\u003e\n\u003cp\u003e4、梳理完的数据可以进行查询展示（有一个日志查询界面）、分级报警、分析趋势报表推送等。\u003c/p\u003e\n\u003ch4\u003e3.7 服务追踪 \u003ca href=\"#scroller-34\" id=\"scroller-34\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e服务追踪的原理主要包括下面两个关键点。\u003c/p\u003e\n\u003cp\u003e1、为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。\u003c/p\u003e\n\u003cp\u003e通过 Trace ID 的记录，我们就能将所有请求过程的日志关联起来。\u003c/p\u003e\n\u003cp\u003e2、为了统计各处理单元的时间延迟，当请求到达各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是前文中提到的 Span ID。对于每个 Span 来说，它必须有开始和结束两个节点，\u003c/p\u003e\n\u003cp\u003e通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如事件名称、请求信息等。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_1_7.png\" alt=\"image_1_7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图显示了Trace ID 和 Spand ID 在链路中的传输过程，它把服务调用的一个时序结构给展现出来了。\u003c/p\u003e\n\u003cp\u003e常见的服务链路追踪的技术有Zipkin、Pinpoint、SkyWalking 等。后面讲到Service Mesh的时候会详细说下Zipkin的x-b3 header头传递，以及流量染色的使用，非常给力。\u003c/p\u003e\n\u003ch3\u003e4 总结 \u003ca href=\"#scroller-35\" id=\"scroller-35\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。\u003c/p\u003e\n\u003cp\u003e后续我们围绕它的核心模块：服务注册与发现、API 网关服务、分布式配置中心、服务通信、服务治理、分布式服务追踪与监控等，从原理到实践，一步步展开来研究。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"18:T148b,"])</script><script>self.__next_f.push([1,"\u003cp\u003e关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。\u003c/p\u003e\n\u003cp\u003e1. AKF扩展立方体\u003c/p\u003e\n\u003cp\u003eAKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度（见下图），分别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eX轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eY轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关注应用中职责的划分，比如数据类型、交易执行类型的划分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eZ轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关注服务和数据的优先级划分，如分地域划\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_5_1.png\" alt=\"image_5_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e以上X、Y和Z轴的划分可以概括为X 轴关注水平复制，Z 轴类似数据分区，而Y 轴则强调基于不同的业务拆分。理论上按照这三个扩展维度，可以将一个单体系统进行无限扩展。举例来说，比如用户预约挂号应用，一个集群撑不住时，分了多个集群，后来用户激增还是不够用，经过分析发现是用户和医生访问量很大，就将预约挂号应用拆成了患者服务、医生服务、支付服务等三个服务。三个服务的业务特点各不相同，独立维护，各自都可以再次按需扩展。\u003c/p\u003e\n\u003cp\u003e在上图中，Y轴就是我们所说的微服务的拆分模式，即基于不同的业务进行拆分。但在进行业务拆分过程中，我们发现业务往往与数据有较大耦合性，所以接下去我们把业务和数据结合起来对服务拆分的维度展开讨论。\u003c/p\u003e\n\u003cp\u003e2. 业务与数据\u003c/p\u003e\n\u003cp\u003e服务拆分存在两大维度，即业务与数据。业务体现在各种功能代码中，通过确定业务的边界，并使用领域与界限上下文、领域事件等技术手段可以实现拆分。而数据的拆分则体现在如何将集中式的中心化数据转变为各个微服务各自拥有的独立数据，这部分工作同样十分具有挑战性。\u003c/p\u003e\n\u003cp\u003e关于业务和数据谁应该先拆分的问题，可以是先数据库后业务代码，也可以是先业务代码后数据库。然而在拆分中遇到的最大挑战可能会是数据层的拆分，因为在数据库中，可能会存在各种跨表连接查询、跨库连接查询以及不同业务模块的代码与数据耦合得非常紧密的场景，这会导致服务的拆分非常的困难。因此在拆分步骤上我们更多的推荐数据库先行。数据模型能否彻底分开，很大程度上决定了微服务的边界功能是否彻底划清。\u003c/p\u003e\n\u003cp\u003e服务拆分的方法需要根据系统自身的特点和运行状态，通常分为绞杀者与修缮者两种模式。\u003c/p\u003e\n\u003cp\u003e1. 绞杀者模式\u003c/p\u003e\n\u003cp\u003e绞杀者模式（Strangler Pattern）最早由\u003ca href=\"https://www.martinfowler.com/\"\u003eMartin Fowler\u003c/a\u003e提出，指的是在现有系统外围将新功能用新的方式构建为新的服务的策略，通过将新功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。采用这种策略，随着时间的推移，新的服务就会逐渐“绞杀”老的系统。对于那些规模很大而又难以对现有架构进行修改的遗留系统，推荐采用绞杀者模式。\u003c/p\u003e\n\u003cp\u003e绞杀者模式的示意图如下图所示，我们可以看到随着功能演进和时间的不断推移，老的遗留系统功能被逐步削弱，而采用微服务架构的新功能越积越多，最终会形成从量变到质变的过程。绞杀者模式在具体实施过程中，所需要把握的最主要一点原则就是对于任何需要开发的功能一定要完整的采用微服务架构，对于完全独立的新功能这点比较容易把握，而对于涉及到老业务变更的新功能则需要通过重构达到这一目标。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_5_2.png\" alt=\"image_5_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e2. 修缮者模式\u003c/p\u003e\n\u003cp\u003e修缮者模式就如修房或修路一样，将老旧待修缮的部分进行隔离，用新的方式对其进行单独修复。修复的同时，需保证与其他部分仍能协同功能。从这种思路出发，修缮者模式更多表现为一种重构技术。修缮者模式在具体实现上可以参考Martine Fowler的BranchByAbstraction重构方法，该重构方法的示意图如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_5_3.png\" alt=\"image_5_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e从上图中，可以看到这种模式的实现方式可以分成三个主要步骤。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层提取\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先通过识别内部的待拆分功能，对其增加抽象接口层，同时对原有代码进行改造，确保其同样实现该抽象层。这样在依赖关系上就添加了一个中间层。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为抽象层提供新的实现，新的实现采用微服务方式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层替换\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e采用新的实现对原有的各个抽象层实现进行逐步替换，直至原有实现被完全废弃，从而完成新老实现方式之间的替换。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"19:Ta3c4,"])</script><script>self.__next_f.push([1,"\u003cp\u003e\u003ca href=\"https://baijiahao.baidu.com/s?id=1767938488419450782\"\u003e转载\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e团队协助基础工具链的选型和培训\u003c/li\u003e\n\u003cli\u003e搭建微服务开发基础设施\u003c/li\u003e\n\u003cli\u003e选择合适的RPC框架\u003c/li\u003e\n\u003cli\u003e选择和搭建高可用的注册中心\u003c/li\u003e\n\u003cli\u003e选择和搭建高可用的配置中心\u003c/li\u003e\n\u003cli\u003e选择和搭建高性能的缓存中间件\u003c/li\u003e\n\u003cli\u003e选择和搭建高性能的消息中间件\u003c/li\u003e\n\u003cli\u003e选择和搭建高性能的关系数据库\u003c/li\u003e\n\u003cli\u003eCICD发布系统/部署系统的架构\u003c/li\u003e\n\u003cli\u003e360度全方位监控和维护的架构\u003c/li\u003e\n\u003cli\u003e生产环境高并发高吞吐负载均衡部署架构\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e整个后台技术架构，主要包括 4 个层面的内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e语言\u003c/strong\u003e：用了哪些开发语言，如：C++/Java/Go/PHP/Python/Ruby 等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e组件\u003c/strong\u003e：用了哪些组件，如：MQ 组件，数据库组件等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e流程\u003c/strong\u003e：怎样的流程和规范，如：开发流程，项目流程，发布流程，监控告警流程，代码规范等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e系统\u003c/strong\u003e：系统化建设，上面的流程需要有系统来保证，如：规范发布流程的发布系统，代码管理系统等等；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e结合以上的的 4 个层面的内容，整个后台技术栈的结构如图1 所示：\u003c/p\u003e\n\u003cp\u003e图1 后台技术栈结构\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics7.baidu.com/feed/f2deb48f8c5494ee55c2ea79fa27a8f29b257ec9.jpeg@f_auto?token=39d8af3c95030b48ad867ef53c70f4c5\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e咱们一个个系统和组件的做选型，最终形成我们的后台技术栈。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e团队协助基础工具链的选型和培训\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e团队协助基础工具链， 主要是三大管理\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e项目管理\u003c/li\u003e\n\u003cli\u003e任务管理\u003c/li\u003e\n\u003cli\u003e问题管理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e项目管理软件是整个业务的需求，问题，流程等等的集中地，大家的跨部门沟通协同大多依赖于项目管理工具。\u003c/p\u003e\n\u003cp\u003e有一些 SaaS 的项目管理服务可以使用，但是很多时间不满足需求，此时我们可以选择一些开源的项目，这些项目本身有一定的定制能力，有丰富的插件可以使用，一般的创业公司需求基本上都能得到满足，常用的项目如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eJira\u003c/strong\u003e：用 Java 开发的，有用户故事，task 拆分，燃尽图等等，可以做项目管理，也可以应用于跨部门沟通场景，较强大；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRedmine\u003c/strong\u003e：用 Ruby 开发的，有较多的插件可以使用，能自定义字段，集成了项目管理，Bug 问题跟踪，WIKI 等功能，不过好多插件 N 年没有更新了；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePhabricator\u003c/strong\u003e：用 PHP 开发的，Facebook 之前的内部工具，开发这工具的哥们离职后自己搞了一个公司专门做这个软件，集成了代码托管， Code Review，任务管理，文档管理，问题跟踪等功能，强烈推荐较敏捷的团队使用；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些平台我都用过，有些甚至还搭建过，惭愧地说一句，盗版的，目前建议是 Jira。像银行，基本上conflue+jira是标配了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e搭建微服务开发基础设施\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e搭建微服务开发基础设施需要考虑多个方面，包括但不限于以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e选择合适的微服务框架和技术栈\u003c/strong\u003e：目前比较流行的微服务框架有 Spring Cloud、Go-Micro、gRPC 等，选择适合自己团队技术栈的框架非常重要。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e选择合适的RPC框架\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e构建基础设施\u003c/strong\u003e：包括但不限于服务注册与发现、负载均衡、API 网关、分布式配置中心、分布式锁、消息队列等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全\u003c/strong\u003e：包括但不限于服务间通信的加密、访问控制、身份认证等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在搭建微服务开发基础设施之前，需要对自己的业务场景进行分析和规划，确定需要哪些基础设施和技术栈，然后再逐步实现。同时，需要注重可扩展性和可维护性，以便在业务发展过程中能够快速适应变化。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择合适的微服务框架和技术栈\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e选择合适的微服务框架和技术栈需要考虑多个因素，包括以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e业务需求\u003c/strong\u003e：不同的业务需求需要不同的技术栈和框架来支持。比如，如果需要高并发和高可用性，可以选择使用 Go 语言和 Kubernetes 等技术来构建微服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开发团队技能\u003c/strong\u003e：选择的技术栈和框架应该符合开发团队的技能水平，以便开发人员能够快速上手并高效开发。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e社区支持\u003c/strong\u003e：选择流行的技术栈和框架可以获得更好的社区支持，能够更快地解决问题和获得更新的功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e性能和稳定性\u003c/strong\u003e：选择的技术栈和框架应该具有良好的性能和稳定性，以便能够支持高负载和长时间运行。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e常见的微服务框架和技术栈包括：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSpring Cloud\u003c/strong\u003e：适用于 Java 开发团队，具有丰富的功能和社区支持。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo Micro\u003c/strong\u003e：适用于 Go 开发团队，具有高性能和简单易用的特点。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNode.js + Express\u003c/strong\u003e：适用于 JavaScript 开发团队，具有轻量级和快速开发的特点。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKubernetes\u003c/strong\u003e：适用于需要高可用性和弹性的微服务架构，可以支持多种编程语言和框架。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIstio\u003c/strong\u003e：适用于需要服务网格功能的微服务架构，可以提供流量管理、安全性和可观察性等功能。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在选择时，需要根据具体的业务需求和开发团队技能来选择合适的微服务框架和技术栈。\u003c/p\u003e\n\u003cp\u003e建议选用 SpringCloud Alibaba+ Dubbo RPC + Dubbo-Go，两个原因：\u003c/p\u003e\n\u003cp\u003e（1） \u003cstrong\u003e高性能\u003c/strong\u003e：做过的性能测试中， Dubbo比Feign性能 强10倍。\u003c/p\u003e\n\u003cp\u003e（2） \u003cstrong\u003e兼顾团队技术栈\u003c/strong\u003e：可以跨Go 和Java 多语言微服务架构，Java技术栈的同学们，可以基于 Java开发业务微服务，这块侧重业务开发。Go 技术栈的同学们，可以基于 Go 开发高性能的 技术微服务，这块侧重技术开发和性能优化。\u003c/p\u003e\n\u003cp\u003e（3）\u003cstrong\u003e功能和性能兼顾\u003c/strong\u003e：Java侧重功能的快速开发， Go侧重性能的快速提升。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择合适的RPC框架\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e维基百科对 RPC 的定义是：远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\u003c/p\u003e\n\u003cp\u003e通俗来讲，一个完整的 RPC 调用过程，就是 Server 端实现了一个函数，客户端使用 RPC 框架提供的接口，调用这个函数的实现，并获取返回值的过程。\u003c/p\u003e\n\u003cp\u003e业界 RPC 框架大致分为两大流派，一种侧重跨语言调用，另一种是偏重服务治理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e跨语言调用型 RPC\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e跨语言调用型的 RPC 框架有 Thrift、gRPC、Hessian、Hprose 等。这类 RPC 框架侧重于服务的跨语言调用，能够支持大部分的语言进行语言无关的调用，非常适合多语言调用场景。但这类框架没有服务发现相关机制，实际使用时需要代理层进行请求转发和负载均衡策略控制。\u003c/p\u003e\n\u003cp\u003e其中，gRPC 是 Google 开发的高性能、通用的开源 RPC 框架，其由 Google 主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf（Protocol Buffers）序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现框架的功能需要进一步的开发。\u003c/p\u003e\n\u003cp\u003eHprose（High Performance Remote Object Service Engine）是一个 MIT 开源许可的新型轻量级跨语言跨平台的面向对象的高性能远程动态通讯中间件。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e冶理型 RPC\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e服务治理型的 RPC 框架\u003c/strong\u003e的特点是功能丰富，提供高性能的远程调用、服务发现及服务治理能力，适用于大型服务的服务解耦及服务治理，对于特定语言(Java)的项目可以实现透明化接入。缺点是语言耦合度较高，跨语言支持难度较大。\u003c/p\u003e\n\u003cp\u003e国内常见的冶理型 RPC 框架如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eDubbo\u003c/strong\u003e：Dubbo 是阿里巴巴公司开源的一个 Java 高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。当年在淘宝内部，Dubbo 由于跟淘宝另一个类似的框架 HSF 有竞争关系，导致 Dubbo 团队解散，最近又活过来了，有专职同学投入。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDubboX\u003c/strong\u003e：DubboX 是由当当在基于 Dubbo 框架扩展的一个 RPC 框架，支持 REST 风格的远程调用、Kryo/FST 序列化，增加了一些新的feature。Motan：Motan 是新浪微博开源的一个 Java 框架。它诞生的比较晚，起于 2013 年，2016 年 5 月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erpcx\u003c/strong\u003e：rpcx 是一个类似阿里巴巴 Dubbo 和微博 Motan 的分布式的 RPC 服务框架，基于 Golang net/rpc 实现。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是 rpcx 基本只有一个人在维护，没有完善的社区，使用前要慎重。\u003c/p\u003e\n\u003cp\u003e建议选用Dubbo，两个原因：\u003c/p\u003e\n\u003cp\u003e（1） \u003cstrong\u003e高性能\u003c/strong\u003e：性能测试案例中， Dubbo比Feign性能 强10倍\u003c/p\u003e\n\u003cp\u003e（2） \u003cstrong\u003e跨语言\u003c/strong\u003e：可以跨Go 和Java 进行 双语言的 RPC调用，从而实现 多语言微服务架构。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高可用的注册中心\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e名字发现和服务发现分为两种模式，一个是客户端发现模式，一种是服务端发现模式。框架中常用的服务发现是客户端发现模式。\u003c/p\u003e\n\u003cp\u003e所谓服务端发现模式是指客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。现在常用的负载均衡器都是此类模式，常用于微服务中。\u003c/p\u003e\n\u003cp\u003e所有的名字发现和服务发现都要依赖于一个可用性非常高的服务注册表，业界常用的服务注册表有如下三个：\u003c/p\u003e\n\u003cp\u003eetcd，一个高可用、分布式、一致性、key-value 方式的存储，被用在分享配置和服务发现中。两个著名的项目使用了它：Kubernetes 和 Cloud Foundry。Consul，一个发现和配置服务的工具，为客户端注册和发现服务提供了API，Consul还可以通过执行健康检查决定服务的可用性。Apache ZooKeeper，是一个广泛使用、高性能的针对分布式应用的协调服务。Apache ZooKeeper 本来是 Hadoop 的子工程，现在已经是顶级工程了。除此之外还有eureka, nacos等，大家可以根据相关的组件特性，选择适合自己的组件。\u003c/p\u003e\n\u003cp\u003e选择和搭建高可用的注册中心，需要考虑以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e功能需求\u003c/strong\u003e：选择注册中心时，需要根据自己的业务需求来选择，比如服务发现、负载均衡、配置管理等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e性能要求\u003c/strong\u003e：注册中心需要具备高性能，能够支持高并发、高吞吐量的请求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可用性要求\u003c/strong\u003e：注册中心需要具备高可用性，能够保证24小时不间断运行，避免因为单点故障导致整个系统不可用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全要求\u003c/strong\u003e：注册中心需要具备一定的安全性，能够保证数据的机密性和完整性，避免数据泄露和篡改。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e常见的注册中心有 ZooKeeper、Etcd、Consul 等，它们都具备高可用性和安全性，并且都支持服务发现和配置管理等功能。其中，ZooKeeper 是最早的分布式协调服务，具备成熟的生态系统和广泛的应用场景；Etcd 是 CoreOS 推出的开源分布式键值存储系统，具备高可用性和一致性保证；Consul 是 HashiCorp 推出的服务发现和配置管理工具，具备易用性和可扩展性。\u003c/p\u003e\n\u003cp\u003e在搭建高可用的注册中心时，需要采用集群部署的方式，避免单点故障。同时，为了保证数据的安全性，可以启用 SSL/TLS 加密功能，并采用访问控制机制来限制访问权限。\u003c/p\u003e\n\u003cp\u003e建议是高可用的nacos，也就是 nacos+mysql的版本\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建统一配置中心\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e随着程序功能的日益复杂，程序的配置日益增多：各种功能的开关、降级开关，灰度开关，参数的配置、服务器的地址、数据库配置等等，除此之外，对后台程序配置的要求也越来越高：配置修改后实时生效，灰度发布，分环境、分用户，分集群管理配置，完善的权限、审核机制等等，在这样的大环境下，传统的通过配置文件、数据库等方式已经越来越无法满足开发人员对配置管理的需求，需要统一的、基础的配置系统\u003c/p\u003e\n\u003cp\u003e统一配置系统是指在一个大型系统中，将所有的配置信息集中管理，以便于对系统进行管理和维护。常见的统一配置系统架构包括以下几个组件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e配置中心\u003c/strong\u003e：用于存储和管理所有的配置信息，提供配置查询、修改、删除等功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置客户端\u003c/strong\u003e：用于从配置中心获取配置信息，并将其应用到系统中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置发布工具\u003c/strong\u003e：用于将配置信息发布到配置中心，以便于配置客户端获取。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置管理工具\u003c/strong\u003e：用于对配置信息进行管理和维护，包括配置的新增、修改、删除等操作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置监控工具\u003c/strong\u003e：用于监控配置信息的变化，及时发现并处理配置信息的异常情况。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在实际应用中，可以选择使用开源的配置中心工具，如 ZooKeeper、Etcd、Consul 、Nacos、Apollo等，也可以自己开发一套配置中心系统。\u003c/p\u003e\n\u003cp\u003e同时，还需要根据实际情况选择合适的配置客户端和配置发布工具。在配置管理和监控方面，可以使用一些开源的工具或者自己开发一套系统。总之，统一配置系统的架构需要根据实际需求进行设计和选择。\u003c/p\u003e\n\u003cp\u003e建议是高可用的nacos，也就是 nacos+mysql的版本\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的缓存中间件\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e选择和搭建高性能的缓存中间件需要考虑多个因素，包括性能、可靠性、可扩展性、易用性等。以下是一些常见的高性能缓存中间件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eRedis\u003c/strong\u003e：Redis 是一个开源的高性能缓存和键值存储系统，支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等。Redis 通过将数据存储在内存中来提高性能，同时支持数据持久化和集群模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMemcached\u003c/strong\u003e：Memcached 是一个开源的高性能分布式内存对象缓存系统，可以缓存任何可序列化的数据，如数据库查询结果、API 响应等。Memcached 可以通过多个节点组成的集群来提高可扩展性和可靠性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHazelcast\u003c/strong\u003e：Hazelcast 是一个开源的分布式内存数据网格系统，支持缓存、分布式数据结构和分布式计算等功能。Hazelcast 可以通过多个节点组成的集群来提高可扩展性和可靠性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCouchbase\u003c/strong\u003e：Couchbase 是一个开源的分布式 NoSQL 数据库和缓存系统，可以缓存任何类型的数据，包括 JSON 文档、键值对和二进制数据等。Couchbase 支持多个节点组成的集群和数据持久化等功能。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在搭建高性能缓存中间件时，需要考虑以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e硬件配置\u003c/strong\u003e：缓存中间件需要占用大量内存，因此需要配置足够的内存和处理器资源。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e部署架构\u003c/strong\u003e：需要考虑缓存中间件的部署架构，如单节点、主从复制、集群等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据持久化\u003c/strong\u003e：需要考虑数据持久化的方式，如内存快照、AOF 日志、RDB 文件等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全性\u003c/strong\u003e：需要考虑缓存中间件的安全性，如访问控制、数据加密等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控和管理\u003c/strong\u003e：需要考虑缓存中间件的监控和管理，如性能监控、故障诊断等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e总之，选择和搭建高性能缓存中间件需要综合考虑多个因素，根据具体需求和场景进行选择和配置。\u003c/p\u003e\n\u003cp\u003e建议是高可用的redis cluster\u003c/p\u003e\n\u003cp\u003e要特别注意的是，redis关系到系统的高可用，很容易出生产事故。\u003c/p\u003e\n\u003cp\u003e如果redis出现big key，在高并发场景下，很容易出现系统瘫痪，严重影响系统的可用性，导致系统瘫痪。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的消息中间件\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e消息中间件在后台系统中是必不可少的一个组件，一般我们会在以下场景中使用消息中间件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e异步处理\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e异步处理是使用消息中间件的一个主要原因，在工作中最常见的异步场景有用户注册成功后需要发送注册成功邮件、缓存过期时先返回老的数据，然后异步更新缓存、异步写日志等等；通过异步处理，可以减少主流程的等待响应时间，让非主流程或者非重要业务通过消息中间件做集中的异步处理。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e系统解耦\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e比如在电商系统中，当用户成功支付完成订单后，需要将支付结果给通知ERP系统、发票系统、WMS、推荐系统、搜索系统、风控系统等进行业务处理；这些业务处理不需要实时处理、不需要强一致，只需要最终一致性即可，因此可以通过消息中间件进行系统解耦。通过这种系统解耦还可以应对未来不明确的系统需求。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e削峰填谷\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当系统遇到大流量时，监控图上会看到一个一个的山峰样的流量图，通过使用消息中间件将大流量的请求放入队列，通过消费者程序将队列中的处理请求慢慢消化，达到消峰填谷的效果。最典型的场景是秒杀系统，在电商的秒杀系统中下单服务往往会是系统的瓶颈，因为下单需要对库存等做数据库操作，需要保证强一致性，此时使用消息中间件进行下单排队和流控，让下单服务慢慢把队列中的单处理完，保护下单服务，以达到削峰填谷的作用。\u003c/p\u003e\n\u003cp\u003e业界消息中间件是一个非常通用的东西，大家在做选型时有使用开源的，也有自己造轮子的，甚至有直接用 MySQL 或 Redis 做队列的，关键看是否满足你的需求.\u003c/p\u003e\n\u003cp\u003e选择合适的消息中间件需要考虑多个因素，包括但不限于：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e需要处理的消息数量和频率\u003c/li\u003e\n\u003cli\u003e消息的大小和格式\u003c/li\u003e\n\u003cli\u003e可用性和容错性要求\u003c/li\u003e\n\u003cli\u003e数据安全性和加密需求\u003c/li\u003e\n\u003cli\u003e扩展性和灵活性要求\u003c/li\u003e\n\u003cli\u003e开发语言和技术栈的兼容性 常见的消息中间件包括RocketMQ、Kafka、 RabbitMQ、Kafka、ActiveMQ、Redis、NATS 等，每种中间件都有其特点和适用场景。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果需要处理大量的消息并且需要高吞吐量和低延迟，可以考虑使用 Kafka。如果需要实时处理消息并且需要高可用性和容错性，可以考虑使用 RabbitMQ。如果需要处理轻量级的消息，并且需要高性能和低延迟，可以考虑使用 Redis。\u003c/p\u003e\n\u003cp\u003e在选择消息中间件时，需要根据具体的业务需求和技术栈进行综合考虑，选择最合适的中间件。\u003c/p\u003e\n\u003cp\u003e目前建议 kafka + RocketMQ\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的关系数据库\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关系数据库分为两种，一种是传统关系数据，如 Oracle，MySQL，Maria，DB2，PostgreSQL 等等，另一种是 NewSQL，即至少要满足以下五点的新型关系数据库：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e完整地支持 SQL，支持 JOIN / GROUP BY /子查询等复杂 SQL 查询。\u003c/li\u003e\n\u003cli\u003e支持传统数据标配的 ACID 事务，支持强隔离级别。\u003c/li\u003e\n\u003cli\u003e具有弹性伸缩的能力，扩容缩容对于业务层完全透明。\u003c/li\u003e\n\u003cli\u003e真正的高可用，异地多活、故障恢复的过程不需要人为的接入，系统能够自动地容灾和进行强一致的数据恢复。\u003c/li\u003e\n\u003cli\u003e具备一定的大数据分析能力。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e传统关系数据库用得最多的是 MySQL，成熟，稳定，一些基本的需求都能满足，在一定数据量级之前基本单机传统数据库都可以搞定，而且现在较多的开源系统都是基于 MySQL，开箱即用，再加上主从同步和前端缓存，百万 pv 的应用都可以搞定了。\u003c/p\u003e\n\u003cp\u003e不过 CentOS 7 已经放弃了 MySQL，而改使用 MariaDB。MariaDB 数据库管理系统是 MySQ L的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。\u003c/p\u003e\n\u003cp\u003e在 Google 发布了 F1: A Distributed SQL Database That Scales 和 Spanner: Google’s Globally-Distributed Databasa 之后，业界开始流行起 NewSQL。于是有了 CockroachDB，以及PingCAP的 TiDB。\u003c/p\u003e\n\u003cp\u003e国内已经有比较多的公司使用 TiDB，之前在创业公司时在大数据分析时已经开始应用 TiDB，当时应用的主要原因是 MySQL 要使用分库分表，逻辑开发比较复杂，扩展性不够。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的NoSQL\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNoSQL 顾名思义就是 Not-Only SQL，也有人说是 No – SQL，个人偏向于 Not-Only SQL，它并不是用来替代关系库，而是作为关系型数据库的补充而存在。\u003c/p\u003e\n\u003cp\u003e常见 NoSQL 有4个类型：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e键值\u003c/strong\u003e，适用于内容缓存，适合混合工作负载并发高扩展要求大的数据集，其优点是简单，查询速度快，缺点是缺少结构化数据，常见的有 Redis，Memcache，BerkeleyDB 和 Voldemort 等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e列式\u003c/strong\u003e，以列簇式存储，将同一列数据存在一起，常见于分布式的文件系统，其中以 Hbase，Cassandra 为代表。Cassandra 多用于写多读少的场景，国内用得比较多的有 360，大概 1500 台机器的集群，国外大规模使用的公司比较多，如 eBay，Instagram，Apple 和沃尔玛等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e文档\u003c/strong\u003e，数据存储方案非常适用承载大量不相关且结构差别很大的复杂信息。性能介于 kv 和关系数据库之间，它的灵感来于 lotus notes，常见的有 MongoDB，CouchDB 等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e图形\u003c/strong\u003e，图形数据库擅长处理任何涉及关系的状况。社交网络，推荐系统等。专注于构建关系图谱，需要对整个图做计算才能得出结果，不容易做分布式的集群方案，常见的有 Neo4J，InfoGrid 等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e除了以上4种类型，还有一些特种的数据库，如对象数据库，XML 数据库，这些都有针对性对某些存储类型做了优化的数据库。\u003c/p\u003e\n\u003cp\u003e在实际应用场景中，何时使用关系数据库，何时使用 NoSQL，使用哪种类型的数据库，这是我们在做架构选型时一个非常重要的考量，甚至会影响整个架构的方案。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCICD发布系统/部署系统的架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e软件生产的层面看，代码到最终服务的典型流程如图2 所示：\u003c/p\u003e\n\u003cp\u003e图2 流程图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics5.baidu.com/feed/79f0f736afc379317be5da173c16ff4942a91159.jpeg@f_auto?token=4bb2c4d1bb9adef5c1a6d5ad85f59fb4\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e从上图中可以看出，从开发人员写下代码到服务最终用户是一个漫长过程，整体可以分成三个阶段：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e从代码（Code）到制品库（Artifact）\u003c/strong\u003e：这个阶段主要对开发人员的代码做持续构建，并把构建产生的制品集中管理，是为部署系统准备输入内容的阶段。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从制品到可运行服务\u003c/strong\u003e：这个阶段主要完成制品部署到指定环境，是部署系统的最基本工作内容。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从开发环境到最终生产环境\u003c/strong\u003e：这个阶段主要完成一次变更在不同环境的迁移，是部署系统上线最终服务的核心能力。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e发布系统集成了制品管理，发布流程，权限控制，线上环境版本变更，灰度发布，线上服务回滚等几方面的内容，是开发人员工作结晶最终呈现的重要通道。\u003c/p\u003e\n\u003cp\u003eCI/CD 发布系统/部署系统的架构通常包括以下组件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e源代码管理系统\u003c/strong\u003e：例如 Git、SVN 等，用于管理代码库。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e持续集成工具\u003c/strong\u003e：例如 Jenkins、GitLab CI、Travis CI 等，用于自动化构建、测试和打包应用程序。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e制品仓库\u003c/strong\u003e：例如 Docker Hub、Harbor、Aliyun Container Registry 等，用于存储应用程序的镜像。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e部署工具\u003c/strong\u003e：例如 Kubernetes、Docker Swarm、Mesos 等，用于自动化部署应用程序。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些组件可以根据实际需求进行选择和组合，形成一个完整的 CI/CD 发布系统/部署系统。\u003c/p\u003e\n\u003cp\u003e其中，持续集成工具和部署工具是核心组件，它们负责自动化构建、测试、打包和部署应用程序，从而实现快速、可靠、可重复的软件发布流程。\u003c/p\u003e\n\u003cp\u003e项目初期可以集成 Jenkins + Gitlab + Harbor，以上方案基本包括制品管理，发布流程，权限控制，线上环境版本变更，灰度发布（需要自己实现），线上服务回滚等功能。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e代码管理工具选型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e代码是项目的命脉之一，代码管理很重要，常见的考量点包括两块：\u003c/p\u003e\n\u003cp\u003e安全和权限管理，将代码放到内网并且对于关系公司命脉的核心代码做严格的代码控制和机器的物理隔离；代码管理工具，Git 作为代码管理的不二之选，你值得拥有。\u003c/p\u003e\n\u003cp\u003eGitLab 是当今最火的开源 Git 托管服务端，没有之一，虽然有企业版，但是其社区版基本能满足我们大部分需求，结合 Gerrit 做 Code review，基本就完美了。\u003c/p\u003e\n\u003cp\u003e当然 GitLab 也有代码对比，但没 Gerrit 直观。\u003c/p\u003e\n\u003cp\u003eGerrit 比 GitLab 提供了更好的代码检查界面与主线管理体验，更适合在对代码质量有高要求的文化下使用。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e持续集成工具选型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e持续集成简称 CI（continuous integration），是一种软件开发实践，即团队开发成员经常集成他们的工作，每天可能会发生多次集成。\u003c/p\u003e\n\u003cp\u003e每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\u003c/p\u003e\n\u003cp\u003e持续集成为研发流程提供了代码分支管理/比对、编译、检查、发布物输出等基础工作，为测试的覆盖率版本编译、生成等提供统一支持。\u003c/p\u003e\n\u003cp\u003e业界免费的持续集成工具中系统我们有如下一些选择：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eJenkins\u003c/strong\u003e：Java 写的有强大的插件机制，MIT 协议开源 （免费，定制化程度高，它可以在多台机器上进行分布式地构建和负载测试）。Jenkins 可以算是无所不能，基本没有 Jenkins 做不了的，无论从小型团队到大型团队 Jenkins 都可以搞定。不过如果要大规模使用，还是需要有人力来学习和维护。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTeamCity\u003c/strong\u003e：TeamCity 与 Jenkins 相比使用更加友好，也是一个高度可定制化的平台。但是用的人多了，TeamCity就要收费了。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStrider\u003c/strong\u003e：Strider 是一个开源的持续集成和部署平台，使用 Node.js 实现，存储使用的是 MongoDB，BSD 许可证，概念上类似 Travis 和Jenkins。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGitLab CI\u003c/strong\u003e：从GitLab 8.0开始，GitLab CI 就已经集成在 GitLab，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。并且 GitLab 与 Docker 有着非常好的相互协作的能力。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTravis\u003c/strong\u003e：Travis 和 GitHub 强关联；闭源代码使用 SaaS 还需考虑安全问题；不可定制；开源项目免费，其它收费。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo\u003c/strong\u003e：Go 是 ThoughtWorks 公司最新的 Cruise Control 的化身。除了 ThoughtWorks 提供的商业支持，Go 是免费的。它适用于 Windows，Mac 和各种 Linux 发行版。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e自动化测试平台的架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接下来，就是自动化测试平台的搭建。\u003c/p\u003e\n\u003cp\u003e搭建自动化测试平台需要考虑以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e选择合适的测试框架和工具\u003c/strong\u003e：可以选择一些流行的测试框架和工具，如Selenium、Appium、JMeter等，根据需要选择适合自己的工具。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e搭建测试环境\u003c/strong\u003e：需要搭建测试环境，包括测试服务器、测试数据库、测试数据等。可以使用虚拟机或者容器来搭建测试环境，以便进行测试。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e编写测试用例\u003c/strong\u003e：需要编写测试用例，测试用例应该覆盖系统的各个功能点，以便发现潜在的问题。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e集成测试工具和测试用例\u003c/strong\u003e：将测试工具和测试用例集成到自动化测试平台中，以便进行自动化测试。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e运行测试用例\u003c/strong\u003e：编写好测试用例后，需要运行测试用例，收集测试结果，并生成测试报告。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e定期维护和更新\u003c/strong\u003e：自动化测试平台需要定期维护和更新，以保证测试环境的稳定性和测试用例的有效性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以上是搭建自动化测试平台的一般步骤，具体实现方式还需要根据实际情况进行调整。\u003c/p\u003e\n\u003cp\u003e可以结合 SpringBoot + TestNG 测试框架，搭建自己的 自动化测试平台\u003c/p\u003e\n\u003cp\u003e提示，不用自己从0到1 去搭建自动化测试平台，可以基于开源的自动化测试平台进行改造。\u003c/p\u003e\n\u003cp\u003e下面的两个测试平台，就是非常好的改造项目：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e接口自动化测试框架（java httpClient + testNg）\u003c/li\u003e\n\u003cli\u003eChenSen5/api_autotest (\u003ca href=\"https://github.com/ChenSen5/api%5C_autotest\"\u003ehttps://github.com/ChenSen5/api\\_autotest\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003e基于SpringBoot的高效模板化自动化测试框架\u003c/li\u003e\n\u003cli\u003ejinganglong123/jg-api-autotest (\u003ca href=\"https://github.com/jinganglong123/jg-api-autotest\"\u003ehttps://github.com/jinganglong123/jg-api-autotest\u003c/a\u003e)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e360度全方位监控和维护的架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e360度全方位监控和维护的架构包括\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e日志系统\u003c/li\u003e\n\u003cli\u003e监控系统\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e日志系统\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e日志系统一般包括打日志，采集，中转，收集，存储，分析，呈现，搜索还有分发等。\u003c/p\u003e\n\u003cp\u003e一些特殊的如\u003cstrong\u003e染色\u003c/strong\u003e，全链条跟踪或者监控都可能需要依赖于日志系统实现。\u003c/p\u003e\n\u003cp\u003e日志系统的建设不仅仅是工具的建设，还有规范和组件的建设，最好一些基本的日志在框架和组件层面加就行了，比如全链接跟踪之类的。\u003c/p\u003e\n\u003cp\u003e对于常规日志系统ELK能满足大部分的需求，ELK 包括如下组件：\u003c/p\u003e\n\u003cp\u003eElasticSearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，RESTful 风格接口，多数据源，自动搜索负载等。\u003c/p\u003e\n\u003cp\u003eLogstash 是一个完全开源的工具，它可以对你的日志进行收集、分析，并将其存储供以后使用。Kibana 是一个开源和免费的工具，它可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。\u003c/p\u003e\n\u003cp\u003eFilebeat 已经完全替代了 Logstash-Forwarder 成为新一代的日志采集器，同时鉴于它轻量、安全等特点，越来越多人开始使用它。\u003c/p\u003e\n\u003cp\u003e因为免费的 ELK 没有任何安全机制，所以这里使用了 Nginx 作反向代理，避免用户直接访问 Kibana 服务器。\u003c/p\u003e\n\u003cp\u003e加上配置 Nginx 实现简单的用户认证，一定程度上提高安全性。\u003c/p\u003e\n\u003cp\u003e另外，Nginx 本身具有负载均衡的作用，能够提高系统访问性能。\u003c/p\u003e\n\u003cp\u003eELK 架构如图3 所示：\u003c/p\u003e\n\u003cp\u003e图3 ELK 流程图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics7.baidu.com/feed/32fa828ba61ea8d38fa0602340d87842241f5871.jpeg@f_auto?token=854c8ec61da88338fc959753af0805ad\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e对于有实时计算的需求，可以使用 Flume + Kafka + Storm + MySQL 方案，一 般架构如图4 所示：\u003c/p\u003e\n\u003cp\u003e图4 实时分析系统架构图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics3.baidu.com/feed/242dd42a2834349b37545a591e385dc234d3befe.jpeg@f_auto?token=1c04504154566417238607715590eae6\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e其中：\u003c/p\u003e\n\u003cp\u003eFlume 是一个分布式、可靠、和高可用的海量日志采集、聚合和传输的日志收集系统，支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume 提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。其本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，它以可水平扩展和高吞吐率而被广泛使用。\u003c/p\u003e\n\u003cp\u003eKafka 追求的是高吞吐量、高负载，Flume 追求的是数据的多样性，二者结合起来简直完美。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e监控系统\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e监控系统只包含与后台相关的，这里主要是两块，一个是操作系统层的监控，比如机器负载，IO，网络流量，CPU，内存等操作系统指标的监控。\u003c/p\u003e\n\u003cp\u003e另一个是服务质量和业务质量的监控，比如服务的可用性，成功率，失败率，容量，QPS 等等。\u003c/p\u003e\n\u003cp\u003e常见业务的监控系统先有操作系统层面的监控（这部分较成熟），然后扩展出其它监控，如 Zabbix，小米的 Open-Falcon，也有一出来就是两者都支持的，如 Prometheus。\u003c/p\u003e\n\u003cp\u003e如果对业务监控要求比较高一些，在创业选型中建议可以优先考虑 Prometheus。\u003c/p\u003e\n\u003cp\u003e这里有一个有趣的分布，如图5 所示。\u003c/p\u003e\n\u003cp\u003e图5 监控系统分布\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics5.baidu.com/feed/91529822720e0cf37dff0cacdd94ba13bf09aab8.jpeg@f_auto?token=78b21d8d26b6390c49bdc8d79949e5c1\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e亚洲区域使用 Zabbix 较多，而美洲和欧洲，以及澳大利亚使用 Prometheus 居多，换句话说，英文国家地区（发达国家？）使用 Prometheus 较多。\u003c/p\u003e\n\u003cp\u003ePrometheus 是由 SoundCloud 开发的开源监控报警系统和时序列数据库（TSDB）。\u003c/p\u003e\n\u003cp\u003ePrometheus 使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。\u003c/p\u003e\n\u003cp\u003e相对于其它监控系统使用的 push 数据的方式，Prometheus 使用的是 pull 的方式，其架构如图6 所示：\u003c/p\u003e\n\u003cp\u003e图6 Prometheus 架构图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics5.baidu.com/feed/7a899e510fb30f24b5dc0bc31e47994faf4b038f.png@f_auto?token=17e4b1472f5b8bf00dff3b872cac7b60\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示，Prometheus 包含的主要组件如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePrometheus Server\u003c/strong\u003e：主要负责数据采集和存储，提供 PromQL 查询语言的支持。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eServer\u003c/strong\u003e：通过配置文件、文本文件、ZooKeeper、Consul、DNS SRV Lookup 等方式指定抓取目标。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e根据这些目标会，Server 定时去抓取 metrics 数据，每个抓取目标需要暴露一个 http 服务的接口给它定时抓取。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e客户端 SDK\u003c/strong\u003e：官方提供的客户端类库有 Go、Java、Scala、Python、Ruby，其他还有很多第三方开发的类库，支持 Nodejs、PHP、Erlang 等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePush Gateway\u003c/strong\u003e：支持临时性 Job 主动推送指标的中间网关。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExporter Exporter\u003c/strong\u003e：是 Prometheus 的一类数据采集组件的总称。它负责从目标处搜集数据，并将其转化为 Prometheus 支持的格式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePrometheus\u003c/strong\u003e：提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAlertmanager\u003c/strong\u003e：是一个单独的服务，可以支持 Prometheus 的查询语句，提供十分灵活的报警方式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrometheus HTTP API\u003c/strong\u003e 的查询方式，自定义所需要的输出。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGrafana\u003c/strong\u003e：是一套开源的分析监视平台，支持 Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch 等数据源，其 UI 非常漂亮且高度定制化。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e创业公司选择 Prometheus + Grafana 的方案，再加上统一的服务框架（如 gRPC），可以满足大部分中小团队的监控需求。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e生产环境高并发高吞吐负载均衡部署架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e高并发高吞吐负载均衡链路架构，包括：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDNS的选型和使用设计\u003c/li\u003e\n\u003cli\u003eLB（负载均衡）的选型和使用设计\u003c/li\u003e\n\u003cli\u003eCDN的选型和使用设计\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eDNS的选型和使用设计\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eDNS 是一个很通用的服务，创业公司基本上选择一个合适的云厂商就行了，国内主要是两家：\u003c/p\u003e\n\u003cp\u003e阿里万网：阿里 2014 年收购了万网，整合了其域名服务，最终形成了现在的阿里万网，其中就包含 DNS 这块的服务；\u003c/p\u003e\n\u003cp\u003e腾讯 DNSPod：腾讯 2012 年以 4000 万收购 DNSPod 100% 股份，主要提供域名解析和一些防护功能；\u003c/p\u003e\n\u003cp\u003e如果你的业务是在国内，主要就是这两家，选 一个就好，像今日头条这样的企业用的也是 DNSPod 的服务，除非一些特殊的原因才需要自建，比如一些 CDN 厂商，或者对区域有特殊限制的。\u003c/p\u003e\n\u003cp\u003e要实惠一点用阿里最便宜的基础版就好了，要成功率高一些，还是用 DNSPod 的贵的那种。\u003c/p\u003e\n\u003cp\u003e在国外还是选择亚马逊吧，阿里的 DNS 服务只有在日本和美国有节点，东南亚最近才开始部点， DNSPod 也只有美国和日本，像一些出海的企业，其选择的云服务基本都是亚马逊。\u003c/p\u003e\n\u003cp\u003e如果是线上产品，DNS 强烈建议用付费版，阿里的那几十块钱的付费版基本可以满足需求。如果还需要一些按省份或按区域调试的逻辑，则需要加钱，一年也就几百块，省钱省力。\u003c/p\u003e\n\u003cp\u003e如果是国外，优先选择亚马逊，如果需要国内外互通并且有自己的 APP 的话，建议还是自己实现一些容灾逻辑或者智能调度，因为没有一个现成的 DNS 服务能同时较好的满足国内外场景，或者用多个域名，不同的域名走不同的 DNS 。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLB（负载均衡）的选型和使用设计\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLB（负载均衡）是一个通用服务，一般云厂商的 LB 服务基本都会如下功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e支持四层协议请求（包括 TCP、UDP 协议）；\u003c/li\u003e\n\u003cli\u003e支持七层协议请求（包括 HTTP、HTTPS 协议）；\u003c/li\u003e\n\u003cli\u003e集中化的证书管理系统支持 HTTPS 协议；\u003c/li\u003e\n\u003cli\u003e健康检查；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果你线上的服务机器都是用的云服务，并且是在同一个云服务商的话，可以直接使用云服务商提供的 LB 服务，如阿里云的 SLB，腾讯云的 CLB，亚马逊的 ELB 等等。如果是自建机房基本都是 LVS + Nginx。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCDN的选型和使用设计\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eCDN 现在已经是一个很红很红的市场，基本上只能挣一些辛苦钱，都是贴着成本在卖。国内以网宿为龙头，他们家占据整个国内市场份额的 40% 以上，后面就是腾讯，阿里。网宿有很大一部分是因为直播的兴起而崛起。\u003c/p\u003e\n\u003cp\u003e国外，Amazon 和 Akamai合起来占比大概在 50%，曾经的国际市场老大 Akamai 拥有全球超一半的份额，在 Amazon CDN入局后，份额跌去了将近 20%，众多中小企业都转向后者，Akamai 也是无能为力。\u003c/p\u003e\n\u003cp\u003e国内出海的 CDN 厂商，更多的是为国内的出海企业服务，三家大一点的 CDN 服务商里面也就网宿的节点多一些，但是也多不了多少。阿里和腾讯还处于前期阶段，仅少部分国家有节点。\u003c/p\u003e\n\u003ch4\u003e最后\u003c/h4\u003e\n\u003cp\u003e好的架构不是一蹴而就的，而是演变出来的。对于一个问题，架构师需要做出正确的判断，而这个“正确”与否，在不同的场景下，也是不同的，也就是说答案是开放的。那么提高自己的技术能力、认知能力，就相当重要了。这就要求我们不断地学习，保持对技术的敏锐，才能做出正确的选择。\u003c/p\u003e\n\u003cp\u003e路漫漫其修远兮，架构求索无止尽也。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"1a:T5070,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e1 微服务的注册与发现 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。\u003c/p\u003e\n\u003cp\u003e微服务注册与发现类似于生活中的\u0026quot;电话通讯录\u0026quot;的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。\u003c/p\u003e\n\u003cp\u003e步骤如下：\u003c/p\u003e\n\u003cp\u003e1、你先要把\u0026quot;好友某某\u0026quot;记录在通讯录中。\u003c/p\u003e\n\u003cp\u003e2、拨打电话的时候通过通讯录中找到\u0026quot;好友某某\u0026quot;，并拨通回电话。\u003c/p\u003e\n\u003cp\u003e3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。\u003c/p\u003e\n\u003cp\u003e从这个过程中我们看到了一些特点：\u003c/p\u003e\n\u003cp\u003e1、把 \u0026quot;好友某某\u0026quot; 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。\u003c/p\u003e\n\u003cp\u003e2、后续我们通过\u0026quot;好友某某\u0026quot;就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。\u003c/p\u003e\n\u003cp\u003e而我们微服务架构中的服务注册与发现结构如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_1.png\" alt=\"image_6_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：\u003c/p\u003e\n\u003cp\u003eprovider - 服务提供者\u003c/p\u003e\n\u003cp\u003econsumer - 服务消费者\u003c/p\u003e\n\u003cp\u003eregister center - 注册中心\u003c/p\u003e\n\u003cp\u003e它们之间的关系大致如下：\u003c/p\u003e\n\u003cp\u003e1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。\u003c/p\u003e\n\u003cp\u003e2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。\u003c/p\u003e\n\u003cp\u003e3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。\u003c/p\u003e\n\u003cp\u003e优点如下：\u003c/p\u003e\n\u003cp\u003e1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响\u003c/p\u003e\n\u003cp\u003e2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响\u003c/p\u003e\n\u003cp\u003e3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。\u003c/p\u003e\n\u003cp\u003e从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。\u003c/p\u003e\n\u003ch3\u003e1.1 服务注册 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_2.png\" alt=\"image_6_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：\u003c/p\u003e\n\u003cp\u003e1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。\u003c/p\u003e\n\u003cp\u003e2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。\u003c/p\u003e\n\u003cp\u003e3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。\u003c/p\u003e\n\u003cp\u003e可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_3.png\" alt=\"image_6_3.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 服务发现 \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e服务发现实际就是我们查询已经注册好的服务提供者，比如 p-\u0026gt;p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，\u003c/p\u003e\n\u003cp\u003e返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。\u003c/p\u003e\n\u003cp\u003e这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。\u003c/p\u003e\n\u003cp\u003e服务发现的方式一般有两种：\u003c/p\u003e\n\u003cp\u003e1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。\u003c/p\u003e\n\u003cp\u003e2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。\u003c/p\u003e\n\u003ch3\u003e1.3 注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。\u003c/p\u003e\n\u003cp\u003e服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。\u003c/p\u003e\n\u003cp\u003e主要的检查方式包括：\u003c/p\u003e\n\u003cp\u003e1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。\u003c/p\u003e\n\u003cp\u003e2、注册中心主动检查服务Provider接口。\u003c/p\u003e\n\u003cp\u003e综合我们前面的内容，可以总结下注册中心有如下几种能力：\u003c/p\u003e\n\u003cp\u003e1、高可用\u003c/p\u003e\n\u003cp\u003e这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的\u003c/p\u003e\n\u003cp\u003e2、可视化操作\u003c/p\u003e\n\u003cp\u003e常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。\u003c/p\u003e\n\u003cp\u003e3、高效运维\u003c/p\u003e\n\u003cp\u003e注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。\u003c/p\u003e\n\u003cp\u003e4、权限控制\u003c/p\u003e\n\u003cp\u003e数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求\u003c/p\u003e\n\u003cp\u003e5、服务注册推、拉能力\u003c/p\u003e\n\u003cp\u003e这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_4.png\" alt=\"image_6_4.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e2 现下的主流注册中心 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e2.1 Eureka \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.1.1 介绍 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eEureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。\u003c/p\u003e\n\u003cp\u003e目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 \u003ca href=\"https://github.com/Netflix/eureka/wiki\"\u003eEureka 2.0已经停止维护\u003c/a\u003e，所以新的微服务架构设计中，不再建议使用。\u003c/p\u003e\n\u003cp\u003eSpring Cloud Netflix主要分为两个部分：\u003c/p\u003e\n\u003cp\u003e1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。\u003c/p\u003e\n\u003cp\u003e2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_5.png\" alt=\"image_6_5.png\"\u003e\u003c/p\u003e\n\u003cp\u003eEureka有比较友好的管理界面，如上图所示：\u003c/p\u003e\n\u003cp\u003e1、System Status：显示当前Eureka Server信息。\u003c/p\u003e\n\u003cp\u003e2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。\u003c/p\u003e\n\u003cp\u003e3、General Info：基本信息，如cpu、内存、环境等。\u003c/p\u003e\n\u003ch4\u003e2.1.2 整体架构 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_6.png\" alt=\"image_6_6.png\"\u003e\u003c/p\u003e\n\u003cp\u003eEureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。\u003c/p\u003e\n\u003cp\u003e所以他有如下特点：\u003c/p\u003e\n\u003cp\u003e1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。\u003c/p\u003e\n\u003cp\u003e2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。\u003c/p\u003e\n\u003cp\u003e3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。\u003c/p\u003e\n\u003cp\u003e同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。\u003c/p\u003e\n\u003cp\u003e4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。\u003c/p\u003e\n\u003ch4\u003e2.1.3 接入Spring Cloud \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_7.png\" alt=\"image_6_7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示：\u003c/p\u003e\n\u003cp\u003e1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -\u0026gt; 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。\u003c/p\u003e\n\u003cp\u003e所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。\u003c/p\u003e\n\u003cp\u003e2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。\u003c/p\u003e\n\u003cp\u003e3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。\u003c/p\u003e\n\u003ch3\u003e2.2 ZooKeeper \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.2.1 介绍 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。\u003c/p\u003e\n\u003cp\u003e这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_8.png\" alt=\"image_6_8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在数据模型上，类似于传统的文件系统，节点类型分为：\u003c/p\u003e\n\u003cp\u003e1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。\u003c/p\u003e\n\u003cp\u003e2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。\u003c/p\u003e\n\u003cp\u003e在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_9.png\" alt=\"image_6_9.png\"\u003e\u003c/p\u003e\n\u003cp\u003eZookeeper有如下特点：\u003c/p\u003e\n\u003cp\u003e1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。\u003c/p\u003e\n\u003ch4\u003e2.2.2 整体架构 \u003ca href=\"#scroller-12\" id=\"scroller-12\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_10.png\" alt=\"image_6_10.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图是Zookeeper 的服务架构，他有如下流程：\u003c/p\u003e\n\u003cp\u003e1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；\u003c/p\u003e\n\u003cp\u003e2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。\u003c/p\u003e\n\u003cp\u003e3、Leader负责处理数据更新等操作（Zab协议）；\u003c/p\u003e\n\u003ch4\u003e2.2.3 接入Dubbo生态 \u003ca href=\"#scroller-13\" id=\"scroller-13\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_11.png\" alt=\"image_6_11.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图中的角色如下：\u003c/p\u003e\n\u003cp\u003eProvider：提供者,服务发布方\u003c/p\u003e\n\u003cp\u003eConsumer：消费者, 调用服务方\u003c/p\u003e\n\u003cp\u003eContainer：Dubbo容器.依赖于Spring容器\u003c/p\u003e\n\u003cp\u003eRegistry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置\u003c/p\u003e\n\u003cp\u003eMonitor:监听器\u003c/p\u003e\n\u003cp\u003e说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。\u003c/p\u003e\n\u003cp\u003e服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。\u003c/p\u003e\n\u003cp\u003e这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。\u003c/p\u003e\n\u003ch3\u003e2.3 Consul \u003ca href=\"#scroller-14\" id=\"scroller-14\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.3.1 介绍 \u003ca href=\"#scroller-15\" id=\"scroller-15\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eConsul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：\u003c/p\u003e\n\u003cp\u003e1、Service Discovery（服务发现）\u003c/p\u003e\n\u003cp\u003e2、Configuration（配置化）\u003c/p\u003e\n\u003cp\u003e3、Segmentation Functionality\u003c/p\u003e\n\u003cp\u003e这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。\u003c/p\u003e\n\u003cp\u003eConsul提供的关键功能如下：\u003c/p\u003e\n\u003cp\u003e1、Service Discovery：服务注册/发现功能。\u003c/p\u003e\n\u003cp\u003e2、Health Checking：健康检查，丰富的健康检查方式；\u003c/p\u003e\n\u003cp\u003e3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。\u003c/p\u003e\n\u003cp\u003e4、Multi DataCenter：多数据中心。\u003c/p\u003e\n\u003ch4\u003e2.3.2 整体架构 \u003ca href=\"#scroller-16\" id=\"scroller-16\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_12.png\" alt=\"image_6_12.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图为Consul的架构，这边对技术点做一下说明：\u003c/p\u003e\n\u003cp\u003e1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式\u003c/p\u003e\n\u003cp\u003e2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。\u003c/p\u003e\n\u003cp\u003e3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。\u003c/p\u003e\n\u003cp\u003e4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。\u003c/p\u003e\n\u003cp\u003e5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。\u003c/p\u003e\n\u003cp\u003e6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。\u003c/p\u003e\n\u003cp\u003e7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。\u003c/p\u003e\n\u003cp\u003e8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。\u003c/p\u003e\n\u003cp\u003e9、RPC: 远程过程调用，用于服务之间的通信。\u003c/p\u003e\n\u003cp\u003e10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。\u003c/p\u003e\n\u003cp\u003e所以是典型的CP模式。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_13.png\" alt=\"image_6_13.png\"\u003e\u003c/p\u003e\n\u003cp\u003e根据Consul 的选举机制和服务原理，我们有两个注意点 ：\u003c/p\u003e\n\u003cp\u003e1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。\u003c/p\u003e\n\u003cp\u003e2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。\u003c/p\u003e\n\u003cp\u003e有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。\u003c/p\u003e\n\u003ch4\u003e2.3.3 生态对接 \u003ca href=\"#scroller-17\" id=\"scroller-17\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e对接Spring Cloud生态\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/microservice-image_6_14.png\" alt=\"image_6_14.png\"\u003e\u003c/p\u003e\n\u003cp\u003eConsul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。\u003c/p\u003e\n\u003cp\u003e但是这边的健康检查更丰富，可以有多种不同的的Check方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScript check（Script+ Interval）\u003c/li\u003e\n\u003cli\u003e基于HTTP请求\u003c/li\u003e\n\u003cli\u003e基于tcp请求\u003c/li\u003e\n\u003cli\u003e基于grpc请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2.4 总结对比 \u003ca href=\"#scroller-19\" id=\"scroller-19\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e指标\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEureka\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eZookeeper\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eConsul\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEtcd\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e一致性协议\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003ctd\u003eCP（Paxos算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e健康检查\u003c/td\u003e\n\u003ctd\u003eTTL(Time To Live)\u003c/td\u003e\n\u003ctd\u003eTCP Keep Alive\u003c/td\u003e\n\u003ctd\u003eTTL\\HTTP\\TCP\\Script\u003c/td\u003e\n\u003ctd\u003eLease TTL KeepAlive\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewatch/long polling\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003ctd\u003elong polling\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e雪崩保护\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全与权限\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eRBAC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持多数据中心\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否有管理界面\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否（可用第三方ZkTools）\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud 集成\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDubbo 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eK8S 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。\u003c/p\u003e\n\u003cp\u003e当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。\u003c/p\u003e\n\u003cp\u003e如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/architecture/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"架构设计\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-03-21\",\"children\":\"2024年03月21日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"微服务拆分策略\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"微服务\",{\"href\":\"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"微服务\"}],[\"$\",\"$L13\",\"服务拆分\",{\"href\":\"/blog/tag/%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"服务拆分\"}],[\"$\",\"$L13\",\"架构设计\",{\"href\":\"/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"架构设计\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/architecture/微服务全景架构\",\"title\":\"微服务全景架构\",\"description\":\"微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。\",\"pubDate\":\"2024-03-20\",\"tags\":[\"微服务\",\"全景架构\",\"分布式系统\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/architecture/微服务拆分策略（附加篇）\",\"title\":\"微服务拆分策略（附加篇）\",\"description\":\"关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。 1. AKF扩展立方体 AKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一...\",\"pubDate\":\"2024-03-22\",\"tags\":[\"微服务\",\"服务拆分\",\"领域驱动\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"微服务\":{\"prev\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"服务拆分\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"架构设计\":{\"prev\":{\"slug\":\"engineering/architecture/从0开始做一个后台项目架构\",\"title\":\"从0开始做一个后台项目架构\",\"description\":\"作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。\",\"pubDate\":\"2024-03-18\",\"tags\":[\"架构设计\",\"后台系统\",\"项目实战\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"},\"next\":{\"slug\":\"engineering/architecture/服务注册与发现\",\"title\":\"服务注册与发现\",\"description\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\",\"pubDate\":\"2024-03-23\",\"tags\":[\"微服务\",\"服务发现\",\"架构设计\"],\"heroImage\":\"$undefined\",\"content\":\"$1a\"}}}}]}],[\"$\",\"$L1b\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"微服务拆分策略 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移...\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"微服务拆分策略\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移...\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-03-21\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"微服务拆分策略\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"前面我们学习了微服务的全景架构，了解到相对于传统单体架构，微服务的优势，以及系统服务化的发展趋势。 对于新启动的项目，我们在权衡之后可以大方的使用微服务架构。但其实大部分情况下，我们还要去维护一些以前研发的单体系统，这些系统可能因为访问流量的膨胀、功能的扩张而显得非常臃肿不堪，急需要向微服务架构迁移...\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
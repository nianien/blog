1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/7dd6b3ec14b0b1d8.css","style"]
0:{"P":null,"b":"kLuGQpYNrv7rzQ0jpQCVp","p":"","c":["","blog","engineering","architecture","%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/architecture/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7dd6b3ec14b0b1d8.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/architecture/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","6s8pfFKCEPNk62bXJQv2xv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1b:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T4849,<h2>服务注册中心 <a href="#scroller-1" id="scroller-1"></a></h2>
<p>前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。</p>
<p>并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景下做正确的技术选型。</p>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>Eureka</strong></th>
<th><strong>Zookeeper</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Etcd</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一致性协议</td>
<td>AP</td>
<td>CP（Paxos算法）</td>
<td>CP（Raft算法）</td>
<td>CP（Raft算法）</td>
</tr>
<tr>
<td>健康检查</td>
<td>TTL(Time To Live)</td>
<td>TCP Keep Alive</td>
<td>TTL\HTTP\TCP\Script</td>
<td>Lease TTL KeepAlive</td>
</tr>
<tr>
<td>watch/long polling</td>
<td>不支持</td>
<td>watch</td>
<td>long polling</td>
<td>watch</td>
</tr>
<tr>
<td>雪崩保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>安全与权限</td>
<td>不支持</td>
<td>ACL</td>
<td>ACL</td>
<td>RBAC</td>
</tr>
<tr>
<td>是否支持多数据中心</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有管理界面</td>
<td>是</td>
<td>否（可用第三方ZkTools）</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Spring Cloud 集成</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Dubbo 集成</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>K8S 集成</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>我们可以看出，四种技术类型对Spring Cloud的支持度都很高。Spring Cloud是微服务架构的一站式解决方案，我们平时构建微服务的过程中需要做的的如 配置管理、服务发现、负载均衡、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作。Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<p>Spring Cloud包含了多个不同开源产品，来保证一站式的微服务解决方案，如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。</p>
<h2>Spring Cloud 框架下实现 <a href="#scroller-2" id="scroller-2"></a></h2>
<p>Spring Cloud为服务治理做了一层抽象，这样能够支持多种不同的服务治理框架，比如：Netflix Eureka、Consul。我们这边就以这两个为例子，看看服务治理是如何实现。</p>
<blockquote>
<p><em>在Spring Cloud服务治理抽象层的作用下，可以无缝地切换服务治理实现，且不影响任何其他的服务注册、发现、调用逻辑。</em></p>
<p><em>所以，下面我们通过介绍这两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。</em></p>
</blockquote>
<h3>2.Spring Cloud Eureka <a href="#scroller-3" id="scroller-3"></a></h3>
<p>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。</p>
<p>通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p>
<p>下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。</p>
<h4>2.1.创建注册中心 <a href="#scroller-4" id="scroller-4"></a></h4>
<p>创建一个Spring Cloud项目，我们命名为micro-service-center，并在<code>pom.xml</code>中引入需要的依赖内容：</p>
<pre><code class="language-xml"> &lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
<p>表明这个项目中可以没有Java代码，也不执行任何代码，只是为了聚合工程或者传递依赖，所以可以把src文件夹删了。这是一个父级项目，因为我们还要在下面建立Eureka的注册中心、客户端等多个子项目 。</p>
<p>在micro-service-center下，新建一个命名为 eureka-service 的Module，依旧是Spring Cloud 项目，建完之后，pom.xml做如下改动：</p>
<pre><code class="language-xml">&lt;xml&gt;
    &lt;!--在子工程中添加父工程名称--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.microservice&lt;/groupId&gt;
        &lt;artifactId&gt;center&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;dependencies&gt;
        &lt;!--加入 eureka 服务 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/xml&gt;
</code></pre>
<p>改完之后，回到父项目micro-service-center，修改pom中的信息：</p>
<pre><code class="language-xml">&lt;xml&gt;
    &lt;groupId&gt;com.microservice&lt;/groupId&gt;
    &lt;artifactId&gt;center&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;name&gt;center&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;!--在父工程添加子工程名称--&gt;
    &lt;modules&gt;
        &lt;module&gt;eureka-service&lt;/module&gt;
        &lt;module&gt;eureka-client&lt;/module&gt;
    &lt;/modules&gt;
&lt;/xml&gt;
</code></pre>
<p>对两个项目进行clean + install，应该是成功的。</p>
<p>eureka-service我们是作为注册中心来用的，所以在它的主类Application中加入<code>@EnableEurekaServer</code>注解，就能开启注册中心功能。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
        System.out.println(&quot;Start Eureka Service&quot;);
    }
}
</code></pre>
<p>但是默认情况下，该注册中心也会把自己当做客户端，那就变成自己注册自己了，这个是可以剔除的，我们看一下它的YAML中的详细配置，注释比较清楚：</p>
<pre><code class="language-yaml">  server:
    port: 1000
  spring:
    application:
      name: eureka-server
  eureka:
    instance:
      hostname: localhost
    client:
    register-with-eureka: false  # 不作为客户端进行注册
    fetch-registry: false  # 不获取注册列表
    service-url:  # 注册地址，客户端需要注册到该地址中
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
</code></pre>
<p>文中的注释还是比较清楚的。 这边可以看到，端口号是1000，所以当工程启动之后，访问 <a href="http://localhost:1000/">http://localhost:1000/</a> 是可以看到Eureka注册中心页面的。其中还没有发现任何服务。</p>
<p><img src="/images/blog/engineering/microservice-image_7_1.png" alt="image_7_1.png"></p>
<h4>2.1.创建客户端 <a href="#scroller-5" id="scroller-5"></a></h4>
<p>目前服务中心还是空的，所以我们创建一个能够提供服务的客户端，并将其注册到注册中心去。</p>
<p>同样的，我们创建一个Spring Cloud的子项目，命名为<code>eureka-client</code>，<code>pom.xml</code>中的配置如下：</p>
<pre><code class="language-xml">  
&lt;xml&gt;
    &lt;!--在子工程中添加父工程名称--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;com.microservice&lt;/groupId&gt;
        &lt;artifactId&gt;center&lt;/artifactId&gt;
        &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/parent&gt;
    &lt;dependencies&gt;
        &lt;!--加入 eureka 服务 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/xml&gt;
</code></pre>
<p>在应用主类Application文件中通过加上<code>@EnableDiscoveryClient</code>注解，该注解保证当前服务被Eureka当成provider发现。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class ClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
        System.out.println(&quot;start client!&quot;);
    }
}jC
</code></pre>
<p>在YAML文件上加上如下配置：</p>
<pre><code class="language-yaml">server:
  port: 1001
spring:
  application:
    name: eureka-client
eureka:
  client:
    service-url:  # 这边就保证了注册到 eureka-service 这个注册中心去
      defaultZone: http://localhost:1000/eureka/
</code></pre>
<p><code>spring.application.name</code>属性，指定了微服务的名称，在调用的时候可以通过该名称进行服务访问。<code>eureka.client.serviceUrl.defaultZone</code>属性对应服务注册中心的配置内容，指定服务注册中心的位置。</p>
<p>大家看到，这边端口设置为1001，那是因为要在本机上测试 服务提供方 和 服务注册中心，所以<code>server的port</code>属性需设置不同的端口。</p>
<p>最后，我们再写一个接口，通过DiscoveryClient对象，在客户端中获取注册中心的所有服务信息。</p>
<pre><code class="language-java">  @Controller
  @RequestMapping(&quot;/eurekacenter&quot;)
  public class EuServiceController {
  
    @Autowired
    DiscoveryClient discoveryClient;
    
    @RequestMapping(value = &quot;/service&quot;, method = {RequestMethod.GET})
    @ResponseBody
    public String getServiceInfo() {
       return  &quot;service:&quot;+discoveryClient.getServices()+&quot; , memo:&quot;+discoveryClient.description();
    }
}
</code></pre>
<p>这时候跑一下试试看，继续访问之前的地址：<a href="http://localhost:1000/">http://localhost:1000/</a> ，可以看到Eureka注册中心页面已经包含一个我们定义的服务了，就是上面新建的 100端口的服务。</p>
<p><img src="/images/blog/engineering/microservice-image_7_2.png" alt="image_7_2.png"></p>
<p>同样，我们可以调用上面的那个获取注册服务信息的接口，从服务发现的角度看看有多少个服务被注册到注册中心去。 <a href="http://localhost:1001/eurekacenter/service">http://localhost:1001/eurekacenter/service</a></p>
<p><img src="/images/blog/engineering/microservice-image_7_3.png" alt="image_7_3.png"></p>
<p>如上图所示，方括号中的<code>eureka-client</code>通过Spring Cloud定义的 getServiceInfo 接口在eureka的实现中获取到的所有服务清单，他是一个String的List，如果注册了多个提供者，就会全部显示。</p>
<h3>2.Spring Cloud Consul <a href="#scroller-6" id="scroller-6"></a></h3>
<p>Consul 用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更具“一站式”特征，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 之类的）。</p>
<p>而Spring Cloud Consul ，是将其作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。</p>
<h4>2.2.Consul 的优势 <a href="#scroller-7" id="scroller-7"></a></h4>
<p>1、使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接。</p>
<p>2、支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持，上面表格中有体现。</p>
<p>3、支持健康检查。</p>
<p>4、支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。</p>
<p>5、官方提供 web 管理界面, etcd 无此功能。</p>
<h4>2.2.Consul的特性 <a href="#scroller-8" id="scroller-8"></a></h4>
<p>1、服务发现</p>
<p>2、健康检查</p>
<p>3、Key/Value存储</p>
<p>4、多数据中心</p>
<h4>2.2.安装Consul注册中心 <a href="#scroller-9" id="scroller-9"></a></h4>
<p>1、官方下载64版本 ：<a href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a></p>
<p>2、解压后复制到目录 /usr/local/bin 下</p>
<p>3、启动终端，先看下啥版本的</p>
<pre><code class="language-sh">liyifei@MacPro ~ % consul --version
Consul v1.10.4
Revision 7bbad6fe
Protocol spoken by default, understands to (agent will automatically use protocol &gt;when speaking to compatible agents)
</code></pre>
<p>4、执行安装命令，可以看到他的 Client Addr 的端口为8500。所以访问 8500端口站点，<a href="http://127.0.0.1:8500/ui/dc1/services">http://127.0.0.1:8500/ui/dc1/services</a></p>
<pre><code class="language-sh">  liyifei@MacPro ~ % consul agent -dev
  ==&gt; Starting Consul agent...
             Version: &#39;1.10.4&#39;
             Node ID: &#39;6db154b4-62ff-e67d-e745-1a7270fa1ce8&#39;
           Node name: &#39;B000000147796DS&#39;
          Datacenter: &#39;dc1&#39; (Segment: &#39;&lt;all&gt;&#39;)
              Server: true (Bootstrap: false)
         Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)
        Cluster Addr: 127.0.0.(LAN: 8301, WAN: 8302)
           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false
</code></pre>
<p><img src="/images/blog/engineering/microservice-image_7_4.png" alt="image_7_4.png"></p>
<p>我们可以看到，现在没有客户端注册上来，只有一个自身的实例。</p>
<h4>2.2.创建服务提供者 <a href="#scroller-10" id="scroller-10"></a></h4>
<p>由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。</p>
<p>我们在micro-service-center下新建一个cloud项目consul-client，该项目pom文件添加如下：</p>
<pre><code class="language-xml">&lt;xml&gt;
  &lt;!--    在子工程中添加父工程名称--&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.microservice&lt;/groupId&gt;
    &lt;artifactId&gt;center&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  
  &lt;dependencies&gt;
    &lt;!--        Consul服务发现--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--        Consul健康检查--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/xml&gt;
</code></pre>
<p>然后修改一下<code>application.yml的配置信息</code>，将consul配置写入，注释应该很清楚了，如下：</p>
<pre><code class="language-yaml">spring:
  application:
    name: consul-producer # 当前服务的名称
  cloud:
    consul: # 以下为Consuk注册中心的地址，如果安装的不是这个host和port，这边可以调整
      host: localhost
      port: 8500
server:
  port: 850# 当前服务的端口
</code></pre>
<p>同样的，我们要在应用主类Application文件中通过加上<code>@EnableDiscoveryClient</code>注解，该注解保证当前服务被Consul当成provider发现。</p>
<p>大家看到这个做法跟Eureka一样，因为Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，</p>
<p>程序上不需要做改变，只需要引入不同的服务治理依赖，并配置相关的配置属性 就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient
public class ConsulClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(ClientApplication.class, args);
    }
}
</code></pre>
<p>修改完成之后，我们就可以把这个服务提供者启动了，然后再去注册中心查看服务的注册情况，就可以看到被注册进来的Provider（consul-producer）：</p>
<p><img src="/images/blog/engineering/microservice-image_7_5.png" alt="image_7_5.png"></p>
<h2>总结 <a href="#scroller-11" id="scroller-11"></a></h2>
<p>除了 Eureka、Consul，还有其他的的注册中心技术，如Zookeeper、Nocas等。但无论何种注册中心技术，本质上都是为了解决微服务中的如下问题：</p>
<p><strong>解耦服务之间相互依赖的细节</strong></p>
<p>我们知道服务之间的远程调用必须要知道对方的IP、端口信息。我们可以在调用方直接配置被调用方的IP、端口，这种调用方直接依赖IP、端口的方式存在明显的问题，如被调用的IP、端口变化后，调用方法也要同步修改。</p>
<p>通过服务发现，将服务之间IP与端口的依赖转化为服务名的依赖，服务名可以根据具微服务业务来做标识，因此，屏蔽、解耦服务之间的依赖细节是服务发现与注册解决的第一个问题。</p>
<p><strong>对微服务进行动态管理</strong></p>
<p>在微服务架构中，服务众多，服务之间的相互依赖也错综复杂，无论是服务主动停止，意外挂掉，还是因为流量增加对服务实现进行扩容，这些服务数据或状态上的动态变化，都需要尽快的通知到被调用方，被调用方才采取相应的措施。因此，对于服务注册与发现要实时管理者服务的数据与状态，包括服务的注册上线、服务主动下线，异常服务的剔除。</p>
17:T5070,<h2>1 微服务的注册与发现 <a href="#scroller-1" id="scroller-1"></a></h2>
<p>我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。</p>
<p>微服务注册与发现类似于生活中的&quot;电话通讯录&quot;的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。</p>
<p>步骤如下：</p>
<p>1、你先要把&quot;好友某某&quot;记录在通讯录中。</p>
<p>2、拨打电话的时候通过通讯录中找到&quot;好友某某&quot;，并拨通回电话。</p>
<p>3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。</p>
<p>从这个过程中我们看到了一些特点：</p>
<p>1、把 &quot;好友某某&quot; 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。</p>
<p>2、后续我们通过&quot;好友某某&quot;就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。</p>
<p>而我们微服务架构中的服务注册与发现结构如下图所示：</p>
<p><img src="/images/blog/engineering/microservice-image_6_1.png" alt="image_6_1.png"></p>
<p>图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：</p>
<p>provider - 服务提供者</p>
<p>consumer - 服务消费者</p>
<p>register center - 注册中心</p>
<p>它们之间的关系大致如下：</p>
<p>1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。</p>
<p>2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。</p>
<p>3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。</p>
<p>优点如下：</p>
<p>1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响</p>
<p>2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响</p>
<p>3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。</p>
<p>从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。</p>
<h3>1.1 服务注册 <a href="#scroller-2" id="scroller-2"></a></h3>
<p>如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。</p>
<p><img src="/images/blog/engineering/microservice-image_6_2.png" alt="image_6_2.png"></p>
<p>服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：</p>
<p>1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。</p>
<p>2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。</p>
<p>3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。</p>
<p>可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。</p>
<p><img src="/images/blog/engineering/microservice-image_6_3.png" alt="image_6_3.png"></p>
<h3>1.2 服务发现 <a href="#scroller-3" id="scroller-3"></a></h3>
<p>服务发现实际就是我们查询已经注册好的服务提供者，比如 p-&gt;p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，</p>
<p>返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。</p>
<p>这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。</p>
<p>服务发现的方式一般有两种：</p>
<p>1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。</p>
<p>2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。</p>
<h3>1.3 注册中心 <a href="#scroller-4" id="scroller-4"></a></h3>
<p>注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。</p>
<p>服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。</p>
<p>主要的检查方式包括：</p>
<p>1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。</p>
<p>2、注册中心主动检查服务Provider接口。</p>
<p>综合我们前面的内容，可以总结下注册中心有如下几种能力：</p>
<p>1、高可用</p>
<p>这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的</p>
<p>2、可视化操作</p>
<p>常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。</p>
<p>3、高效运维</p>
<p>注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。</p>
<p>4、权限控制</p>
<p>数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求</p>
<p>5、服务注册推、拉能力</p>
<p>这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。</p>
<p><img src="/images/blog/engineering/microservice-image_6_4.png" alt="image_6_4.png"></p>
<h2>2 现下的主流注册中心 <a href="#scroller-5" id="scroller-5"></a></h2>
<h3>2.1 Eureka <a href="#scroller-6" id="scroller-6"></a></h3>
<h4>2.1.1 介绍 <a href="#scroller-7" id="scroller-7"></a></h4>
<p>Eureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。</p>
<p>目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 <a href="https://github.com/Netflix/eureka/wiki">Eureka 2.0已经停止维护</a>，所以新的微服务架构设计中，不再建议使用。</p>
<p>Spring Cloud Netflix主要分为两个部分：</p>
<p>1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。</p>
<p>2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。</p>
<p><img src="/images/blog/engineering/microservice-image_6_5.png" alt="image_6_5.png"></p>
<p>Eureka有比较友好的管理界面，如上图所示：</p>
<p>1、System Status：显示当前Eureka Server信息。</p>
<p>2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。</p>
<p>3、General Info：基本信息，如cpu、内存、环境等。</p>
<h4>2.1.2 整体架构 <a href="#scroller-8" id="scroller-8"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_6.png" alt="image_6_6.png"></p>
<p>Eureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。</p>
<p>所以他有如下特点：</p>
<p>1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>
<p>2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。</p>
<p>3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p>
<p>同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。</p>
<p>4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。</p>
<h4>2.1.3 接入Spring Cloud <a href="#scroller-9" id="scroller-9"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_7.png" alt="image_6_7.png"></p>
<p>如上图所示：</p>
<p>1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -&gt; 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。</p>
<p>所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。</p>
<p>2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。</p>
<p>3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。</p>
<h3>2.2 ZooKeeper <a href="#scroller-10" id="scroller-10"></a></h3>
<h4>2.2.1 介绍 <a href="#scroller-11" id="scroller-11"></a></h4>
<p>作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。</p>
<p>这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。</p>
<p><img src="/images/blog/engineering/microservice-image_6_8.png" alt="image_6_8.png"></p>
<p>在数据模型上，类似于传统的文件系统，节点类型分为：</p>
<p>1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。</p>
<p>2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。</p>
<p>在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。</p>
<p><img src="/images/blog/engineering/microservice-image_6_9.png" alt="image_6_9.png"></p>
<p>Zookeeper有如下特点：</p>
<p>1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。</p>
<h4>2.2.2 整体架构 <a href="#scroller-12" id="scroller-12"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_10.png" alt="image_6_10.png"></p>
<p>上图是Zookeeper 的服务架构，他有如下流程：</p>
<p>1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；</p>
<p>2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。</p>
<p>3、Leader负责处理数据更新等操作（Zab协议）；</p>
<h4>2.2.3 接入Dubbo生态 <a href="#scroller-13" id="scroller-13"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_11.png" alt="image_6_11.png"></p>
<p>上图中的角色如下：</p>
<p>Provider：提供者,服务发布方</p>
<p>Consumer：消费者, 调用服务方</p>
<p>Container：Dubbo容器.依赖于Spring容器</p>
<p>Registry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置</p>
<p>Monitor:监听器</p>
<p>说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。</p>
<p>服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。</p>
<p>这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。</p>
<h3>2.3 Consul <a href="#scroller-14" id="scroller-14"></a></h3>
<h4>2.3.1 介绍 <a href="#scroller-15" id="scroller-15"></a></h4>
<p>Consul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：</p>
<p>1、Service Discovery（服务发现）</p>
<p>2、Configuration（配置化）</p>
<p>3、Segmentation Functionality</p>
<p>这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。</p>
<p>Consul提供的关键功能如下：</p>
<p>1、Service Discovery：服务注册/发现功能。</p>
<p>2、Health Checking：健康检查，丰富的健康检查方式；</p>
<p>3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。</p>
<p>4、Multi DataCenter：多数据中心。</p>
<h4>2.3.2 整体架构 <a href="#scroller-16" id="scroller-16"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_6_12.png" alt="image_6_12.png"></p>
<p>如上图为Consul的架构，这边对技术点做一下说明：</p>
<p>1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式</p>
<p>2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。</p>
<p>3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。</p>
<p>4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。</p>
<p>5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。</p>
<p>6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。</p>
<p>7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。</p>
<p>8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。</p>
<p>9、RPC: 远程过程调用，用于服务之间的通信。</p>
<p>10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。</p>
<p>所以是典型的CP模式。</p>
<p><img src="/images/blog/engineering/microservice-image_6_13.png" alt="image_6_13.png"></p>
<p>根据Consul 的选举机制和服务原理，我们有两个注意点 ：</p>
<p>1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。</p>
<p>2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。</p>
<p>有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。</p>
<h4>2.3.3 生态对接 <a href="#scroller-17" id="scroller-17"></a></h4>
<p><strong>对接Spring Cloud生态</strong></p>
<p><img src="/images/blog/engineering/microservice-image_6_14.png" alt="image_6_14.png"></p>
<p>Consul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。</p>
<p>但是这边的健康检查更丰富，可以有多种不同的的Check方式：</p>
<ul>
<li>Script check（Script+ Interval）</li>
<li>基于HTTP请求</li>
<li>基于tcp请求</li>
<li>基于grpc请求</li>
</ul>
<h3>2.4 总结对比 <a href="#scroller-19" id="scroller-19"></a></h3>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>Eureka</strong></th>
<th><strong>Zookeeper</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Etcd</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一致性协议</td>
<td>AP</td>
<td>CP（Paxos算法）</td>
<td>CP（Raft算法）</td>
<td>CP（Raft算法）</td>
</tr>
<tr>
<td>健康检查</td>
<td>TTL(Time To Live)</td>
<td>TCP Keep Alive</td>
<td>TTL\HTTP\TCP\Script</td>
<td>Lease TTL KeepAlive</td>
</tr>
<tr>
<td>watch/long polling</td>
<td>不支持</td>
<td>watch</td>
<td>long polling</td>
<td>watch</td>
</tr>
<tr>
<td>雪崩保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>安全与权限</td>
<td>不支持</td>
<td>ACL</td>
<td>ACL</td>
<td>RBAC</td>
</tr>
<tr>
<td>是否支持多数据中心</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有管理界面</td>
<td>是</td>
<td>否（可用第三方ZkTools）</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Spring Cloud 集成</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Dubbo 集成</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>K8S 集成</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。</p>
<p>当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。</p>
<p>如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。</p>
18:T2b20,<p><a href="https://baijiahao.baidu.com/s?id=1769207484615537227">转载</a></p>
<h4>引言</h4>
<h4>1、队列应用场景：</h4>
<p>MQ（Message Queue，消息队列）<br><strong>消息队列在实际应用中常用的使用场景（优点）</strong>：<code>异步处理</code>，<code>应用解耦</code>，<code>流量削锋</code>和<code>消息通讯</code>四个场景。</p>
<h4>2、目前使用较多的消息队列：</h4>
<p>有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ。</p>
<h4>3、如何选型（目前现状）：</h4>
<p>ActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。最早大家都用 ActiveMQ，但是现在确实大家用的不多了，社区也不是很活跃，不推荐用这个了；</p>
<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，可视化的管理界面比较友好；</p>
<p>不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），它是纯Java开发，它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则老老实实用 RabbitMQ 吧，毕竟RabbitMQ有活跃的开源社区，绝对不会黄。</p>
<p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>
<p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，适合产生大量数据的互联网服务的数据收集业务等。社区活跃度很高，何况几乎是全世界这个领域的事实性规范。kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。</p>
<h4>4、使用消息队列缺点：</h4>
<ul>
<li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，整套系统崩溃了。</li>
<li>系统复杂性提高：加MQ进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li>
<li>一致性问题：A系统处理完了直接返回成功了，后面的如果失败了，这数据就不一致了。</li>
</ul>
<h4>一、RabbitMQ</h4>
<h4>1、RabbitMQ概述</h4>
<p><code>AMQP</code>，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层<strong>标准高级消息队列协议</strong>，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
<p><code>RabbitMQ</code>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。</p>
<p>RabbitMQ 是比较有代表性的，因为是<code>基于主从（非分布式）做高可用性</code>的。</p>
<h4>2、RabbitMQ原理图</h4>
<p>RabbitMQ通过<code>信道</code>的方式传输数据，将消息发布到交换机上，消息拥有一个路邮键，由消息创建时设定，通过队列路由键，可以把队列绑定到交换机上，消息到达交换机后，RabbitMQ将消息的路由键与队列的路由键进行匹配（不同的交换机有不同的路由规则），匹配到相应的队列，消息投递到队列的队列中供消费者消费。</p>
<blockquote>
<p>多个消费者可以订阅同一个Queue，消息将以<code>循环（round-robin）</code>的方式发送给消费者，每条消息只会发给一个订阅的消费者，而不是每个消费者都收到所有的消息并处理。</p>
</blockquote>
<blockquote>
<p>每个Channel运行在独立的线程上，多个线程共享同一个socket。</p>
</blockquote>
<p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/dfde605794cc90a31ce1223c54218372.jpeg@c_1,w_901,h_315,x_0,y_0" alt=""><br><strong>相关概念：</strong></p>
<ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；</li>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li>Channel（信道）：消息推送使用的通道；</li>
<li>Exchange（交换器）：用于接受、分配消息；</li>
<li>Queue（队列）：用于存储生产者的消息；</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；【最大255个字节】</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上；【最大255个字节】</li>
<li>vhost（虚拟主机）每个Rabbit都能创建很多vhost，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。</li>
</ul>
<h4>3、RabbitMQ常用的三种交换机</h4>
<p><strong>RabbitMQ常用的三种Exchange</strong>：fanout,direct,topic</p>
<h4>（1）Direct Exchange ：</h4>
<p>直连型交换机，根据消息携带的路由键将消息投递给对应队列。<br>　　大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key。　然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。</p>
<h4>（2）Fanout Exchange：</h4>
<p>扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。</p>
<h4>（3）Topic Exchange：</h4>
<p>主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。<br>　　<br><strong>性能排序</strong>：fanout &gt; direct &gt;&gt; topic。</p>
<h4>4、 RabbitMQ集群元数据</h4>
<p>RabbitMQ集群会始终同步四种类型的内部元数据：</p>
<ul>
<li>a. 队列元数据：队列名称和它的属性</li>
<li>b. 交换器元数据：交换器名称、类型和属性</li>
<li>c. 绑定元数据：一张简单的表格展示了如何将消息路由到队列</li>
<li>d. vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性</li>
</ul>
<h4>5、RabbitMQ镜像集群</h4>
<p><strong>RabbitMQ 有三种模式</strong>：单机模式、普通集群模式（无高可用性）、<code>镜像集群模式</code>（高可用性）。</p>
<p><code>镜像队列</code>将需要消费的队列变成镜像队列，存在于多个节点，实现RabbitMQ的高可用，保证 100% 数据不丢失。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在消费者消费数据时临时拉取，缺点就是集群内部的<code>同步通讯</code>会占去大量的网络带宽。<br><img src="https://pic.rmb.bdstatic.com/bjh/beautify/53a92fdedade9355420e866bbdb51be1.jpeg@c_1,w_613,h_390,x_0,y_0" alt=""></p>
<h4>二、RocketMQ</h4>
<p><code>RocketMQ</code>是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目。用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p>
<p><strong>RocketMQ缺点：</strong></p>
<ul>
<li>单机支持1万以上持久化队列；</li>
<li>RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。</li>
<li>模型简单，接口易用（JMS的接口很多场合并不太实用）；</li>
<li>性能非常好，可以允许大量堆积消息在Broker中；</li>
<li>支持多种消费模式，包括集群消费、广播消费等；</li>
<li>各个环节分布式扩展设计，支持主从和高可用；</li>
<li>开发度较活跃，版本更新很快。</li>
</ul>
<p><strong>RocketMQ缺点：</strong></p>
<ul>
<li>支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟</li>
<li>维护RocketMQ需要专业的团队</li>
<li>商业版收费，有许多功能是不对外提供的。</li>
<li>没有在MQ核心里实现JMS等接口</li>
</ul>
<h4>三、kafka</h4>
<h4>1、kafka概述</h4>
<p><code>kafka</code>是Linkedin于2010年12月份开源的<code>消息发布订阅</code>系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。作为hadoop生态系统的一部分，被各种商业公司广泛应用。</p>
<p><strong>kafka优点：</strong></p>
<ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<p><strong>kafka缺点：</strong></p>
<ul>
<li>快速持久化：可以在O(1)的系统开销下进行消息持久化；</li>
<li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li>
<li>完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；</li>
<li>支持同步和异步复制两种高可用机制；</li>
<li>支持数据批量发送和拉取；</li>
<li>零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；</li>
<li>数据迁移、扩容对用户透明；</li>
<li>无需停机即可扩展机器；</li>
<li>其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制</li>
</ul>
<h4>2、kafka原理图</h4>
<p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/3d90e1705de49c669f22628af2f6004a.jpeg@c_1,w_1010,h_651,x_0,y_0" alt=""><br><img src="https://pic.rmb.bdstatic.com/bjh/beautify/a5531d658050ce7abecb5ad4242d92ab.jpeg@c_1,w_1002,h_300,x_0,y_0" alt=""></p>
<h4>四、总结</h4>
<p><img src="/images/blog/engineering/middleware-img_20250723_04.png" alt="img_20250723_04.png">{: .full-width}</p>
19:T5c64,<blockquote>
<p>微服务架构已经成为互联网后端系统的主流架构范式。然而，从单体架构迁移到微服务，绝不仅仅是把代码拆成几个服务那么简单——它涉及服务如何注册与发现、如何通信与容错、如何部署与监控等一系列基础设施问题。本文从架构设计的核心关注点出发，结合业界最佳实践，系统性地梳理微服务架构落地所需的技术体系。</p>
</blockquote>
<h2>微服务架构概览</h2>
<h3>什么是微服务架构？</h3>
<p>与单体（Monolithic）架构不同，微服务架构是由一系列<strong>职责单一的细粒度服务</strong>构成的分布式网状结构，服务之间通过轻量级机制进行通信。这种架构带来了独立部署、技术异构、弹性伸缩等优势，但同时也引入了一系列新的技术挑战。</p>
<h3>核心技术关注点</h3>
<p>一个完整的微服务架构需要关注以下层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>关注点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信</strong></td>
<td>服务注册与发现、负载均衡、RPC 框架、API 网关</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>服务容错（熔断、隔离、限流、降级）</td>
</tr>
<tr>
<td><strong>基础设施</strong></td>
<td>配置中心、缓存、消息队列、数据库</td>
</tr>
<tr>
<td><strong>交付</strong></td>
<td>CI/CD 流水线、自动化测试、灰度发布</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>日志系统、监控告警、链路追踪</td>
</tr>
<tr>
<td><strong>部署</strong></td>
<td>负载均衡、DNS、CDN</td>
</tr>
</tbody></table>
<p>接下来，我们逐一展开讨论。</p>
<h2>服务注册、发现与负载均衡</h2>
<p>微服务架构下，服务提供方需要注册通告服务地址，服务调用方需要发现目标服务，同时服务提供方一般以集群方式提供服务，这就引入了负载均衡和健康检查问题。</p>
<p>根据负载均衡器（LB）所在位置的不同，目前主要有三种方案：</p>
<h3>方案一：集中式 LB</h3>
<p>在服务消费者和服务提供者之间设置独立的 LB（如 F5 硬件或 LVS/HAProxy 软件），LB 上有所有服务的地址映射表，由运维配置注册。服务消费方通过 DNS 域名指向 LB。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>实现简单，当前业界主流</td>
<td>单点问题，LB 容易成为瓶颈</td>
</tr>
<tr>
<td>易于做集中式访问控制</td>
<td>增加一跳（hop），有性能开销</td>
</tr>
<tr>
<td></td>
<td>一旦 LB 故障，影响是灾难性的</td>
</tr>
</tbody></table>
<h3>方案二：进程内 LB（客户端负载）</h3>
<p>将 LB 功能以库的形式集成到服务消费方进程内，也称为<strong>软负载（Soft Load Balancing）</strong>。需要配合服务注册表（Service Registry）支持服务自注册和自发现。</p>
<p>工作原理：</p>
<ol>
<li>服务提供方启动时，将地址注册到服务注册表，并定期发送心跳</li>
<li>服务消费方通过内置 LB 组件查询注册表，缓存并定期刷新目标地址列表</li>
<li>以某种负载均衡策略选择目标地址，直接发起请求</li>
</ol>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分布式方案，无单点问题</td>
<td>多语言栈需开发多种客户端库</td>
</tr>
<tr>
<td>服务间直接调用，性能好</td>
<td>客户端库升级需服务方重新发布</td>
</tr>
</tbody></table>
<p>典型案例：Netflix OSS（Eureka + Ribbon + Karyon）、阿里 Dubbo。</p>
<h3>方案三：主机独立 LB 进程（Sidecar 模式）</h3>
<p>将 LB 和服务发现功能从进程内移出，变成主机上的独立进程。同一主机上的多个服务共享该 LB 进程完成服务发现和负载均衡。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>无单点，一个 LB 挂只影响该主机</td>
<td>部署较复杂，环节多</td>
</tr>
<tr>
<td>不需要为不同语言开发客户端库</td>
<td>出错调试排查不方便</td>
</tr>
<tr>
<td>LB 升级不需要服务方改代码</td>
<td></td>
</tr>
</tbody></table>
<p>典型案例：Airbnb SmartStack（Zookeeper + Nerve + Synapse/HAProxy）、Kubernetes 内部服务发现。</p>
<blockquote>
<p>三种方案各有取舍，选择时需要综合考虑团队技术栈的多样性、运维能力和性能要求。当前趋势是方案三（Sidecar 模式）逐渐演化为 Service Mesh（服务网格），如 Istio + Envoy。</p>
</blockquote>
<h2>API 网关（Service Gateway）</h2>
<p>微服务最终需要以某种方式暴露给外部系统访问，这就需要<strong>服务网关</strong>。网关是连接企业内部和外部系统的一道门，承担以下关键职责：</p>
<table>
<thead>
<tr>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>反向路由</strong></td>
<td>将外部请求路由到内部具体的微服务，对外呈现统一入口</td>
</tr>
<tr>
<td><strong>安全认证</strong></td>
<td>集中处理用户认证、授权和防爬虫</td>
</tr>
<tr>
<td><strong>限流容错</strong></td>
<td>流量高峰期限流保护后台，内部故障时集中容错</td>
</tr>
<tr>
<td><strong>监控</strong></td>
<td>集中监控访问量、调用延迟、错误计数</td>
</tr>
<tr>
<td><strong>日志</strong></td>
<td>收集所有访问日志，为后续分析提供数据</td>
</tr>
</tbody></table>
<p>除此之外，网关还可以实现<strong>线上引流、线上压测、金丝雀发布（Canary Testing）、数据中心双活</strong>等高级功能。</p>
<h3>微服务的分层架构</h3>
<p>引入网关和服务注册表之后，微服务可以简化为两层结构：</p>
<ul>
<li><strong>后端通用服务（Middle Tier Service）</strong>：启动时注册地址到注册表</li>
<li><strong>前端边缘服务（Edge Service）</strong>：查询注册表发现后端服务，对后端服务做聚合和裁剪后暴露给外部设备</li>
</ul>
<p>网关通过查询注册表将外部请求路由到前端服务，整个微服务体系的自注册、自发现和软路由就此串联起来。如果用设计模式的视角看——<strong>网关类似 Proxy/Facade 模式，服务注册表类似 IoC 依赖注入模式</strong>。</p>
<p>常见的网关组件：Netflix Zuul、Kong、APISIX、Spring Cloud Gateway。</p>
<h2>服务容错</h2>
<p>当企业微服务化后，服务之间存在错综复杂的依赖关系。一个前端请求一般依赖多个后端服务（1→N 扇出）。在生产环境中，如果一个应用不能对其依赖的故障进行容错和隔离，就面临被拖垮的风险。在高流量场景下，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源（线程、队列等）被耗尽，造成<strong>雪崩效应（Cascading Failure）</strong>。</p>
<p>业界总结出以下核心容错模式：</p>
<h3>熔断器模式（Circuit Breaker）</h3>
<p>原理类似家用电路熔断器。当目标服务慢或大量超时时，调用方主动熔断，防止服务被进一步拖垮。</p>
<p>熔断器有三种状态：</p>
<pre><code>Closed（正常）→ Open（熔断）→ Half-Open（半熔断）→ Closed/Open
</code></pre>
<ul>
<li><strong>Closed</strong>：正常状态，请求正常通过</li>
<li><strong>Open</strong>：调用持续出错或超时，进入熔断状态，后续请求直接拒绝（Fail Fast）</li>
<li><strong>Half-Open</strong>：一段时间后允许少量请求尝试，成功则恢复，失败则继续熔断</li>
</ul>
<h3>舱壁隔离模式（Bulkhead Isolation）</h3>
<p>像船舱一样对资源进行隔离。典型实现是<strong>线程隔离</strong>：假定应用 A 调用 Svc1/Svc2/Svc3 三个服务，容器共有 120 个工作线程，可以给每个服务各分配 40 个线程。当 Svc2 变慢时，只有分配给 Svc2 的 40 个线程被耗尽，Svc1 和 Svc3 的 80 个线程不受影响。</p>
<h3>限流（Rate Limiting）</h3>
<p>对服务限定并发访问量，比如单位时间只允许 100 个并发调用，超过限制的请求拒绝并回退。没有限流机制的服务在突发流量（秒杀、大促）时极易被冲垮。</p>
<h3>降级回退（Fallback）</h3>
<p>当熔断或限流发生时的后续处理策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Fail Fast</td>
<td>直接抛出异常</td>
</tr>
<tr>
<td>返回缺省值</td>
<td>返回空值或默认数据</td>
</tr>
<tr>
<td>备份服务</td>
<td>从备份数据源获取数据</td>
</tr>
</tbody></table>
<blockquote>
<p>Netflix 将上述容错模式集成到 Hystrix 开源组件中（现已进入维护模式，社区推荐 Resilience4j 或 Sentinel 作为替代）。Spring Cloud Circuit Breaker 提供了统一的抽象层。</p>
</blockquote>
<h2>服务框架的核心能力</h2>
<p>微服务化后，为了让业务开发人员专注于业务逻辑，避免冗余和重复劳动，需要将公共关注点推到框架层面。一个成熟的服务框架应当封装以下能力：</p>
<table>
<thead>
<tr>
<th>能力</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册发现</td>
<td>服务端自注册，客户端自发现和负载均衡</td>
</tr>
<tr>
<td>监控日志</td>
<td>框架层日志、Metrics、调用链数据的记录和暴露</td>
</tr>
<tr>
<td>REST/RPC 与序列化</td>
<td>支持 HTTP/REST 和 Binary/RPC，可定制序列化（JSON/Protobuf 等）</td>
</tr>
<tr>
<td>动态配置</td>
<td>运行时动态调整参数和配置</td>
</tr>
<tr>
<td>限流容错</td>
<td>集成限流和熔断组件，结合动态配置实现动态限流</td>
</tr>
<tr>
<td>管理接口</td>
<td>在线查看和动态调整框架及服务内部状态（如 Spring Boot Actuator）</td>
</tr>
<tr>
<td>统一错误处理</td>
<td>框架层统一处理异常并记录日志</td>
</tr>
<tr>
<td>安全</td>
<td>访问控制逻辑的插件化封装</td>
</tr>
<tr>
<td>文档自动生成</td>
<td>如 Swagger/OpenAPI 的自动化文档方案</td>
</tr>
</tbody></table>
<p>当前业界成熟的微服务框架有：Spring Cloud/Spring Boot、Apache Dubbo、Go-Micro、gRPC 等。</p>
<h2>基础设施选型</h2>
<h3>RPC 框架选型</h3>
<p>RPC（Remote Procedure Call）框架大致分为两大流派：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表框架</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>跨语言调用型</strong></td>
<td>gRPC、Thrift、Hprose</td>
<td>支持多语言调用，无服务治理机制</td>
<td>多语言调用场景</td>
</tr>
<tr>
<td><strong>服务治理型</strong></td>
<td>Dubbo、Motan、rpcx</td>
<td>功能丰富，含服务发现和治理能力</td>
<td>大型服务的解耦和治理</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：如果是 Java 为主的团队，推荐 <strong>Dubbo</strong>（高性能，性能测试中比 Feign 强约 10 倍）。如果需要跨语言支持，Dubbo 也支持通过 Dubbo-Go 实现 Java + Go 双语言微服务架构。如果是纯粹的跨语言场景，<strong>gRPC</strong> 基于 HTTP/2 + Protobuf，是业界标准选择。</p>
<h3>注册中心选型</h3>
<p>所有的服务发现都依赖于一个高可用的服务注册表。主流选择：</p>
<table>
<thead>
<tr>
<th>注册中心</th>
<th>特点</th>
<th>一致性模型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nacos</strong></td>
<td>同时支持注册中心和配置中心，功能全面</td>
<td>AP/CP 可切换</td>
</tr>
<tr>
<td><strong>ZooKeeper</strong></td>
<td>最早的分布式协调服务，生态成熟</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Etcd</strong></td>
<td>Kubernetes 默认存储，高可用和一致性</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Consul</strong></td>
<td>支持多数据中心，内置健康检查</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Eureka</strong></td>
<td>Netflix 开源，AP 模型，已停止维护</td>
<td>AP</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：推荐 <strong>Nacos</strong>（nacos + MySQL 高可用部署），一站式解决注册中心和配置中心的需求。</p>
<h3>配置中心选型</h3>
<p>随着系统复杂度增长，配置管理面临越来越高的要求：配置修改实时生效、灰度发布、分环境/分集群管理、完善的权限审核机制。传统的配置文件方式已经无法满足需求。</p>
<p>配置中心的核心架构组件：</p>
<ul>
<li><strong>配置服务端</strong>：集中存储和管理所有配置信息</li>
<li><strong>配置客户端</strong>：通过<strong>定期拉取（Pull）</strong> 或 <strong>服务端推送（Push）</strong> 方式获取配置更新</li>
<li><strong>管理界面</strong>：配置的增删改查和审计</li>
</ul>
<table>
<thead>
<tr>
<th>配置中心</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nacos</strong></td>
<td>阿里开源，同时支持注册和配置，生态活跃</td>
</tr>
<tr>
<td><strong>Apollo</strong></td>
<td>携程开源，功能完善，支持灰度发布和权限管理</td>
</tr>
<tr>
<td><strong>Spring Cloud Config</strong></td>
<td>Spring 生态原生支持，基于 Git 存储</td>
</tr>
</tbody></table>
<h3>缓存中间件选型</h3>
<table>
<thead>
<tr>
<th>缓存</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Redis</strong></td>
<td>多数据结构，支持持久化和集群</td>
<td>通用缓存、分布式锁、排行榜等</td>
</tr>
<tr>
<td><strong>Memcached</strong></td>
<td>纯内存 KV，简单高效</td>
<td>简单的对象缓存</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：推荐 <strong>Redis Cluster</strong> 高可用集群部署。</p>
<blockquote>
<p>需要特别关注 Redis 的 Big Key 问题。在高并发场景下，Big Key 会导致单个节点内存和网络带宽瓶颈，严重时可造成系统瘫痪。建议制定 Key 规范并定期扫描。</p>
</blockquote>
<h3>消息中间件选型</h3>
<p>消息中间件的三大核心场景：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
<th>典型案例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步处理</strong></td>
<td>减少主流程等待时间，非核心逻辑异步执行</td>
<td>注册后发送邮件、异步更新缓存</td>
</tr>
<tr>
<td><strong>系统解耦</strong></td>
<td>上下游系统通过消息通信，不需要强一致</td>
<td>支付成功后通知 ERP/WMS/推荐等系统</td>
</tr>
<tr>
<td><strong>削峰填谷</strong></td>
<td>大流量请求放入队列，消费者按能力消化</td>
<td>秒杀系统的下单排队</td>
</tr>
</tbody></table>
<p>主流消息中间件对比：</p>
<table>
<thead>
<tr>
<th>中间件</th>
<th>吞吐量</th>
<th>延迟</th>
<th>可靠性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Kafka</strong></td>
<td>极高</td>
<td>毫秒级</td>
<td>高（可配置）</td>
<td>日志收集、大数据流处理、事件溯源</td>
</tr>
<tr>
<td><strong>RocketMQ</strong></td>
<td>高</td>
<td>毫秒级</td>
<td>极高（事务消息）</td>
<td>电商交易、金融场景</td>
</tr>
<tr>
<td><strong>RabbitMQ</strong></td>
<td>中等</td>
<td>微秒级</td>
<td>高</td>
<td>实时性要求高、路由复杂的场景</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：<strong>Kafka</strong> 用于日志采集和大数据场景，<strong>RocketMQ</strong> 用于业务消息和交易场景，二者搭配使用。</p>
<h3>数据库选型</h3>
<h4>关系型数据库</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>代表</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>传统 RDBMS</strong></td>
<td>MySQL、PostgreSQL</td>
<td>成熟稳定，生态丰富，百万级 PV 搭配主从 + 缓存可满足</td>
</tr>
<tr>
<td><strong>NewSQL</strong></td>
<td>TiDB、CockroachDB</td>
<td>完整 SQL 支持 + ACID 事务 + 弹性伸缩 + 高可用 + 大数据分析能力</td>
</tr>
</tbody></table>
<p>当 MySQL 需要分库分表且逻辑复杂度高、扩展性不足时，可以考虑 TiDB。</p>
<h4>NoSQL 数据库</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>键值型</strong></td>
<td>Redis、Memcache</td>
<td>缓存、会话管理</td>
</tr>
<tr>
<td><strong>列式</strong></td>
<td>HBase、Cassandra</td>
<td>写多读少、时序数据</td>
</tr>
<tr>
<td><strong>文档型</strong></td>
<td>MongoDB、CouchDB</td>
<td>非结构化数据、灵活 Schema</td>
</tr>
<tr>
<td><strong>图数据库</strong></td>
<td>Neo4J</td>
<td>社交网络、推荐系统</td>
</tr>
</tbody></table>
<h2>CI/CD 流水线</h2>
<p>从代码到最终服务用户，可以分为三个阶段：</p>
<pre><code>Code → Artifact（制品库）→ Running Service → Production
</code></pre>
<ol>
<li><strong>代码到制品</strong>：持续构建，制品集中管理</li>
<li><strong>制品到服务</strong>：部署到指定环境</li>
<li><strong>开发到生产</strong>：变更在不同环境间的迁移和灰度发布</li>
</ol>
<h3>工具链推荐</h3>
<table>
<thead>
<tr>
<th>环节</th>
<th>推荐工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码管理</strong></td>
<td>GitLab</td>
<td>社区版功能丰富，结合 Gerrit 做 Code Review</td>
</tr>
<tr>
<td><strong>持续集成</strong></td>
<td>Jenkins / GitLab CI</td>
<td>Jenkins 插件生态强大；GitLab CI 与 GitLab 深度集成</td>
</tr>
<tr>
<td><strong>制品仓库</strong></td>
<td>Harbor</td>
<td>开源的 Docker 镜像仓库，支持镜像签名和漏洞扫描</td>
</tr>
<tr>
<td><strong>部署编排</strong></td>
<td>Kubernetes</td>
<td>容器编排的事实标准，支持声明式部署和自动伸缩</td>
</tr>
<tr>
<td><strong>项目管理</strong></td>
<td>Jira + Confluence</td>
<td>项目管理、任务跟踪和知识管理的行业标配</td>
</tr>
</tbody></table>
<p><strong>初期建议</strong>：Jenkins + GitLab + Harbor 的组合，可以覆盖制品管理、发布流程、权限控制、版本变更和服务回滚。</p>
<h3>自动化测试</h3>
<p>自动化测试平台是 CI/CD 流水线的重要一环：</p>
<ul>
<li><strong>单元测试</strong>：JUnit / TestNG，覆盖核心业务逻辑</li>
<li><strong>接口测试</strong>：可基于开源框架（如 SpringBoot + TestNG）搭建</li>
<li><strong>性能测试</strong>：JMeter / Gatling</li>
<li><strong>端到端测试</strong>：Selenium / Cypress</li>
</ul>
<h2>可观测性体系</h2>
<h3>日志系统</h3>
<p>日志系统涵盖日志打印、采集、中转、存储、分析、搜索和分发。日志系统的建设不仅是工具建设，还包括规范和组件建设——基本的日志（如全链路追踪 ID）应在框架和组件层面统一注入。</p>
<p><strong>常规方案：ELK Stack</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Filebeat</strong></td>
<td>轻量级日志采集器，替代 Logstash-Forwarder</td>
</tr>
<tr>
<td><strong>Logstash</strong></td>
<td>日志收集、过滤和转换</td>
</tr>
<tr>
<td><strong>Elasticsearch</strong></td>
<td>分布式搜索引擎，存储和索引日志</td>
</tr>
<tr>
<td><strong>Kibana</strong></td>
<td>可视化界面，日志搜索和分析</td>
</tr>
</tbody></table>
<blockquote>
<p>免费版 ELK 没有安全机制，建议前置 Nginx 做反向代理和简单用户认证。</p>
</blockquote>
<p><strong>实时计算方案</strong>：对于需要实时分析的场景，可以采用 Flume + Kafka + Flink（或 Storm）的架构。Kafka 负责高吞吐的消息缓冲，Flume 负责多样化的数据采集，Flink 负责实时流计算。</p>
<h3>监控系统</h3>
<p>监控系统主要覆盖两个层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>监控指标</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础设施</strong></td>
<td>机器负载、IO、网络流量、CPU、内存</td>
</tr>
<tr>
<td><strong>服务质量</strong></td>
<td>可用性、成功率、失败率、QPS、延迟</td>
</tr>
</tbody></table>
<p><strong>推荐方案：Prometheus + Grafana</strong></p>
<p>Prometheus 是 Google BorgMon 的开源版本，使用 Go 开发，采用 <strong>Pull</strong> 模式主动拉取指标数据。其核心组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Prometheus Server</strong></td>
<td>数据采集和存储，提供 PromQL 查询</td>
</tr>
<tr>
<td><strong>Exporter</strong></td>
<td>各类数据采集组件（数据库、硬件、MQ、HTTP 服务器等）</td>
</tr>
<tr>
<td><strong>Push Gateway</strong></td>
<td>支持短生命周期 Job 主动推送指标</td>
</tr>
<tr>
<td><strong>Alertmanager</strong></td>
<td>灵活的报警规则和通知管理</td>
</tr>
<tr>
<td><strong>Grafana</strong></td>
<td>高度定制化的可视化监控面板</td>
</tr>
</tbody></table>
<p>Prometheus + Grafana 搭配统一的服务框架，可以满足绝大部分中小团队的监控需求。</p>
<h2>生产环境部署架构</h2>
<h3>DNS</h3>
<p>DNS 是基础服务，一般直接选择云厂商：</p>
<ul>
<li><strong>国内</strong>：阿里云 DNS 或腾讯 DNSPod，线上产品建议使用付费版</li>
<li><strong>海外</strong>：优先选择 AWS Route 53</li>
<li><strong>国内外互通</strong>：建议在 APP 层实现容灾逻辑或智能调度，因为没有单一 DNS 服务能同时很好地覆盖国内外</li>
</ul>
<h3>负载均衡（LB）</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>云服务环境</td>
<td>直接使用云厂商 LB（阿里云 SLB / 腾讯云 CLB / AWS ELB）</td>
</tr>
<tr>
<td>自建机房</td>
<td>LVS（四层）+ Nginx（七层）</td>
</tr>
</tbody></table>
<p>云厂商 LB 通常支持四层（TCP/UDP）和七层（HTTP/HTTPS）协议、集中化证书管理和健康检查。</p>
<h3>CDN</h3>
<p>CDN 的选型主要看业务覆盖区域：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td>国内</td>
<td>阿里云 CDN、腾讯云 CDN</td>
</tr>
<tr>
<td>海外</td>
<td>AWS CloudFront、Akamai</td>
</tr>
</tbody></table>
<h2>总结</h2>
<p>微服务架构的落地是一个系统工程，核心技术关注点可以归纳为以下几个层面：</p>
<ol>
<li><strong>服务通信</strong>：通过注册中心 + 负载均衡 + API 网关，构建服务间和内外部的通信体系</li>
<li><strong>服务可靠性</strong>：通过熔断、隔离、限流和降级四大模式，保障系统在故障和高峰期的稳定性</li>
<li><strong>服务框架</strong>：将公共关注点下沉到框架层，让业务开发专注于业务逻辑</li>
<li><strong>基础设施</strong>：根据业务需求和团队技术栈，选择合适的 RPC、注册中心、缓存、消息队列和数据库</li>
<li><strong>持续交付</strong>：通过 CI/CD 流水线实现代码到生产环境的自动化、可重复的发布流程</li>
<li><strong>可观测性</strong>：通过日志、监控和链路追踪构建系统的透明度，为问题排查和性能优化提供数据支撑</li>
</ol>
<p>好的架构不是设计出来的，而是演进出来的。架构师需要在不同阶段做出合适的判断——既不过度设计，也不欠缺考虑。关键是保持对技术的敏锐度，在实践中不断验证和调整。</p>
<blockquote>
<p>路漫漫其修远兮，架构求索无止尽也。</p>
</blockquote>
1a:T79b2,<h2>原则不是教条</h2>
<p>几年前带一个校招生，他技术功底不错，学习能力也强，入职没多久就把《重构》和《代码整洁之道》翻了个遍。然后事情开始变得有趣起来。</p>
<p>他接手了一段业务代码，发现订单创建和退款创建里有一段相似的参数校验逻辑。他本能地觉得这违反了 DRY 原则，于是花了两天时间把这段逻辑抽成了一个通用的 <code>ValidationEngine</code>，支持规则配置、支持链式校验、支持自定义错误码映射。代码从 20 行变成了 200 行，引入了三个新类和一个配置文件。</p>
<p>上线后第二周，产品说退款的金额上限要从 10 万调到 50 万，但订单的不变。改这个需求本来只需要改一个数字，结果因为共用了 <code>ValidationEngine</code>，他不得不在通用逻辑里加了一个 <code>if-else</code> 分支来区分场景。再过两周，订单校验需要新增一个风控维度，退款不需要。通用引擎再加一个条件分支。三个月后，这个&quot;消除重复&quot;的引擎变成了一个没人敢碰的怪物。</p>
<p><strong>这不是 DRY 原则的问题，而是对 DRY 原则的机械理解。</strong> 他看到了代码的重复，却没有看到两段代码背后代表的是两种不同的业务知识——它们今天碰巧相同，但明天一定会分道扬镳。</p>
<p>从那之后我经常跟团队说一句话：编程原则是路标，不是法律。路标告诉你大致方向，但前面是山路还是平路、要不要绕行、能不能抄近道，你得自己判断。更重要的是，这些原则之间经常互相矛盾——DRY 和 KISS 会打架，YAGNI 和开闭原则会冲突，单一职责拆到极致反而会让系统变得更难理解。<strong>真正的功力不在于背诵原则，而在于知道什么时候该用哪一条、什么时候该故意违反哪一条。</strong></p>
<p>下面我按照主题把常见的编程原则分成几组，聊聊它们在真实工程中的样子。</p>
<h2>做减法的原则：KISS、YAGNI 与做最简单能工作的事</h2>
<p>这三条原则的精神内核是一致的：<strong>克制</strong>。在一个鼓励&quot;多做&quot;的工程文化里，&quot;少做&quot;反而是最难的事。</p>
<h3>KISS：简单不是简陋</h3>
<p>KISS（Keep It Simple, Stupid）大概是最容易被误解的原则之一。很多人把&quot;简单&quot;等同于&quot;简陋&quot;或&quot;偷懒&quot;，觉得不用设计模式、不做分层就是 KISS。但恰恰相反，<strong>真正的简单是深思熟虑后的结果，不是偷工减料。</strong> 简单意味着更少的活动部件、更少的状态、更少的分支路径。做到这一点通常比做一个复杂方案更难。</p>
<p>一个真实的例子。我在某个项目里见过一个&quot;特性开关&quot;系统，它的设计是这样的：</p>
<pre><code class="language-java">// 过度设计的特性开关
public class FeatureToggleEngine {
    private PluginRegistry pluginRegistry;
    private RuleEvaluator ruleEvaluator;
    private ConfigurationProvider configProvider;
    private FeatureToggleCache cache;

    public boolean isEnabled(String feature, UserContext ctx) {
        Rule rule = configProvider.loadRule(feature);
        List&lt;Plugin&gt; plugins = pluginRegistry.getPlugins(feature);
        EvaluationContext evalCtx = buildContext(ctx, plugins);
        return ruleEvaluator.evaluate(rule, evalCtx);
    }
}
</code></pre>
<p>这套东西支持插件式规则引擎、支持动态加载、支持用户维度的灰度。听起来很专业，但实际上整个系统一共只有 6 个特性开关，而且全都是简单的开/关控制，没有任何灰度需求。真正需要的是什么？</p>
<pre><code class="language-java">// 够用的特性开关
public class FeatureFlags {
    private static final Map&lt;String, Boolean&gt; FLAGS = Map.of(
        &quot;new_checkout_flow&quot;, true,
        &quot;dark_mode&quot;, false,
        &quot;v2_search&quot;, true
    );

    public static boolean isEnabled(String feature) {
        return FLAGS.getOrDefault(feature, false);
    }
}
</code></pre>
<p>六行代码解决问题。如果未来真的需要灰度能力，到那时候再加也不迟。</p>
<p>Saint-Exupery 说过一句话，我觉得是对 KISS 最好的注解：<strong>&quot;Perfection is achieved not when there is nothing more to add, but when there is nothing left to take away.&quot;</strong> 完美不是无可增加，而是无可删减。</p>
<h3>YAGNI：你不会需要它的</h3>
<p>YAGNI（You Ain&#39;t Gonna Need It）是 KISS 的延伸，专门针对&quot;未来需求&quot;的过度设计。</p>
<p>我经历过一个教科书级别的反面案例。某个团队在项目初期就搭建了一套完整的数据库抽象层，理由是&quot;将来可能要从 MySQL 迁移到 PostgreSQL&quot;。这套抽象层包括自定义的 Query Builder、方言转换器、连接池代理——完全屏蔽了底层数据库的差异。</p>
<p>结果怎样？三年过去了，数据库迁移从未发生。但这套抽象层带来的问题倒是实实在在：没法用 MySQL 的特定优化（比如 <code>INSERT ... ON DUPLICATE KEY UPDATE</code>）、调试 SQL 性能问题时要穿透三层封装才能看到真正执行的语句、ORM 的延迟加载在抽象层下面出现了诡异的行为。团队花了大量时间维护一个解决&quot;想象中的问题&quot;的系统，同时不断给&quot;真实存在的问题&quot;打补丁。</p>
<p><strong>YAGNI 的核心洞察是：写出来的每一行代码都是负债，不是资产。</strong> 代码要维护、要测试、要被后来的人理解。如果这些代码解决的是一个不存在的问题，那它就是纯粹的负债。</p>
<h3>Make It Work, Make It Right, Make It Fast</h3>
<p>这条原则规定了正确的工作顺序，而大多数人搞错了顺序——尤其是第三步。</p>
<p><strong>先让它跑起来</strong>，用最直接的方式实现功能，验证逻辑是对的。<strong>然后让它正确</strong>，重构代码结构，处理边界情况，写测试。<strong>最后让它快</strong>——但只有在性能确实是问题的时候。</p>
<p>我见过太多提前优化的案例。有一次一个同事花了整整一周优化一个数据处理循环，用上了位运算、对象池、手写内存管理，把循环体的执行时间从 200 微秒降到了 15 微秒。代码从清晰易读变成了只有他自己能看懂的&quot;性能艺术品&quot;。</p>
<p>后来做压测发现，瓶颈根本不在这个循环上，而在数据库的一个全表扫描查询。那个查询耗时 800 毫秒，加个索引就降到了 5 毫秒。他花一周优化的那个循环，在整个请求链路里占比不到 0.002%。</p>
<p><strong>过早优化是万恶之源</strong>，这话 Knuth 说过。但比这更重要的是：<strong>在优化之前，先量化。</strong> 不要凭直觉猜瓶颈在哪里，用 profiler 去测。人类的直觉在性能问题上出奇地不靠谱。</p>
<h2>消除重复的原则：DRY 与它的陷阱</h2>
<p>DRY（Don&#39;t Repeat Yourself）大概是被引用最多、同时也被误用最多的编程原则。</p>
<h3>DRY 的真正含义</h3>
<p>DRY 的原始定义来自 Andrew Hunt 和 David Thomas 的《程序员修炼之道》：<strong>&quot;Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.&quot;</strong> 注意，这里说的是 knowledge（知识），不是 code（代码）。</p>
<p><strong>两段代码看起来一模一样，但它们可能代表的是完全不同的知识。</strong> 回到文章开头的例子：</p>
<pre><code class="language-java">// 订单金额校验
if (amount &gt; 0 &amp;&amp; amount &lt;= 100000) {
    processOrder(amount);
}

// 退款金额校验
if (amount &gt; 0 &amp;&amp; amount &lt;= 100000) {
    processRefund(amount);
}
</code></pre>
<p>这两段代码形式上完全相同，但它们背后的业务知识是不同的。订单金额的上限是 10 万，退款金额的上限也恰好是 10 万——但这是两条独立的业务规则。订单的上限可能因为合规要求调整到 50 万，退款的上限可能因为风控策略降低到 5 万。如果你把它们抽成一个 <code>validateAmount()</code> 函数，当业务需要差异化调整时，你就会陷入尴尬。</p>
<p><strong>错误的 DRY 是消除代码的重复；正确的 DRY 是消除知识的重复。</strong></p>
<h3>什么时候该用 DRY</h3>
<p>那什么情况下应该消除重复呢？当两段代码不仅看起来一样，而且<strong>改变的原因也一样</strong>的时候。</p>
<p>比如，系统中有三个地方都在做用户手机号的格式校验：注册、修改个人信息、绑定手机号。这三个场景的校验规则来自同一条业务规则——&quot;合法的中国大陆手机号格式&quot;。如果手机号规则变了（比如新增了某个号段），这三个地方必须同步修改。这才是真正的知识重复，应该抽成一个共享函数。</p>
<pre><code class="language-java">// 这是正确的 DRY：一条业务规则，一个权威来源
public class PhoneValidator {
    private static final Pattern CN_MOBILE =
        Pattern.compile(&quot;^1[3-9]\\d{9}$&quot;);

    public static boolean isValid(String phone) {
        return phone != null &amp;&amp; CN_MOBILE.matcher(phone).matches();
    }
}
</code></pre>
<p><strong>判断的标准不是&quot;代码像不像&quot;，而是&quot;改变的原因是不是同一个&quot;。</strong> 如果两段代码因为不同的业务需求而可能各自演化，即使今天一模一样，也不要合并。如果两段代码永远因为同一个原因而同步变化，即使今天看起来有细微差异，也应该统一。</p>
<h2>划边界的原则：关注分离、单一职责与正交性</h2>
<p>这三条原则本质上在讨论同一个问题：<strong>怎么画线</strong>。在代码中画出清晰的边界，让每一部分各管各的，互不干扰。</p>
<h3>关注分离：一个方法不该知道太多事情</h3>
<p>看一段在业务代码里极其常见的&quot;全能方法&quot;：</p>
<pre><code class="language-java">public Response createOrder(HttpRequest request) {
    // 1. 鉴权
    String token = request.getHeader(&quot;Authorization&quot;);
    User user = tokenService.verify(token);
    if (user == null) return Response.unauthorized();

    // 2. 参数解析与校验
    OrderDTO dto = parseBody(request);
    if (dto.getAmount() &lt;= 0) return Response.badRequest(&quot;金额无效&quot;);

    // 3. 业务逻辑
    Order order = new Order(user.getId(), dto.getAmount());
    order.applyDiscount(discountService.calculate(user));
    orderRepository.save(order);

    // 4. 发消息通知
    kafkaTemplate.send(&quot;order-created&quot;, order.toEvent());

    // 5. 构造响应
    return Response.ok(order.toVO());
}
</code></pre>
<p>这个方法做了五件事：鉴权、参数校验、核心业务逻辑、消息发送、响应构造。任何一件事的改变都需要修改这个方法。鉴权方式从 JWT 换成 OAuth？改这个方法。消息中间件从 Kafka 换成 RocketMQ？改这个方法。响应格式要加个字段？还是改这个方法。</p>
<p>关注分离之后：</p>
<pre><code class="language-java">// Controller：只负责 HTTP 层的事务
@PostMapping(&quot;/orders&quot;)
public Response createOrder(@Authenticated User user,
                            @Valid OrderDTO dto) {
    Order order = orderService.create(user, dto);
    return Response.ok(order.toVO());
}

// Service：只负责核心业务逻辑
public Order create(User user, OrderDTO dto) {
    Order order = new Order(user.getId(), dto.getAmount());
    order.applyDiscount(discountService.calculate(user));
    orderRepository.save(order);
    eventPublisher.publish(new OrderCreatedEvent(order));
    return order;
}
</code></pre>
<p>鉴权交给框架的拦截器，参数校验交给注解，消息发送抽象成事件发布。每一层只关心自己那一件事。<strong>改变鉴权方式不需要碰业务逻辑，改变消息中间件不需要碰 Controller。</strong></p>
<h3>单一职责：什么是&quot;变化的原因&quot;</h3>
<p>单一职责原则（SRP）经常被简化为&quot;一个类只做一件事&quot;，但 Robert Martin 的原始表述是：<strong>一个类应该只有一个变化的原因（reason to change）。</strong></p>
<p>&quot;变化的原因&quot;是什么？不是技术上的分类，而是<strong>谁会要求你改这段代码</strong>。一个 <code>UserService</code> 如果同时处理用户的序列化格式和用户的业务校验规则，那它就有两个变化的原因：前端团队可能要求改序列化格式（比如从 XML 换成 JSON），业务团队可能要求改校验规则（比如新增实名认证）。这两个变化来自不同的利益相关方，进度不同、频率不同、测试方式也不同，它们不应该被塞在同一个类里互相影响。</p>
<h3>正交性：被低估的核心原则</h3>
<p>在我看来，<strong>正交性是所有设计原则中最值得反复强调的一个</strong>，但它很少被单独拿出来讨论。</p>
<p>正交性的意思是：<strong>系统中的一个维度发生变化时，不应该影响其他维度。</strong> 借用线性代数的概念——正交的向量互不干扰，改变一个方向上的分量不会影响另一个方向。</p>
<p>举一个具体的例子。假设你要把日志框架从 Log4j 换成 Logback，你需要改多少个文件？如果答案是&quot;几百个业务类都要改&quot;，那说明你的日志使用和业务逻辑不是正交的——它们耦合在一起了。</p>
<p>非正交的设计：</p>
<pre><code class="language-java">// 业务代码直接依赖具体的日志实现
import org.apache.log4j.Logger;

public class OrderService {
    private static final Logger log =
        Logger.getLogger(OrderService.class);

    public void create(Order order) {
        log.info(&quot;创建订单: &quot; + order.getId());
        // ...业务逻辑
    }
}
</code></pre>
<p>正交的设计：</p>
<pre><code class="language-java">// 业务代码依赖抽象
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class OrderService {
    private static final Logger log =
        LoggerFactory.getLogger(OrderService.class);

    public void create(Order order) {
        log.info(&quot;创建订单: {}&quot;, order.getId());
        // ...业务逻辑
    }
}
</code></pre>
<p>用 SLF4J 这样的门面之后，底层从 Log4j 切换到 Logback 只需要改 POM 依赖和一个配置文件，业务代码一行都不用动。这就是正交——日志实现这个维度的变化，不会波及到业务逻辑这个维度。</p>
<p><strong>检验正交性的方法很简单：问自己&quot;如果我要替换 X，需要改多少个与 X 无关的文件？&quot;</strong> 如果答案不是&quot;零&quot;或&quot;接近零&quot;，你的设计就有正交性问题。</p>
<p>把这个思路推广到 API 设计上。假设一个配置 API 是这样的：</p>
<pre><code class="language-java">// 非正交的 API：存储格式和业务语义耦合
config.setJsonProperty(&quot;order.maxRetry&quot;, &quot;3&quot;);
</code></pre>
<p>调用方既要知道业务配置项的含义，又要知道底层是 JSON 存储。如果将来存储格式换成 YAML 或数据库，所有调用方都要改。正交的设计应该隐藏存储细节：</p>
<pre><code class="language-java">// 正交的 API：调用方不需要知道存储格式
config.set(&quot;order.maxRetry&quot;, 3);
</code></pre>
<p>存储格式是一个维度，业务配置是另一个维度，它们应该可以独立变化。</p>
<h2>控制依赖的原则：最小耦合、迪米特法则与组合优于继承</h2>
<p>前面说的是怎么划边界，这一组原则说的是<strong>划完边界之后，边界两侧怎么打交道</strong>。</p>
<h3>最小耦合：依赖越少越好</h3>
<p>在做架构评审时，我有一个简单的判断标准：<strong>打开一个 Service 类，数一下它的构造函数参数或注入的依赖有多少个。</strong> 如果超过 7 个，这个类几乎一定有问题。</p>
<p>我见过一个真实的 <code>OrderService</code>，它依赖了 15 个其他服务：UserService、ProductService、InventoryService、PricingService、DiscountService、PaymentService、LogisticsService、NotificationService、AuditService、RiskService、ConfigService、CacheService、MetricsService、ABTestService、FeatureFlagService。这意味着这 15 个服务中任何一个的接口变更，都可能导致 <code>OrderService</code> 需要修改。任何一个服务出故障，都可能导致订单创建失败。测试这个类需要 mock 15 个依赖。</p>
<p><strong>耦合的代价不是线性增长的，而是组合爆炸。</strong> 15 个依赖意味着 15 个潜在的变更源、15 个潜在的故障点，以及它们之间可能产生的交互问题。</p>
<p>解决办法不是把 15 个依赖减少到 14 个，而是重新审视这个类的职责划分。一个需要 15 个依赖的类，几乎一定是承担了太多职责。把它拆成 3-4 个更小的服务，每个只依赖 3-4 个接口，整个系统的可维护性会有质的飞跃。</p>
<h3>迪米特法则：不要和陌生人说话</h3>
<p>迪米特法则（Law of Demeter）说的是：一个对象应该只和它的直接朋友交流，不应该和朋友的朋友交流。</p>
<p>看一个经典的&quot;火车残骸&quot;式代码：</p>
<pre><code class="language-java">// 坏：链式调用穿透了整个对象图
String zipCode = user.getAddress().getCity().getZipCode();
</code></pre>
<p>这行代码看起来简洁，但它把你的代码和 User、Address、City 三个类的内部结构绑死了。如果 Address 的结构变了（比如 City 不再是一个独立对象而是一个字符串），所有写了这种链式调用的地方都要改。</p>
<pre><code class="language-java">// 好：告诉对象做什么，而不是向对象要数据再自己做
String zipCode = user.getShippingZipCode();
</code></pre>
<p>这样 User 内部怎么组织 Address 和 City 的关系，是它自己的事。外部调用方只知道&quot;我可以向 User 要一个邮编&quot;，不需要知道内部是 <code>address.city.zipCode</code> 还是 <code>shippingInfo.postalCode</code>。</p>
<p><strong>迪米特法则的本质是信息隐藏：你不需要知道的结构细节，就不应该知道。</strong> 你知道得越多，你被耦合得就越深。</p>
<h3>组合优于继承：继承是最强的耦合</h3>
<p>在所有的代码关系中，继承是耦合最强的一种。子类和父类之间是白盒依赖——子类不仅依赖父类的接口，还依赖它的实现细节。父类改一个私有方法的行为，子类可能就炸了。</p>
<p>一个在业务系统里反复出现的陷阱：</p>
<pre><code class="language-java">// 第一版：看起来很合理
class User {
    String name;
    String email;
    void login() { ... }
}

class VIPUser extends User {
    int level;
    double discount;
    void login() {
        super.login();
        recordVIPLogin(); // VIP 登录有额外的积分逻辑
    }
}
</code></pre>
<p>问题出在哪里？有一天 <code>User</code> 类的 <code>login()</code> 方法增加了一个返回值，或者加了一个参数，<code>VIPUser</code> 的覆写方法需要同步修改。更糟的是，如果产品说&quot;用户可以同时是 VIP 用户和企业用户&quot;，你就陷入了 Java 的单继承困境——<code>VIPEnterpriseUser</code> 该继承谁？</p>
<p>用组合来解决：</p>
<pre><code class="language-java">class User {
    String name;
    String email;
    private MembershipStrategy membership;

    void login() {
        // ...基础登录逻辑
        membership.onLogin(this);
    }
}

interface MembershipStrategy {
    void onLogin(User user);
    double getDiscount();
}

class VIPMembership implements MembershipStrategy {
    public void onLogin(User user) { /* VIP 积分逻辑 */ }
    public double getDiscount() { return 0.8; }
}
</code></pre>
<p>用户的会员类型变成了一个可替换的策略。VIP 和企业会员可以自由组合，新增一种会员类型不需要修改 <code>User</code> 类。<strong>这就是组合的力量：用&quot;有一个&quot;代替&quot;是一个&quot;，用接口契约代替实现继承。</strong></p>
<p>这里顺便提一句里氏替换原则（LSP）：如果你的子类不能在所有场景下替代父类使用而不出问题，那你就不应该用继承。很多继承关系在设计时看起来合理（VIPUser &quot;是一个&quot; User），但在实际使用中会违反 LSP——比如 VIPUser 的某些方法有额外的前置条件，或者返回值的语义发生了变化。当你发现继承关系让你不舒服的时候，通常意味着应该用组合。</p>
<h2>面向未来的原则：开闭原则、为维护者编码与童子军规则</h2>
<p>前面的原则关注的是代码的结构，这一组关注的是时间——<strong>代码要活很多年，而写它的人可能早就不在了。</strong></p>
<h3>开闭原则：对扩展开放，对修改关闭</h3>
<p>开闭原则（OCP）不要停留在抽象层面来理解它，看一个具体场景。</p>
<p>一个支付系统，第一版支持支付宝和微信支付：</p>
<pre><code class="language-java">// 不符合开闭原则：每加一个支付方式都要改这个方法
public void pay(String channel, BigDecimal amount) {
    switch (channel) {
        case &quot;alipay&quot;:
            // 支付宝逻辑
            break;
        case &quot;wechat&quot;:
            // 微信支付逻辑
            break;
        // 加 Apple Pay？在这里加 case...
    }
}
</code></pre>
<p>每次新增一个支付渠道，你都需要修改这个方法。修改意味着引入 bug 的可能，意味着需要重新测试所有已有的支付逻辑，意味着合并冲突（如果有两个人同时在加不同的支付方式）。</p>
<p>符合开闭原则的做法：</p>
<pre><code class="language-java">public interface PaymentGateway {
    boolean supports(String channel);
    PayResult pay(BigDecimal amount, PayContext ctx);
}

// 新增 Apple Pay：写一个新类，不碰任何已有代码
public class ApplePayGateway implements PaymentGateway {
    public boolean supports(String channel) {
        return &quot;apple_pay&quot;.equals(channel);
    }
    public PayResult pay(BigDecimal amount, PayContext ctx) {
        // Apple Pay 的具体逻辑
    }
}
</code></pre>
<p>新增支付渠道变成了新增一个类，完全不需要修改已有的代码。已有的支付宝和微信的逻辑不会因为你加了 Apple Pay 而受到任何影响。</p>
<p><strong>开闭原则的实现手段是抽象。</strong> 通过定义稳定的接口，让新的变化以&quot;扩展&quot;的形式加入系统，而不是以&quot;修改&quot;的形式侵入已有代码。</p>
<h3>为维护者编码</h3>
<p>有一句在程序员社区流传很广的话：<strong>&quot;Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.&quot;</strong> 翻译过来就是&quot;写代码时要假设维护者是个知道你家住址的暴脾气&quot;。虽然夸张，但道理是真的。</p>
<p>我接手过一个内部系统的维护工作，原作者已经离职。打开代码的那一刻，我体会到了什么叫&quot;技术暴力&quot;。</p>
<p>变量名全是单字母加数字：<code>a1</code>、<code>b2</code>、<code>tmp3</code>。一个核心方法有 300 行，中间穿插着三层嵌套的 try-catch。最致命的是一段位运算逻辑——用 6 个 bit 分别存储了 6 种业务状态，通过位与和位或来判断组合状态。没有一行注释解释为什么要用位运算（估计是为了&quot;性能&quot;），也没有注释解释每个 bit 代表什么状态。我花了三天才搞懂这 20 行代码在做什么，又花了两天写测试确认我的理解是对的。</p>
<p>这段代码在性能上确实更快——大概快了 0.01 毫秒。但它让每一个后来的维护者多花几天时间来理解。这种&quot;聪明&quot;的代码是真正的技术债。</p>
<p><strong>为维护者编码的核心原则：</strong></p>
<ul>
<li>变量名和函数名要表达意图，不要表达实现</li>
<li>非显而易见的逻辑必须写注释解释&quot;为什么&quot;，而不是&quot;做什么&quot;</li>
<li>不要为了微不足道的性能提升牺牲可读性</li>
<li>如果你觉得一段代码需要注释才能看懂，先考虑能不能重写得不需要注释</li>
</ul>
<h3>童子军规则</h3>
<p>Robert Martin 提出的童子军规则很简单：<strong>离开时让营地比来时更干净。</strong> 映射到代码上就是：每次你碰一个文件，离开时让它比你打开时更好一点——改一个命名、删一段死代码、补一句注释。</p>
<p>但这条规则有一个重要的约束：<strong>范围要合理。</strong> 我见过有人在一个修复线上 bug 的 PR 里顺手重构了整个模块。review 的人分不清哪些改动是修 bug、哪些是重构，测试团队也不知道回归测试的范围应该多大。结果修 bug 的 PR 反复被打回，原本一天能上线的修复拖了一周。</p>
<p><strong>童子军规则的正确姿势：小步改进，和功能改动明确分开。</strong> 如果重构范围比较大，单独开一个 PR。如果是顺手改的小优化，确保 reviewer 能一眼分辨出来。</p>
<h2>原则之间的冲突与权衡</h2>
<p>如果前面每一条原则都读进去了，你应该已经隐约感觉到一个问题：<strong>这些原则之间是会打架的。</strong> 这不是理论上的可能性，而是每天都在发生的事情。</p>
<h3>DRY vs KISS</h3>
<p>两个 API 接口的处理逻辑有 70% 相似。DRY 说：把共同部分抽出来。KISS 说：抽象会增加复杂度。</p>
<p>如果你抽一个共享的 handler，就需要用参数和条件分支来处理那 30% 的差异。结果这个&quot;统一&quot;的 handler 里充满了 <code>if (isTypeA)</code> 的判断，比两个独立的 handler 更难理解，也更容易在修改一个场景时不小心影响另一个。</p>
<pre><code class="language-java">// DRY 的做法：抽一个共享 handler
public Response handleRequest(Request req, boolean isTypeA) {
    // 公共逻辑...
    if (isTypeA) {
        // A 的特殊逻辑
    } else {
        // B 的特殊逻辑
    }
    // 更多公共逻辑...
    if (isTypeA) {
        // A 的另一段特殊逻辑
    }
    // ...
}
</code></pre>
<pre><code class="language-java">// KISS 的做法：各写各的，接受重复
public Response handleTypeA(Request req) {
    // A 的完整逻辑，简单直接
}

public Response handleTypeB(Request req) {
    // B 的完整逻辑，简单直接
}
</code></pre>
<p>在很多情况下，<strong>后者是更好的选择。</strong> 两个独立的方法各自 50 行，比一个 80 行但充满条件分支的&quot;统一方法&quot;更容易理解和维护。这里 KISS 赢了 DRY。</p>
<p>但如果那 70% 的相似逻辑来自同一条业务规则（比如都是同一套风控校验流程），那就应该抽出来——因为这时候 DRY 保护的是知识的一致性，一旦风控规则变了，你不想记住&quot;有两个地方要改&quot;。</p>
<p><strong>判断标准：重复的是&quot;知识&quot;还是&quot;代码&quot;。如果是知识，DRY 优先；如果只是代码碰巧像，KISS 优先。</strong></p>
<h3>YAGNI vs 开闭原则</h3>
<p>YAGNI 说&quot;不要为未来设计&quot;，开闭原则说&quot;要方便未来扩展&quot;。这两者怎么调和？</p>
<p>答案是：<strong>不要构建功能，但要留下接缝。</strong></p>
<p>以前面支付系统的例子来说，YAGNI 告诉你不要在第一版就建一个&quot;通用支付网关框架&quot;，支持二十种支付方式的动态注册和热加载。但开闭原则告诉你，至少把支付逻辑藏在一个接口后面，这样将来加新的支付方式时不需要改已有的代码。</p>
<p><strong>定义一个接口的成本很低，但它留下的扩展空间很大。</strong> 这就是 YAGNI 和 OCP 的平衡点：不构建不需要的实现，但留下简单的扩展接口。接口是轻量的——它不包含实现，不需要维护逻辑，不会引入 bug——但它给未来的变化留了一扇门。</p>
<h3>SRP vs KISS</h3>
<p>单一职责拆到极致会怎样？一个简单的用户注册流程被拆成 <code>UserInputValidator</code>、<code>UserFactory</code>、<code>UserPersistenceService</code>、<code>WelcomeEmailSender</code>、<code>RegistrationEventPublisher</code>、<code>RegistrationOrchestrator</code> 六个类。每个类确实只有一个职责，非常&quot;干净&quot;。</p>
<p>但当一个新来的开发者要理解注册流程时，他需要在六个文件之间跳转，理解它们的协作关系，才能拼凑出完整的图景。如果把核心逻辑放在一个 <code>RegistrationService</code> 里，可能只有 80 行代码，但读一个文件就能理解整个流程。</p>
<p><strong>SRP 的目标是让变化可控，但如果拆得太细导致理解成本剧增，就需要退一步。</strong> 实践中的经验法则是：如果两个职责几乎总是同时变化、几乎总是被同一个人修改、几乎总是在同一个上下文中被讨论，那就没必要强行拆开。&quot;一个变化的原因&quot;不是一个精确的定义，它需要你对业务有判断力才能合理运用。</p>
<h2>结语</h2>
<p>写了这么多原则和案例，最后想说的反而是最简单的一句话：<strong>好的代码不是最聪明的代码，而是下一个人能看懂、能改动、能扩展而不心惊胆战的代码。</strong></p>
<p>编程原则是前人踩过无数坑之后留下的路标。KISS 告诉你克制，DRY 告诉你统一知识，关注分离告诉你画好边界，迪米特法则告诉你管好依赖，开闭原则告诉你面向未来。但这些路标指的是方向，不是精确坐标。你不能闭着眼睛沿着路标走，因为路标之间有时候指向不同的方向——DRY 和 KISS 打架、YAGNI 和 OCP 拉锯、SRP 和可理解性博弈。</p>
<p><strong>真正的工程判断力，不是记住所有原则然后逐条执行，而是在具体场景下感知到原则之间的张力，然后做出一个&quot;足够好&quot;的决定。</strong> 这种判断力没有捷径，只能通过写代码、犯错误、读别人的代码、维护别人的系统，一点一点积累。</p>
<p>如果非要给出一条元原则的话，我会说：<strong>用最简单的方式解决当下的问题，同时不给下一个人制造麻烦。</strong> 大多数时候，遵循这一条就够了。</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/architecture/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"架构设计"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-03-24","children":"2024年03月24日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"服务注册与发现（实践篇）"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","微服务",{"href":"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"微服务"}],["$","$L13","服务发现",{"href":"/blog/tag/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"服务发现"}],["$","$L13","工程实践",{"href":"/blog/tag/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"工程实践"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/architecture/服务注册与发现","title":"服务注册与发现","description":"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。","pubDate":"2024-03-23","tags":["微服务","服务发现","架构设计"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/middleware/RabbitMQ、RocketMQ、Kafka区别","title":"RabbitMQ、RocketMQ、Kafka区别","description":"MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ","pubDate":"2024-03-31","tags":["消息队列","中间件","技术选型"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"微服务":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":{"slug":"engineering/architecture/微服务架构落地指南：从核心模式到技术选型","title":"微服务架构落地指南：从核心模式到技术选型","description":"系统性地探讨微服务架构设计的核心关注点，包括服务注册发现、API 网关、服务容错、基础设施选型、CI/CD 流水线和可观测性体系，帮助你从 0 到 1 构建一套完整的微服务技术栈。","pubDate":"2025-12-12","tags":["架构设计","微服务","分布式系统","技术选型"],"heroImage":"$undefined","content":"$19"}},"服务发现":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":null},"工程实践":{"prev":null,"next":{"slug":"engineering/practice/编程原则的工程实践：从KISS到正交性","title":"编程原则的工程实践：从 KISS 到正交性","description":"编程原则不是教条，而是前人踩过无数坑后留下的路标。KISS、YAGNI、DRY、关注分离、最小耦合、迪米特法则、组合优于继承、正交性——这些原则之间既有共鸣也有冲突，真正的功力在于权衡。","pubDate":"2025-10-18","tags":["编程原则","软件设计","工程实践","代码质量"],"heroImage":"$undefined","content":"$1a"}}}}]}],["$","$L1b",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"服务注册与发现（实践篇） - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景..."}],["$","meta","2",{"property":"og:title","content":"服务注册与发现（实践篇）"}],["$","meta","3",{"property":"og:description","content":"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景..."}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-03-24"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"服务注册与发现（实践篇）"}],["$","meta","9",{"name":"twitter:description","content":"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景..."}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/fffdcdb4fb651185.css","style"]
0:{"P":null,"b":"wlOkUxTzHfxl8sQA11M8Z","p":"","c":["","blog","engineering","architecture","%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/architecture/%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/fffdcdb4fb651185.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/architecture/%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","7tqeuirMx0tzVipne355Gv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1c:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T824e,<h3>整体思考 <a href="#item-0-2" id="item-0-2"></a></h3>
<h4>1 秒杀存在的问题 <a href="#item-0-3" id="item-0-3"></a></h4>
<p>对于一个日常平稳的业务系统，如果直接开通秒杀功能的话，往往会出现很多问题——</p>
<table>
<thead>
<tr>
<th>干系人</th>
<th>问题分类</th>
<th>业务出现的问题</th>
<th>设计要求</th>
</tr>
</thead>
<tbody><tr>
<td>用户</td>
<td>体验较差</td>
<td>秒杀开始，系统瞬间承受平时数十倍甚至上百倍的流量，直接宕掉</td>
<td>高性能</td>
</tr>
<tr>
<td></td>
<td></td>
<td>用户下单后却付不了款，显示商品已经被其他人买走了</td>
<td>一致性</td>
</tr>
<tr>
<td>商家</td>
<td>商品超卖</td>
<td>100 件商品，却出现 200 人下单成功，成功下单买到商品的人数远远超过活动商品数量的上限</td>
<td>一致性</td>
</tr>
<tr>
<td></td>
<td>资金受损</td>
<td>竞争对手通过恶意下单的方式将活动商品全部下单，导致库存清零，商家无法正常售卖</td>
<td>高可用</td>
</tr>
<tr>
<td></td>
<td></td>
<td>秒杀器猖獗，黄牛通过秒杀器扫货，商家无法达到营销目的</td>
<td>高可用</td>
</tr>
<tr>
<td>平台</td>
<td>风险不可控</td>
<td>系统的其它与秒杀活动不相关的模块变得异常缓慢，业务影响面扩散</td>
<td>高可用</td>
</tr>
<tr>
<td></td>
<td>拖垮网站</td>
<td>在线人数创新高，核心链路涉及的上下游服务从前到后都在告警</td>
<td>高性能</td>
</tr>
<tr>
<td></td>
<td></td>
<td>库存只有一份，所有请求集中读写同一个数据，DB 出现单点</td>
<td>高性能</td>
</tr>
</tbody></table>
<h4>2 设计方向的思考 <a href="#item-0-4" id="item-0-4"></a></h4>
<p>秒杀本质是要求一个瞬时高发下的承压系统，这也是其区别于其他业务的核心场景。对日常系统秒杀产生的问题逐一进行拆解分类，秒杀对应到架构设计，其实就是高可用、一致性和高性能的要求。关于秒杀系统的设计思考，本文即基于此 3 层依次推进，简述如下——</p>
<ul>
<li>高性能。 秒杀涉及高读和高写的支持，如何支撑高并发，如何抵抗高IOPS？核心优化理念其实是类似的：高读就尽量&quot;少读&quot;或&quot;读少&quot;，高写就数据拆分。本文将从动静分离、热点优化以及服务端性能优化 3 个方面展开</li>
<li>一致性。 秒杀的核心关注是商品库存，有限的商品在同一时间被多个请求同时扣减，而且要保证准确性，显而易见是一个难题。如何做到既不多又不少？本文将从业界通用的几种减库存方案切入，讨论一致性设计的核心逻辑</li>
<li>高可用。 大型分布式系统在实际运行过程中面对的工况是非常复杂的，业务流量的突增、依赖服务的不稳定、应用自身的瓶颈、物理资源的损坏等方方面面都会对系统的运行带来大大小小的的冲击。如何保障应用在复杂工况环境下还能高效稳定运行，如何预防和面对突发问题，系统设计时应该从哪些方面着手？本文将从架构落地的全景视角进行关注思考</li>
</ul>
<h3>高性能 <a href="#item-0-5" id="item-0-5"></a></h3>
<h4>1 动静分离 <a href="#item-0-6" id="item-0-6"></a></h4>
<p>大家可能会注意到，秒杀过程中你是不需要刷新整个页面的，只有时间在不停跳动。这是因为一般都会对大流量的秒杀系统做系统的静态化改造，即数据意义上的动静分离。动静分离三步走：1、数据拆分；2、静态缓存；3、数据整合。</p>
<p><strong>1.1 数据拆分</strong></p>
<p>动静分离的首要目的是将动态页面改造成适合缓存的静态页面。因此第一步就是分离出动态数据，主要从以下 2 个方面进行：</p>
<ol>
<li>用户。用户身份信息包括登录状态以及登录画像等，相关要素可以单独拆分出来，通过动态请求进行获取；与之相关的广平推荐，如用户偏好、地域偏好等，同样可以通过异步方式进行加载</li>
<li>时间。秒杀时间是由服务端统一管控的，可以通过动态请求进行获取</li>
</ol>
<p>这里你可以打开电商平台的一个秒杀页面，看看这个页面里都有哪些动静数据。</p>
<p><strong>1.2 静态缓存</strong></p>
<p>分离出动静态数据之后，第二步就是将静态数据进行合理的缓存，由此衍生出两个问题：1、怎么缓存；2、哪里缓存</p>
<p><strong>1.2.1 怎么缓存</strong></p>
<p>静态化改造的一个特点是直接缓存整个 HTTP 连接而不是仅仅缓存静态数据，如此一来，Web 代理服务器根据请求 URL，可以直接取出对应的响应体然后直接返回，响应过程无需重组 HTTP 协议，也无需解析 HTTP 请求头。而作为缓存键，URL唯一化是必不可少的，只是对于商品系统，URL 天然是可以基于商品 ID 来进行唯一标识的，比如淘宝的 <a href="https://link.segmentfault.com/?enc=MYTx%2B1O98e0H2OhCbw2yrg%3D%3D.eRmrBGs8O3Hv0%2BVZ4yO3J8RpgwhKne1xP0L6oRT4KFKWY4nTZucRo5o6QTC3xhtN">https://item.taobao.com/item....</a>。</p>
<p><strong>1.2.2 哪里缓存</strong></p>
<p>静态数据缓存到哪里呢？可以有三种方式：1、浏览器；2、CDN ；3、服务端。</p>
<p>浏览器当然是第一选择，但用户的浏览器是不可控的，主要体现在如果用户不主动刷新，系统很难主动地把消息推送给用户（注意，当讨论静态数据时，潜台词是 “相对不变”，言外之意是 “可能会变”），如此可能会导致用户端在很长一段时间内看到的信息都是错误的。对于秒杀系统，保证缓存可以在秒级时间内失效是不可或缺的。</p>
<p>服务端主要进行动态逻辑计算及加载，本身并不擅长处理大量连接，每个连接消耗内存较多，同时 Servlet 容器解析 HTTP 较慢，容易侵占逻辑计算资源；另外，静态数据下沉至此也会拉长请求路径。</p>
<p>因此通常将静态数据缓存在 CDN，其本身更擅长处理大并发的静态文件请求，既可以做到主动失效，又离用户尽可能近，同时规避 Java 语言层面的弱点。需要注意的是，上 CDN 有以下几个问题需要解决：</p>
<ol>
<li>失效问题。任何一个缓存都应该是有时效的，尤其对于一个秒杀场景。所以，系统需要保证全国各地的 CDN 在秒级时间内失效掉缓存信息，这实际对 CDN 的失效系统要求是很高的</li>
<li>命中率问题。高命中是缓存系统最为核心的性能要求，不然缓存就失去了意义。如果将数据放到全国各地的 CDN ，势必会导致请求命中同一个缓存的可能性降低，那么命中率就成为一个问题</li>
</ol>
<p>因此，将数据放到全国所有的 CDN 节点是不太现实的，失效问题、命中率问题都会面临比较大的挑战。更为可行的做法是选择若干 CDN 节点进行静态化改造，节点的选取通常需要满足以下几个条件：</p>
<ol>
<li>临近访问量集中的地区</li>
<li>距离主站较远的地区</li>
<li>节点与主站间网络质量良好的地区</li>
</ol>
<p>基于以上因素，选择 CDN 的二级缓存比较合适，因为二级缓存数量偏少，容量也更大，访问量相对集中，这样就可以较好解决缓存的失效问题以及命中率问题，是当前比较理想的一种 CDN 化方案。部署方式如下图所示：</p>
<p><img src="/images/blog/engineering/system-image_1_2.png" alt="image_1_2.png"></p>
<p><strong>1.3 数据整合</strong></p>
<p>分离出动静态数据之后，前端如何组织数据页就是一个新的问题，主要在于动态数据的加载处理，通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</p>
<ol>
<li>ESI 方案：Web 代理服务器上请求动态数据，并将动态数据插入到静态页面中，用户看到页面时已经是一个完整的页面。这种方式对服务端性能要求高，但用户体验较好</li>
<li>CSI 方案：Web 代理服务器上只返回静态页面，前端单独发起一个异步 JS 请求动态数据。这种方式对服务端性能友好，但用户体验稍差</li>
</ol>
<p><strong>1.4 小结</strong></p>
<p>动静分离对于性能的提升，抽象起来只有两点，一是数据要尽量少，以便减少没必要的请求，二是路径要尽量短，以便提高单次请求的效率。具体方法其实就是基于这个大方向进行的。</p>
<h4>2 热点优化 <a href="#item-0-7" id="item-0-7"></a></h4>
<p>热点分为热点操作和热点数据，以下分开进行讨论。</p>
<p><strong>2.1 热点操作</strong></p>
<p>零点刷新、零点下单、零点添加购物车等都属于热点操作。热点操作是用户的行为，不好改变，但可以做一些限制保护，比如用户频繁刷新页面时进行提示阻断。</p>
<p><strong>2.2 热点数据</strong></p>
<p>热点数据的处理三步走，一是热点识别，二是热点隔离，三是热点优化。</p>
<p><strong>2.2.1 热点识别</strong></p>
<p>热点数据分为静态热点和动态热点，具体如下：</p>
<ol>
<li>静态热点：能够提前预测的热点数据。大促前夕，可以根据大促的行业特点、活动商家等纬度信息分析出热点商品，或者通过卖家报名的方式提前筛选；另外，还可以通过技术手段提前预测，例如对买家每天访问的商品进行大数据计算，然后统计出 TOP N 的商品，即可视为热点商品</li>
<li>动态热点：无法提前预测的热点数据。冷热数据往往是随实际业务场景发生交替变化的，尤其是如今直播卖货模式的兴起——带货商临时做一个广告，就有可能导致一件商品在短时间内被大量购买。由于此类商品日常访问较少，即使在缓存系统中一段时间后也会被逐出或过期掉，甚至在db中也是冷数据。瞬时流量的涌入，往往导致缓存被击穿，请求直接到达DB，引发DB压力过大</li>
</ol>
<p>因此秒杀系统需要实现热点数据的动态发现能力，一个常见的实现思路是：</p>
<ol>
<li>异步采集交易链路各个环节的热点 Key 信息，如 Nginx采集访问URL或 Agent 采集热点日志（一些中间件本身已具备热点发现能力），提前识别潜在的热点数据</li>
<li>聚合分析热点数据，达到一定规则的热点数据，通过订阅分发推送到链路系统，各系统根据自身需求决定如何处理热点数据，或限流或缓存，从而实现热点保护</li>
</ol>
<p>需要注意的是：</p>
<ol>
<li>热点数据采集最好采用异步方式，一方面不会影响业务的核心交易链路，一方面可以保证采集方式的通用性</li>
<li>热点发现最好做到秒级实时，这样动态发现才有意义，实际上也是对核心节点的数据采集和分析能力提出了较高的要求</li>
</ol>
<p><strong>2.2.2 热点隔离</strong></p>
<p>热点数据识别出来之后，第一原则就是将热点数据隔离出来，不要让 1% 影响到另外的 99%，可以基于以下几个层次实现热点隔离：</p>
<ol>
<li>业务隔离。秒杀作为一种营销活动，卖家需要单独报名，从技术上来说，系统可以提前对已知热点做缓存预热</li>
<li>系统隔离。系统隔离是运行时隔离，通过分组部署和另外 99% 进行分离，另外秒杀也可以申请单独的域名，入口层就让请求落到不同的集群中</li>
<li>数据隔离。秒杀数据作为热点数据，可以启用单独的缓存集群或者DB服务组，从而更好的实现横向或纵向能力扩展</li>
</ol>
<p>当然，实现隔离还有很多种办法。比如，可以按照用户来区分，为不同的用户分配不同的 Cookie，入口层路由到不同的服务接口中；再比如，域名保持一致，但后端调用不同的服务接口；又或者在数据层给数据打标进行区分等等，这些措施的目的都是把已经识别的热点请求和普通请求区分开来。</p>
<p><strong>2.2.3 热点优化</strong></p>
<p>热点数据隔离之后，也就方便对这 1% 的请求做针对性的优化，方式无外乎两种：</p>
<ol>
<li>缓存：热点缓存是最为有效的办法。如果热点数据做了动静分离，那么可以长期缓存静态数据</li>
<li>限流：流量限制更多是一种保护机制。需要注意的是，各服务要时刻关注请求是否触发限流并及时进行review</li>
</ol>
<p><strong>2.2.4 小结</strong></p>
<p>数据的热点优化与动静分离是不一样的，热点优化是基于二八原则对数据进行了纵向拆分，以便进行针对性地处理。热点识别和隔离不仅对“秒杀”这个场景有意义，对其他的高性能分布式系统也非常有参考价值。</p>
<h4>3 系统优化 <a href="#item-0-8" id="item-0-8"></a></h4>
<p>对于一个软件系统，提高性能可以有很多种手段，如提升硬件水平、调优JVM 性能，这里主要关注代码层面的性能优化——</p>
<ol>
<li>减少序列化：减少 Java 中的序列化操作可以很好的提升系统性能。序列化大部分是在 RPC 阶段发生，因此应该尽量减少 RPC 调用，一种可行的方案是将多个关联性较强的应用进行 “合并部署”，从而减少不同应用之间的 RPC 调用（微服务设计规范）</li>
<li>直接输出流数据：只要涉及字符串的I/O操作，无论是磁盘 I/O 还是网络 I/O，都比较耗费 CPU 资源，因为字符需要转换成字节，而这个转换又必须查表编码。所以对于常用数据，比如静态字符串，推荐提前编码成字节并缓存，具体到代码层面就是通过 OutputStream() 类函数从而减少数据的编码转换；另外，热点方法toString()不要直接调用ReflectionToString实现，推荐直接硬编码，并且只打印DO的基础要素和核心要素</li>
<li>裁剪日志异常堆栈：无论是外部系统异常还是应用本身异常，都会有堆栈打出，超大流量下，频繁的输出完整堆栈，只会加剧系统当前负载。可以通过日志配置文件控制异常堆栈输出的深度</li>
<li>去组件框架：极致优化要求下，可以去掉一些组件框架，比如去掉传统的 MVC 框架，直接使用 Servlet 处理请求。这样可以绕过一大堆复杂且用处不大的处理逻辑，节省毫秒级的时间，当然，需要合理评估你对框架的依赖程度</li>
</ol>
<h4>4 总结一下 <a href="#item-0-9" id="item-0-9"></a></h4>
<p>性能优化需要一个基准值，所以系统还需要做好应用基线，比如性能基线（何时性能突然下降）、成本基线（去年大促用了多少机器）、链路基线（核心流程发生了哪些变化），通过基线持续关注系统性能，促使系统在代码层面持续提升编码质量、业务层面及时下掉不合理调用、架构层面不断优化改进。</p>
<h3>一致性 <a href="#item-0-10" id="item-0-10"></a></h3>
<p>秒杀系统中，库存是个关键数据，卖不出去是个问题，超卖更是个问题。秒杀场景下的一致性问题，主要就是库存扣减的准确性问题。</p>
<h4>1 减库存的方式 <a href="#item-0-11" id="item-0-11"></a></h4>
<p>电商场景下的购买过程一般分为两步：下单和付款。“提交订单”即为下单，“支付订单”即为付款。基于此设定，减库存一般有以下几个方式：</p>
<ol>
<li>下单减库存。买家下单后，扣减商品库存。下单减库存是最简单的减库存方式，也是控制最为精确的一种</li>
<li>付款减库存。买家下单后，并不立即扣减库存，而是等到付款后才真正扣减库存。但因为付款时才减库存，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了</li>
<li>预扣库存。这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 15 分钟），超过这段时间，库存自动释放，释放后其他买家可以购买</li>
</ol>
<p>能够看到，减库存方式是基于购物过程的多阶段进行划分的，但无论是在下单阶段还是付款阶段，都会存在一些问题，下面进行具体分析。</p>
<h4>2 减库存的问题 <a href="#item-0-12" id="item-0-12"></a></h4>
<p><strong>2.1 下单减库存</strong></p>
<p>优势：用户体验最好。下单减库存是最简单的减库存方式，也是控制最精确的一种。下单时可以直接通过数据库事务机制控制商品库存，所以一定不会出现已下单却付不了款的情况。</p>
<p>劣势：可能卖不出去。正常情况下，买家下单后付款概率很高，所以不会有太大问题。但有一种场景例外，就是当卖家参加某个促销活动时，竞争对手通过恶意下单的方式将该商品全部下单，导致库存清零，那么这就不能正常售卖了——要知道，恶意下单的人是不会真正付款的，这正是 “下单减库存” 的不足之处。</p>
<p><strong>2.2 付款减库存</strong></p>
<p>优势：一定实际售卖。“下单减库存” 可能导致恶意下单，从而影响卖家的商品销售， “付款减库存” 由于需要付出真金白银，可以有效避免。</p>
<p>劣势：用户体验较差。用户下单后，不一定会实际付款，假设有 100 件商品，就可能出现 200 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在大促的热门商品上。如此一来就会导致很多买家下单成功后却付不了款，购物体验自然是比较差的。</p>
<p><strong>2.3 预扣库存</strong></p>
<p>优势：缓解了以上两种方式的问题。预扣库存实际就是“下单减库存”和 “付款减库存”两种方式的结合，将两次操作进行了前后关联，下单时预扣库存，付款时释放库存。</p>
<p>劣势：并没有彻底解决以上问题。比如针对恶意下单的场景，虽然可以把有效付款时间设置为 10 分钟，但恶意买家完全可以在 10 分钟之后再次下单。</p>
<p><strong>2.4 小结</strong></p>
<p>减库存的问题主要体现在用户体验和商业诉求两方面，其本质原因在于购物过程存在两步甚至多步操作，在不同阶段减库存，容易存在被恶意利用的漏洞。</p>
<h4>3 实际如何减库存 <a href="#item-0-13" id="item-0-13"></a></h4>
<p>业界最为常见的是预扣库存。无论是外卖点餐还是电商购物，下单后一般都有个 “有效付款时间”，超过该时间订单自动释放，这就是典型的预扣库存方案。但如上所述，预扣库存还需要解决恶意下单的问题，保证商品卖的出去；另一方面，如何避免超卖，也是一个痛点。</p>
<ol>
<li>卖的出去：恶意下单的解决方案主要还是结合安全和反作弊措施来制止。比如，识别频繁下单不付款的买家并进行打标，这样可以在打标买家下单时不减库存；再比如为大促商品设置单人最大购买件数，一人最多只能买 N 件商品；又或者对重复下单不付款的行为进行次数限制阻断等</li>
<li>避免超卖：库存超卖的情况实际分为两种。对于普通商品，秒杀只是一种大促手段，即使库存超卖，商家也可以通过补货来解决；而对于一些商品，秒杀作为一种营销手段，完全不允许库存为负，也就是在数据一致性上，需要保证大并发请求时数据库中的库存字段值不能为负，一般有多种方案：一是在通过事务来判断，即保证减后库存不能为负，否则就回滚；二是直接设置数据库字段类型为无符号整数，这样一旦库存为负就会在执行 SQL 时报错；三是使用 CASE WHEN 判断语句——</li>
</ol>
<pre><code class="language-sql">UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END
</code></pre>
<p>业务手段保证商品卖的出去，技术手段保证商品不会超卖，库存问题从来就不是简单的技术难题，解决问题的视角是多种多样的。</p>
<h4>4 一致性性能的优化 <a href="#item-0-14" id="item-0-14"></a></h4>
<p>库存是个关键数据，更是个热点数据。对系统来说，热点的实际影响就是 “高读” 和 “高写”，也是秒杀场景下最为核心的一个技术难题。</p>
<p><strong>4.1 高并发读</strong></p>
<p>秒杀场景解决高并发读问题，关键词是“分层校验”。即在读链路时，只进行不影响性能的检查操作，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求等，而不做一致性校验等容易引发瓶颈的检查操作；直到写链路时，才对库存做一致性检查，在数据层保证最终准确性。</p>
<p>因此，在分层校验设定下，系统可以采用分布式缓存甚至LocalCache来抵抗高并发读。即允许读场景下一定的脏数据，这样只会导致少量原本无库存的下单请求被误认为是有库存的，等到真正写数据时再保证最终一致性，由此做到高可用和一致性之间的平衡。</p>
<p>实际上，分层校验的核心思想是：不同层次尽可能过滤掉无效请求，只在“漏斗” 最末端进行有效处理，从而缩短系统瓶颈的影响路径。</p>
<p><strong>4.2 高并发写</strong></p>
<p>高并发写的优化方式，一种是更换DB选型，一种是优化DB性能，以下分别进行讨论。</p>
<p>4.2.1 更换DB选型</p>
<p>秒杀商品和普通商品的减库存是有差异的，核心区别在数据量级小、交易时间短，因此能否把秒杀减库存直接放到缓存系统中实现呢，也就是直接在一个带有持久化功能的缓存中进行减库存操作，比如 Redis？</p>
<p>如果减库存逻辑非常单一的话，比如没有复杂的 SKU 库存和总库存这种联动关系的话，个人认为是完全可以的。但如果有比较复杂的减库存逻辑，或者需要使用到事务，那就必须在数据库中完成减库存操作。</p>
<p>4.2.2 优化DB性能</p>
<p>库存数据落地到数据库实现其实是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁。但并发越高，等待线程就会越多，TPS 下降，RT 上升，吞吐量会受到严重影响——注意，这里假设数据库已基于上文【性能优化】完成数据隔离，以便于讨论聚焦 。</p>
<p>解决并发锁的问题，有两种办法：</p>
<ol>
<li>应用层排队。通过缓存加入集群分布式锁，从而控制集群对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用过多的数据库连接</li>
<li>数据层排队。应用层排队是有损性能的，数据层排队是最为理想的。业界中，阿里的数据库团队开发了针对InnoDB 层上的补丁程序（patch），可以基于DB层对单行记录做并发排队，从而实现秒杀场景下的定制优化——注意，排队和锁竞争是有区别的，如果熟悉 MySQL 的话，就会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB 的切换都是比较消耗性能的。另外阿里的数据库团队还做了很多其他方面的优化，如 COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL 的补丁程序，通过在 SQL 里加入提示（hint），实现事务不需要等待实时提交，而是在数据执行完最后一条 SQL 后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，减少网络等待的时间（毫秒级）。目前阿里已将包含这些补丁程序的 MySQL 开源：<a href="https://link.segmentfault.com/?enc=I%2FCSvHmwhqWWaIcvx%2BoGuw%3D%3D.9twostwyDIweyMcUrly3Zp6KPhQuFFX7eS%2FNY5bGVH3W2EN%2FLLcCmxl3cSe4rhiflb5yVJtZxmcjdRE5e2CqiLn7gsvN1ymwz5bAEmNgIr0%3D">AliSQL</a></li>
</ol>
<p><strong>4.3 小结</strong></p>
<p>高读和高写的两种处理方式大相径庭。读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化思路的本质还是基于 CAP 理论做平衡。</p>
<h4>5 总结一下 <a href="#item-0-15" id="item-0-15"></a></h4>
<p>当然，减库存还有很多细节问题，例如预扣的库存超时后如何进行回补，再比如第三方支付如何保证减库存和付款时的状态一致性，这些也是很大的挑战。</p>
<h3>高可用 <a href="#item-0-16" id="item-0-16"></a></h3>
<p>盯过秒杀流量监控的话，会发现它不是一条蜿蜒而起的曲线，而是一条挺拔的直线，这是因为秒杀请求高度集中于某一特定的时间点。这样一来就会造成一个特别高的零点峰值，而对资源的消耗也几乎是瞬时的。所以秒杀系统的可用性保护是不可或缺的。</p>
<h4>1 流量削峰 <a href="#item-0-17" id="item-0-17"></a></h4>
<p>对于秒杀的目标场景，最终能够抢到商品的人数是固定的，无论 100 人和 10000 人参加结果都是一样的，即有效请求额度是有限的。并发度越高，无效请求也就越多。但秒杀作为一种商业营销手段，活动开始之前是希望有更多的人来刷页面，只是真正开始后，秒杀请求不是越多越好。因此系统可以设计一些规则，人为的延缓秒杀请求，甚至可以过滤掉一些无效请求。</p>
<p><strong>1.1 答题</strong></p>
<p>早期秒杀只是简单的点击秒杀按钮，后来才增加了答题。为什么要增加答题呢？主要是通过提升购买的复杂度，达到两个目的：</p>
<ol>
<li>防止作弊。早期秒杀器比较猖獗，存在恶意买家或竞争对手使用秒杀器扫货的情况，商家没有达到营销的目的，所以增加答题来进行限制</li>
<li>延缓请求。零点流量的起效时间是毫秒级的，答题可以人为拉长峰值下单的时长，由之前的 &lt;1s 延长到 &lt;10s。这个时间对于服务端非常重要，会大大减轻高峰期并发压力；另外，由于请求具有先后顺序，答题后置的请求到来时可能已经没有库存了，因此根本无法下单，此阶段落到数据层真正的写也就非常有限了</li>
</ol>
<p>需要注意的是，答题除了做正确性验证，还需要对提交时间做验证，比如&lt;1s 人为操作的可能性就很小，可以进一步防止机器答题的情况。</p>
<p>答题目前已经使用的非常普遍了，本质是通过在入口层削减流量，从而让系统更好地支撑瞬时峰值。</p>
<p><strong>1.2 排队</strong></p>
<p>最为常见的削峰方案是使用消息队列，通过把同步的直接调用转换成异步的间接推送缓冲瞬时流量。除了消息队列，类似的排队方案还有很多，例如：</p>
<ol>
<li>线程池加锁等待</li>
<li>本地内存蓄洪等待</li>
<li>本地文件序列化写，再顺序读</li>
</ol>
<p>排队方式的弊端也是显而易见的，主要有两点：</p>
<ol>
<li>请求积压。流量高峰如果长时间持续，达到了队列的水位上限，队列同样会被压垮，这样虽然保护了下游系统，但是和请求直接丢弃也没多大区别</li>
<li>用户体验。异步推送的实时性和有序性自然是比不上同步调用的，由此可能出现请求先发后至的情况，影响部分敏感用户的购物体验</li>
</ol>
<p>排队本质是在业务层将一步操作转变成两步操作，从而起到缓冲的作用，但鉴于此种方式的弊端，最终还是要基于业务量级和秒杀场景做出妥协和平衡。</p>
<p><strong>1.3 过滤</strong></p>
<p>过滤的核心结构在于分层，通过在不同层次过滤掉无效请求，达到数据读写的精准触发。常见的过滤主要有以下几层：</p>
<p>1、读限流：对读请求做限流保护，将超出系统承载能力的请求过滤掉 2、读缓存：对读请求做数据缓存，将重复的请求过滤掉 3、写限流：对写请求做限流保护，将超出系统承载能力的请求过滤掉 4、写校验：对写请求做一致性校验，只保留最终的有效数据</p>
<p>过滤的核心目的是通过减少无效请求的数据IO保障有效请求的IO性能。</p>
<p><strong>1.4 小结</strong></p>
<p>系统可以通过入口层的答题、业务层的排队、数据层的过滤达到流量削峰的目的，本质是在寻求商业诉求与架构性能之间的平衡。另外，新的削峰手段也层出不穷，以业务切入居多，比如零点大促时同步发放优惠券或发起抽奖活动，将一部分流量分散到其他系统，这样也能起到削峰的作用。</p>
<h4>2 Plan B <a href="#item-0-18" id="item-0-18"></a></h4>
<p>当一个系统面临持续的高峰流量时，其实是很难单靠自身调整来恢复状态的，日常运维没有人能够预估所有情况，意外总是无法避免。尤其在秒杀这一场景下，为了保证系统的高可用，必须设计一个 Plan B 方案来进行兜底。</p>
<p>高可用建设，其实是一个系统工程，贯穿在系统建设的整个生命周期。</p>
<p><img src="/images/blog/engineering/system-image_1_1.png" alt="image_1_1.png"></p>
<p>具体来说，系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时，逐一进行分析：</p>
<ol>
<li>架构阶段：考虑系统的可扩展性和容错性，避免出现单点问题。例如多地单元化部署，即使某个IDC甚至地市出现故障，仍不会影响系统运转</li>
<li>编码阶段：保证代码的健壮性，例如RPC调用时，设置合理的超时退出机制，防止被其他系统拖垮，同时也要对无法预料的返回错误进行默认的处理</li>
<li>测试阶段：保证CI的覆盖度以及Sonar的容错率，对基础质量进行二次校验，并定期产出整体质量的趋势报告</li>
<li>发布阶段：系统部署最容易暴露错误，因此要有前置的checklist模版、中置的上下游周知机制以及后置的回滚机制</li>
<li>运行阶段：系统多数时间处于运行态，最重要的是运行时的实时监控，及时发现问题、准确报警并能提供详细数据，以便排查问题</li>
<li>故障发生：首要目标是及时止损，防止影响面扩大，然后定位原因、解决问题，最后恢复服务</li>
</ol>
<p>对于日常运维而言，高可用更多是针对运行阶段而言的，此阶段需要额外进行加强建设，主要有以下几种手段：</p>
<ol>
<li>预防：建立常态压测体系，定期对服务进行单点压测以及全链路压测，摸排水位</li>
<li>管控：做好线上运行的降级、限流和熔断保护。需要注意的是，无论是限流、降级还是熔断，对业务都是有损的，所以在进行操作前，一定要和上下游业务确认好再进行。就拿限流来说，哪些业务可以限、什么情况下限、限流时间多长、什么情况下进行恢复，都要和业务方反复确认</li>
<li>监控：建立性能基线，记录性能的变化趋势；建立报警体系，发现问题及时预警</li>
<li>恢复：遇到故障能够及时止损，并提供快速的数据订正工具，不一定要好，但一定要有</li>
</ol>
<p>在系统建设的整个生命周期中，每个环节中都可能犯错，甚至有些环节犯的错，后面是无法弥补的或者成本极高的。所以高可用是一个系统工程，必须放到整个生命周期中进行全面考虑。同时，考虑到服务的增长性，高可用更需要长期规划并进行体系化建设。</p>
<h4>3 总结一下 <a href="#item-0-19" id="item-0-19"></a></h4>
<p>高可用其实是在说 “稳定性”，稳定性是一个平时不重要，但出了问题就要命的事情，然而它的落地又是一个问题——平时业务发展良好，稳定性建设就会降级给业务让路。解决这个问题必须在组织上有所保障，比如让业务负责人背上稳定性绩效指标，同时在部门中建立稳定性建设小组，小组成员由每条线的核心力量兼任，绩效由稳定性负责人来打分，这样就可以把体系化的建设任务落实到具体的业务系统中了。</p>
<h3>个人总结 <a href="#item-0-20" id="item-0-20"></a></h3>
<p>一个秒杀系统的设计，可以根据不同级别的流量，由简单到复杂打造出不同的架构，本质是各方面的取舍和权衡。当然，你可能注意到，本文并没有涉及具体的选型方案，因为这些对于架构来说并不重要，作为架构师，应该时刻提醒自己主线是什么。</p>
<p>同时也在这里抽象、提炼一下，主要是个人对于秒杀设计的提纲式整理，方便各位同学进行参考——!</p>
<p><img src="/images/blog/engineering/system-image_1_3.png" alt="image_1_3.png"></p>
17:T33d1,<p><a href="https://baijiahao.baidu.com/s?id=1767197729364093558">转载</a></p>
<p>今天，我就来讲讲电商到底该重点关注哪些指标，又该拿这些指标来进行怎么样的分析。</p>
<p>一般来说，在运营模块，需要重点关注的是新用户的引流和转化，以及老用户的活跃、留存、回购、流失。</p>
<p><img src="/images/blog/engineering/business-image_2_1.png" alt="image_2_1.png"></p>
<h2>01 引流</h2>
<p>简单来说，引流就是要吸引没买过我们的商品的人来买我们的商品。</p>
<h2>1. 用户浏览量周分布</h2>
<p>分析这个指标，主要是为了摸索出不同日期、不同时段的流量规律，并据此对企业服务及推广活动进行调整。</p>
<p>对于互联网企业来说，流量数据往往都会呈工作周相关。对此，我们可以先宏观地统计出周一到周日中的总的平台流量柱状图数据对比情况。首先我们可以仔细观察工作日和非工作日的数据，发现周末的平台流量较工作日流量要高，这在互联网行业来说都是一个比较普遍的现象。</p>
<p><img src="/images/blog/engineering/business-image_2_2.png" alt="image_2_2.png"></p>
<p>掌握了用户流量的周分布规律之后，我们就大致有一个推广方向，周末休息时间用户群体较大，相较于工作日可以投入更多的和丰富有吸引力推广活动来进行新用户引流和老用户活跃。</p>
<p>接着我们可以进行下一步思考，那工作日和周末我们的活动推广时间如何制定？</p>
<p>有的同学们可能会觉得全天活动都可以，不需要关注具体的活动时间。但是对于互联网行业来说，每个时间段的推广费用都是较为昂贵的，我们完全可以分析出工作日和周末的用户流量趋势，进行有针对性的时间段投入推广，通过更小的成本获取到更多的用户流入。</p>
<p>首先是工作日的时间段流量统计分布，我们通过FineBI工具分时间段作图得到如下所示的流量分布图。可以看出，工作日的流量主要集成在每日的9点（上班时间）、13点（午餐时间）、20点（晚间娱乐休息时间），那么在得到这样的一些用户流量规律之后，便可以在这些用户活跃高峰期时间段有针对性对白领群体多做一些相关商品推广活动，以实现最小时间成本和推广费用最大化用户引流效果。</p>
<p><img src="/images/blog/engineering/business-image_2_3.png" alt="image_2_3.png"></p>
<p>再来看周末的各时间段流量分布走势，和工作日所不同的是，周末的流量早高峰期延后到了10点，这可能和各位小伙伴们周日作息较晚有关（同学们周末都是几点起床呢），除此之外，晚上的流量高峰退潮期也有延后。针对与周末用户流量分布的特性，互联网企业在周末时可以将活动开始时间和活动结束时间都适当进行延后，这个时候不能再套用工作日制定好的活动时间计划了，因为符合用户群体作息规律的推广促销活动才能达到更好的效果。</p>
<h2>2. 推广渠道流量分布</h2>
<p>电商推广渠道主要有三种：线上渠道（谷歌、百度等），线下渠道（活动、会议等），新媒体营销（微信、小红书等）。</p>
<p>通过对不同推广渠道的流量进行分析，我们可以清晰看出各个渠道对企业带来的价值占比差异，便于制定有针对性的营销策略。<br><img src="/images/blog/engineering/business-image_2_4.png" alt="image_2_4.png"></p>
<p>如上图所示，由于推广渠道是分多层级的，我们通过FineBI工具的多层饼图进行数据的分析统计再合适不过了。分析下图的数据我们可以看出，首先是一级渠道的主要战斗力来自于新媒体营销，当今的微信、知乎等社交媒介社区时代受众广泛，用户群体非常庞大，是公司需要投入主要成本进行推广的。其次线上渠道的效果也不容忽视，对于互联网企业来说，做好百度、Google等SEO搜索引擎关键词推广也是很重要的一部分工作。相较于线上渠道和新媒体营销，线下渠道说所需要的经费和时间、人力成本较大，受众又相对较小，所以此类活动往往针对核心粉丝进行运营即可。</p>
<p><img src="/images/blog/engineering/business-image_2_5.png" alt="image_2_5.png"></p>
<h2>3. 访问深度用户群体分布</h2>
<p>这里涉及到跳失率的概念，即顾客通过相应入口进入，只访问了一个页面就离开的访问次数占该页面总访问次数的比例。跳失率=跳出次数/访问次数。跳失率越低，用户的访问越有深度。</p>
<p><img src="/images/blog/engineering/business-image_2_6.png" alt="image_2_6.png"></p>
<p>如上图所示，我们通过BI工具将企业的VIP用户、老用户、新用户分别进行分时间段的用户群体访问深度分析统计。总体来说可以发现平台的VIP用户访问深度较老用户以及新用户稍微高些，但是不是太明显，说明平台运营的VIP这部分群体的活跃度还有待提升。</p>
<p>同时，平台老用户访问深度和新用户更是相差无几，公司对于用户这方面的活跃运营明显需要加油了，建议将平台的部分忠诚度较高的老用户以VIP用户组建起来，共建平台生态圈，增加整体的用户活跃度。也可以向老用户以及VIP用户实施一些优惠政策，如定向商品折扣、根据用户画像进行喜好商品特惠推送等。</p>
<h2>4. 核心指标对比走势</h2>
<p>主要强调的是核心指标的动态变化。那什么是这里所提及的“核心指标”呢？</p>
<p>不管是电商还是其他互联网行业，往往都需要关注如下指标：</p>
<ul>
<li>浏览量-PV;</li>
<li>访问次数-Visits；</li>
<li>访客数-UV；</li>
<li>平均访问深度（总浏览量/访问次数），</li>
<li>平均停留时间（总停留时间/总浏览量），</li>
<li>跳失率（跳出次数/访问次数）。</li>
</ul>
<p>其中，前面三个指标常常用来衡量流量数据的数量，后面三个指标则多用衡量流量指标的质量。通过对这些指标的动态分析，我们可以很好地评估某一时段推出的营销策略的效果。</p>
<p><img src="/images/blog/engineering/business-image_2_7.png" alt="image_2_7.png"></p>
<p>举个例子，我们仔细分析上图中的平台流量指标，可以发现10月份是2017全年的流量高峰期，应该跟企业在国庆黄金假期所做的促销引流活动有关。浏览量、跳失次数、访问次数分别为4941、1290、2182，对比计算可得到跳失率为59.12%，明显低于其他时间段的跳失率，说明10月份的活动效果还不错，其经验对以后的营销推广可以起到参考作用。</p>
<h2>02 转化</h2>
<p>在通过引流吸引到了新用户的目光之后，往往需要采取一系列的运营策略，实现用户的转化，也就是让用户搜索商品-浏览商品-下单商品-交易付款。在转化阶段，需要重点关注的指标有：下单转化率、事件转化率、服务转化率和退货率。</p>
<h2>1. 下单转化率</h2>
<p>对于平台经营方来说，我们希望一旦有用户流量进入平台网站，他们就能够顺利按照我们平台运营设定好的系列要求一步步进行下去，最终完成交易付款操作。那么对于互联网运营方来说，就需要做好用户在会员注册、商品收藏、购物车添加、交易付款等环节的转化操作。对于这样需要进行逐级转化的平台运营，我们首先可以通过漏斗图进行宏观的流程转化数据分析找出目前阶段最需要优化的运营环节，有效地进行针对性治理，最终提高整体平台用户下单转化率。</p>
<p><img src="/images/blog/engineering/business-image_2_8.png" alt="image_2_8.png"></p>
<p>以上面这个漏斗呈现的信息为例：</p>
<p>首先看用户从浏览商品行为到添加购物车行为这一流程的转化情况，通过漏斗图可以快速看出其转化率为50.77%，反映出该平台的商品介绍、图片描述等对用户有较强的吸引力。</p>
<p>接下来继续看添加购物车到下单的转化率，可以看出其转化率高达99.66%，非常不错。之后却看到单至付款的转化率仅50%，这是一个值得反思的转化节点，通过数据分析猜测该平台商铺支付渠道不完善，需要增加例如支付宝、微信等快捷支付渠道，降低平台因为没有提供用户习惯性的支付渠道而导致用户放弃购买行为的几率。</p>
<h2>2、事件转化率</h2>
<p>事件转化率通常指的是平台或商铺通过一系列的运营推广活动以及由于公共事件影响所带来的额外价值。这一指标对于平台运营评估和指导市场推广运营活动极为重要，例如网络营销总的SEO关键词投放、折扣促销活动、邮件营销等等效果跟踪。关于事件转化率方面的数据分析，通常我们可关注于营销渠道转化率、会员转化率、店铺流量转化率、下单转化率等指标进行活动的推广营销效果评估。</p>
<p>利用BI工具，首先分析出各个营销推广渠道的转化率环形玫瑰分布图。可以看出目前平台的转化率最高的渠道主要是基础上线工作、SEO关键词推广、微信推广、品牌推广几个渠道。同时我们想联动查看每个渠道对应的转化率数据时，通过BI工具提供的数据自动联动过滤功能让用户无需任何设置即可进行所有相关联的数据联动。</p>
<p><img src="/images/blog/engineering/business-image_2_9.png" alt="image_2_9.png"></p>
<p>除了以上渠道营销策略之外，对于平台商铺而言，合适的关联性商品推荐也能够提高用户对关联商品的购买率，比如用户在购买完服装之后可以再给他推送鞋子一类商品。另外关于事件转化率方面，由于季节性以及公共事件也会影响商品的下单转化率，针对不同时期较流行的商品进行进货营销往往才能够达到最大的盈利目的。</p>
<p><img src="/images/blog/engineering/business-image_2_10.png" alt="image_2_10.png"></p>
<h2>3、服务转化率</h2>
<p>服务转化率方面，通常用户在网上购买商品时，对于商品的一些细节品质以及发货渠道和速度等会需要做一些了解。那么良好的服务自然能够提高顾客的购买率，对于平台的客户人员，我们可以统计处其咨询到下单的节点转化率，并且以咨询到下单的转换率指标作为KPI指标之一来评价客服人员的工作绩效。</p>
<p>如下图所示，通过BI工具进行客服咨询下单转化率条形图的数据分析统计可以发现，该平台的Blanche、Henry、Christian、汉克、贝蒂这五名客服的转化率比较优秀，并且都在10%以上，其他的客服员工的转化率则相对较低，故而这方面可以让转化率最为优秀的Blanche客服给其他客服做一次服务培训，整体上提升平台的服务水平，进而提升用户的下单转化率。</p>
<p><img src="/images/blog/engineering/business-image_2_11.png" alt="image_2_11.png"></p>
<h2>4、退货率</h2>
<p>对于用户而言退货的原因通常可分为两大类，一类是由于买到的商品质量有问题而申请退货，另外一类可能是由于用户自身原因想申请退货。平台方往往更为需要关注第一类因为商品质量问题而申请退货的商品，通过历史商品的质量原因退货数据统计分析，对于确确实实是存在质量问题的商品需要及时反馈给供应商，质量过于严重的话可以考虑该类商品和供应商的协商库存退货。</p>
<h2>03 留存</h2>
<p>新用户转化成功，变成老用户之后，我们需要着重关注留存问题，简而言之就是关注怎么做才能留住客户的心。</p>
<p>我们可以从宏观上来定义平台的留存用户：在互联网行业中，用户在某段时间内开始使用应用，经过一段时间后，仍然继续使用该应用的用户，被认作是留存用户。我们往往希望留存用户越多越好。</p>
<p>一般来说，留存方面，需要关注如下指标：</p>
<h2>1. 次日/7日/30日留存</h2>
<p>即某天新增的用户中，在次日/7天后/30天后依然”活跃“（比如有浏览行为、收藏行为、购买行为等）的比例。</p>
<p>不同时长的留存率分析可以折射出不同的问题。一般而言，分析次日留存率有利于抓住产品的品质变动和渠道优势；7日留存率可以体现出一个较为完整的周期后的用户去留情况；30日留存率可以反应产品或渠道迭代后的稳定性，协助判断演进方向的合理性。</p>
<p><img src="/images/blog/engineering/business-image_2_12.png" alt="image_2_12.png"></p>
<h2>2. 渠道留存</h2>
<p>不同渠道的用户质量往往是不尽相同的。再考虑留存率的同时，对比留存渠道，可以进行更高质量的广告投放。</p>
<p><img src="/images/blog/engineering/business-image_2_13.png" alt="image_2_13.png"></p>
18:T55bd,<h2>摘要</h2>
<p>语言的本质是什么？本文提出一个鲜明命题：<strong>没有文字与符号系统支撑的声音至多是信号，不足以构成“语言”</strong><br>。文字让声音获得切分、记忆、跨代传承与逻辑组织的能力，是语言成为文明工具的<strong>根本条件</strong>。<br>20 世纪中叶，乔姆斯基以“普遍语法（UG）”与“语言习得装置（LAD）”解释儿童习得的速度与普遍性，由此重塑现代语言学图景。但在田野语言学、神经科学、儿童发展与社会语言学等维度上，UG<br>面临越来越多的反证与挑战。<br>本文在系统梳理历史与证据的基础上，提出一个<strong>神经网络语言习得模型</strong>：儿童习得快并非源于预装的“语法模板”，而是由于<strong>神经网络高可塑性<br><strong>与</strong>第一语言的独占写入优势</strong>；成人学习第二语言之所以困难，在于<strong>已有网络的干扰与寻址成本</strong>。最终我们回到起点：**文字先于语言<br>**，符号系统奠定语言的稳定性与复杂性；声学层面的“会说”，离文明意义上的“有语言”，还差一个文字世界。</p>
<h2>引言</h2>
<p>人类常以“语言动物”自居，但语言究竟靠什么从声音跃升为文明？日常经验会诱使我们把“会说话”当作语言的全部，忽略了文字为声音提供的稳定支架。动物的叫声与人类的口语在声学层面并无高下，但<br><strong>文字</strong>将声音锚定为可见、可存、可传之“符号”，再把符号编织成逻辑体系与社会制度。<br>20<br>世纪的“普遍语法”强调语言的“天生性”，把儿童习得的速度归因于大脑“模板”。然而，越来越多的跨学科证据在问一个更贴近现实的问题：**<br>如果没有符号与文字的环境，所谓“语言”还能发展到何种程度？**本文将沿“历史—证据—模型—反思”的脉络，提出对 UG<br>的系统性批判，并给出一套以神经网络与资源分配为核心的替代模型，最终回到“文字是语言的根本”的主张。</p>
<h2>一、语言与文字的区别</h2>
<h3>1.1 声音与信号</h3>
<p>在自然界，声音首先是一种<strong>生理—物理事件</strong>：气流推动声带振动，经腔体共鸣，由空气传播。鸟鸣、猩猩的呼号、鲸豚的声纳，都可以完成信号传递：告警、求偶、领地。<br><strong>信号</strong>的共同特征是<strong>即时性</strong>与<strong>功能性</strong>——它们有效，却难以脱离当下环境而被<strong>稳定地保存与重构</strong>。<br>人类的口语如果不进入符号系统，也只是更复杂的“叫声”。人可以即兴编出千百句，但倘若没有<strong>外部化的记忆介质</strong><br>，这些句子在扩散中会以惊人的速度消散、变形，无法累积为可检索、可校正、可再加工的知识。于是，**“会发音”与“有语言”之间隔着一个文明的门槛<br>**。</p>
<h3>1.2 文字的重要性</h3>
<p><strong>文字</strong>是语言从“声学行为”过渡为“文明工程”的关键发明。其作用至少体现在四个维度：<br><strong>（1）切分</strong>：口语是连续的时间流。文字用视觉空间把它<strong>切成单位</strong>（音节、词、短语、句），由此才能定义、规范与比较。<br><strong>（2）存储</strong>：文字让信息<strong>固化</strong>在介质上（龟甲、竹简、羊皮纸、纸张、硬盘），避免“记忆衰减”。<br><strong>（3）传承</strong>：文字突破个体寿命与社交半径，实现<strong>跨代扩散</strong>；语言由此获得<strong>校对与纠错机制</strong>。<br><strong>（4）逻辑</strong>：抽象推理、递归结构、数学与法典等<strong>复杂组织</strong>，需要在外部符号上反复操作，纯口语难以承载这类高精度任务。<br>“日”之为“日”，不仅是一个发音，更是一个<strong>视觉符号</strong>，它把感知中的太阳稳定地<strong>指称</strong>出来。声音“rì”若失去“日”的符号锚点，就像空气中的水汽，无处聚合为湖海。</p>
<h3>1.3 动物“语言”与人类语言的边界</h3>
<p>鹦鹉能模仿人类发音，黑猩猩能学习若干手势或图形符号，这些成果令人惊叹，却仍停留在<strong>信号操作</strong>阶层。它们缺少以文字为核心的*<br><em>抽象记忆平台<strong>与</strong>公共校准机制*</em>，不能形成复杂的句法网络与跨代积累的<strong>符号传统</strong>。<br>“狼孩”案例更像是一面镜子：<strong>缺乏符号—文字环境</strong>的人类个体，纵使拥有人类的器官与大脑，也难以在后天完整搭建语言系统。这不是能力“未被唤醒”，而是<br><strong>缺了语言赖以耸立的地基</strong>。</p>
<h2>二、普遍语法的兴起与局限</h2>
<h3>2.1 行为主义的困境</h3>
<p>20<br>世纪上半叶，美国语言学受行为主义影响深重。语言被视为“刺激—反应—强化”的产物：儿童模仿成人，成人用奖惩塑形。该观点难以解释三件事：<br><strong>其一</strong>，儿童<strong>速度惊人</strong>的语法建构能力；<br><strong>其二</strong>，儿童频繁产出**“未输入过”的句子**；<br><strong>其三</strong>，儿童的“错误”常呈现<strong>系统性</strong>，像在“推演规则”而非照搬句子。<br>行为主义由此陷入解释危机：如果不是机械模仿，那么<strong>语法从何而来</strong>？</p>
<h3>2.2 乔姆斯基的提出</h3>
<p>1957 年，乔姆斯基以《句法结构》引入“生成语法”，随后提出“普遍语法（UG）”与“语言习得装置（LAD）”——<strong>语言的核心结构是人类大脑的天生属性<br><strong>，儿童只需在稀疏输入下</strong>触发</strong>模板即可。<br>UG 有两把解决问题的钥匙：<br><strong>一把</strong>是“形式化”——用规则系统表示句法，使语言学看起来更像自然科学；<br><strong>另一把</strong>是“先天性”——用“模板”解释儿童习得的速度与普遍模式，似乎一招化解行为主义的难题。<br>凭借这两把钥匙，UG 获得冷战时期对<strong>形式系统</strong>与<strong>可计算模型</strong>的制度性追捧。</p>
<h3>2.3 UG 的问题初现</h3>
<p>然而，UG 从一开始就埋下了三个麻烦：<br><strong>（1）范围错置</strong>：它聚焦“声音的习得”，却被等同于“语言的起源”。<strong>忽视文字/符号的奠基作用</strong>，导致解释对象与真实语言工程<strong>不匹配<br><strong>。<br><strong>（2）证伪困难</strong>：凡遇反例，往往以“特例”回避，呈现</strong>自我免疫</strong>的倾向。<br><strong>（3）跨学科脱节</strong>：与神经科学、发展心理、社会语言学的证据<strong>耦合不足</strong>，越来越难与经验事实对齐。</p>
<h2>三、学术界的挑战与证据</h2>
<h3>3.1 田野语言学：递归并非“普遍”</h3>
<p>田野语言学把语言从课堂带回人群。以亚马逊流域的某些语言为例，研究者长期观察到一种令人不安的事实：<strong>递归并非无处不在</strong>。他们经常采用<br><strong>短句并列</strong>而非<strong>层层嵌套</strong>来表达复杂含义；他们的数字体系与颜色词汇也显著依赖<strong>情境与比喻</strong>而非抽象范畴。<br>这并不是“能力缺陷”，而是<strong>文化生态</strong>的合理选择：当一个社会以“即时经验”为价值核心，语言自然会倾向<strong>眼前、可证、可感</strong>的表达方式。对<br>UG 而言，这一事实至少说明：<strong>把某种句法操作（如递归）当作“普遍属性”是不严谨的</strong>。语言的形态深受<strong>文化、生产方式与社会结构</strong><br>塑形，而不是由一块“先天模板”强行刻画。</p>
<h3>3.2 神经科学：可塑性胜于“模板”</h3>
<p>神经影像学的进展揭示：<strong>语言学习改变大脑</strong>。白质通路的<strong>髓鞘化程度</strong>、灰质区域的<strong>厚度与活动模式</strong><br>，都会随着语言输入与训练而变化。与其说“大脑里有现成的语法芯片”，不如说大脑像一张<strong>可重构的网络</strong>：输入<strong>在哪里密集、稳定、重复<br><strong>，网络就向哪里</strong>加粗、加权、固化</strong>。<br>尤其在儿童期，大脑表现出<strong>极高的突触可塑性</strong>：新的连接更容易建立与巩固，旧的连接也更容易被<strong>修剪</strong>以让位于高效路径。这种“重布线”的机制，是对“<br><strong>学习=资源分配</strong>”这一朴素直觉的生物学证成。</p>
<h3>3.3 儿童习得：关键期与“第一语言优势”</h3>
<p>发展心理学与临床案例显示：<strong>语言习得存在关键期</strong>。在关键期内，海量、稳定且具有交互性的输入能迅速重塑网络；一旦越过这一窗口，学习同样内容的<br><strong>边际成本</strong>陡增。<br>进一步的对比发现：</p>
<ul>
<li><strong>单语儿童</strong>的第一语言往往习得迅速；</li>
<li><strong>双语儿童</strong>因资源在两种输入间竞争，速度略慢，但在合适环境下仍能达成高水平；</li>
<li><strong>成年人</strong>学习第二语言常受母语干扰，语音—句法层面的<strong>迁移成本</strong>显著。<br>这组事实更符合“<strong>第一语言独占写入</strong>+<strong>可塑性递减</strong>+<strong>干扰成本</strong>”的框架，而不是“模板被触发”的故事。</li>
</ul>
<h3>3.4 听觉加工：从低层机制到高层语言</h3>
<p>婴幼儿对<strong>节律、时长、频率变化</strong>等低层听觉特征的敏感性，能预测其后续的<strong>词汇增长</strong>与<strong>音位类别</strong>分化能力。换言之，语言的高层表现在很大程度上<br><strong>以低层处理为地基</strong>。<br>如果“语法模板”是决定性因素，那么对低层听觉加工的个体差异为何如此强烈地<strong>牵动</strong>语言发展？合理的解释是：语言的“塔尖”并非自天而降，它<br><strong>沿神经处理的阶梯</strong>逐级建起。</p>
<h3>3.5 社会语言学：语言服从文化—文字的任务</h3>
<p>比较不同社会的语言生态可见：</p>
<ul>
<li>在<strong>以文字为枢纽</strong>的社会，语言承担<strong>法律、学术、技术、金融</strong>等高复杂任务，外部符号的“二次加工”把语言推上文明的高地；</li>
<li>在<strong>口传传统</strong>中，语言的任务更偏向<strong>仪式、叙事、谚语</strong>与<strong>当场沟通</strong>，信息的<strong>精确累积</strong>受限。<br>这不是“高低之分”，而是<strong>媒介之别</strong>。当语言要背上文明重负，它需要文字的<strong>稳定平台</strong>与<strong>可复核机制</strong>。UG 对此语焉不详，而“语言—文字—制度”的<br><strong>三角结构</strong>，却恰恰是语言成为文明工具的真实路径。</li>
</ul>
<h2>四、普遍语法的逻辑漏洞</h2>
<h3>4.1 自我免疫：不可证伪</h3>
<p>一个理论若总能用“特例”“非核心”来回避反证，就容易滑向<strong>不可证伪</strong>。UG 面临的恰是这种尴尬：当递归遭遇反例，理论不是更新边界，而是<br><strong>收缩定义</strong>以保全自身。科学需要通过失败来变得更强，而非通过<strong>免疫</strong>来维持体面。</p>
<h3>4.2 第一个人的悖论：语言从何点燃</h3>
<p>如果语言“天生”，那么<strong>第一个人</strong>如何在无语言环境中启动模板？“关键期未触发”的回答把问题向后推，却没回答<strong>无输入如何点火</strong><br>。反观“符号—文字先行”的路线：当一群人开始用<strong>外部符号</strong>稳固指称、积累与校准时，语言才逐渐获得<strong>制度化的生命</strong>。</p>
<h3>4.3 与动物的差距并不在“叫得更像人”</h3>
<p>若把“会发很多、很复杂的声音”当作语言的本质，人类与某些高智能动物之间的差距并不决定性。真正拉开鸿沟的，是<strong>文字—符号平台</strong>带来的<br><strong>重写、校对、递归外化</strong>与<strong>跨代工程化</strong>能力。UG 淡化了媒介因素，因而在“文明分水岭”的解释上显得<strong>力有不逮</strong>。</p>
<h3>4.4 神学化叙事：模板从何而来</h3>
<p>UG 将复杂解释折叠为一个优雅设定：<strong>模板</strong>。但模板来源何在、如何进化、有哪些解剖学基座、如何与发展轨迹耦合，答案常被“先天—后天”的二元对立吞没。一个解释若主要靠<br><strong>设定</strong>而稀缺<strong>机制</strong>与<strong>证据</strong>，就难免沾上神学色彩。</p>
<h2>五、什么是“习得模型”：定义、范式与对比</h2>
<h3>5.1 习得的概念</h3>
<p>“习得（acquisition）”指<strong>在自然互动中自发内化</strong>语言的过程，与课堂式“学习（learning）”相对。<strong>习得模型</strong>就是对这一过程的**机制性解释<br>**：输入如何被加工、知识如何刻写、规则如何抽象、限制如何出现。</p>
<h3>5.2 三类经典范式</h3>
<p><strong>（1）行为主义范式</strong>：模仿＋强化，但忽略生成性与系统错误。<br><strong>（2）普遍语法范式</strong>：先天模板＋触发，但遭遇证伪与生物学证据贫乏。<br><strong>（3）使用—认知范式</strong>：从<strong>频率、共现、构式</strong>中抽象规则，强调<strong>一般学习机制</strong>与<strong>社会互动</strong>。<br>三者各有所长，但要解释“儿童快—成人慢”“一语快—二语慢”“媒介改变语言命运”这些事实，还需要更贴近<strong>神经与资源</strong>的模型。</p>
<h3>5.3 我们的定位</h3>
<p>本文的<strong>神经网络语言习得模型</strong>，是一个“<strong>资源—可塑性—干扰</strong>”的综合框架：它既继承使用—认知范式对<strong>频率与互动</strong>的重视，也把“*<br><em>神经可塑性与资源分配</em><em>”作为导致速度差异的*<em>第一性原理</em></em>。</p>
<h2>六、神经网络语言习得模型</h2>
<h3>6.1 基本假设：网络、容量与代价</h3>
<p>把大脑看作一个<strong>可塑的神经网络</strong>：</p>
<ul>
<li><strong>容量</strong>并非无限，需要在任务间<strong>竞争</strong>；</li>
<li><strong>可塑性</strong>随年龄<strong>递减</strong>，早期“写入”更轻松；</li>
<li><strong>代价</strong>来自<strong>寻址</strong>（把新信息安置到有效位置）与<strong>干扰</strong>（与旧网络冲突）。</li>
</ul>
<h3>6.2 第一语言的“独占写入”</h3>
<p>新生儿的网络相当于一个<strong>资源富足的空盘</strong>。第一语言在<strong>高频—高一致性—高情境依托</strong>的环境中写入，几乎无竞争、无冲突、无替代项。孩子不是在“选择规则”，而是在<br><strong>把频率最高的模式固化为路径</strong>。此时形成的<strong>主干通路</strong>将成为之后语言处理的<strong>默认高速路</strong>。</p>
<h3>6.3 第二语言的“碎片化写入”</h3>
<p>当网络已有一套稳固主干，第二语言的写入要么<strong>复用旧通路</strong>、要么<strong>旁路新建</strong>。两种方案都带来成本：复用会引发<strong>母语迁移</strong><br>与“假朋友”，旁路会面对<strong>稀疏输入</strong>与<strong>低频巩固</strong>的困境。成人常见的<strong>口音难改、语序僵硬、形态错误</strong>，是<strong>高代价寻址</strong>的外化表征。</p>
<h3>6.4 机制细化：从输入到通路</h3>
<p><strong>（1）统计依赖</strong>：高频共现触发<strong>Hebbian</strong>式增强（“一起放电的连在一起”），形成<strong>搭配</strong>与<strong>构式</strong>的早期雏形。<br><strong>（2）层级抽象</strong>：多次在<strong>不同词项</strong>上复现同一<strong>句式图谱</strong>，网络提炼出<strong>不依赖具体词的结构槽</strong>（如 SVO）。<br><strong>（3）误差驱动</strong>：预测失败带来<strong>误差信号</strong>，促成微调；儿童的“系统性错误”正是<strong>活跃抽象</strong>的证据。<br><strong>（4）资源整形</strong>：反复成功—巩固—惩罚—修剪，使<strong>白质通路</strong>更顺滑、<strong>灰质回路</strong>更高效。</p>
<h3>6.5 预测与可检验点</h3>
<ul>
<li><strong>预测一</strong>：在等量输入下，<strong>单语儿童</strong>的写入速度高于<strong>双语儿童</strong>；成人二语最低。</li>
<li><strong>预测二</strong>：<strong>交互式输入</strong>优于<strong>被动暴露</strong>，因其提供更强的<strong>误差信号</strong>与<strong>注意引导</strong>。</li>
<li><strong>预测三</strong>：脑影像应显示第一语言主干通路<strong>髓鞘化更充分</strong>，二语更多借助<strong>旁路/跨区协作</strong>。</li>
<li><strong>预测四</strong>：高强度、短期、沉浸的二语训练可在<strong>白质</strong>与<strong>功能连接</strong>上留下可测痕迹。</li>
</ul>
<h3>6.6 与 AI 的启示性类比</h3>
<p>深度学习里，<strong>预训练—微调</strong>与<strong>迁移—遗忘</strong>的张力，几乎是“成人学二语”的技术隐喻：已有模型越强，新任务越容易被<strong>旧先验</strong><br>扭曲；若不提供足量的新数据与适当的正则策略，就会出现<strong>灾难性遗忘</strong>或<strong>固着</strong>。这不是把人等同机器，而是说明**<br>“资源—可塑—干扰”是一条跨系统的普遍规律**。</p>
<h2>七、文字先于语言：媒介如何决定上限</h2>
<h3>7.1 从记号到文字：外部化记忆的革命</h3>
<p>早期社会的<strong>刻痕、结绳、图画</strong>，已是在把经验外部化。真正的<strong>文字</strong>出现后，信息第一次可以<strong>脱离说话者的身体</strong>，拥有**客观、可复核的存在<br>**。语言因此从“对话事件”跃升为“<strong>知识工程</strong>”：可被归档、检索、扩展与驯化。</p>
<h3>7.2 文字让语言具备“文明任务能力”</h3>
<p>没有文字，语言难以胜任<strong>法典化</strong>（可执行的通则）、<strong>科学化</strong>（可积累的模型）、<strong>财政金融化</strong>（可核算的账目）等高复杂任务。口述传统可以伟大，但<br><strong>对精确度与可重复性</strong>的约束不同。语言的文明上限，强烈依赖其<strong>文字基础设施</strong>。</p>
<h3>7.3 儿童习得与文字环境</h3>
<p>儿童从出生便浸泡在<strong>标识、标签、图书、屏幕、作业本</strong>构成的符号景观中。即使在开口之前，他们已经在与<strong>文字世界</strong><br>对接：看见图标，指向书页，模仿书写。所谓“习得速度”，本质上是<strong>早期符号化环境+高可塑网络</strong>的乘积。狼孩之困，不是“没有触发模板”，而是<br><strong>缺了符号土壤</strong>。</p>
<h2>八、可能的反驳与回应</h2>
<p><strong>反驳一：许多社会在文字出现之前也有语言。</strong><br><strong>回应</strong>：可以有高效口语的社会，但没有文字的口语<strong>难以</strong>达到“文明工程”的稳定度与精准度。我们讨论的“语言”，不是“会说”的最低标准，而是<br><strong>能支撑复杂制度</strong>的语言。</p>
<p><strong>反驳二：UG 提供了优雅的解释，何必替代？</strong><br><strong>回应</strong>：优雅不是充分条件。面对反例与跨学科证据，一个理论应当<strong>更新或让位</strong>。把“模板”当作终点，阻滞了对<strong>机制</strong>与<strong>媒介</strong><br>的深入研究。</p>
<p><strong>反驳三：你的模型也需要强证据。</strong><br><strong>回应</strong>：正因此我们把模型设计为<strong>可预测、可测量、可证伪</strong>：输入—通路—行为三位一体的指标链条，允许实验室与田野相互校验。理论的价值在于<br><strong>生产可被打败的预言</strong>。</p>
<h2>结论</h2>
<p>本文从一个简单却常被忽略的起点出发：<strong>文字是语言的根本</strong><br>。没有文字—符号的承托，声音至多是信号；有了文字，语言才拥有切分、存储、传承与逻辑的骨架，得以承担文明的高复杂任务。<br>以此为参照，我们重审普遍语法：它以“模板”解释习得速度，却在范围、证伪与跨学科耦合上暴露出结构性弱点。随后我们提出<strong>神经网络语言习得模型<br><strong>：把儿童优势还原为</strong>高可塑网络上的第一语言独占写入</strong>，把成人二语的困境解释为<strong>寻址与干扰的代价</strong>。<br>语言不是从大脑里“预装”的一块黑盒芯片，而是<strong>神经网络 × 输入统计 × 符号媒介 × 社会制度</strong>的协同产物。回到起点，<strong>文字</strong><br>并非语言的装饰，而是语言得以成为文明的<strong>地基与脚手架</strong>。当我们在纸上、屏幕上与数据库里持续写下并校正自己的声音，语言才真正开始——并得以继续。</p>
19:T3749,<p>记得很久之前，去面试过<strong>字节跳动</strong>。被三面的面试官问了一道场景设计题目：<strong>如何设计一个高并发系统</strong>。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。</p>
<p><img src="/images/blog/engineering/system-image_3_1.png" alt="image_3_1.png"></p>
<h3>如何理解高并发系统 <a href="#item-0-1" id="item-0-1"></a></h3>
<p>所谓设计<strong>高并发</strong>系统，就是设计一个系统，保证它<strong>整体可用</strong>的同时，能够<strong>处理很高的并发用户请求</strong>，能够承受<strong>很大的流量冲击</strong>。</p>
<p>我们要设计高并发的系统，那就需要处理好一些常见的系统瓶颈问题，如<strong>内存不足、磁盘空间不足，连接数不够，网络宽带不够</strong>等等，以应对突发的流量洪峰。</p>
<h3>1. 分而治之，横向扩展 <a href="#item-0-2" id="item-0-2"></a></h3>
<p>如果你<strong>只部署一个应用，只部署一台服务器</strong>，那抗住的流量请求是非常有限的。并且，单体的应用，有单点的风险，如果它挂了，那服务就不可用了。</p>
<p>因此，设计一个高并发系统，我们可以<strong>分而治之，横向扩展</strong>。也就是说，采用分布式部署的方式，部署多台服务器，把流量分流开，让每个服务器都承担一部分的并发和流量，提升<strong>整体系统的并发能力</strong>。</p>
<h3>2. 微服务拆分（系统拆分） <a href="#item-0-3" id="item-0-3"></a></h3>
<p>要提高系统的吞吐，提高系统的处理并发请求的能力。除了采用<strong>分布式部署的方式</strong>外，还可以做<strong>微服务拆分</strong>，这样就可以达到分摊请求流量的目的，提高了并发能力。</p>
<p>所谓的<strong>微服务拆分</strong>，其实就是把一个单体的应用，按功能单一性，拆分为多个服务模块。<strong>比如一个电商系统，拆分为用户系统、订单系统、商品系统等等</strong>。</p>
<p><img src="/images/blog/engineering/system-image_3_2.png" alt="image_3_2.png"></p>
<h3>3. 分库分表 <a href="#item-0-4" id="item-0-4"></a></h3>
<p>当业务量暴增的话，MySQL单机<strong>磁盘容量会撑爆</strong>。并且，我们知道数据库连接数是有限的。<strong>在高并发的场景下</strong>，大量请求访问数据库，<code>MySQL</code>单机是扛不住的！高并发场景下，会出现<code>too many connections</code>报错。</p>
<p>所以高并发的系统，<strong>需要考虑拆分为多个数据库，来抗住高并发的毒打</strong>。而假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做<strong>分表</strong>了。一般千万级别数据量，就需要<strong>分表</strong>，每个表的数据量少一点，提升SQL查询性能。</p>
<p>当面试官问要求你设计一个高并发系统的时候，一般都要说到<strong>分库分表</strong>这个点。</p>
<h3>4. 池化技术 <a href="#item-0-5" id="item-0-5"></a></h3>
<p>在高并发的场景下，<strong>数据库连接数</strong>可能成为瓶颈，因为连接数是有限的。</p>
<p>我们的请求调用数据库时，都会先获取数据库的连接，然后依靠这个连接来查询数据，搞完收工，最后关闭连接，释放资源。如果我们不用数据库连接池的话，每次执行<code>SQL</code>，都要创建连接和销毁连接，这就会导致每个查询请求都变得更慢了，相应的，系统处理用户请求的能力就降低了。</p>
<p>因此，需要使用池化技术，即<strong>数据库连接池、HTTP 连接池、Redis 连接池</strong>等等。使用数据库连接池，可以避免每次查询都新建连接，减少不必要的资源开销，通过复用连接池，<strong>提高系统处理高并发请求的能力</strong>。</p>
<p>同理，我们使用线程池，也能<strong>让任务并行处理，更高效地完成任务</strong>。</p>
<h3>5. 主从分离 <a href="#item-0-6" id="item-0-6"></a></h3>
<p>通常来说，一台单机的MySQL服务器，可以支持<code>500</code>左右的<code>TPS</code>和<code>10000</code>左右的<code>QPS</code>，即单机支撑的<strong>请求访问是有限</strong>的。因此你做了分布式部署，部署了多台机器，部署了主数据库、从数据库。</p>
<p>但是，如果双十一搞活动，流量肯定会猛增的。如果所有的查询请求，都走主库的话，主库肯定扛不住，因为查询请求量是非常非常大的。因此一般都要求做<strong>主从分离</strong>，然后实时性要求不高的读请求，都去读从库，<strong>写的请求或者实时性要求高的请求，才走主库</strong>。这样就很好保护了主库，也提高了系统的吞吐。</p>
<p>当然，如果回答了主从分离，面试官可能扩展开问你<strong>主从复制原理，问你主从延迟问题</strong>等等，这块大家需要<strong>全方位复习好</strong>哈。</p>
<h3>6. 使用缓存 <a href="#item-0-7" id="item-0-7"></a></h3>
<p>无论是操作系统，浏览器，还是一些复杂的中间件，你都可以看到缓存的影子。我们使用缓存，主要是提升系统接口的性能，这样高并发场景，你的系统就可以支持更多的用户同时访问。</p>
<p>常用的缓存包括：<code>Redis</code>缓存，<code>JVM</code>本地缓存，<code>memcached</code>等等。就拿<code>Redis</code>来说，它单机就能轻轻松松应对几万的并发，你读场景的业务，可以用缓存来抗高并发。</p>
<p>缓存虽然用得爽，但是要<strong>注意缓存使用的一些问题</strong>：</p>
<ul>
<li>缓存与数据库的一致性问题</li>
<li>缓存雪崩</li>
<li>缓存穿透</li>
<li>缓存击穿</li>
</ul>
<h3>7. CDN，加速静态资源访问 <a href="#item-0-8" id="item-0-8"></a></h3>
<p>商品图片，<code>icon</code>等等静态资源，可以对页面做<strong>静态化处理，减少访问服务端的请求</strong>。如果用户分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到页面，可以使用<code>CDN</code>。<code>CDN</code>可以让用户就近获取所需内容。</p>
<p>什么是CDN？</p>
<blockquote>
<p>Content Delivery Network/Content Distribution Network,翻译过来就是内容分发网络，它表示将静态资源分发到位于多个地理位置机房的服务器，可以做到数据就近访问，加速了静态资源的访问速度，因此让系统更好处理正常别的动态请求。</p>
</blockquote>
<h3>8. 消息队列，削锋 <a href="#item-0-9" id="item-0-9"></a></h3>
<p>我们搞一些双十一、双十二等运营活动时，需要<strong>避免流量暴涨，打垮应用系统的风险</strong>。因此一般会引入消息队列，来应对<strong>高并发的场景</strong>。</p>
<p><img src="/images/blog/engineering/system-image_3_3.png" alt="image_3_3.png"></p>
<p>假设你的应用系统每秒最多可以处理<code>2k</code>个请求，每秒却有<code>5k</code>的请求过来，可以引入消息队列，应用系统每秒从消息队列拉<code>2k</code>请求处理得了。</p>
<p>有些伙伴担心这样可能会出现<strong>消息积压</strong>的问题：</p>
<ul>
<li>首先，搞一些运营活动，不会每时每刻都那么多请求过来你的系统（<strong>除非有人恶意攻击</strong>），高峰期过去后，积压的请求可以慢慢处理；</li>
<li>其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；</li>
</ul>
<h3>9. ElasticSearch <a href="#item-0-10" id="item-0-10"></a></h3>
<p><code>Elasticsearch</code>，大家都使用得比较多了吧，<strong>一般搜索功能都会用到它</strong>。它是一个分布式、高扩展、高实时的搜索与数据分析引擎，简称为<code>ES</code>。</p>
<p>我们在聊高并发，为啥聊到<code>ES</code>呢？因为<code>ES</code>可以扩容方便，天然支撑高并发。<strong>当数据量大的时候，不用动不动就加机器扩容，分库等等</strong>，可以考虑用<code>ES</code>来支持简单的查询搜索、统计类的操作。</p>
<h3>10. 降级熔断 <a href="#item-0-11" id="item-0-11"></a></h3>
<p><strong>熔断降级</strong>是保护系统的一种手段。当前互联网系统一般都是分布式部署的。而分布式系统中偶尔会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为<strong>服务雪崩效应</strong>。</p>
<p>比如分布式调用链路<code>A-&gt;B-&gt;C....</code>，下图所示：</p>
<p><img src="/images/blog/engineering/system-image_3_4.png" alt="image_3_4.png"></p>
<blockquote>
<p>如果服务<code>C</code>出现问题，比如是因为慢<code>SQL</code>导致调用缓慢，那将导致<code>B</code>也会延迟，从而<code>A</code>也会延迟。堵住的<code>A</code>请求会消耗占用系统的线程、IO、CPU等资源。当请求<code>A</code>的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。</p>
</blockquote>
<p>为了应对服务雪崩, 常见的做法是<strong>熔断和降级</strong>。最简单是加开关控制，当下游系统出问题时，开关打开降级，不再调用下游系统。还可以选用开源组件<code>Hystrix</code>来支持。</p>
<p>你要保证设计的系统能应对<strong>高并发场景</strong>，那肯定要考虑<strong>熔断降级</strong>逻辑进来。</p>
<h3>11. 限流 <a href="#item-0-12" id="item-0-12"></a></h3>
<p>限流也是我们应对高并发的一种方案。我们当然希望，在高并发大流量过来时，系统能全部请求都正常处理。但是有时候没办法，系统的CPU、网络带宽、内存、线程等资源都是有限的。因此，我们要考虑限流。</p>
<p>如果你的系统每秒扛住的请求是一千，<strong>如果一秒钟来了十万请求呢</strong>？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？</p>
<p>这时候，我们可以采取限流方案。就是为了保护系统，多余的请求，直接丢弃。</p>
<blockquote>
<p><strong>什么是限流</strong>：在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。</p>
</blockquote>
<p>可以使用<code>Guava</code>的<code>RateLimiter</code>单机版限流，也可以使用<code>Redis</code>分布式限流，还可以使用阿里开源组件<code>sentinel</code>限流。</p>
<p>面试的时候，你说到限流这块的话？面试官很大概率会问你限流的算法，因此，大家在准备面试的时候，需要复习一下这几种经典的限流算法哈</p>
<h3>12. 异步 <a href="#item-0-13" id="item-0-13"></a></h3>
<blockquote>
<p>回忆一下什么是同步，什么是异步呢？以<strong>方法调用</strong>为例，它代表<strong>调用方要阻塞等待被调用方法中的逻辑执行完成</strong>。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。</p>
</blockquote>
<p>因此，设计一个高并发的系统，<strong>需要在恰当的场景使用异步</strong>。如何使用异步呢？后端可以借用消息队列实现。比如在海量秒杀请求过来时，先放到消息队列中，快速响应用户，告诉用户请求正在处理中，这样就可以释放资源来处理更多的请求。秒杀请求处理完后，通知用户秒杀抢购成功或者失败。</p>
<h3>13. 接口的常规优化 <a href="#item-0-14" id="item-0-14"></a></h3>
<p>设计一个高并发的系统，需要设计接口的性能足够好，这样系统在相同时间，就可以处理更多的请求。当说到这里的话，可以跟面试官说说接口优化的一些方案了。</p>
<p><img src="/images/blog/engineering/system-image_3_5.png" alt="image_3_5.png"></p>
<h3>14. 压力测试确定系统瓶颈 <a href="#item-0-15" id="item-0-15"></a></h3>
<p>设计高并发系统，离不开最重要的一环，<strong>就是压力测试</strong>。就是在系统上线前，需要对系统进行压力测试，测清楚你的系统支撑的最大并发是多少，确定系统的瓶颈点，让自己心里有底，最好预防措施。</p>
<p>压测完要分析整个调用链路，性能可能出现问题是网络层（如带宽）、Nginx层、服务层、还是数据路缓存等中间件等等。</p>
<p><code>loadrunner</code>是一款不错的压力测试工具，<code>jmeter</code>则是接口性能测试工具，都可以来做下压测。</p>
<h3>15. 应对突发流量峰值：扩容+切流量 <a href="#item-0-16" id="item-0-16"></a></h3>
<p>如果是突发的流量高峰，除了降级、限流保证系统不跨，我们可以采用这两种方案，保证系统尽可能服务用户请求：</p>
<ul>
<li>扩容：<strong>比如增加从库、提升配置的方式</strong>，提升系统/组件的流量承载能力。比如增加<code>MySQL、Redis</code>从库来处理查询请求。</li>
<li>切流量：<strong>服务多机房部署</strong>，如果高并发流量来了，把流量从一个机房切换到另一个机房。</li>
</ul>
1a:T6991,<blockquote>
<p>业务平台是连接业务战略与技术实现的桥梁。好的业务平台架构，不仅要沉淀可复用的基础设施以降低成本，更要通过开放的架构能力支持业务的快速创新与差异化经营。本文从&quot;业务是什么&quot;这一基本问题出发，逐步展开对业务平台架构定位、能力建模、域划分以及架构构建方法的系统性思考。</p>
</blockquote>
<h2>从我们最熟悉的说起——业务是什么？</h2>
<p>不同来源对&quot;业务&quot;有着不同层次的解读：</p>
<ol>
<li>职业上的事务，统称为「业务」——辞海</li>
<li>&quot;业务&quot;更白话一些来说，就是各行业中需要处理的事务，但通常偏向指销售的事务，因为任何公司单位最终仍然是以销售产品、销售服务、销售技术等等为主。&quot;业务&quot;最终的目的是&quot;售出产品，换取利润&quot;。——百度</li>
<li>&quot;Anything that relates to organizing the exchange of goods and services by a business, a governmental institution, or an agency.&quot;——OpenGroup TOGAF Business Architecture</li>
</ol>
<h3>业务的定义</h3>
<p><strong>业务</strong>：企业接受客户订购，并将商品或服务交付给客户的一系列活动的总和，称之为一个业务。</p>
<p>业务的基本特征是<strong>产品+组织</strong>。当产品交付给客户时，面向不同客户、市场、行业，如何解决业务的差异性？答案是<strong>业务身份</strong>。</p>
<p>业务身份是现实业务在系统中给予的唯一编码标识，是基于&quot;业务&quot;差异性划分而形成的系统 ID。业务身份的本质不是为了区分逻辑判断，而是区分需求来源以及规则的适用范围。因此，业务身份应该有全局的一致性。</p>
<h2>业务平台架构的定位</h2>
<h3>从业务内部看，要解决的主要问题</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>创新</td>
<td>不断适应市场的业务策略</td>
</tr>
<tr>
<td>低成本</td>
<td>实施成本低</td>
</tr>
<tr>
<td>快速响应</td>
<td>能快速推进，快速试错</td>
</tr>
<tr>
<td>外部资源</td>
<td>易于获得生态内足够的外部资源，如流量、供给、渠道</td>
</tr>
</tbody></table>
<h3>从全局看，怎样支持业务快速发展？</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>基础强大</td>
<td>有强大的基础平台支撑，通用能力得到保证</td>
</tr>
<tr>
<td>组装灵活</td>
<td>可以快速选择部分能力，构建适合自身需要的支撑体系</td>
</tr>
<tr>
<td>易于变化</td>
<td>变化牵涉面小，可以快速定制</td>
</tr>
<tr>
<td>自主投入</td>
<td>不受基础平台资源瓶颈限制</td>
</tr>
</tbody></table>
<h3>从技术与业务两个角度看，需要的能力</h3>
<ul>
<li><strong>功能丰富</strong>：靠积累</li>
<li><strong>易于复用</strong>：粒度合适，易于集成（技术兼容）</li>
<li><strong>开放定制</strong>：平台开放（架构开放），运行解耦（部署灵活）、研发过程解耦</li>
<li><strong>信息共享</strong>：概念一致、场景链接</li>
<li><strong>沟通顺畅</strong>：共同的术语、对业务整体的一致认识</li>
</ul>
<h3>被复用或信息共享的前提</h3>
<p>从业务角度看，能够被复用或信息共享需要满足以下前提：</p>
<ul>
<li>核心管理对象的一致性<ul>
<li>概念一致：对象+关系</li>
<li>数据描述一致：主数据</li>
</ul>
</li>
<li>存在一定层次的流程一致性<ul>
<li>关键活动</li>
<li>基本规则</li>
</ul>
</li>
</ul>
<h3>软件复用的四种形式</h3>
<p>从技术的角度，软件怎样被复用？</p>
<table>
<thead>
<tr>
<th>复用形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>功能复用</td>
<td>一段功能被完整使用</td>
</tr>
<tr>
<td>接口复用</td>
<td>输入输出定义复用，实现逻辑重写</td>
</tr>
<tr>
<td>流程复用</td>
<td>一段控制结构被复用，控制逻辑加上节点</td>
</tr>
<tr>
<td>规则复用</td>
<td>一段判断逻辑被复用</td>
</tr>
</tbody></table>
<blockquote>
<p>复用的前提是业务实质的相似性。如果管理的核心对象存在较大差异，绝大部分情况下，以上复用都没可能。</p>
</blockquote>
<h3>业务平台的能力取决于什么？</h3>
<ul>
<li>是否存在基础的具有共性的关键业务环节</li>
<li>是否存在需要全局共享的关键资源</li>
<li>是否存在需要广泛连接的关键应用</li>
<li>是否存在需要大范围执行的管控规则</li>
<li>是否需要稳定性 SLA</li>
</ul>
<h3>业务平台的价值</h3>
<ul>
<li><strong>降低成本</strong>：通过沉淀可复用的软件基础设施</li>
<li><strong>支持创新</strong>：通过提供开放的基础架构能力，支持创新和差异化经营</li>
<li><strong>全局管控</strong>：通过管理基础数据和基本流程节点，提供全局管控的手段和稳定性保障</li>
</ul>
<h2>业务架构模型分析</h2>
<p>业界对业务架构的描述方式有多种参考模型：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>Business Process</td>
<td>TMF、APQC</td>
</tr>
<tr>
<td>Business Capability</td>
<td>Open Group、Gartner</td>
</tr>
<tr>
<td>Value Stream</td>
<td>Open Group</td>
</tr>
<tr>
<td>Business Service</td>
<td>FEA</td>
</tr>
</tbody></table>
<h3>描述业务的三个视角</h3>
<ul>
<li><p><strong>Business Capability（What）</strong>：业务为实现特定目的或结果而可能拥有或交互的特定能力或产能</p>
<blockquote>
<p>A particular ability or capacity that a business may process or exchange to achieve a specific purpose.</p>
</blockquote>
</li>
<li><p><strong>Business Process（How）</strong>：一组有逻辑行为的结构化活动或任务，产生特定的结果、服务或产品</p>
<blockquote>
<p>A set of structured activities or tasks with logical behaviors that produce a specific outcome, service or product.</p>
</blockquote>
</li>
<li><p><strong>Business Value Stream（Why）</strong>：表示一组端到端增值活动集合，这些活动为客户、干系人或者最终用户获得一个总体结果</p>
<blockquote>
<p>A sequence of activities an enterprise undertakes to deliver on a customer request.</p>
</blockquote>
</li>
</ul>
<h3>参考模型的共性</h3>
<p>在推动企业 IT 服务能力的持续演进方面，业界已经有丰富的参考。分析前述参考模型可以看到：</p>
<ul>
<li><strong>顶层视图一致</strong>：不论哪种描述方式，都是先从企业的管理范围做大的划分——基于价值链的分析形成顶级视图，以是否直接服务客户为基准划分不同分类</li>
<li><strong>内容逻辑趋同</strong>：大多讨论都涉及组织、能力、过程的关系</li>
<li><strong>目标一致</strong>：虽然在不同的时期、不同的视角强调的重点不同，但都是希望建立更易于为业务理解的视图，并成为构建 IT 系统的桥梁</li>
</ul>
<h2>业务架构的现状与挑战</h2>
<p>通常，企业架构包括<strong>业务架构、技术架构、应用架构、数据/信息架构</strong>，而业务平台最薄弱的环节往往在于业务架构：</p>
<ul>
<li>已经形成框架，但缺乏对关键概念的确切定义</li>
<li>已经形成平台，但缺乏长期演进的规划指引</li>
<li>已经形成对业务的基础性支撑，但基础能力没有明确的定义</li>
<li>平台团队缺乏对业务的结构化思考框架指引，容易造成团队能力的瓶颈</li>
</ul>
<p>因此，我们首先需要健全业务架构体系。业务架构体系的构建关键在于先要建立<strong>业务视角</strong>。</p>
<h3>什么是业务视角？</h3>
<ul>
<li>用业务发生的方式描述业务：围绕能力、流程与场景描述</li>
<li>将业务现象背后的逻辑进行结构化呈现</li>
<li>强调结果而非方法实现，屏蔽技术细节</li>
</ul>
<h3>如何建立业务视角？</h3>
<ul>
<li>首先要明确业务目标，理解业务含义，知道结构划分的依据</li>
<li>要建立端到端的全流程视角，业务需求能够对应到系统功能</li>
<li>在业务沟通中，统一使用达成共识的业务语言而非技术术语</li>
<li>系统被业务感知的部分要有明确的业务语义以及清晰的边界</li>
</ul>
<h3>业务平台架构的层次结构</h3>
<p>业务平台架构是一个<strong>以流程为基础，以能力为表达</strong>的层次结构：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>第一层</td>
<td>明确语义和范围</td>
</tr>
<tr>
<td>第二层</td>
<td>构建完备、正交的业务模型</td>
</tr>
<tr>
<td>第三层</td>
<td>与交付形态相结合，提供服务 SLA</td>
</tr>
</tbody></table>
<p>无论从能力角度，还是从流程角度，都是对企业行为的一种描述方式。我们既可以通过满足的客户需求出发，构建能力的集合，也可以根据流程到企业能力的对应，建立起整体的能力框架或过程框架。</p>
<h2>关于域（Domain）的思考</h2>
<p>域是一个广泛被使用的词，但定义也很宽泛。领域建模这个词很熟悉，但具体&quot;领域&quot;是什么，在实践中并没有可以判定的简单标准。域常常被理解为不同的场景：功能域、过程域、数据域。</p>
<p>如果从 OO（面向对象）的核心思想出发，则可以将域做一个统一认知：</p>
<ul>
<li><strong>功能</strong>是对象行为的外部表现，但作为域的聚合依据是对象</li>
<li><strong>对象</strong>的行为和数据是不可分开的，过程是对象行为的执行过程</li>
</ul>
<p>基于以上认知，域的概念可以统一为**「信息域」**——数据是信息的载体，信息是对数据的语义解释。因此，<strong>领域建模就是找出问题范围内的对象及其关系，根据对象间关系的紧密程度，来确定是否属于一个域。</strong></p>
<h3>价值链视角下的能力划分</h3>
<p>价值链把企业的能力划分为<strong>核心能力</strong>以及<strong>辅助能力</strong>，实质是以客户为中心，区分客户与企业两个角色。根据 TMF-eTOM 的划分方式，在核心流程进一步细分基础设施和战略、运营，和生产不直接相关的活动都定义为企业管理。</p>
<h2>能力的语义分析——5W1H 的逻辑</h2>
<p>对能力进行语义分析，可以借助经典的 5W1H 框架：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>关注点</th>
<th>层次</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Why</strong></td>
<td>价值</td>
<td>高层次</td>
</tr>
<tr>
<td><strong>What</strong></td>
<td>目标</td>
<td>高层次</td>
</tr>
<tr>
<td><strong>When</strong></td>
<td>时间</td>
<td>细节层次</td>
</tr>
<tr>
<td><strong>Where</strong></td>
<td>地点</td>
<td>细节层次</td>
</tr>
<tr>
<td><strong>Who</strong></td>
<td>参与人</td>
<td>细节层次</td>
</tr>
<tr>
<td><strong>How</strong></td>
<td>方式方法</td>
<td>细节层次</td>
</tr>
</tbody></table>
<p>当我们在较高层次谈能力，往往是在谈 <strong>Why</strong> 和 <strong>What</strong>；在较低或细节的层次谈能力，则往往强调的是 <strong>3W1H</strong>（When、Where、Who、How）——即做的程度和特性。</p>
<h3>能力的两种描述形式</h3>
<p>能力的描述通常有两种形式：</p>
<p><strong>形式一：按照目标描述</strong>——做什么以及达到的目标。</p>
<p><strong>形式二：按照特性描述</strong>——特性往往体现为两类：</p>
<ol>
<li><strong>对象属性值的组合</strong>：值的组合往往体现为场景。例如&quot;担保交易&quot;是一个能力描述，&quot;担保&quot;本身是交易的分类特性，描述的是交易具有的特点。</li>
<li><strong>过程执行的非功能特性</strong>：如时间、空间等。例如&quot;秒杀&quot;描述的是交易的时间特性；&quot;店铺红包&quot;描述的是红包使用的范围（空间特性）。</li>
</ol>
<h3>能力与场景的结合</h3>
<p>能力的特性描述实际是场景切分的方式。一旦进入场景，就是离散的结构；而按照流程的能力划分方式，则可以是逐步细化的方式，会形成<strong>树状的结构</strong>。</p>
<p>如果我们把二者结合并加以规范，就能形成既满足 MECE（Mutually Exclusive, Collectively Exhaustive）原则，又能把两种特点有效体现的描述方式：</p>
<ol>
<li>按照端到端流程完成初始能力描述</li>
<li>找到流程的各个环节，分解成不同的能力</li>
<li>在流程各个环节里，找出关键参数，描述业务的适应能力</li>
<li>找出关键的非功能性的特性</li>
<li>把流程各个环节较为固定的组合找出来</li>
</ol>
<h2>能力分析 vs 流程分析</h2>
<ul>
<li><strong>能力</strong>：要达到一个目的，得到一个结果。如果是服务于客户，从客户的角度看，就是&quot;我&quot;帮客户完成了一件什么事情。</li>
<li><strong>流程</strong>：我要干一件什么样的事情，其步骤是什么，体现的是做的过程。</li>
</ul>
<p>从划分的结果来看，能力划分和流程划分是一致的，但从思考的角度看是不同的。从划分的确定性看，因为角色有限，能力从结果和目标的角度出发，避开路径的复杂性，有更强的确定性。</p>
<h2>业务建模 vs 业务架构</h2>
<p>在独立讲述流程建模或者能力建模的论述中，都强调用业务的语言，构建符合业务习惯的成果。业务建模只强调逻辑的完整性，但是在以 IT 实现为目标的前提下，业务建模和 IT 实现之间必须建立简单的对应关系。</p>
<p>无论是能力建模或者过程建模，最终要与信息模型建立映射关系。在业务分散而平台支撑要统一的情况下，也可以看作是 IT 在寻找和业务的共同语言。</p>
<h2>商业能力的划分</h2>
<h3>划分的核心原则</h3>
<p>能力划分的核心是<strong>围绕客户，以是否与客户诉求直接相关作为基准</strong>。在顶层视图中，划分能力和流程的视角是一致的——无论流程视角还是能力视角，都要找出我们能为客户做什么。</p>
<p>因此，我们可以区分<strong>三类能力</strong>：</p>
<ol>
<li><strong>客户销售与服务能力</strong>——直接面向客户</li>
<li><strong>支撑能力</strong>——为前端能力提供基础保障</li>
<li><strong>企业管理能力</strong>——支撑组织自身运转</li>
</ol>
<h3>能力划分的逻辑</h3>
<p>能力划分是自顶向下的逻辑分解过程。其出发点首先是<strong>角色分析</strong>，以满足角色的诉求为目的。因此，顶层的划分都是以角色的诉求为基础，本质是场景（或流程）的划分。</p>
<table>
<thead>
<tr>
<th>能力类型</th>
<th>划分逻辑</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>前端能力</td>
<td>按消费逻辑划分</td>
<td>直接服务于客户需求，按客户消费场景进行顶层划分</td>
</tr>
<tr>
<td>后端支撑能力</td>
<td>按资源/角色分类</td>
<td>服务于经营者，因内部角色分散，形成面向资源的分散流程</td>
</tr>
</tbody></table>
<p>场景的细分本身可以构成能力细分的逻辑基础，但仍需要找到场景细分的逻辑。后端支撑能力本质是服务于经营者，可以从经营者的诉求进行划分。但因为内部角色的分散，难以在顶层形成贯穿全局的流程主线，就会形成面向资源的分散流程。这里的<strong>资源，本质就是我们所说的域</strong>。</p>
<p>这代表了一类细分的思路：在场景细分的基础上，通过资源的分类完成下一级的细分。即便到了资源的分类层次，仍有可能进一步细分，这又会回到场景划分的逻辑。所以，<strong>业务能力建模的过程也是在不断寻找不同层次的能力切分逻辑的过程</strong>。</p>
<p>从全局看，核心是以客户为中心进行能力的划分。实际上，每一部分能力都服务于生态中的某个特定角色，所以在能力的描述上，直接满足的是当前角色的价值要求，间接地通过以客户为中心的视角进行原则性校验。</p>
<p><img src="/images/blog/engineering/business-image_4_1.png" alt="企业能力生态闭环"></p>
<ul>
<li>企业的能力围绕&quot;客户、企业自身、合作伙伴&quot;的生态形成闭环</li>
<li>前端围绕满足客户需求</li>
<li>后端分为满足生产要素管理和满足企业自身管理</li>
<li>企业管理暂不涉及</li>
</ul>
<p><img src="/images/blog/engineering/business-image_4_2.png" alt="能力划分全景图"></p>
<h3>后端支撑能力与企业管理能力</h3>
<p><strong>后端支撑能力：</strong></p>
<ul>
<li>客户管理</li>
<li>产品管理（PLM）</li>
<li>合作伙伴管理</li>
<li>营销活动管理</li>
<li>账单与收入管理</li>
<li>资源管理</li>
</ul>
<p><strong>企业管理能力：</strong></p>
<ul>
<li>人力资源</li>
<li>财务</li>
<li>技术发展</li>
<li>基础建设</li>
<li>法务</li>
<li>……</li>
</ul>
<h3>从概念性的能力到软件实现的层次</h3>
<p><img src="/images/blog/engineering/business-image_4_3.png" alt="能力到软件实现的映射"></p>
<p><strong>能力的表现形式：</strong></p>
<ul>
<li><strong>高层的能力</strong>：应该是逻辑的表达，对应于软件的整体或可独立交付的部分</li>
<li><strong>低层的能力</strong>：应该和软件的外在存在形式关联，如分布式环境中的服务接口、SDK 中定义的接口</li>
</ul>
<p><strong>能力的划分原则：</strong></p>
<p>能力是围绕以完成客户诉求为目标来划分的，完成一个能力可能需要多个领域对象的协作。能力的细分有横向和纵向的划分方式，未必代表软件实现的粒度细分，所以要建立能力和软件实现的映射关系。但在能力粒度上，一定需要和软件的交付物有一致并且明确的边界。</p>
<h2>能力、流程、域的关系</h2>
<p>三者的划分依据各有不同，但最终需要建立映射：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>划分依据</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>能力</td>
<td>按照完成目标划分</td>
<td>面向结果</td>
</tr>
<tr>
<td>流程</td>
<td>按照执行过程划分</td>
<td>面向步骤</td>
</tr>
<tr>
<td>域</td>
<td>按照实体聚合切分</td>
<td>面向对象</td>
</tr>
</tbody></table>
<p>业务流程是业务感知结果的流程，系统流程是执行步骤的划分。域内可以有流程，域的多项能力可能对应细分流程的多个步骤，不一定有必然的先后顺序，也可能是离散的能力组合。</p>
<p>域和能力之间也需要在一定的粒度上建立映射关系，否则会造成在域和能力都有很多层次，并在多个层次间建立复杂的映射。</p>
<h2>商业能力层的设计</h2>
<h3>商业能力层和域内的关系</h3>
<p>商业能力是客户可直接感知的能力。越是面向客户直接交互的层次，在技术上越难以限制其差异性，可能会与需求直接映射；越是趋近技术实现的层次，越是需要更高的抽象，以间接满足需求。</p>
<p>商业能力层提供流程性的封装，在顶层按照与客户的交互场景划分，并结合域的划分进行分解：</p>
<ul>
<li><strong>商业能力层</strong>：以提高交互场景的合理性和对外的灵活性为目标，关注面向客户体验的逻辑实现</li>
<li><strong>域内</strong>：以实现领域内的接口复用为目的，提供合适粒度的接口，与商业能力层确认概念模型</li>
</ul>
<blockquote>
<p>商业能力团队应该首先是一个<strong>设计团队</strong>，其次才是一个实现团队。设计应该是和各域一起探讨的过程，商业能力要限制向下层过度延伸，也要迫使下层更注重域内抽象。</p>
</blockquote>
<p>在设计过程中，逻辑分解应该尽量形成在各域的独立逻辑，然后组合成对外的交互逻辑。最外层交互所依赖的服务都在商业能力层实现封装，应该以业务设计结果为准，而不是技术设计。对外的扩展点，都在商业能力层定义和体现。</p>
<h3>商业能力在软件结构上的分层</h3>
<p>如果对外提供的就是商业能力，那么域和商业能力的边界到底在哪里？</p>
<ul>
<li>所有在 SDK、RPC 接口中对外提供调用或者是 SPI 提供实现的，都在商业能力层定义</li>
<li>需要提供给外部使用或扩展的（这里不包含界面层对后端的调用，界面是软件的一部分）</li>
</ul>
<h3>如何界定&quot;内&quot;和&quot;外&quot;？</h3>
<p>&quot;内&quot;与&quot;外&quot;的界定取决于商业能力的服务对象和组织边界：</p>
<table>
<thead>
<tr>
<th>视角</th>
<th>&quot;内&quot;</th>
<th>&quot;外&quot;</th>
</tr>
</thead>
<tbody><tr>
<td>业务平台 vs 业务方</td>
<td>业务平台</td>
<td>业务方</td>
</tr>
<tr>
<td>整个中台</td>
<td>所有中台能力</td>
<td>中台以外</td>
</tr>
<tr>
<td>企业内外</td>
<td>企业</td>
<td>客户</td>
</tr>
</tbody></table>
<p>如果考虑放大到所有提供中台能力的都和业务平台同等的地位，那么整个中台就是内——但这样就要有整个中台的统一对外组织和架构标准。</p>
<h3>商业能力和域的分层及域间关系</h3>
<p>域间是否允许调用？调用规则如下：</p>
<table>
<thead>
<tr>
<th>调用类型</th>
<th>是否允许</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>依赖另一个域的实体对象信息的查询调用</td>
<td><strong>允许</strong></td>
<td>不限制下层的信息查询</td>
</tr>
<tr>
<td>依赖另一个域的判断的调用</td>
<td><strong>禁止</strong></td>
<td>交给上层去集成</td>
</tr>
<tr>
<td>嵌入另一个域的处理环节的调用</td>
<td><strong>禁止</strong></td>
<td>限制下层的逻辑蔓延</td>
</tr>
</tbody></table>
<p>核心原则是：<strong>上层进行逻辑和控制结构的组装，不限制下层的信息查询，但限制下层的逻辑蔓延。</strong></p>
<p>对于下层能够独立完成的判断逻辑或处理环节，鼓励下层去做。但对象必须有属主域，判断应该是本域的关键对象的行为判断，而不能是跨越边界。只有直接被认为是对象的直接属性的内容，才被认为是查询，所以对于一个域要有基本的概念模型。</p>
<h3>商业能力的表达</h3>
<p>对组织边界外的外部系统服务，都是商业能力封装；对于和客户直接交互的、提供给界面的，都是商业能力。</p>
<p>商业能力本身可以分成两类：</p>
<ol>
<li><strong>领域内服务</strong>：单域完成的能力</li>
<li><strong>跨域服务</strong>：可以作为独立的分类</li>
</ol>
<p>从上下级关系看，上级的逻辑必然覆盖下层的逻辑，建立能力树，是给用户导航的方式。</p>
<h2>基于企业架构，构建业务架构</h2>
<p>要想构建业务平台架构，我们需要有一套行之有效的构建方法论。方法论的构成包括：<strong>原理过程 + 表示法 + 工具</strong>。</p>
<p>能力地图代表业务架构，概念模型代表信息架构。对于多数业务平台，技术架构一般已经有较为明确的选择。所以，业务平台亟需构建的是除技术架构之外的泛&quot;业务架构&quot;。</p>
<p>从企业管理维度上看，企业架构在业务平台通常可以解决的问题包括：</p>
<ul>
<li><strong>研发投资的价值识别</strong></li>
<li><strong>架构演进的组织方法</strong></li>
<li><strong>组织的职责划分</strong></li>
</ul>
<h3>构建架构体系：战略-模式-能力-过程</h3>
<p>业务架构的边界来源于战略输入。从能力的角度，产品目录是业务架构的延续；从实现的角度，产品目录是应用架构的延续。在交互层面，通过合适的集成手段，实现应用功能面向用户的有效整合。</p>
<p>应用架构的边界和域的边界有内在的关联，可以通过自顶向下的讨论以及循环迭代完成演进。</p>
<h3>构建能力地图</h3>
<ol>
<li><strong>确定架构定义及结构描述</strong><ul>
<li>分层划分的规则确定</li>
</ul>
</li>
<li><strong>现状描述</strong><ul>
<li>能力地图的草稿初建</li>
</ul>
</li>
<li><strong>搜集关键场景，确定目标架构</strong><ul>
<li>补充关键演进场景</li>
</ul>
</li>
<li><strong>Gap 分析</strong></li>
<li><strong>演进计划</strong></li>
<li><strong>构建一个基础的完备正交集合</strong></li>
<li><strong>构建不同场景的视图</strong><ul>
<li>外部客户交付关键能力视图</li>
<li>内部业务的热点关键能力视图</li>
</ul>
</li>
</ol>
<h3>构建概念模型</h3>
<p><strong>现状搜集：</strong></p>
<ul>
<li>已经被广泛引用的概念、实体</li>
<li>已经被广泛使用的术语</li>
<li>已经被相对固化的流程节点</li>
<li>已经广泛使用的场景</li>
</ul>
<p><strong>未来场景搜集：</strong></p>
<ul>
<li>战略输入</li>
<li>业务规划</li>
</ul>
<p><strong>建模：</strong></p>
<ul>
<li>域划分</li>
<li>模型定义</li>
<li>耦合验证</li>
</ul>
<p><strong>演进计划</strong></p>
<h2>总结</h2>
<p>业务平台架构的构建是一个系统性工程，其核心在于找到业务与技术之间的共同语言。回顾全文，可以提炼出以下关键认知：</p>
<ol>
<li><strong>业务身份是差异性管理的基础</strong>——通过全局一致的业务身份，区分需求来源和规则适用范围</li>
<li><strong>能力、流程、域三位一体</strong>——能力面向结果，流程面向过程，域面向对象，三者需要在合适的粒度上建立映射</li>
<li><strong>以客户为中心的划分逻辑</strong>——无论前端能力还是后端支撑，最终都服务于客户价值的交付</li>
<li><strong>商业能力层是关键的架构抽象</strong>——它既要限制向下层的过度延伸，又要迫使下层注重域内抽象</li>
<li><strong>域间调用的原则</strong>——允许信息查询，禁止逻辑蔓延，上层负责编排</li>
<li><strong>业务架构需要持续演进</strong>——通过能力地图和概念模型的迭代构建，逐步完善架构体系</li>
</ol>
<p>好的业务平台架构不是一蹴而就的，它需要在实践中不断验证和演进。关键是始终保持以业务视角为出发点，用结构化的方法将业务逻辑转化为可落地的技术架构。</p>
1b:T72c6,<h1>SET化架构：从单元化原理到大规模落地实践</h1>
<blockquote>
<p>当系统规模突破单机房、单集群的承载极限，当一次机房故障就可能导致全站不可用时，SET 化架构就成为了必然选择。它不是一种特定的技术方案，而是一种<strong>将系统划分为独立自治单元，实现水平扩展和故障隔离</strong>的架构思想。</p>
</blockquote>
<p>互联网业务的高速增长给架构带来了两个根本性挑战：<strong>容量的天花板</strong>和<strong>可用性的脆弱性</strong>。传统的垂直扩展（Scale-up）终有极限，而简单的水平扩展（Scale-out）在数据一致性、服务依赖、运维复杂度等方面又面临诸多困难。</p>
<p>SET 化架构（也称为单元化架构、Cell-based Architecture）正是为了系统性地解决这些问题而诞生的。本文将从原理到实践，全面解析 SET 化架构的设计与落地。</p>
<h2>什么是 SET 化架构？</h2>
<h3>概念定义</h3>
<p>SET（Scalable Elastic Topology，可扩展弹性拓扑）化架构是一种<strong>将系统按照某个维度（通常是用户 ID）划分为多个独立、自包含的部署单元</strong>的架构模式。每个 SET 都是一个&quot;小型完整系统&quot;，拥有独立的应用服务、缓存、数据库等全套基础设施，能够独立处理分配给它的流量。</p>
<pre><code>SET 化的核心思想：

传统架构：         所有用户 → 一套系统
                    （纵向扩展，存在单点瓶颈）

SET 化架构：       用户按规则分组 → 每组对应一个 SET
                    SET-1: 用户 0~999W    → 独立的一套完整系统
                    SET-2: 用户 1000W~1999W → 独立的一套完整系统
                    SET-3: 用户 2000W~2999W → 独立的一套完整系统
                    （水平扩展，理论上无上限）
</code></pre>
<h3>SET 的核心特征</h3>
<table>
<thead>
<tr>
<th>特征</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>自包含</strong></td>
<td>每个 SET 拥有完整的服务栈（应用、缓存、DB），能独立处理请求</td>
</tr>
<tr>
<td><strong>对等部署</strong></td>
<td>所有 SET 的架构相同，只是处理的数据分片不同</td>
</tr>
<tr>
<td><strong>故障隔离</strong></td>
<td>单个 SET 的故障不会影响其他 SET</td>
</tr>
<tr>
<td><strong>水平扩展</strong></td>
<td>通过增加 SET 数量实现容量扩展</td>
</tr>
<tr>
<td><strong>流量可调度</strong></td>
<td>通过路由规则灵活调度流量在 SET 间的分配</td>
</tr>
</tbody></table>
<h3>SET 化与传统分布式的区别</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>传统分布式架构</th>
<th>SET 化架构</th>
</tr>
</thead>
<tbody><tr>
<td>扩展方式</td>
<td>各层独立扩展（加应用节点、加 DB 从库）</td>
<td>整体作为一个单元扩展</td>
</tr>
<tr>
<td>故障影响</td>
<td>某一层故障影响全局</td>
<td>故障隔离在单个 SET 内</td>
</tr>
<tr>
<td>数据分片</td>
<td>数据库层分片，应用层无感知</td>
<td>从入口到数据库全链路分片</td>
</tr>
<tr>
<td>部署单元</td>
<td>按服务部署</td>
<td>按 SET（单元）部署</td>
</tr>
<tr>
<td>容量规划</td>
<td>各组件独立评估</td>
<td>按 SET 整体评估</td>
</tr>
</tbody></table>
<h2>SET 化架构演进历程</h2>
<p>SET 化不是一步到位的设计，而是随着业务规模增长逐步演化的结果。</p>
<h3>阶段一：单体架构</h3>
<pre><code>用户 → 应用服务器 → 数据库
</code></pre>
<p>所有功能在一个应用中，单库单表。适用于初创期，简单高效。</p>
<p><strong>瓶颈</strong>：单机容量有限，数据库成为瓶颈。</p>
<h3>阶段二：读写分离 + 缓存</h3>
<pre><code>用户 → 应用集群 → 缓存 → 主库（写）/ 从库（读）
</code></pre>
<p>通过读写分离缓解数据库压力，引入缓存降低 DB 负载。</p>
<p><strong>瓶颈</strong>：写入瓶颈无法解决，主库仍是单点。</p>
<h3>阶段三：分库分表</h3>
<pre><code>用户 → 应用集群 → 数据库中间件 → DB 分片 1 / DB 分片 2 / DB 分片 N
</code></pre>
<p>数据库水平拆分，解决写入瓶颈。但分片逻辑散落在各处，跨分片查询复杂。</p>
<p><strong>瓶颈</strong>：应用层无分片感知，缓存与 DB 分片不对齐，运维复杂。</p>
<h3>阶段四：服务化（微服务）</h3>
<pre><code>用户 → API 网关 → 微服务 A / 微服务 B / ... → 各自的 DB
</code></pre>
<p>按业务域拆分为独立服务，各服务独立部署和扩展。</p>
<p><strong>瓶颈</strong>：服务间调用复杂，全链路缺乏统一的分片和隔离机制。</p>
<h3>阶段五：SET 化（单元化）</h3>
<pre><code>用户 → 统一路由层 → SET-1（完整服务栈）/ SET-2 / SET-N
                       ↕ 数据同步
</code></pre>
<p>全链路按统一维度分片，每个 SET 自包含完整服务栈，实现真正的水平扩展和故障隔离。</p>
<p><strong>这就是 SET 化架构的终态。</strong> 下面详细介绍每个核心组件的设计。</p>
<h2>核心设计一：流量路由</h2>
<p>流量路由是 SET 化架构的&quot;大脑&quot;，它决定了每个请求应该被路由到哪个 SET。</p>
<h3>路由键的选择</h3>
<p>路由键（Sharding Key）是 SET 化的核心决策之一，选择不当会导致严重的跨 SET 调用问题。</p>
<table>
<thead>
<tr>
<th>路由键</th>
<th>优点</th>
<th>缺点</th>
<th>适用业务</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用户 ID</strong></td>
<td>用户维度天然隔离，覆盖面广</td>
<td>用户间交互需跨 SET</td>
<td>电商、社交、O2O</td>
</tr>
<tr>
<td><strong>商户 ID</strong></td>
<td>商户维度隔离</td>
<td>用户下单需跨 SET</td>
<td>B 端平台</td>
</tr>
<tr>
<td><strong>地理区域</strong></td>
<td>天然的流量隔离</td>
<td>跨区域业务需特殊处理</td>
<td>本地生活、物流</td>
</tr>
<tr>
<td><strong>订单 ID</strong></td>
<td>订单维度隔离</td>
<td>需要提前生成带路由信息的 ID</td>
<td>交易系统</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>实践经验</strong>：绝大多数 C 端业务选择<strong>用户 ID</strong> 作为路由键，因为用户是最核心的业务实体，以用户为维度分片可以最大程度地减少跨 SET 调用。</p>
</blockquote>
<h3>路由架构设计</h3>
<p>SET 化的路由通常分为三层：</p>
<p><strong>第一层：接入路由（DNS / LB 层）</strong></p>
<p>在最外层通过 DNS 或负载均衡器将流量分配到对应的 SET。</p>
<pre><code>用户请求 → DNS 解析 → 全局负载均衡（GSLB）
                            ↓
                    根据用户 ID 哈希路由
                    ↓           ↓           ↓
                 SET-1 LB    SET-2 LB    SET-3 LB
</code></pre>
<p><strong>第二层：网关路由（API Gateway 层）</strong></p>
<p>API 网关根据请求中的路由键（如 Header、Cookie、Token 中的用户 ID）将请求路由到正确的 SET。</p>
<pre><code>请求 → API Gateway → 提取路由键 → 查询路由表 → 转发到目标 SET
</code></pre>
<p><strong>第三层：服务路由（RPC 层）</strong></p>
<p>服务间调用时，RPC 框架自动根据上下文中的路由键将请求路由到同 SET 的服务实例。</p>
<pre><code>Service A (SET-1) → RPC Framework → 自动路由到 → Service B (SET-1)
                    （通过上下文传递 SET 标识）
</code></pre>
<h3>路由表设计</h3>
<p>路由表是映射用户到 SET 的核心数据结构：</p>
<pre><code>路由表结构：
┌──────────────┬──────────┬──────────┐
│  分片范围      │  SET ID  │  状态     │
├──────────────┼──────────┼──────────┤
│  0 ~ 999      │  SET-1   │  Active  │
│  1000 ~ 1999  │  SET-2   │  Active  │
│  2000 ~ 2999  │  SET-3   │  Active  │
│  3000 ~ 3999  │  SET-1   │  Active  │  ← 同一个 SET 可承载多个分片
└──────────────┴──────────┴──────────┘
</code></pre>
<p>路由策略的关键设计要点：</p>
<ol>
<li><strong>虚拟分片</strong>：不直接将用户映射到物理 SET，而是先映射到虚拟分片（如 1024 个），再将虚拟分片映射到物理 SET。这样扩容时只需调整虚拟分片的映射关系</li>
<li><strong>路由缓存</strong>：路由表在网关和服务端本地缓存，避免每次请求都查询路由服务</li>
<li><strong>路由一致性</strong>：路由表变更时需要保证全链路一致性，避免请求被路由到错误的 SET</li>
</ol>
<h2>核心设计二：数据分片与同步</h2>
<p>数据层是 SET 化最复杂的部分，需要解决数据分片、跨 SET 数据访问、数据同步等问题。</p>
<h3>数据分类</h3>
<p>SET 化架构中的数据按照与路由键的关系分为三类：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>定义</th>
<th>存储方式</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SET 内数据</strong></td>
<td>与路由键强绑定的数据</td>
<td>仅存储在对应 SET</td>
<td>用户订单、用户资产、购物车</td>
</tr>
<tr>
<td><strong>全局数据</strong></td>
<td>所有 SET 共享的数据</td>
<td>全局存储 + 各 SET 只读副本</td>
<td>商品信息、配置数据、类目</td>
</tr>
<tr>
<td><strong>跨 SET 数据</strong></td>
<td>涉及多个路由键的数据</td>
<td>全局存储或冗余存储</td>
<td>商户维度的聚合数据、排行榜</td>
</tr>
</tbody></table>
<h3>SET 内数据</h3>
<p>SET 内数据遵循&quot;谁的数据谁存储&quot;原则，每个 SET 只处理和存储自己分片内的数据：</p>
<pre><code>SET-1 数据库：只存储 UserID 0~999 的数据
SET-2 数据库：只存储 UserID 1000~1999 的数据

用户 A (ID=500) 下单 → 请求路由到 SET-1 → 订单写入 SET-1 DB
用户 B (ID=1500) 下单 → 请求路由到 SET-2 → 订单写入 SET-2 DB
</code></pre>
<h3>全局数据</h3>
<p>全局数据（如商品信息）需要所有 SET 都能访问，通常采用以下方案：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>全局服务</strong></td>
<td>独立部署的全局服务 + 数据库</td>
<td>数据一致性好</td>
<td>全局服务成为依赖瓶颈</td>
</tr>
<tr>
<td><strong>数据广播</strong></td>
<td>写入全局库后异步同步到各 SET</td>
<td>本地读取性能好</td>
<td>数据有延迟，存储冗余</td>
</tr>
<tr>
<td><strong>缓存分发</strong></td>
<td>全局数据写入后推送到各 SET 缓存</td>
<td>读取极快</td>
<td>缓存一致性需要保障</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>实践建议</strong>：高频读取的全局数据（如商品详情）采用&quot;数据广播 + 本地缓存&quot;方案；低频但要求强一致的全局数据（如配置变更）采用&quot;全局服务&quot;方案。</p>
</blockquote>
<h3>数据同步机制</h3>
<p>SET 间的数据同步是保证业务连续性的关键，特别是在故障切换场景下：</p>
<pre><code>                     主 SET                          备 SET
                 ┌──────────┐                    ┌──────────┐
                 │  应用层    │                    │  应用层    │
                 │  缓存层    │                    │  缓存层    │
                 │  数据库    │ ── Binlog 同步 ──→ │  数据库    │
                 └──────────┘                    └──────────┘

        同步方式：MySQL Binlog → Canal/DTS → 目标 SET 数据库
        同步延迟：通常 &lt; 1s，需要监控告警
</code></pre>
<p>数据同步的关键指标：</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>目标值</th>
<th>监控方式</th>
</tr>
</thead>
<tbody><tr>
<td>同步延迟</td>
<td>&lt; 1 秒</td>
<td>Binlog 位点差监控</td>
</tr>
<tr>
<td>数据一致性</td>
<td>99.99%</td>
<td>定期全量对账</td>
</tr>
<tr>
<td>同步可用性</td>
<td>99.99%</td>
<td>同步链路健康检查</td>
</tr>
</tbody></table>
<h2>核心设计三：全局服务</h2>
<p>有些服务天然不能被 SET 化，它们需要作为全局服务为所有 SET 提供能力。</p>
<h3>全局 ID 生成</h3>
<p>在 SET 化架构中，ID 生成必须保证全局唯一且带有路由信息：</p>
<pre><code>ID 结构设计：
┌────────────┬──────────┬───────────┬──────────┐
│  时间戳      │  SET ID  │  机器 ID   │  序列号   │
│  41 bits    │  5 bits  │  5 bits   │  12 bits │
└────────────┴──────────┴───────────┴──────────┘

总长度：63 bits（Long 类型）
</code></pre>
<table>
<thead>
<tr>
<th>生成方案</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>全局 ID 服务</strong></td>
<td>全局唯一性保证最强</td>
<td>依赖外部服务，存在可用性风险</td>
<td>核心业务（订单、支付）</td>
</tr>
<tr>
<td><strong>本地 Snowflake</strong></td>
<td>无外部依赖，性能最高</td>
<td>需要解决时钟回拨问题</td>
<td>非核心业务</td>
</tr>
<tr>
<td><strong>号段模式</strong></td>
<td>批量获取减少调用</td>
<td>号段用尽时有短暂延迟</td>
<td>通用场景</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>兜底策略</strong>：本地 ID 生成作为兜底方案，当全局 ID 服务不可用时自动降级为本地生成，确保业务不中断。</p>
</blockquote>
<h3>全局配置中心</h3>
<p>配置中心负责管理所有 SET 的路由规则、业务配置和开关：</p>
<pre><code>配置中心架构：
                  ┌─────────────────┐
                  │   配置中心集群     │
                  │  (ZK/Nacos/etcd) │
                  └────────┬────────┘
                     ↙     ↓     ↘
            SET-1 Agent  SET-2 Agent  SET-3 Agent
               ↓            ↓            ↓
            本地缓存      本地缓存      本地缓存

推送机制：配置变更 → 配置中心 → 推送给各 SET Agent → 更新本地缓存
</code></pre>
<h3>全局调度中心</h3>
<p>负责 SET 的健康监控、故障检测和流量调度：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>健康检查</td>
<td>定期探测各 SET 的健康状态</td>
</tr>
<tr>
<td>故障检测</td>
<td>发现 SET 异常时触发告警</td>
</tr>
<tr>
<td>流量切换</td>
<td>故障 SET 的流量自动切换到备用 SET</td>
</tr>
<tr>
<td>容量管理</td>
<td>监控各 SET 的容量使用率</td>
</tr>
<tr>
<td>扩缩容编排</td>
<td>新增或下线 SET 时的流量编排</td>
</tr>
</tbody></table>
<h2>核心设计四：故障隔离与切换</h2>
<p>故障隔离是 SET 化架构最核心的价值之一。</p>
<h3>故障域划分</h3>
<p>SET 化架构将故障影响范围从&quot;全站&quot;缩小到&quot;单个 SET&quot;：</p>
<pre><code>传统架构故障：
  DB 主库宕机 → 全站不可用 → 影响 100% 用户

SET 化架构故障：
  SET-2 DB 宕机 → 仅 SET-2 不可用 → 影响约 33% 用户（假设 3 个 SET）
                    ↓ 自动切换
                 SET-2 流量切换到备用 → 影响时间 &lt; 分钟级
</code></pre>
<h3>故障切换策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>切换速度</th>
<th>数据风险</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主备切换</strong></td>
<td>秒级~分钟级</td>
<td>可能丢失未同步数据</td>
<td>SET 内部 DB 主备切换</td>
</tr>
<tr>
<td><strong>SET 间切换</strong></td>
<td>分钟级</td>
<td>依赖数据同步延迟</td>
<td>整个 SET 故障</td>
</tr>
<tr>
<td><strong>跨机房切换</strong></td>
<td>分钟级~小时级</td>
<td>需要全量数据同步</td>
<td>机房级故障</td>
</tr>
</tbody></table>
<h3>故障切换流程</h3>
<pre><code>正常状态：
  用户流量 → 路由层 → SET-2（主）

故障检测：
  健康检查失败 → 确认 SET-2 不可用 → 触发切换流程

切换执行：
  1. 停止 SET-2 的流量接入（路由层摘除）
  2. 等待 SET-2 → SET-2-备 的数据同步完成（或接受部分数据丢失）
  3. 更新路由表：SET-2 的分片 → SET-2-备
  4. 开放 SET-2-备 的流量接入
  5. 验证切换后的业务正确性

恢复状态：
  用户流量 → 路由层 → SET-2-备（新主）
</code></pre>
<h3>容灾等级</h3>
<table>
<thead>
<tr>
<th>等级</th>
<th>容灾范围</th>
<th>实现方式</th>
<th>RTO</th>
</tr>
</thead>
<tbody><tr>
<td><strong>L1</strong></td>
<td>单机故障</td>
<td>应用集群 + DB 主备</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>L2</strong></td>
<td>机架故障</td>
<td>跨机架部署</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>L3</strong></td>
<td>机房故障</td>
<td>同城双机房 SET 互备</td>
<td>分钟级</td>
</tr>
<tr>
<td><strong>L4</strong></td>
<td>城市故障</td>
<td>异地 SET 互备</td>
<td>分钟级~小时级</td>
</tr>
</tbody></table>
<h2>核心设计五：SET 扩缩容</h2>
<p>SET 化架构的一个重要优势是可以通过增减 SET 数量来调整系统容量。</p>
<h3>扩容流程</h3>
<pre><code>扩容场景：当前 3 个 SET 容量不足，需要扩容到 4 个 SET

Step 1: 部署新 SET（SET-4）
  - 部署完整的应用服务、缓存、数据库
  - 从现有 SET 同步全局数据

Step 2: 数据迁移
  - 将 SET-1 的部分虚拟分片的数据迁移到 SET-4
  - 采用双写方案保证迁移过程不中断服务

Step 3: 路由切换
  - 更新路由表：迁移的虚拟分片指向 SET-4
  - 灰度切换流量，逐步验证

Step 4: 清理
  - 验证完成后，清理 SET-1 中已迁移的数据
  - 回收空闲资源
</code></pre>
<h3>虚拟分片的价值</h3>
<p>虚拟分片是实现平滑扩缩容的关键：</p>
<pre><code>初始状态（3 个 SET，1024 个虚拟分片）：
  SET-1: 虚拟分片 0~341
  SET-2: 虚拟分片 342~682
  SET-3: 虚拟分片 683~1023

扩容到 4 个 SET（只需调整虚拟分片映射）：
  SET-1: 虚拟分片 0~255
  SET-2: 虚拟分片 256~511
  SET-3: 虚拟分片 512~767
  SET-4: 虚拟分片 768~1023

优势：用户 → 虚拟分片的映射不变，只调整虚拟分片 → 物理 SET 的映射
</code></pre>
<h2>实践案例：电商交易系统 SET 化</h2>
<p>以一个典型的电商交易系统为例，展示 SET 化的具体落地方案。</p>
<h3>业务分析</h3>
<table>
<thead>
<tr>
<th>服务</th>
<th>路由键关系</th>
<th>SET 化策略</th>
</tr>
</thead>
<tbody><tr>
<td>用户服务</td>
<td>用户 ID（强绑定）</td>
<td>SET 内部署</td>
</tr>
<tr>
<td>订单服务</td>
<td>用户 ID（强绑定）</td>
<td>SET 内部署</td>
</tr>
<tr>
<td>支付服务</td>
<td>用户 ID（强绑定）</td>
<td>SET 内部署</td>
</tr>
<tr>
<td>商品服务</td>
<td>无关（全局数据）</td>
<td>全局部署 + 数据广播</td>
</tr>
<tr>
<td>库存服务</td>
<td>商品维度（跨 SET）</td>
<td>全局部署</td>
</tr>
<tr>
<td>搜索服务</td>
<td>无关（全局数据）</td>
<td>全局部署</td>
</tr>
<tr>
<td>营销服务</td>
<td>活动维度（跨 SET）</td>
<td>全局部署</td>
</tr>
</tbody></table>
<h3>整体架构</h3>
<pre><code>                        ┌──────────────────────────────────┐
                        │          统一接入层（GSLB）         │
                        └───────────────┬──────────────────┘
                                        ↓
                        ┌──────────────────────────────────┐
                        │         API Gateway（路由层）       │
                        │    提取 UserID → 查询路由表 → 转发   │
                        └──┬──────────────┬────────────┬───┘
                           ↓              ↓            ↓
                    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
                    │   SET-1     │ │   SET-2     │ │   SET-3     │
                    │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────┐ │
                    │ │用户服务  │ │ │ │用户服务  │ │ │ │用户服务  │ │
                    │ │订单服务  │ │ │ │订单服务  │ │ │ │订单服务  │ │
                    │ │支付服务  │ │ │ │支付服务  │ │ │ │支付服务  │ │
                    │ │Redis    │ │ │ │Redis    │ │ │ │Redis    │ │
                    │ │MySQL    │ │ │ │MySQL    │ │ │ │MySQL    │ │
                    │ └─────────┘ │ │ └─────────┘ │ │ └─────────┘ │
                    └─────────────┘ └─────────────┘ └─────────────┘
                           ↕              ↕            ↕
                    ┌──────────────────────────────────────────┐
                    │              全局服务层                     │
                    │  商品服务 │ 库存服务 │ 搜索服务 │ 营销服务    │
                    │         全局 ID 服务 │ 配置中心              │
                    └──────────────────────────────────────────┘
</code></pre>
<h3>下单流程的 SET 化处理</h3>
<pre><code>用户 A（ID=500）下单购买商品 X：

1. 请求到达 API Gateway
2. Gateway 提取 UserID=500，查路由表 → SET-1
3. 请求转发到 SET-1 的订单服务
4. 订单服务调用全局商品服务查询商品信息
5. 订单服务调用全局库存服务扣减库存
6. 订单服务在 SET-1 本地 DB 创建订单
7. 订单服务调用 SET-1 本地的支付服务发起支付
8. 支付完成后，SET-1 的订单服务更新本地订单状态
</code></pre>
<p>关键点：</p>
<ul>
<li>用户维度的数据操作（创建订单、支付）在 SET 内完成，无跨 SET 调用</li>
<li>商品、库存等全局数据通过全局服务访问</li>
<li>RPC 框架自动将 SET 标识通过上下文传递，保证 SET 内调用的正确性</li>
</ul>
<h2>SET 化实施路线</h2>
<p>SET 化是一个渐进式的过程，不应该一步到位。</p>
<h3>阶段规划</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>目标</th>
<th>关键动作</th>
<th>周期</th>
</tr>
</thead>
<tbody><tr>
<td><strong>P0：基础设施准备</strong></td>
<td>具备 SET 化的基础能力</td>
<td>统一 RPC 框架、引入路由组件、改造 ID 生成</td>
<td>1~2 月</td>
</tr>
<tr>
<td><strong>P1：核心链路 SET 化</strong></td>
<td>交易核心链路实现 SET 化</td>
<td>订单、支付、用户服务 SET 化部署</td>
<td>2~3 月</td>
</tr>
<tr>
<td><strong>P2：全链路 SET 化</strong></td>
<td>所有服务完成 SET 化改造</td>
<td>非核心服务 SET 化、全局服务治理</td>
<td>3~6 月</td>
</tr>
<tr>
<td><strong>P3：异地 SET</strong></td>
<td>实现异地多活能力</td>
<td>跨机房 SET 部署、数据同步、故障切换</td>
<td>3~6 月</td>
</tr>
</tbody></table>
<h3>改造清单</h3>
<p><strong>应用层改造</strong>：</p>
<ul>
<li>所有服务支持从请求上下文中提取和传递路由键</li>
<li>RPC 框架支持基于路由键的服务路由</li>
<li>消息队列的生产和消费支持 SET 路由</li>
<li>定时任务支持按 SET 分片执行</li>
</ul>
<p><strong>数据层改造</strong>：</p>
<ul>
<li>数据库按 SET 进行物理隔离</li>
<li>缓存按 SET 进行 namespace 隔离</li>
<li>全局数据的同步机制建设</li>
<li>数据对账和修复工具</li>
</ul>
<p><strong>基础设施改造</strong>：</p>
<ul>
<li>统一路由服务建设</li>
<li>全局 ID 生成服务建设</li>
<li>监控体系支持 SET 维度</li>
<li>发布系统支持按 SET 灰度</li>
</ul>
<h2>SET 化与异地多活的关系</h2>
<p>SET 化架构是异地多活的基础。两者的关系可以这样理解：</p>
<pre><code>SET 化 = 单元化部署 + 流量路由 + 数据分片
异地多活 = SET 化 + 跨地域部署 + 数据同步 + 故障切换
</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>同城 SET 化</th>
<th>异地多活 SET 化</th>
</tr>
</thead>
<tbody><tr>
<td>部署范围</td>
<td>同城多机房</td>
<td>跨城市多机房</td>
</tr>
<tr>
<td>网络延迟</td>
<td>&lt; 1ms</td>
<td>10~50ms</td>
</tr>
<tr>
<td>数据同步</td>
<td>同步/半同步复制</td>
<td>异步复制（最终一致性）</td>
</tr>
<tr>
<td>故障切换</td>
<td>自动秒级切换</td>
<td>手动/半自动分钟级切换</td>
</tr>
<tr>
<td>核心挑战</td>
<td>路由准确性</td>
<td>数据一致性 + 切换决策</td>
</tr>
</tbody></table>
<blockquote>
<p>SET 化架构天然具备&quot;每个 SET 独立自治&quot;的特性，这为异地多活提供了完美的基础。只需将不同的 SET 部署到不同的地域，配合数据同步和流量调度，就能实现异地多活。</p>
</blockquote>
<h2>常见问题与解决方案</h2>
<h3>跨 SET 调用问题</h3>
<p><strong>问题</strong>：部分业务场景不可避免需要跨 SET 访问数据。</p>
<p><strong>解决方案</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>用户查看商户信息</td>
<td>商户数据作为全局数据广播</td>
</tr>
<tr>
<td>商户查看所有订单</td>
<td>聚合服务从各 SET 并行查询后合并</td>
</tr>
<tr>
<td>全站排行榜</td>
<td>各 SET 本地计算后汇总到全局服务</td>
</tr>
<tr>
<td>跨用户转账</td>
<td>通过消息队列异步通知目标 SET</td>
</tr>
</tbody></table>
<h3>数据迁移问题</h3>
<p><strong>问题</strong>：扩容时需要在 SET 间迁移数据。</p>
<p><strong>解决方案</strong>：双写方案</p>
<pre><code>Phase 1: 新 SET 开始从旧 SET 同步增量数据（Binlog 订阅）
Phase 2: 同步追上后，开启双写模式（新请求同时写入新旧 SET）
Phase 3: 路由切换，新请求全部路由到新 SET
Phase 4: 验证无误后，停止双写，清理旧数据
</code></pre>
<h3>全局服务瓶颈</h3>
<p><strong>问题</strong>：全局服务成为所有 SET 的共同依赖，可能成为瓶颈。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li><strong>数据本地化</strong>：全局数据尽可能广播到各 SET 本地，减少全局服务调用</li>
<li><strong>缓存优先</strong>：全局数据走多级缓存，降低对全局 DB 的访问</li>
<li><strong>异步化</strong>：非实时性要求的全局操作通过消息队列异步处理</li>
<li><strong>弹性扩展</strong>：全局服务本身也需要集群化部署和弹性扩展</li>
</ol>
<h2>总结</h2>
<p>SET 化架构是应对互联网业务规模化增长的系统性解决方案。它的核心思想并不复杂——<strong>把一个大系统拆分成多个独立自治的小系统</strong>——但真正的挑战在于落地过程中的每一个细节。</p>
<p>回顾 SET 化的关键设计决策：</p>
<ol>
<li><strong>路由键选择决定了架构的天花板</strong>。选错路由键会导致大量跨 SET 调用，抵消 SET 化的优势</li>
<li><strong>数据分类是 SET 化的基础</strong>。明确哪些是 SET 内数据、哪些是全局数据，才能设计合理的数据架构</li>
<li><strong>虚拟分片是弹性扩展的关键</strong>。不要将用户直接映射到物理 SET，虚拟分片层带来的灵活性至关重要</li>
<li><strong>全局服务的治理不能忽视</strong>。全局服务是所有 SET 的共同依赖，必须做到高可用和高性能</li>
<li><strong>渐进式实施是务实的选择</strong>。从核心链路开始，逐步扩展，而不是试图一步到位</li>
</ol>
<blockquote>
<p><strong>SET 化不是目的，而是手段。</strong> 它服务于两个根本目标：让系统能够水平扩展以承载业务增长，让故障影响可控以保障用户体验。在实施 SET 化之前，先问自己：当前的业务规模真的需要 SET 化吗？</p>
</blockquote>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/architecture/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"架构设计"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-03-14","children":"2024年03月14日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"一个秒杀系统的设计思考"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","秒杀系统",{"href":"/blog/tag/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"秒杀系统"}],["$","$L13","高并发",{"href":"/blog/tag/%E9%AB%98%E5%B9%B6%E5%8F%91/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"高并发"}],["$","$L13","架构设计",{"href":"/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"架构设计"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/data/电商分析必懂的指标体系","title":"电商分析必懂的指标体系","description":"今天，我就来讲讲电商到底该重点关注哪些指标，又该拿这些指标来进行怎么样的分析。 一般来说，在运营模块，需要重点关注的是新用户的引流和转化，以及老用户的活跃、留存、回购、流失。 简单来说，引流就是要吸引没买过我们的商品的人来买我们的商品。...","pubDate":"2024-03-10","tags":["电商分析","指标体系","数据分析"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"insights/science/从普遍语法到神经网络习得模型","title":"文字是语言的根本","description":"语言的本质是什么？本文提出一个鲜明命题：没有文字与符号系统支撑的声音至多是信号，不足以构成“语言” 。文字让声音获得切分、记忆、跨代传承与逻辑组织的能力，是语言成为文明工具的根本条件。","pubDate":"2024-03-15","tags":["语言学","认知科学","神经网络"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"秒杀系统":{"prev":null,"next":null},"高并发":{"prev":null,"next":{"slug":"engineering/architecture/高并发系统设计的15个锦囊","title":"高并发系统设计的15个锦囊","description":"记得很久之前，去面试过**字节跳动**。被三面的面试官问了一道场景设计题目：**如何设计一个高并发系统**。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。 所谓设计**高并发**系统，就是设计一个系统，保证它**整体可用**的同时，能够**处理很高...","pubDate":"2024-03-17","tags":["高并发","系统架构","性能优化"],"heroImage":"$undefined","content":"$19"}},"架构设计":{"prev":{"slug":"engineering/architecture/关于业务平台架构的思考","title":"关于业务平台架构的思考","description":"从业务的本质出发，探讨业务平台架构的定位、能力建模方法、域的划分逻辑，以及如何基于企业架构思维构建可持续演进的业务架构体系。","pubDate":"2024-03-04","tags":["业务架构","平台化","架构设计","领域建模","企业架构"],"heroImage":"$undefined","content":"$1a"},"next":{"slug":"engineering/architecture/SET化架构：从单元化原理到大规模落地实践","title":"SET化架构：从单元化原理到大规模落地实践","description":"深入剖析SET化（单元化）架构的核心原理与设计实践，涵盖流量路由、数据分片、全局服务、故障隔离等关键环节，结合美团、阿里等大厂实践经验，构建可水平扩展的弹性架构体系。","pubDate":"2024-03-15","tags":["架构设计","SET化架构","单元化","异地多活","高可用"],"heroImage":"$undefined","content":"$1b"}}}}]}],["$","$L1c",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"一个秒杀系统的设计思考 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"前言 秒杀大家都不陌生。自2011年首次出现以来，无论是双十一购物还是 12306抢票，秒杀场景已随处可见。简单来说，秒杀就是在同一时刻大量请求争抢购买同一商品并完成交易的过程。从架构视角来看，秒杀系统本质是一个高性能、高一致、高可用的三高系统。"}],["$","meta","2",{"property":"og:title","content":"一个秒杀系统的设计思考"}],["$","meta","3",{"property":"og:description","content":"前言 秒杀大家都不陌生。自2011年首次出现以来，无论是双十一购物还是 12306抢票，秒杀场景已随处可见。简单来说，秒杀就是在同一时刻大量请求争抢购买同一商品并完成交易的过程。从架构视角来看，秒杀系统本质是一个高性能、高一致、高可用的三高系统。"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-03-14"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"一个秒杀系统的设计思考"}],["$","meta","9",{"name":"twitter:description","content":"前言 秒杀大家都不陌生。自2011年首次出现以来，无论是双十一购物还是 12306抢票，秒杀场景已随处可见。简单来说，秒杀就是在同一时刻大量请求争抢购买同一商品并完成交易的过程。从架构视角来看，秒杀系统本质是一个高性能、高一致、高可用的三高系统。"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/fffdcdb4fb651185.css","style"]
0:{"P":null,"b":"wlOkUxTzHfxl8sQA11M8Z","p":"","c":["","blog","engineering","architecture","%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E6%BC%94%E8%BF%9B%E5%8F%B2",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E6%BC%94%E8%BF%9B%E5%8F%B2","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/fffdcdb4fb651185.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E6%BC%94%E8%BF%9B%E5%8F%B2","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","HrhZzWR0_Z8pIbzkFJnYNv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1a:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T3ba4,<h3>1 传统单体系统介绍 <a href="#scroller-1" id="scroller-1"></a></h3>
<p>在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增，</p>
<p>发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。</p>
<p>但是物理服务器的CPU、内存、存储器、连接数等资源有限，单体系统能够承受的的QPS也是有限的，某个时段大量连接同时执行操作，会导致web服务和数据库服务在处理上遇到性能瓶颈。</p>
<p>为了解决这个问题，伟大的前辈们发扬了分而治之的思想，对大数据库、大表进行分割，可以参考我的《<a href="https://www.cnblogs.com/wzh2010/p/15049878.html">分库分表</a>》，以便实施更好的控制和管理。</p>
<p>同时创建多个服务实例，使用多台服务机进行CPU、内存、存储的分摊，提供更好的性能。</p>
<h4>1.1 单体系统的问题 <a href="#scroller-2" id="scroller-2"></a></h4>
<p>1、复杂性高：由于是一个单体的系统，所以整个系统的模块是耦合在一起的，模块的边界比较模糊、依赖关系错综复杂。功能的调整，容易带来不可知的影响和潜在的bug风险。</p>
<p>2、服务性能问题：单体系统遇到性能瓶颈问题，只能横向扩展，增加服务实例，进行负载均衡分担压力。无法纵向扩展，做模块拆分。</p>
<p>3、扩缩容能力受限：单体应用只能作为一个整体进行扩展，影响范围大，无法根据业务模块的需要进行单个模块的伸缩。</p>
<p>4、无法做故障隔离：当所有的业务功能模块都聚集在一个程序集当中，如果其中的某一个小的功能模块出现问题（如某个请求堵塞），那么都有可能会造成整个系统的崩溃。</p>
<p>5、发布的影响范围较大：每次发布都是整个系统进行发布，发布会导致整个系统的重启，对于大型的综合系统挑战比较大，如果将各个模块拆分，哪个部分做了修改，只发布哪个部分所在的模块即可。</p>
<h4>&#x20;<a href="#scroller-3" id="scroller-3"></a></h4>
<h4>1.2 单体系统的优点 <a href="#scroller-4" id="scroller-4"></a></h4>
<p>1、系统的简易性：系统语言风格、业务结构，接口格式均具有一致性，服务都是耦合在一起的，不存在各个业务通信问题。</p>
<p>2、易于测试：单体应用一旦部署，所有的服务或特性就都可以使用了，简化了测试过程，无需额外测试服务间的依赖，测试均可在部署完成后开始。</p>
<p>3、易于部署与升级：相对于微服务架构中的每个服务独立部署，单体系统只需将单个目录下的服务程序统一部署和升级。</p>
<p>4、较低的维护成本：只需维护单个系统即可。运维主要包括配置、部署、监控与告警和日志收集四大方面。相对于单体系统，微服务架构中的每个服务都需要独立地配置、部署、监控和日志收集，成本呈指数级增长。</p>
<h4>&#x20;<a href="#scroller-5" id="scroller-5"></a></h4>
<h4>1.3 单体服务到微服务的发展过程 <a href="#scroller-6" id="scroller-6"></a></h4>
<p>EUREKA的注册中心逐渐被ZooKeeper和Nacos等替代了。</p>
<p><img src="/images/blog/engineering/microservice-image_2_1.png" alt="image_2_1.png"></p>
<h3>2 关于微服务 <a href="#scroller-7" id="scroller-7"></a></h3>
<p>微服务是一种架构模式，是面向服务的体系结构（SOA）软件架构模式的一种演变，它提倡将单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，为用户提供最终价值。所以，微服务（或微服务架构）是一种云原生架构方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成。这些服务通常包含如下特点：</p>
<h4>2.1 单一职责 <a href="#scroller-8" id="scroller-8"></a></h4>
<p>微服务架构中的每个节点高度服务化，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，包括数据库和数据模型；不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</p>
<h4>2.2 轻量级通信 <a href="#scroller-9" id="scroller-9"></a></h4>
<p>通过REST API模式或者RPC框架，实现服务间互相协作的轻量级通信机制。</p>
<h4>2.3 独立性 <a href="#scroller-10" id="scroller-10"></a></h4>
<p>在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试、部署、运维。</p>
<h4>2.4 进程隔离 <a href="#scroller-11" id="scroller-11"></a></h4>
<p>在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上，实现高度自治和高度隔离。进程的隔离，还能保证服务达到动态扩缩容的能力，业务高峰期自动增加服务资源以提升并发能力，业务低谷期则可自动释放服务资源以节省开销。</p>
<h4>2.5 混合技术栈和混合部署方式 <a href="#scroller-12" id="scroller-12"></a></h4>
<p>团队可以为不同的服务组件使用不同的技术栈和不同的部署方式（公有云、私有云、混合云）。</p>
<h4>2.6 简化治理 <a href="#scroller-13" id="scroller-13"></a></h4>
<p>组件可以彼此独立地进行扩缩容和治理，从而减少了因必须缩放整个应用程序而产生的浪费和成本，因为单个功能可能面临过多的负载。</p>
<h4>2.7 安全可靠，可维护。 <a href="#scroller-14" id="scroller-14"></a></h4>
<p>从架构上对运维提供友好的支撑，在安全、可维护的基础上规范化发布流程，支持数据存储容灾、业务模块隔离、访问权限控制、编码安全检测等。</p>
<h3>3 微服务演进史 <a href="#scroller-15" id="scroller-15"></a></h3>
<p>我们前面已经了解了微服务的概念，通过百度指数可以看出，从2012年之后，微服务的发展有显著的发展趋势。</p>
<p><img src="/images/blog/engineering/microservice-image_2_2.png" alt="image_2_2.png"></p>
<p>目前业内的微服务相关开发平台和框架还是比较多的，比如较早的Spring Cloud（使用Eureke做服务注册与发现，Ribbon做服务间负载均衡，Hystrix做服务容错保护），</p>
<p>阿里的Dubbo，微软的.Net体系微服务框架 Service Fabric，再到后来进阶的服务网格(Service Mesh,如 Istio、Linkerd）。</p>
<p>那从12年开始到现在，微服务到底发展到哪个阶段了，在各个阶段的进阶过程中，又有哪些的变化。所以我们需要了解微服务技术的历史发展脉络。</p>
<p>下面的内容参考了 <a href="https://philcalcado.com/">Phil Calçado</a>的文章<a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">《Pattern: Service Mesh》</a>，从开发者的视角，详细分析了从微服务到Service Mesh技术的演进过程，这边做了进一步的整理和总结。</p>
<h4>3.1 第一阶：简单服务通信模块 <a href="#scroller-16" id="scroller-16"></a></h4>
<p>这是最初的模样，开发人员最开始的时候想象的两个服务间简单的通信模式，抽象表示如下，两个服务之间直接进行通信：</p>
<p><img src="/images/blog/engineering/microservice-image_2_3.png" alt="image_2_3.png"></p>
<p>3.2 第二阶：原始通信时代</p>
<p>上面的方式非常简单，但实际情况远比想象的复杂很多，通信需要底层字节码传输和电子信号的物理层来完成，在TCP协议出现之前，</p>
<p>服务需要自己处理网络通信所面临的丢包、错误、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还包含对网络传输问题的处理逻辑。</p>
<p><img src="/images/blog/engineering/microservice-image_2_4.png" alt="image_2_4.png"></p>
<h4>3.3 第三阶：TCP时代 <a href="#scroller-18" id="scroller-18"></a></h4>
<p>TCP协议的出现，避免了每个服务自己实现一套相似的网络传输处理逻辑，解决网络传输中通用的流量控制问题。</p>
<p>这时候我们把处理网络传输的能力下沉，从服务的实现中抽离出来，成为操作系统网络层的一部分。</p>
<p><img src="/images/blog/engineering/microservice-image_2_5.png" alt="image_2_5.png"></p>
<h4>3.4 第四阶：第一代微服务（Spring Cloud/RPC） <a href="#scroller-19" id="scroller-19"></a></h4>
<p>TCP出现之后，服务间的网络通信已经不是一个难题了，所以 GFS/BigTable/MapReduce 为代表的分布式系统得到了蓬勃的发展。</p>
<p>这时，分布式系统特有的通信语义又出现了，如服务注册与发现、负载均衡、熔断降级策略、认证和授权、端到端trace、日志与监控等，因此根据业务需求,完成一些通信语义的实现。</p>
<p><img src="/images/blog/engineering/microservice-image_2_6.png" alt="image_2_6.png"></p>
<h4>3.5 第五阶：第二代微服务 <a href="#scroller-20" id="scroller-20"></a></h4>
<p>为了避免每个服务都需要自己实现一套分布式系统通信的语义功能，随着技术的发展，一些面向微服务架构的通用开发框架出现了，如Twitter的<a href="https://finagle.github.io/">Finagle</a>、Facebook的<a href="https://code.facebook.com/posts/1503205539947302">Proxygen</a>以及Spring Cloud等，</p>
<p>这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。</p>
<p><img src="/images/blog/engineering/microservice-image_2_7.png" alt="image_2_7.png"></p>
<h4>3.6 第六阶：第一代Service Mesh <a href="#scroller-21" id="scroller-21"></a></h4>
<p>上面的第二代微服务框架目前看着挺完美了，但整套微服务框架其实是很复杂的，比如Spring Cloud，聚合了很多组件。所以在实践过程中，会发现有如下诸多问题：</p>
<ul>
<li>**侵入性强。**想要集成SDK的能力，除了需要添加相关依赖，业务层中入侵的代码、注解、配置，与治理层界限不清晰。</li>
<li>**升级成本高。**每次升级都需要业务应用修改SDK版本，重新进行功能回归测试，并对每一台服务进行部署上线，与快速迭代开发相悖。</li>
<li>**版本碎片化严重。**由于升级成本高，而中间件版本更新快，导致线上不同服务引用的SDK版本不统一、能力参差不齐，造成很难统一治理。</li>
<li>**中间件演变困难。**由于版本碎片化严重，导致中间件向前演进的过程中就需要在代码中兼容各种各样的老版本逻辑，带着&quot;枷锁”前行，无法实现快速迭代。</li>
<li>**内容多、门槛高。**依赖组件多，学习成本高，即使通用分布式系统屏蔽了很多的实现细节，我们引入微服务框架并熟练使用也是要花费巨大的精力的。</li>
<li>**治理功能不全。**不同于RPC框架，SpringCloud作为治理全家桶的典型，也不是万能的，诸如协议转换支持、多重授权机制、动态请求路由、故障注入、灰度发布等高级功能并没有覆盖到。</li>
<li>**无法实现真正意义上的语言无关性。**提供的框架一般只支持一种或几种语言，要将框架不支持的语言研发的服务也纳入微服务架构中，是比较有难度的。</li>
</ul>
<p>所以，第一代微服务架构 Service Mesh就产生了，它作为一个基础设施层，能够与业务解耦，主要解决复杂网络拓扑下微服务与微服务之间的通信，其实现形态一般为轻量级网络代理，并与应用以边车代理（SideCar）模式部署，同时对业务应用透明。</p>
<p><img src="/images/blog/engineering/microservice-image_2_8.png" alt="image_2_8.png"></p>
<p>SideCar将分布式服务的通信抽象为单独一层，需要和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求。</p>
<p>所以在这一层中它能够实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能。</p>
<p><img src="/images/blog/engineering/microservice-image_2_9.png" alt="image_2_9.png"></p>
<p>如果我们从一个全局视角来看，绿色的为应用服务，蓝色的为SideCar，就会得到如下部署图：</p>
<p><img src="/images/blog/engineering/microservice-image_2_10.png" alt="image_2_10.png"></p>
<p>如果我们省略去服务，只看Service Mesh的代理边车的网格应该是这样的：</p>
<p><img src="/images/blog/engineering/microservice-image_2_11.png" alt="image_2_11.png"></p>
<p>流量经过的时候，会先被代理边车所劫持，然后再进入服务，所以它就是一个由若干服务代理所组成的错综复杂的网格。</p>
<h4>3.7 第七阶：第二代Service Mesh <a href="#scroller-22" id="scroller-22"></a></h4>
<p>第一代Service Mesh由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的控制面板，我们称之为控制面（control plane）。</p>
<p>控制面和所有的数据面（data plane，即代理边车）进行交互，比如策略下发、数据采集等。这就是以Istio为代表的第二代Service Mesh。</p>
<p><img src="/images/blog/engineering/microservice-image_2_12.png" alt="image_2_12.png"></p>
<p>只包含控制面和数据面的 Service Mesh 服务网格全局结构图 如下：</p>
<p><img src="/images/blog/engineering/microservice-image_2_13.png" alt="image_2_13.png"></p>
<p>从上面的结构图可以看出，Service Mesh 的基础设施层主要分为两部分：控制平面与数据平面。当前流行的开源服务网格 Istio 和 Linkerd 都是这种构造。</p>
<p>控制平面的特点：</p>
<ul>
<li>不直接解析数据包。</li>
<li>与控制平面中的代理通信，下发策略和配置。</li>
<li>负责网络行为的可视化。</li>
<li>通常提供 API 或者命令行工具可用于配置版本化管理，便于持续集成和部署。</li>
</ul>
<p>数据平面的特点：</p>
<ul>
<li>通常是按照无状态目标设计的，但实际上为了提高流量转发性能，需要缓存一些数据，因此无状态也是有争议的。</li>
<li>直接处理入站和出站数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据等。</li>
<li>对应用来说透明，即可以做到无感知部署。</li>
</ul>
<p>到这一步我们大概了解了微服务架构的演进过程，也初步了解Service Mesh技术比较于传统的微服务架构有哪些优势。</p>
17:T5c64,<blockquote>
<p>微服务架构已经成为互联网后端系统的主流架构范式。然而，从单体架构迁移到微服务，绝不仅仅是把代码拆成几个服务那么简单——它涉及服务如何注册与发现、如何通信与容错、如何部署与监控等一系列基础设施问题。本文从架构设计的核心关注点出发，结合业界最佳实践，系统性地梳理微服务架构落地所需的技术体系。</p>
</blockquote>
<h2>微服务架构概览</h2>
<h3>什么是微服务架构？</h3>
<p>与单体（Monolithic）架构不同，微服务架构是由一系列<strong>职责单一的细粒度服务</strong>构成的分布式网状结构，服务之间通过轻量级机制进行通信。这种架构带来了独立部署、技术异构、弹性伸缩等优势，但同时也引入了一系列新的技术挑战。</p>
<h3>核心技术关注点</h3>
<p>一个完整的微服务架构需要关注以下层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>关注点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>通信</strong></td>
<td>服务注册与发现、负载均衡、RPC 框架、API 网关</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>服务容错（熔断、隔离、限流、降级）</td>
</tr>
<tr>
<td><strong>基础设施</strong></td>
<td>配置中心、缓存、消息队列、数据库</td>
</tr>
<tr>
<td><strong>交付</strong></td>
<td>CI/CD 流水线、自动化测试、灰度发布</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>日志系统、监控告警、链路追踪</td>
</tr>
<tr>
<td><strong>部署</strong></td>
<td>负载均衡、DNS、CDN</td>
</tr>
</tbody></table>
<p>接下来，我们逐一展开讨论。</p>
<h2>服务注册、发现与负载均衡</h2>
<p>微服务架构下，服务提供方需要注册通告服务地址，服务调用方需要发现目标服务，同时服务提供方一般以集群方式提供服务，这就引入了负载均衡和健康检查问题。</p>
<p>根据负载均衡器（LB）所在位置的不同，目前主要有三种方案：</p>
<h3>方案一：集中式 LB</h3>
<p>在服务消费者和服务提供者之间设置独立的 LB（如 F5 硬件或 LVS/HAProxy 软件），LB 上有所有服务的地址映射表，由运维配置注册。服务消费方通过 DNS 域名指向 LB。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>实现简单，当前业界主流</td>
<td>单点问题，LB 容易成为瓶颈</td>
</tr>
<tr>
<td>易于做集中式访问控制</td>
<td>增加一跳（hop），有性能开销</td>
</tr>
<tr>
<td></td>
<td>一旦 LB 故障，影响是灾难性的</td>
</tr>
</tbody></table>
<h3>方案二：进程内 LB（客户端负载）</h3>
<p>将 LB 功能以库的形式集成到服务消费方进程内，也称为<strong>软负载（Soft Load Balancing）</strong>。需要配合服务注册表（Service Registry）支持服务自注册和自发现。</p>
<p>工作原理：</p>
<ol>
<li>服务提供方启动时，将地址注册到服务注册表，并定期发送心跳</li>
<li>服务消费方通过内置 LB 组件查询注册表，缓存并定期刷新目标地址列表</li>
<li>以某种负载均衡策略选择目标地址，直接发起请求</li>
</ol>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>分布式方案，无单点问题</td>
<td>多语言栈需开发多种客户端库</td>
</tr>
<tr>
<td>服务间直接调用，性能好</td>
<td>客户端库升级需服务方重新发布</td>
</tr>
</tbody></table>
<p>典型案例：Netflix OSS（Eureka + Ribbon + Karyon）、阿里 Dubbo。</p>
<h3>方案三：主机独立 LB 进程（Sidecar 模式）</h3>
<p>将 LB 和服务发现功能从进程内移出，变成主机上的独立进程。同一主机上的多个服务共享该 LB 进程完成服务发现和负载均衡。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>无单点，一个 LB 挂只影响该主机</td>
<td>部署较复杂，环节多</td>
</tr>
<tr>
<td>不需要为不同语言开发客户端库</td>
<td>出错调试排查不方便</td>
</tr>
<tr>
<td>LB 升级不需要服务方改代码</td>
<td></td>
</tr>
</tbody></table>
<p>典型案例：Airbnb SmartStack（Zookeeper + Nerve + Synapse/HAProxy）、Kubernetes 内部服务发现。</p>
<blockquote>
<p>三种方案各有取舍，选择时需要综合考虑团队技术栈的多样性、运维能力和性能要求。当前趋势是方案三（Sidecar 模式）逐渐演化为 Service Mesh（服务网格），如 Istio + Envoy。</p>
</blockquote>
<h2>API 网关（Service Gateway）</h2>
<p>微服务最终需要以某种方式暴露给外部系统访问，这就需要<strong>服务网关</strong>。网关是连接企业内部和外部系统的一道门，承担以下关键职责：</p>
<table>
<thead>
<tr>
<th>职责</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>反向路由</strong></td>
<td>将外部请求路由到内部具体的微服务，对外呈现统一入口</td>
</tr>
<tr>
<td><strong>安全认证</strong></td>
<td>集中处理用户认证、授权和防爬虫</td>
</tr>
<tr>
<td><strong>限流容错</strong></td>
<td>流量高峰期限流保护后台，内部故障时集中容错</td>
</tr>
<tr>
<td><strong>监控</strong></td>
<td>集中监控访问量、调用延迟、错误计数</td>
</tr>
<tr>
<td><strong>日志</strong></td>
<td>收集所有访问日志，为后续分析提供数据</td>
</tr>
</tbody></table>
<p>除此之外，网关还可以实现<strong>线上引流、线上压测、金丝雀发布（Canary Testing）、数据中心双活</strong>等高级功能。</p>
<h3>微服务的分层架构</h3>
<p>引入网关和服务注册表之后，微服务可以简化为两层结构：</p>
<ul>
<li><strong>后端通用服务（Middle Tier Service）</strong>：启动时注册地址到注册表</li>
<li><strong>前端边缘服务（Edge Service）</strong>：查询注册表发现后端服务，对后端服务做聚合和裁剪后暴露给外部设备</li>
</ul>
<p>网关通过查询注册表将外部请求路由到前端服务，整个微服务体系的自注册、自发现和软路由就此串联起来。如果用设计模式的视角看——<strong>网关类似 Proxy/Facade 模式，服务注册表类似 IoC 依赖注入模式</strong>。</p>
<p>常见的网关组件：Netflix Zuul、Kong、APISIX、Spring Cloud Gateway。</p>
<h2>服务容错</h2>
<p>当企业微服务化后，服务之间存在错综复杂的依赖关系。一个前端请求一般依赖多个后端服务（1→N 扇出）。在生产环境中，如果一个应用不能对其依赖的故障进行容错和隔离，就面临被拖垮的风险。在高流量场景下，某个单一后端一旦发生延迟，可能在数秒内导致所有应用资源（线程、队列等）被耗尽，造成<strong>雪崩效应（Cascading Failure）</strong>。</p>
<p>业界总结出以下核心容错模式：</p>
<h3>熔断器模式（Circuit Breaker）</h3>
<p>原理类似家用电路熔断器。当目标服务慢或大量超时时，调用方主动熔断，防止服务被进一步拖垮。</p>
<p>熔断器有三种状态：</p>
<pre><code>Closed（正常）→ Open（熔断）→ Half-Open（半熔断）→ Closed/Open
</code></pre>
<ul>
<li><strong>Closed</strong>：正常状态，请求正常通过</li>
<li><strong>Open</strong>：调用持续出错或超时，进入熔断状态，后续请求直接拒绝（Fail Fast）</li>
<li><strong>Half-Open</strong>：一段时间后允许少量请求尝试，成功则恢复，失败则继续熔断</li>
</ul>
<h3>舱壁隔离模式（Bulkhead Isolation）</h3>
<p>像船舱一样对资源进行隔离。典型实现是<strong>线程隔离</strong>：假定应用 A 调用 Svc1/Svc2/Svc3 三个服务，容器共有 120 个工作线程，可以给每个服务各分配 40 个线程。当 Svc2 变慢时，只有分配给 Svc2 的 40 个线程被耗尽，Svc1 和 Svc3 的 80 个线程不受影响。</p>
<h3>限流（Rate Limiting）</h3>
<p>对服务限定并发访问量，比如单位时间只允许 100 个并发调用，超过限制的请求拒绝并回退。没有限流机制的服务在突发流量（秒杀、大促）时极易被冲垮。</p>
<h3>降级回退（Fallback）</h3>
<p>当熔断或限流发生时的后续处理策略：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Fail Fast</td>
<td>直接抛出异常</td>
</tr>
<tr>
<td>返回缺省值</td>
<td>返回空值或默认数据</td>
</tr>
<tr>
<td>备份服务</td>
<td>从备份数据源获取数据</td>
</tr>
</tbody></table>
<blockquote>
<p>Netflix 将上述容错模式集成到 Hystrix 开源组件中（现已进入维护模式，社区推荐 Resilience4j 或 Sentinel 作为替代）。Spring Cloud Circuit Breaker 提供了统一的抽象层。</p>
</blockquote>
<h2>服务框架的核心能力</h2>
<p>微服务化后，为了让业务开发人员专注于业务逻辑，避免冗余和重复劳动，需要将公共关注点推到框架层面。一个成熟的服务框架应当封装以下能力：</p>
<table>
<thead>
<tr>
<th>能力</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册发现</td>
<td>服务端自注册，客户端自发现和负载均衡</td>
</tr>
<tr>
<td>监控日志</td>
<td>框架层日志、Metrics、调用链数据的记录和暴露</td>
</tr>
<tr>
<td>REST/RPC 与序列化</td>
<td>支持 HTTP/REST 和 Binary/RPC，可定制序列化（JSON/Protobuf 等）</td>
</tr>
<tr>
<td>动态配置</td>
<td>运行时动态调整参数和配置</td>
</tr>
<tr>
<td>限流容错</td>
<td>集成限流和熔断组件，结合动态配置实现动态限流</td>
</tr>
<tr>
<td>管理接口</td>
<td>在线查看和动态调整框架及服务内部状态（如 Spring Boot Actuator）</td>
</tr>
<tr>
<td>统一错误处理</td>
<td>框架层统一处理异常并记录日志</td>
</tr>
<tr>
<td>安全</td>
<td>访问控制逻辑的插件化封装</td>
</tr>
<tr>
<td>文档自动生成</td>
<td>如 Swagger/OpenAPI 的自动化文档方案</td>
</tr>
</tbody></table>
<p>当前业界成熟的微服务框架有：Spring Cloud/Spring Boot、Apache Dubbo、Go-Micro、gRPC 等。</p>
<h2>基础设施选型</h2>
<h3>RPC 框架选型</h3>
<p>RPC（Remote Procedure Call）框架大致分为两大流派：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表框架</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>跨语言调用型</strong></td>
<td>gRPC、Thrift、Hprose</td>
<td>支持多语言调用，无服务治理机制</td>
<td>多语言调用场景</td>
</tr>
<tr>
<td><strong>服务治理型</strong></td>
<td>Dubbo、Motan、rpcx</td>
<td>功能丰富，含服务发现和治理能力</td>
<td>大型服务的解耦和治理</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：如果是 Java 为主的团队，推荐 <strong>Dubbo</strong>（高性能，性能测试中比 Feign 强约 10 倍）。如果需要跨语言支持，Dubbo 也支持通过 Dubbo-Go 实现 Java + Go 双语言微服务架构。如果是纯粹的跨语言场景，<strong>gRPC</strong> 基于 HTTP/2 + Protobuf，是业界标准选择。</p>
<h3>注册中心选型</h3>
<p>所有的服务发现都依赖于一个高可用的服务注册表。主流选择：</p>
<table>
<thead>
<tr>
<th>注册中心</th>
<th>特点</th>
<th>一致性模型</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nacos</strong></td>
<td>同时支持注册中心和配置中心，功能全面</td>
<td>AP/CP 可切换</td>
</tr>
<tr>
<td><strong>ZooKeeper</strong></td>
<td>最早的分布式协调服务，生态成熟</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Etcd</strong></td>
<td>Kubernetes 默认存储，高可用和一致性</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Consul</strong></td>
<td>支持多数据中心，内置健康检查</td>
<td>CP</td>
</tr>
<tr>
<td><strong>Eureka</strong></td>
<td>Netflix 开源，AP 模型，已停止维护</td>
<td>AP</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：推荐 <strong>Nacos</strong>（nacos + MySQL 高可用部署），一站式解决注册中心和配置中心的需求。</p>
<h3>配置中心选型</h3>
<p>随着系统复杂度增长，配置管理面临越来越高的要求：配置修改实时生效、灰度发布、分环境/分集群管理、完善的权限审核机制。传统的配置文件方式已经无法满足需求。</p>
<p>配置中心的核心架构组件：</p>
<ul>
<li><strong>配置服务端</strong>：集中存储和管理所有配置信息</li>
<li><strong>配置客户端</strong>：通过<strong>定期拉取（Pull）</strong> 或 <strong>服务端推送（Push）</strong> 方式获取配置更新</li>
<li><strong>管理界面</strong>：配置的增删改查和审计</li>
</ul>
<table>
<thead>
<tr>
<th>配置中心</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Nacos</strong></td>
<td>阿里开源，同时支持注册和配置，生态活跃</td>
</tr>
<tr>
<td><strong>Apollo</strong></td>
<td>携程开源，功能完善，支持灰度发布和权限管理</td>
</tr>
<tr>
<td><strong>Spring Cloud Config</strong></td>
<td>Spring 生态原生支持，基于 Git 存储</td>
</tr>
</tbody></table>
<h3>缓存中间件选型</h3>
<table>
<thead>
<tr>
<th>缓存</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Redis</strong></td>
<td>多数据结构，支持持久化和集群</td>
<td>通用缓存、分布式锁、排行榜等</td>
</tr>
<tr>
<td><strong>Memcached</strong></td>
<td>纯内存 KV，简单高效</td>
<td>简单的对象缓存</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：推荐 <strong>Redis Cluster</strong> 高可用集群部署。</p>
<blockquote>
<p>需要特别关注 Redis 的 Big Key 问题。在高并发场景下，Big Key 会导致单个节点内存和网络带宽瓶颈，严重时可造成系统瘫痪。建议制定 Key 规范并定期扫描。</p>
</blockquote>
<h3>消息中间件选型</h3>
<p>消息中间件的三大核心场景：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
<th>典型案例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>异步处理</strong></td>
<td>减少主流程等待时间，非核心逻辑异步执行</td>
<td>注册后发送邮件、异步更新缓存</td>
</tr>
<tr>
<td><strong>系统解耦</strong></td>
<td>上下游系统通过消息通信，不需要强一致</td>
<td>支付成功后通知 ERP/WMS/推荐等系统</td>
</tr>
<tr>
<td><strong>削峰填谷</strong></td>
<td>大流量请求放入队列，消费者按能力消化</td>
<td>秒杀系统的下单排队</td>
</tr>
</tbody></table>
<p>主流消息中间件对比：</p>
<table>
<thead>
<tr>
<th>中间件</th>
<th>吞吐量</th>
<th>延迟</th>
<th>可靠性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Kafka</strong></td>
<td>极高</td>
<td>毫秒级</td>
<td>高（可配置）</td>
<td>日志收集、大数据流处理、事件溯源</td>
</tr>
<tr>
<td><strong>RocketMQ</strong></td>
<td>高</td>
<td>毫秒级</td>
<td>极高（事务消息）</td>
<td>电商交易、金融场景</td>
</tr>
<tr>
<td><strong>RabbitMQ</strong></td>
<td>中等</td>
<td>微秒级</td>
<td>高</td>
<td>实时性要求高、路由复杂的场景</td>
</tr>
</tbody></table>
<p><strong>选型建议</strong>：<strong>Kafka</strong> 用于日志采集和大数据场景，<strong>RocketMQ</strong> 用于业务消息和交易场景，二者搭配使用。</p>
<h3>数据库选型</h3>
<h4>关系型数据库</h4>
<table>
<thead>
<tr>
<th>类别</th>
<th>代表</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>传统 RDBMS</strong></td>
<td>MySQL、PostgreSQL</td>
<td>成熟稳定，生态丰富，百万级 PV 搭配主从 + 缓存可满足</td>
</tr>
<tr>
<td><strong>NewSQL</strong></td>
<td>TiDB、CockroachDB</td>
<td>完整 SQL 支持 + ACID 事务 + 弹性伸缩 + 高可用 + 大数据分析能力</td>
</tr>
</tbody></table>
<p>当 MySQL 需要分库分表且逻辑复杂度高、扩展性不足时，可以考虑 TiDB。</p>
<h4>NoSQL 数据库</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>键值型</strong></td>
<td>Redis、Memcache</td>
<td>缓存、会话管理</td>
</tr>
<tr>
<td><strong>列式</strong></td>
<td>HBase、Cassandra</td>
<td>写多读少、时序数据</td>
</tr>
<tr>
<td><strong>文档型</strong></td>
<td>MongoDB、CouchDB</td>
<td>非结构化数据、灵活 Schema</td>
</tr>
<tr>
<td><strong>图数据库</strong></td>
<td>Neo4J</td>
<td>社交网络、推荐系统</td>
</tr>
</tbody></table>
<h2>CI/CD 流水线</h2>
<p>从代码到最终服务用户，可以分为三个阶段：</p>
<pre><code>Code → Artifact（制品库）→ Running Service → Production
</code></pre>
<ol>
<li><strong>代码到制品</strong>：持续构建，制品集中管理</li>
<li><strong>制品到服务</strong>：部署到指定环境</li>
<li><strong>开发到生产</strong>：变更在不同环境间的迁移和灰度发布</li>
</ol>
<h3>工具链推荐</h3>
<table>
<thead>
<tr>
<th>环节</th>
<th>推荐工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代码管理</strong></td>
<td>GitLab</td>
<td>社区版功能丰富，结合 Gerrit 做 Code Review</td>
</tr>
<tr>
<td><strong>持续集成</strong></td>
<td>Jenkins / GitLab CI</td>
<td>Jenkins 插件生态强大；GitLab CI 与 GitLab 深度集成</td>
</tr>
<tr>
<td><strong>制品仓库</strong></td>
<td>Harbor</td>
<td>开源的 Docker 镜像仓库，支持镜像签名和漏洞扫描</td>
</tr>
<tr>
<td><strong>部署编排</strong></td>
<td>Kubernetes</td>
<td>容器编排的事实标准，支持声明式部署和自动伸缩</td>
</tr>
<tr>
<td><strong>项目管理</strong></td>
<td>Jira + Confluence</td>
<td>项目管理、任务跟踪和知识管理的行业标配</td>
</tr>
</tbody></table>
<p><strong>初期建议</strong>：Jenkins + GitLab + Harbor 的组合，可以覆盖制品管理、发布流程、权限控制、版本变更和服务回滚。</p>
<h3>自动化测试</h3>
<p>自动化测试平台是 CI/CD 流水线的重要一环：</p>
<ul>
<li><strong>单元测试</strong>：JUnit / TestNG，覆盖核心业务逻辑</li>
<li><strong>接口测试</strong>：可基于开源框架（如 SpringBoot + TestNG）搭建</li>
<li><strong>性能测试</strong>：JMeter / Gatling</li>
<li><strong>端到端测试</strong>：Selenium / Cypress</li>
</ul>
<h2>可观测性体系</h2>
<h3>日志系统</h3>
<p>日志系统涵盖日志打印、采集、中转、存储、分析、搜索和分发。日志系统的建设不仅是工具建设，还包括规范和组件建设——基本的日志（如全链路追踪 ID）应在框架和组件层面统一注入。</p>
<p><strong>常规方案：ELK Stack</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Filebeat</strong></td>
<td>轻量级日志采集器，替代 Logstash-Forwarder</td>
</tr>
<tr>
<td><strong>Logstash</strong></td>
<td>日志收集、过滤和转换</td>
</tr>
<tr>
<td><strong>Elasticsearch</strong></td>
<td>分布式搜索引擎，存储和索引日志</td>
</tr>
<tr>
<td><strong>Kibana</strong></td>
<td>可视化界面，日志搜索和分析</td>
</tr>
</tbody></table>
<blockquote>
<p>免费版 ELK 没有安全机制，建议前置 Nginx 做反向代理和简单用户认证。</p>
</blockquote>
<p><strong>实时计算方案</strong>：对于需要实时分析的场景，可以采用 Flume + Kafka + Flink（或 Storm）的架构。Kafka 负责高吞吐的消息缓冲，Flume 负责多样化的数据采集，Flink 负责实时流计算。</p>
<h3>监控系统</h3>
<p>监控系统主要覆盖两个层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>监控指标</th>
</tr>
</thead>
<tbody><tr>
<td><strong>基础设施</strong></td>
<td>机器负载、IO、网络流量、CPU、内存</td>
</tr>
<tr>
<td><strong>服务质量</strong></td>
<td>可用性、成功率、失败率、QPS、延迟</td>
</tr>
</tbody></table>
<p><strong>推荐方案：Prometheus + Grafana</strong></p>
<p>Prometheus 是 Google BorgMon 的开源版本，使用 Go 开发，采用 <strong>Pull</strong> 模式主动拉取指标数据。其核心组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Prometheus Server</strong></td>
<td>数据采集和存储，提供 PromQL 查询</td>
</tr>
<tr>
<td><strong>Exporter</strong></td>
<td>各类数据采集组件（数据库、硬件、MQ、HTTP 服务器等）</td>
</tr>
<tr>
<td><strong>Push Gateway</strong></td>
<td>支持短生命周期 Job 主动推送指标</td>
</tr>
<tr>
<td><strong>Alertmanager</strong></td>
<td>灵活的报警规则和通知管理</td>
</tr>
<tr>
<td><strong>Grafana</strong></td>
<td>高度定制化的可视化监控面板</td>
</tr>
</tbody></table>
<p>Prometheus + Grafana 搭配统一的服务框架，可以满足绝大部分中小团队的监控需求。</p>
<h2>生产环境部署架构</h2>
<h3>DNS</h3>
<p>DNS 是基础服务，一般直接选择云厂商：</p>
<ul>
<li><strong>国内</strong>：阿里云 DNS 或腾讯 DNSPod，线上产品建议使用付费版</li>
<li><strong>海外</strong>：优先选择 AWS Route 53</li>
<li><strong>国内外互通</strong>：建议在 APP 层实现容灾逻辑或智能调度，因为没有单一 DNS 服务能同时很好地覆盖国内外</li>
</ul>
<h3>负载均衡（LB）</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>方案</th>
</tr>
</thead>
<tbody><tr>
<td>云服务环境</td>
<td>直接使用云厂商 LB（阿里云 SLB / 腾讯云 CLB / AWS ELB）</td>
</tr>
<tr>
<td>自建机房</td>
<td>LVS（四层）+ Nginx（七层）</td>
</tr>
</tbody></table>
<p>云厂商 LB 通常支持四层（TCP/UDP）和七层（HTTP/HTTPS）协议、集中化证书管理和健康检查。</p>
<h3>CDN</h3>
<p>CDN 的选型主要看业务覆盖区域：</p>
<table>
<thead>
<tr>
<th>区域</th>
<th>推荐</th>
</tr>
</thead>
<tbody><tr>
<td>国内</td>
<td>阿里云 CDN、腾讯云 CDN</td>
</tr>
<tr>
<td>海外</td>
<td>AWS CloudFront、Akamai</td>
</tr>
</tbody></table>
<h2>总结</h2>
<p>微服务架构的落地是一个系统工程，核心技术关注点可以归纳为以下几个层面：</p>
<ol>
<li><strong>服务通信</strong>：通过注册中心 + 负载均衡 + API 网关，构建服务间和内外部的通信体系</li>
<li><strong>服务可靠性</strong>：通过熔断、隔离、限流和降级四大模式，保障系统在故障和高峰期的稳定性</li>
<li><strong>服务框架</strong>：将公共关注点下沉到框架层，让业务开发专注于业务逻辑</li>
<li><strong>基础设施</strong>：根据业务需求和团队技术栈，选择合适的 RPC、注册中心、缓存、消息队列和数据库</li>
<li><strong>持续交付</strong>：通过 CI/CD 流水线实现代码到生产环境的自动化、可重复的发布流程</li>
<li><strong>可观测性</strong>：通过日志、监控和链路追踪构建系统的透明度，为问题排查和性能优化提供数据支撑</li>
</ol>
<p>好的架构不是设计出来的，而是演进出来的。架构师需要在不同阶段做出合适的判断——既不过度设计，也不欠缺考虑。关键是保持对技术的敏锐度，在实践中不断验证和调整。</p>
<blockquote>
<p>路漫漫其修远兮，架构求索无止尽也。</p>
</blockquote>
18:T7a49,<h1>架构师成长路线：从技术深度到架构思维的蜕变</h1>
<blockquote>
<p>架构的本质不是技术选型，而是在约束条件下做出最合理的决策。架构师的成长不是一蹴而就的技能习得，而是从&quot;解决问题&quot;到&quot;定义问题&quot;的思维蜕变。</p>
</blockquote>
<p>技术人的职业发展中，&quot;架构师&quot;是一个绕不开的里程碑。但很多人对架构师的认知停留在&quot;画架构图&quot;或&quot;选技术栈&quot;的层面，这远远不够。真正的架构能力是一种系统化的思维方式——它要求你既能深入技术细节，又能站在全局视角做出取舍。</p>
<p>本文将从架构的本质定义出发，系统梳理架构师的能力模型、知识体系、设计方法论与成长路径，为技术人提供一份可落地的架构认知框架。</p>
<h2>什么是架构？</h2>
<h3>从定义到本质</h3>
<p>IEEE 1471 对软件架构的定义是：</p>
<blockquote>
<p><strong>软件架构是一个系统的基本组织，由其组件、组件之间的关系以及与环境之间的关系，还有指导其设计和演化的原则所体现。</strong></p>
</blockquote>
<p>这个定义包含三个关键要素：</p>
<table>
<thead>
<tr>
<th>要素</th>
<th>含义</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>组件（Components）</strong></td>
<td>系统的构成单元</td>
<td>服务、模块、数据库、消息队列</td>
</tr>
<tr>
<td><strong>关系（Relationships）</strong></td>
<td>组件之间的交互方式</td>
<td>同步调用、异步消息、事件驱动</td>
</tr>
<tr>
<td><strong>原则（Principles）</strong></td>
<td>指导设计决策的约束</td>
<td>高内聚低耦合、最终一致性、服务自治</td>
</tr>
</tbody></table>
<p>架构的本质可以用一句话概括：<strong>架构 = 结构 + 决策 + 演进</strong>。</p>
<ul>
<li><strong>结构</strong>是系统的静态组织方式</li>
<li><strong>决策</strong>是在多种方案中做出的关键取舍</li>
<li><strong>演进</strong>是架构随业务发展持续适应的能力</li>
</ul>
<h3>架构的四个层次</h3>
<p>在企业级系统中，架构通常分为四个层次，每一层关注的维度不同：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>关注点</th>
<th>核心问题</th>
<th>典型产出</th>
</tr>
</thead>
<tbody><tr>
<td><strong>业务架构</strong></td>
<td>业务域、能力、流程</td>
<td>业务边界在哪？核心能力是什么？</td>
<td>业务能力地图、流程图</td>
</tr>
<tr>
<td><strong>应用架构</strong></td>
<td>系统边界、服务划分</td>
<td>系统如何拆分？服务如何协作？</td>
<td>应用全景图、服务依赖图</td>
</tr>
<tr>
<td><strong>技术架构</strong></td>
<td>技术选型、基础设施</td>
<td>用什么技术实现？如何部署？</td>
<td>技术栈选型、部署架构图</td>
</tr>
<tr>
<td><strong>数据架构</strong></td>
<td>数据模型、流转、存储</td>
<td>数据如何组织？如何流转？</td>
<td>数据模型、数据流图</td>
</tr>
</tbody></table>
<p>四个层次之间的关系是<strong>自上而下驱动、自下而上支撑</strong>：</p>
<pre><code>业务架构（WHY）
    ↓ 驱动
应用架构（WHAT）
    ↓ 驱动
技术架构 + 数据架构（HOW）
</code></pre>
<p>很多技术人在做架构设计时直接跳到&quot;用什么技术&quot;，忽略了业务架构和应用架构的推导过程。<strong>脱离业务的架构设计就是空中楼阁。</strong></p>
<h2>架构师的核心能力模型</h2>
<p>架构师不是一个纯技术角色，而是技术与业务之间的桥梁。一个合格的架构师需要具备以下六个维度的能力：</p>
<h3>能力雷达图</h3>
<table>
<thead>
<tr>
<th>能力维度</th>
<th>定义</th>
<th>初级要求</th>
<th>高级要求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>技术深度</strong></td>
<td>对核心技术的原理级理解</td>
<td>掌握主力技术栈源码</td>
<td>能从原理推导解决方案</td>
</tr>
<tr>
<td><strong>技术广度</strong></td>
<td>对多领域技术的了解</td>
<td>熟悉 3+ 技术领域</td>
<td>能做跨领域技术整合</td>
</tr>
<tr>
<td><strong>抽象能力</strong></td>
<td>从具象中提炼本质的能力</td>
<td>能做模块抽象</td>
<td>能做业务域建模</td>
</tr>
<tr>
<td><strong>业务理解</strong></td>
<td>对业务本质和商业逻辑的洞察</td>
<td>理解业务流程</td>
<td>能用技术语言翻译业务战略</td>
</tr>
<tr>
<td><strong>系统思维</strong></td>
<td>全局视角和权衡取舍的能力</td>
<td>能做技术方案对比</td>
<td>能在复杂约束下做最优决策</td>
</tr>
<tr>
<td><strong>沟通影响</strong></td>
<td>跨团队协调和技术布道的能力</td>
<td>能清晰表达方案</td>
<td>能影响组织技术方向</td>
</tr>
</tbody></table>
<h3>架构思维的三个核心</h3>
<p><strong>1. 抽象思维</strong></p>
<p>抽象是架构师最重要的思维能力。抽象不是简单的&quot;去掉细节&quot;，而是<strong>识别事物的本质特征，忽略非本质差异</strong>。</p>
<pre><code>具体问题: 订单超时未支付需要自动取消
    ↓ 抽象
通用问题: 延时任务调度
    ↓ 进一步抽象
核心模型: 时间驱动的状态机
</code></pre>
<p>好的抽象应该是<strong>稳定的</strong>——业务在变，但抽象出的模型不轻易变化。比如&quot;购物车&quot;的业务形态千差万别，但抽象到本质就是&quot;临时容器 + 商品列表 + 计价规则&quot;。</p>
<p><strong>2. 分解思维</strong></p>
<p>复杂系统必须被分解才能被理解和管理。分解的关键是找到<strong>正确的切面</strong>：</p>
<table>
<thead>
<tr>
<th>分解方式</th>
<th>切面</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>水平分层</td>
<td>职责层次</td>
<td>展示层 / 业务层 / 数据层</td>
</tr>
<tr>
<td>垂直切分</td>
<td>业务域</td>
<td>按业务领域拆分微服务</td>
</tr>
<tr>
<td>功能分解</td>
<td>能力单元</td>
<td>将系统拆分为可独立部署的功能模块</td>
</tr>
<tr>
<td>流程分解</td>
<td>时间序列</td>
<td>将长流程拆分为异步编排的子流程</td>
</tr>
</tbody></table>
<p><strong>3. 权衡思维</strong></p>
<p>架构设计没有银弹，只有 Trade-off。架构师需要在以下维度中不断权衡：</p>
<ul>
<li><strong>一致性 vs 可用性</strong>（CAP 定理）</li>
<li><strong>性能 vs 可维护性</strong>（内联 vs 抽象）</li>
<li><strong>灵活性 vs 复杂度</strong>（配置化 vs 硬编码）</li>
<li><strong>当前成本 vs 未来成本</strong>（快速交付 vs 技术债务）</li>
<li><strong>理想方案 vs 资源约束</strong>（完美设计 vs 现实落地）</li>
</ul>
<blockquote>
<p>架构师的价值不在于设计出最优方案，而在于在给定约束下设计出最合理的方案。</p>
</blockquote>
<h2>架构设计三原则</h2>
<p>在做架构决策时，有三条根本性原则需要遵循：</p>
<h3>合适原则</h3>
<p><strong>合适优于先进。</strong> 没有最好的架构，只有最合适的架构。</p>
<p>一个日活 1000 的内部管理系统不需要微服务架构；一个创业期产品不需要分布式事务框架。架构的选择必须匹配：</p>
<ul>
<li><strong>业务阶段</strong>：0→1 阶段优先快速验证，1→N 阶段优先可扩展性</li>
<li><strong>团队能力</strong>：团队驾驭不了的架构就是最差的架构</li>
<li><strong>资源约束</strong>：时间、人力、基础设施的现实限制</li>
</ul>
<h3>简单原则</h3>
<p><strong>简单优于复杂。</strong> 如果两个方案能达到相同效果，选更简单的那个。</p>
<p>复杂度是软件系统的头号杀手。每引入一个组件、一层抽象、一种模式，都要问自己：<strong>这个复杂度带来的收益，是否大于它引入的成本？</strong></p>
<pre><code>单体应用能解决的问题 → 不要用微服务
本地缓存能解决的问题 → 不要用分布式缓存
同步调用能解决的问题 → 不要用消息队列
</code></pre>
<h3>演化原则</h3>
<p><strong>演化优于一步到位。</strong> 架构不是一次性设计出来的，而是演化出来的。</p>
<p>优秀的架构师不会试图在第一天就设计出&quot;完美架构&quot;，而是：</p>
<ol>
<li>识别当前最关键的架构决策，做出合理选择</li>
<li>为未来的变化预留扩展点（而不是过度设计）</li>
<li>建立持续演进的机制（架构治理、技术债务管理）</li>
</ol>
<h2>技术知识体系全景</h2>
<p>架构师需要具备广泛而有深度的技术知识。以下是一个体系化的技术知识地图：</p>
<h3>编程基础与语言</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心知识点</th>
</tr>
</thead>
<tbody><tr>
<td>数据结构与算法</td>
<td>树、图、哈希、排序、动态规划、时间/空间复杂度分析</td>
</tr>
<tr>
<td>设计模式</td>
<td>创建型、结构型、行为型模式；反模式识别</td>
</tr>
<tr>
<td>编程范式</td>
<td>OOP、函数式编程、响应式编程</td>
</tr>
<tr>
<td>JVM 体系</td>
<td>内存模型、GC 算法、类加载机制、JIT 编译、性能调优</td>
</tr>
<tr>
<td>并发编程</td>
<td>线程模型、锁机制、AQS、并发容器、线程池、协程</td>
</tr>
</tbody></table>
<h3>框架与中间件</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心技术</th>
<th>需要理解的深度</th>
</tr>
</thead>
<tbody><tr>
<td>Web 框架</td>
<td>Spring Boot / Spring MVC</td>
<td>IoC 容器原理、AOP 实现、自动配置机制</td>
</tr>
<tr>
<td>ORM 框架</td>
<td>MyBatis / JPA</td>
<td>SQL 映射原理、缓存机制、N+1 问题</td>
</tr>
<tr>
<td>RPC 框架</td>
<td>Dubbo / gRPC</td>
<td>序列化协议、服务发现、负载均衡策略</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka / RocketMQ / RabbitMQ</td>
<td>消息模型、持久化机制、顺序性保证、事务消息</td>
</tr>
<tr>
<td>缓存系统</td>
<td>Redis / Caffeine</td>
<td>数据结构、持久化、集群方案、缓存一致性</td>
</tr>
<tr>
<td>搜索引擎</td>
<td>Elasticsearch</td>
<td>倒排索引、分词、相关性评分、集群管理</td>
</tr>
<tr>
<td>数据库</td>
<td>MySQL / PostgreSQL</td>
<td>索引原理（B+ 树）、事务隔离级别、锁机制、主从复制</td>
</tr>
</tbody></table>
<h3>分布式与云原生</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心知识点</th>
</tr>
</thead>
<tbody><tr>
<td>分布式理论</td>
<td>CAP 定理、BASE 理论、FLP 不可能定理</td>
</tr>
<tr>
<td>一致性协议</td>
<td>Paxos、Raft、ZAB、Gossip</td>
</tr>
<tr>
<td>分布式事务</td>
<td>2PC、3PC、TCC、Saga、本地消息表</td>
</tr>
<tr>
<td>服务治理</td>
<td>服务发现、负载均衡、熔断降级、限流、灰度发布</td>
</tr>
<tr>
<td>容器与编排</td>
<td>Docker、Kubernetes、Service Mesh（Istio）</td>
</tr>
<tr>
<td>DevOps</td>
<td>CI/CD、GitOps、IaC、可观测性（Metrics/Logging/Tracing）</td>
</tr>
</tbody></table>
<h3>架构设计能力</h3>
<table>
<thead>
<tr>
<th>领域</th>
<th>核心知识点</th>
</tr>
</thead>
<tbody><tr>
<td>架构模式</td>
<td>分层架构、微服务、事件驱动、CQRS、六边形架构</td>
</tr>
<tr>
<td>高可用设计</td>
<td>冗余、故障转移、限流降级、异地多活</td>
</tr>
<tr>
<td>高性能设计</td>
<td>缓存策略、异步化、并行化、池化、零拷贝</td>
</tr>
<tr>
<td>可扩展设计</td>
<td>水平扩展、分库分表、读写分离、弹性伸缩</td>
</tr>
<tr>
<td>安全设计</td>
<td>认证授权、数据加密、SQL 注入防御、OWASP Top 10</td>
</tr>
</tbody></table>
<h2>分布式系统核心理论</h2>
<p>分布式系统是现代架构的基石，理解其核心理论是架构师的必修课。</p>
<h3>CAP 定理</h3>
<p>分布式系统不可能同时满足以下三个特性：</p>
<ul>
<li><strong>C（Consistency）一致性</strong>：所有节点在同一时刻看到的数据一致</li>
<li><strong>A（Availability）可用性</strong>：每个请求都能收到非错误响应</li>
<li><strong>P（Partition Tolerance）分区容错性</strong>：网络分区时系统仍能继续运行</li>
</ul>
<p>由于网络分区在分布式环境中不可避免，实际上的选择是在 <strong>CP</strong> 和 <strong>AP</strong> 之间做取舍：</p>
<table>
<thead>
<tr>
<th>选择</th>
<th>含义</th>
<th>典型场景</th>
<th>代表系统</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CP</strong></td>
<td>牺牲可用性保一致性</td>
<td>金融交易、库存扣减</td>
<td>ZooKeeper、etcd、HBase</td>
</tr>
<tr>
<td><strong>AP</strong></td>
<td>牺牲一致性保可用性</td>
<td>商品展示、用户动态</td>
<td>Cassandra、DynamoDB、Eureka</td>
</tr>
</tbody></table>
<h3>BASE 理论</h3>
<p>BASE 是对 CAP 中 AP 方案的延伸，是大规模互联网系统的实践指导：</p>
<ul>
<li><strong>BA（Basically Available）基本可用</strong>：允许部分功能降级，保证核心功能可用</li>
<li><strong>S（Soft State）软状态</strong>：允许中间状态存在，不要求实时一致</li>
<li><strong>E（Eventually Consistent）最终一致性</strong>：经过一段时间后，数据最终达到一致</li>
</ul>
<h3>一致性协议</h3>
<p>分布式共识是解决多节点数据一致性的核心手段：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>核心思想</th>
<th>复杂度</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Paxos</strong></td>
<td>提案-承诺-接受三阶段</td>
<td>高，难以工程实现</td>
<td>Google Chubby</td>
</tr>
<tr>
<td><strong>Raft</strong></td>
<td>Leader 选举 + 日志复制</td>
<td>中，易于理解和实现</td>
<td>etcd、Consul</td>
</tr>
<tr>
<td><strong>ZAB</strong></td>
<td>崩溃恢复 + 消息广播</td>
<td>中</td>
<td>ZooKeeper</td>
</tr>
<tr>
<td><strong>Gossip</strong></td>
<td>去中心化的信息传播</td>
<td>低，最终一致</td>
<td>Redis Cluster、Consul（成员管理）</td>
</tr>
</tbody></table>
<h3>分布式事务</h3>
<p>跨服务的数据一致性是分布式系统最具挑战性的问题之一：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>一致性</th>
<th>性能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2PC</strong></td>
<td>准备-提交两阶段</td>
<td>强一致</td>
<td>低（同步阻塞）</td>
<td>数据库层面的跨库事务</td>
</tr>
<tr>
<td><strong>TCC</strong></td>
<td>Try-Confirm-Cancel</td>
<td>强一致</td>
<td>中</td>
<td>资金类高一致性业务</td>
</tr>
<tr>
<td><strong>Saga</strong></td>
<td>正向操作 + 补偿操作</td>
<td>最终一致</td>
<td>高</td>
<td>长流程业务编排</td>
</tr>
<tr>
<td><strong>本地消息表</strong></td>
<td>本地事务 + 异步消息</td>
<td>最终一致</td>
<td>高</td>
<td>跨服务异步通知</td>
</tr>
<tr>
<td><strong>事务消息</strong></td>
<td>半消息 + 确认机制</td>
<td>最终一致</td>
<td>高</td>
<td>基于 MQ 的数据同步</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>实践建议</strong>：绝大多数业务场景不需要强一致性。优先考虑最终一致性方案（Saga、本地消息表），只有在资金、库存等核心场景才使用 TCC。</p>
</blockquote>
<h2>架构演进：从单体到云原生</h2>
<p>架构不是一成不变的，它随着业务规模和技术发展不断演进。理解每个阶段的特征和驱动力，比记住具体方案更重要。</p>
<h3>演进路线</h3>
<pre><code>单体架构 → 垂直拆分 → SOA → 微服务 → 云原生 → Serverless
</code></pre>
<h3>各阶段特征对比</h3>
<table>
<thead>
<tr>
<th>阶段</th>
<th>核心特征</th>
<th>解决的问题</th>
<th>引入的问题</th>
<th>适用规模</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单体架构</strong></td>
<td>所有功能在一个进程</td>
<td>开发部署简单</td>
<td>扩展困难、技术栈锁定</td>
<td>初创期、小团队</td>
</tr>
<tr>
<td><strong>垂直拆分</strong></td>
<td>按业务线拆分独立应用</td>
<td>业务隔离、独立扩展</td>
<td>公共功能重复、数据冗余</td>
<td>多业务线</td>
</tr>
<tr>
<td><strong>SOA</strong></td>
<td>服务化 + ESB 集中治理</td>
<td>服务复用、统一治理</td>
<td>ESB 单点瓶颈、治理复杂</td>
<td>中大型企业</td>
</tr>
<tr>
<td><strong>微服务</strong></td>
<td>细粒度服务 + 去中心化</td>
<td>独立部署、技术异构</td>
<td>运维复杂度、分布式事务</td>
<td>大型互联网</td>
</tr>
<tr>
<td><strong>云原生</strong></td>
<td>容器化 + 编排 + 服务网格</td>
<td>弹性伸缩、基础设施抽象</td>
<td>技术栈门槛高、学习曲线陡</td>
<td>规模化互联网</td>
</tr>
<tr>
<td><strong>Serverless</strong></td>
<td>函数计算 + 事件驱动</td>
<td>零运维、按需付费</td>
<td>冷启动、厂商锁定</td>
<td>事件驱动型业务</td>
</tr>
</tbody></table>
<h3>演进的驱动力</h3>
<p>架构演进不是为了追新，而是被以下力量推动的：</p>
<ol>
<li><strong>业务复杂度增长</strong>：单体无法承载越来越复杂的业务逻辑</li>
<li><strong>团队规模扩大</strong>：多团队并行开发需要服务边界隔离</li>
<li><strong>流量规模变化</strong>：从百级到亿级 QPS 需要不同的架构模式</li>
<li><strong>交付效率要求</strong>：从月级发布到日级发布需要服务独立部署</li>
<li><strong>技术生态成熟</strong>：容器、服务网格等基础设施的成熟降低了架构升级的门槛</li>
</ol>
<blockquote>
<p><strong>关键认知</strong>：架构演进应该是业务驱动的、渐进式的。不要因为&quot;微服务很火&quot;就拆分单体，也不要因为&quot;Kubernetes 很酷&quot;就上云原生。每次架构升级都应该有明确的业务收益支撑。</p>
</blockquote>
<h2>架构设计方法论</h2>
<p>光有知识储备还不够，架构师需要一套系统化的方法论来指导架构设计过程。</p>
<h3>TOGAF：企业架构框架</h3>
<p>TOGAF（The Open Group Architecture Framework）是最广泛采用的企业架构框架，其核心是 <strong>ADM（Architecture Development Method）</strong> 架构开发方法：</p>
<pre><code>预备阶段 → 架构愿景 → 业务架构 → 信息系统架构 → 技术架构
    → 机会和解决方案 → 迁移规划 → 实施治理 → 架构变更管理
</code></pre>
<p>TOGAF 的核心价值在于提供了一套<strong>从业务到技术的推导过程</strong>，避免架构设计的随意性。</p>
<h3>架构设计的四步法</h3>
<p>在实际工作中，可以将架构设计简化为四个步骤：</p>
<p><strong>第一步：需求分析与约束识别</strong></p>
<pre><code>功能需求 → 系统需要做什么？
质量需求 → 性能、可用性、安全性指标是什么？
约束条件 → 时间、人力、技术栈、合规要求有哪些？
</code></pre>
<p><strong>第二步：关键决策与方案选型</strong></p>
<p>识别架构中的关键决策点（通常是那些一旦确定就难以更改的决策），然后对每个决策点做方案对比：</p>
<table>
<thead>
<tr>
<th>决策点</th>
<th>方案 A</th>
<th>方案 B</th>
<th>选择依据</th>
</tr>
</thead>
<tbody><tr>
<td>服务通信</td>
<td>REST</td>
<td>gRPC</td>
<td>内部服务间高频调用选 gRPC</td>
</tr>
<tr>
<td>数据存储</td>
<td>MySQL</td>
<td>MongoDB</td>
<td>结构化数据 + 事务需求选 MySQL</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka</td>
<td>RocketMQ</td>
<td>需要事务消息选 RocketMQ</td>
</tr>
</tbody></table>
<p><strong>第三步：架构方案设计</strong></p>
<p>从全局到局部，分层输出架构方案：</p>
<ol>
<li>系统上下文图（C4 Level 1）：系统与外部的关系</li>
<li>容器图（C4 Level 2）：系统内部的主要构件</li>
<li>组件图（C4 Level 3）：关键服务的内部结构</li>
<li>关键流程的时序图</li>
</ol>
<p><strong>第四步：架构评审与验证</strong></p>
<p>使用 <strong>ATAM（Architecture Tradeoff Analysis Method）</strong> 对架构方案进行评审：</p>
<ul>
<li>识别架构中的风险点</li>
<li>验证方案是否满足质量属性需求</li>
<li>确认 Trade-off 是否被利益相关者接受</li>
</ul>
<h3>架构决策记录（ADR）</h3>
<p>每个重要的架构决策都应该被记录下来，格式可以采用 ADR：</p>
<pre><code># ADR-001: 采用事件驱动架构处理订单状态变更

## 状态
已采纳

## 背景
订单状态变更需要通知下游 10+ 个系统，同步调用导致耦合严重且响应时间过长。

## 决策
采用事件驱动架构，订单状态变更时发布领域事件，下游系统订阅事件自行处理。

## 影响
- 正面：服务解耦、响应时间降低、可扩展性增强
- 负面：引入最终一致性、增加消息中间件运维成本、需要处理消息幂等

## 备选方案
1. 同步 HTTP 调用（被否：耦合度高、链路过长）
2. 数据库轮询（被否：实时性差、数据库压力大）
</code></pre>
<h2>高可用架构设计</h2>
<p>高可用是架构设计中最核心的质量属性之一。它的本质是<strong>通过冗余和自动化来对抗故障的不确定性</strong>。</p>
<h3>可用性度量</h3>
<table>
<thead>
<tr>
<th>可用性等级</th>
<th>年度不可用时间</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td>99%（2 个 9）</td>
<td>3.65 天</td>
<td>内部管理系统</td>
</tr>
<tr>
<td>99.9%（3 个 9）</td>
<td>8.76 小时</td>
<td>一般业务系统</td>
</tr>
<tr>
<td>99.99%（4 个 9）</td>
<td>52.56 分钟</td>
<td>核心交易系统</td>
</tr>
<tr>
<td>99.999%（5 个 9）</td>
<td>5.26 分钟</td>
<td>金融核心系统</td>
</tr>
</tbody></table>
<h3>高可用设计策略</h3>
<p><strong>冗余策略</strong>：消除单点故障</p>
<pre><code>单点             →  冗余方案
单台应用服务器    →  集群 + 负载均衡
单个数据库实例    →  主从复制 + 自动切换
单个机房          →  同城双活 / 异地多活
单个注册中心      →  集群部署 + 多节点
</code></pre>
<p><strong>容错策略</strong>：优雅应对局部故障</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>原理</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>超时控制</td>
<td>避免无限等待</td>
<td>设置合理的超时时间</td>
</tr>
<tr>
<td>重试机制</td>
<td>应对瞬时故障</td>
<td>指数退避 + 最大重试次数</td>
</tr>
<tr>
<td>熔断器</td>
<td>防止故障蔓延</td>
<td>Hystrix / Sentinel / Resilience4j</td>
</tr>
<tr>
<td>降级策略</td>
<td>保核心弃非核心</td>
<td>返回默认值、关闭非关键功能</td>
</tr>
<tr>
<td>限流控制</td>
<td>保护系统容量</td>
<td>令牌桶、滑动窗口</td>
</tr>
<tr>
<td>隔离机制</td>
<td>故障域隔离</td>
<td>线程池隔离、信号量隔离、泳道隔离</td>
</tr>
</tbody></table>
<p><strong>发布策略</strong>：变更是故障的主要来源</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>原理</th>
<th>风险</th>
</tr>
</thead>
<tbody><tr>
<td>蓝绿部署</td>
<td>两套环境瞬间切换</td>
<td>资源成本翻倍</td>
</tr>
<tr>
<td>滚动发布</td>
<td>逐步替换旧实例</td>
<td>新旧版本短暂共存</td>
</tr>
<tr>
<td>金丝雀发布</td>
<td>小流量验证后全量</td>
<td>需要流量分配能力</td>
</tr>
<tr>
<td>Feature Flag</td>
<td>功能开关控制上线</td>
<td>代码分支复杂度增加</td>
</tr>
</tbody></table>
<h2>高性能架构设计</h2>
<p>高性能不是&quot;用最快的技术&quot;，而是&quot;在每个环节消除不必要的等待和浪费&quot;。</p>
<h3>性能优化的分层思路</h3>
<pre><code>用户端 → CDN/静态资源优化 → 接入层(负载均衡/连接池)
    → 应用层(缓存/异步/并行) → 数据层(索引/分库分表/读写分离)
</code></pre>
<h3>核心优化策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>原理</th>
<th>典型实践</th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓存</strong></td>
<td>用空间换时间</td>
<td>多级缓存（L1 本地 → L2 分布式 → DB）</td>
</tr>
<tr>
<td><strong>异步化</strong></td>
<td>将串行变并行</td>
<td>消息队列异步处理非关键路径</td>
</tr>
<tr>
<td><strong>并行化</strong></td>
<td>充分利用多核</td>
<td>CompletableFuture 并行调用多个下游</td>
</tr>
<tr>
<td><strong>池化</strong></td>
<td>复用昂贵资源</td>
<td>连接池、线程池、对象池</td>
</tr>
<tr>
<td><strong>批量化</strong></td>
<td>减少 I/O 次数</td>
<td>批量查询、批量写入、Pipeline</td>
</tr>
<tr>
<td><strong>预计算</strong></td>
<td>提前计算结果</td>
<td>离线计算报表、预生成推荐结果</td>
</tr>
<tr>
<td><strong>压缩</strong></td>
<td>减少传输量</td>
<td>Gzip 压缩、Protocol Buffers</td>
</tr>
</tbody></table>
<h3>缓存设计的三大问题</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓存穿透</strong></td>
<td>查询不存在的数据</td>
<td>布隆过滤器、空值缓存</td>
</tr>
<tr>
<td><strong>缓存击穿</strong></td>
<td>热点 Key 过期瞬间</td>
<td>互斥锁、永不过期 + 异步更新</td>
</tr>
<tr>
<td><strong>缓存雪崩</strong></td>
<td>大量 Key 同时过期</td>
<td>过期时间加随机值、多级缓存</td>
</tr>
</tbody></table>
<h2>架构师的软实力</h2>
<p>技术能力是架构师的基础，但真正决定架构师高度的是软实力。</p>
<h3>决策能力：在不确定性中做选择</h3>
<p>架构决策往往发生在信息不完全的情况下。优秀的架构师需要：</p>
<ul>
<li><strong>识别关键决策与次要决策</strong>：不是每个技术选择都需要深度分析，把精力放在不可逆的关键决策上</li>
<li><strong>设定决策框架</strong>：明确评估维度和权重，避免拍脑袋决策</li>
<li><strong>接受&quot;足够好&quot;而非&quot;最优&quot;</strong>：在时间压力下，80% 的正确比 100% 的犹豫更有价值</li>
</ul>
<h3>沟通能力：让技术方案&quot;被买单&quot;</h3>
<p>架构师的方案再好，如果不能被团队理解和接受，就等于零。有效的技术沟通需要：</p>
<ul>
<li><strong>面向不同听众调整表达</strong>：给 CEO 讲业务价值，给研发讲技术方案，给运维讲部署方案</li>
<li><strong>用图说话</strong>：一张好的架构图胜过千字描述</li>
<li><strong>讲清&quot;为什么不选 B&quot;</strong>：决策的说服力不在于方案 A 有多好，而在于你对备选方案的分析有多透彻</li>
</ul>
<h3>平衡能力：在理想与现实之间</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>理想主义</th>
<th>务实主义</th>
<th>平衡点</th>
</tr>
</thead>
<tbody><tr>
<td>代码质量</td>
<td>完美的代码</td>
<td>能跑就行</td>
<td>核心模块高质量，边缘模块可接受</td>
</tr>
<tr>
<td>技术债务</td>
<td>零债务</td>
<td>先上线</td>
<td>有计划地管理技术债务</td>
</tr>
<tr>
<td>架构设计</td>
<td>一步到位</td>
<td>走一步算一步</td>
<td>关键决策前瞻设计 + 渐进演化</td>
</tr>
<tr>
<td>新技术</td>
<td>全面拥抱</td>
<td>保守不动</td>
<td>在非核心场景试点验证</td>
</tr>
</tbody></table>
<h2>架构师成长路径</h2>
<h3>成长阶段</h3>
<pre><code>初级开发 → 高级开发 → 技术主管 → 架构师 → 首席架构师/CTO
</code></pre>
<p>每个阶段的核心差异在于<strong>视野的宽度和决策的影响范围</strong>：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>关注范围</th>
<th>核心能力</th>
<th>时间分配</th>
</tr>
</thead>
<tbody><tr>
<td><strong>初级开发</strong></td>
<td>单个功能模块</td>
<td>编码能力、调试能力</td>
<td>80% 编码 + 20% 设计</td>
</tr>
<tr>
<td><strong>高级开发</strong></td>
<td>单个系统/服务</td>
<td>系统设计、性能优化</td>
<td>60% 编码 + 40% 设计</td>
</tr>
<tr>
<td><strong>技术主管</strong></td>
<td>多个系统/团队</td>
<td>技术决策、团队管理</td>
<td>30% 编码 + 50% 设计 + 20% 管理</td>
</tr>
<tr>
<td><strong>架构师</strong></td>
<td>技术体系全局</td>
<td>架构设计、技术战略</td>
<td>10% 编码 + 60% 设计 + 30% 沟通</td>
</tr>
<tr>
<td><strong>首席架构师</strong></td>
<td>技术 + 业务全局</td>
<td>技术愿景、组织影响</td>
<td>70% 战略 + 30% 关键问题攻坚</td>
</tr>
</tbody></table>
<h3>从开发到架构师的关键跨越</h3>
<p>很多优秀的开发者在向架构师转型时会遇到瓶颈。核心原因在于需要完成三个关键跨越：</p>
<p><strong>跨越一：从&quot;怎么做&quot;到&quot;做不做&quot;</strong></p>
<p>开发者关注的是&quot;如何实现一个功能&quot;，架构师关注的是&quot;这个功能应不应该做，用什么方式做最合理&quot;。这是从执行思维到决策思维的跨越。</p>
<p><strong>跨越二：从&quot;局部最优&quot;到&quot;全局最优&quot;</strong></p>
<p>开发者追求单个模块的代码质量，架构师追求整个系统的平衡。有时候某个模块的&quot;不完美&quot;恰恰是全局最优的选择。</p>
<p><strong>跨越三：从&quot;技术驱动&quot;到&quot;业务驱动&quot;</strong></p>
<p>开发者用技术解决问题，架构师用技术创造业务价值。如果不理解业务，就无法做出正确的架构决策。</p>
<h3>持续成长的方法</h3>
<ol>
<li><strong>深度学习</strong>：选 2-3 个核心技术领域，深入到源码级别理解</li>
<li><strong>广度拓展</strong>：关注技术趋势，了解不同领域的架构模式</li>
<li><strong>实践总结</strong>：每个项目结束后做架构复盘，记录 ADR</li>
<li><strong>输出分享</strong>：写技术博客、做技术分享，输出倒逼输入</li>
<li><strong>跨界学习</strong>：了解业务、产品、运营，建立全局视角</li>
</ol>
<h2>总结</h2>
<p>架构师的成长是一条从&quot;技术专精&quot;到&quot;架构思维&quot;的蜕变之路。这条路上有几个核心认知需要建立：</p>
<ol>
<li><strong>架构是决策，不是画图</strong>。架构师的核心价值在于在复杂约束条件下做出合理的技术决策</li>
<li><strong>业务是根基，技术是手段</strong>。脱离业务的架构设计没有意义，技术选型必须服务于业务目标</li>
<li><strong>简单是终极的复杂</strong>。能用简单方案解决的问题，不要用复杂方案；能不引入的组件，就不引入</li>
<li><strong>演化优于完美</strong>。不要追求一步到位的架构设计，建立持续演进的能力比设计完美的架构更重要</li>
<li><strong>Trade-off 是永恒的主题</strong>。没有银弹，只有在给定约束下的最佳平衡</li>
</ol>
<blockquote>
<p><strong>一个架构师的成熟度，不在于他掌握了多少种技术，而在于他知道什么时候不该用某种技术。</strong></p>
</blockquote>
19:T4fc2,<h3>1 微服务优势与挑战 <a href="#scroller-1" id="scroller-1"></a></h3>
<h4>1.1 微服务的优势 <a href="#scroller-2" id="scroller-2"></a></h4>
<p><strong>1.1.1 单一职责</strong></p>
<p>微服务架构中的每个节点高度服务化，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，包括数据库和数据模型；不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。</p>
<p><strong>1.1.2 轻量级通信</strong></p>
<p>通过REST API模式或者RPC框架，事件流和消息代理的组合相互通信，实现服务间互相协作的轻量级通信机制。</p>
<p><strong>1.1.3 独立性</strong></p>
<p>在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试、部署、运维。</p>
<p><strong>1.1.4 进程隔离</strong></p>
<p>在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上，实现高度自治和高度隔离。进程的隔离，还能保证服务达到动态扩缩容的能力，业务高峰期自动增加服务资源以提升并发能力，业务低谷期则可自动释放服务资源以节省开销。</p>
<p><strong>1.1.5 混合技术栈和混合部署方式</strong></p>
<p>团队可以为不同的服务组件使用不同的技术栈和不同的部署方式（公有云、私有云、混合云）。</p>
<p><strong>1.1.6 简化治理</strong></p>
<p>组件可以彼此独立地进行缩放，从而减少了因必须缩放整个应用程序而产生的浪费和成本，独立的发布、服务治理。</p>
<p><strong>1.1.7 安全可靠，可维护。</strong></p>
<p>从架构上对运维提供友好的支撑，在安全、可维护的基础上规范化发布流程，支持数据存储容灾、业务模块隔离、访问权限控制、编码安全检测等。</p>
<h4>1.2 面临的挑战 <a href="#scroller-10" id="scroller-10"></a></h4>
<p><strong>1.2.1 分布式固有复杂性</strong></p>
<p>微服务架构是基于分布式的系统，而构建分布式系统必然会带来额外的开销。</p>
<ul>
<li>性能： 分布式系统是跨进程、跨网络的调用，受网络延迟和带宽的影响。</li>
<li>可靠性： 由于高度依赖于网络状况，任何一次的远程调用都有可能失败，随着服务的增多还会出现更多的潜在故障点。因此，如何提高系统的可靠性、降低因网络引起的故障率，是系统构建的一大挑战。</li>
<li>分布式通信： 分布式通信大大增加了功能实现的复杂度，并且伴随着定位难、调试难等问题。</li>
<li>数据一致性： 需要保证分布式系统的数据强一致性，即在 C（一致性）A（可用性）P（分区容错性） 三者之间做出权衡。这块可以参考我的这篇《<a href="https://www.cnblogs.com/wzh2010/p/15311142.html">分布式事务</a>》。</li>
</ul>
<p><strong>1.2.2 服务的依赖管理和测试</strong></p>
<p>在单体应用中，通常使用集成测试来验证依赖是否正常。而在微服务架构中，服务数量众多，每个服务都是独立的业务单元，服务主要通过接口进行交互，如何保证它的正常，是测试面临的主要挑战。</p>
<p>所以单元测试和单个服务链路的可用性非常重要。</p>
<p><strong>1.2.3 有效的配置版本管理</strong></p>
<p>在单体系统中，配置可以写在yaml文件，分布式系统中需要统一进行配置管理，同一个服务在不同的场景下对配置的值要求还可能不一样，所以需要引入配置的版本管理、环境管理。</p>
<p><strong>1.2.4 自动化的部署流程</strong></p>
<p>在微服务架构中，每个服务都独立部署，交付周期短且频率高，人工部署已经无法适应业务的快速变化。有效地构建自动化部署体系，配合服务网格、容器技术，是微服务面临的另一个挑战。</p>
<p><strong>1.2.5 对于DevOps更高的要求</strong></p>
<p>在微服务架构的实施过程中，开发人员和运维人员的角色发生了变化，开发者也将承担起整个服务的生命周期的责任，包括部署、链路追踪、监控；因此，按需调整组织架构、构建全功能的团队，也是一个不小的挑战。</p>
<p><strong>1.2.6 运维成本</strong></p>
<p>运维主要包括配置、部署、监控与告警和日志收集四大方面。微服务架构中，每个服务都需要独立地配置、部署、监控和收集日志，成本呈指数级增长。</p>
<p>服务化粒度越细，运维成本越高。</p>
<p>怎样去解决这些问题，是微服务架构必须面临的挑战。</p>
<h3>2 微服务全景架构 <a href="#scroller-17" id="scroller-17"></a></h3>
<p><img src="/images/blog/engineering/microservice-image_1_1.png" alt="image_1_1.png"></p>
<h3>3 微服务核心组件 <a href="#scroller-19" id="scroller-19"></a></h3>
<p>微服务架构核心组件包括：</p>
<table>
<thead>
<tr>
<th><strong>组件名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>服务注册与发现</td>
</tr>
<tr>
<td>API 网关服务</td>
</tr>
<tr>
<td>分布式配置中心</td>
</tr>
<tr>
<td>服务通信</td>
</tr>
<tr>
<td>服务治理</td>
</tr>
<tr>
<td>服务监控</td>
</tr>
<tr>
<td>分布式服务追踪</td>
</tr>
</tbody></table>
<h4>3.1 服务注册与发现 <a href="#scroller-20" id="scroller-20"></a></h4>
<p><strong>3.1.1 原理图</strong></p>
<p><img src="/images/blog/engineering/microservice-image_1_2.png" alt="image_1_2.png"></p>
<p>服务注册与发现三要素：</p>
<ul>
<li>Provider：服务的提供方</li>
<li>Consumer：调用远程服务的服务消费方</li>
<li>Registry：服务注册和发现的注册中心</li>
</ul>
<p><strong>3.1.2 注册中心的原理、流程</strong></p>
<p>1、 Provider(服务提供者)绑定指定端口并启动服务</p>
<p>2、提供者连接注册中心，并发本机 IP、端口、应用信息和服务信息发送至注册中心存储</p>
<p>3、Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</p>
<p>4、注册中心根据消费者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。</p>
<p>5、Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</p>
<p>6、Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer设计的原因：</p>
<p>Consumer 与 Provider 解偶，双方都可以横向增减节点数。注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</p>
<p>7、去中心化，双方不直接依赖注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用（Consumer应用缓存中保留提供者 Provider 列表）</p>
<p>8、服务提供者无状态，任意一台宕掉后，不影响使用</p>
<p>注册中心包含如下功能：注册中心、服务注册和反注册、心跳监测与汇报、服务订阅、服务变更查询、集群部署、服务健康状态检测、服务状态变更通知 等</p>
<p>我们有很多种注册中心的技术，Zookeeper、Etcd、Consul、Eureka 4种比较常用，如下</p>
<table>
<thead>
<tr>
<th></th>
<th>Zookeeper</th>
<th>Etcd</th>
<th>Consul</th>
<th>Eureka</th>
</tr>
</thead>
<tbody><tr>
<td>CAP模型</td>
<td>CP</td>
<td>CP</td>
<td>CP</td>
<td>AP</td>
</tr>
<tr>
<td>数据一致性算法</td>
<td>ZAB</td>
<td>Raft</td>
<td>Raft</td>
<td>❌</td>
</tr>
<tr>
<td>多数据中心</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>多语言支持</td>
<td>客户端</td>
<td>Http/gRPC</td>
<td>Http/DNS</td>
<td>Http</td>
</tr>
<tr>
<td>Watch</td>
<td>TCP</td>
<td>Long Polling</td>
<td>Long Polling</td>
<td>Long Polling</td>
</tr>
<tr>
<td>KV存储</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>服务健康检查</td>
<td>心跳</td>
<td>心跳</td>
<td><p>服务状态，<br>内存，硬盘等</p></td>
<td>自定义</td>
</tr>
<tr>
<td>自身监控</td>
<td>❌</td>
<td>metrics</td>
<td>metrics</td>
<td>metrics</td>
</tr>
<tr>
<td>SpringCloud 支持</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>自身开发语言</td>
<td>Java</td>
<td>Go</td>
<td>Go</td>
<td>Java</td>
</tr>
</tbody></table>
<p>分布式系统中CAP模型3者不可兼得。由于网络的原因，分布式系统中P是必备的，意味着只能选择 AP 或者 CP。CP 代表数据一致性是第一位的，AP 代表可用性是第一位的。</p>
<p>Zookeeper、Etcd、Consul 是 CP 型注册中心，牺牲可用性来保证数据强一致性</p>
<p>Eureka 是 AP 型注册中心，牺牲一致性来保证可用性</p>
<h4>3.2 API 网关服务 <a href="#scroller-23" id="scroller-23"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_1_3.png" alt="image_1_3.png"></p>
<p>上面是Api网关服务的基本架构：用户的请求经过统一的Api网关来访问微服务里具体的服务颗粒，并且可能产生串联的链路服务调用。</p>
<p>有很多耳熟能详的API网关技术，比如 Zuul、Kong、Tyk等，提供了服务路由在内的很多通用功能，后面会有专门的章节来说这个。</p>
<p>Tyk：Tyk是一个开放源码的API网关，它是快速、可扩展和现代的。Tyk提供了一个API管理平台，其中包括API网关、API分析、开发人员门户和API管理面板。Try 是一个基于Go实现的网关服务。</p>
<p>Kong：Kong是一个可扩展的开放源码API Layer(也称为API网关或API中间件)。Kong 在任何RESTful API的前面运行，通过插件扩展，它提供了超越核心平台的额外功能和服务。</p>
<p>Netflix zuul：Zuul是一种提供动态路由、监视、弹性、安全性等功能的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>
<p>除了路由之外，Api网关服务还包含：认证和授权，重试、熔断、降级，负载均衡，日志、监控、链路追踪，灰度发布，ABTesting 等功能。</p>
<h4>3.3 配置中心 <a href="#scroller-24" id="scroller-24"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_1_4.png" alt="image_1_4.png"></p>
<p>上面这个是携程的开源配置中心Apollo系统的架构设计，我们从下往上进行分析：</p>
<p>1、Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端</p>
<p>2、Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）</p>
<p>3、Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳，支持注册、更新、删除能力</p>
<p>4、在Eureka之上我们架了一层Meta Server用于封装Eureka的服务发现接口</p>
<p>5、Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试</p>
<p>6、Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试</p>
<p>7、为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中</p>
<p>上面的架构体现了如下特点：</p>
<p>•高可用：配置服务为多实例部署，访问层保证 load balance、错误重试 •弱依赖：使用了Eureka来做配置中心的服务注册，如果出现问题或者网络出现问题的时候，服务应该可以依赖于它本身所缓存的配置来提供正常的服务</p>
<h4>3.4 服务通信 <a href="#scroller-25" id="scroller-25"></a></h4>
<p>分布式系统一般是由多个微服务颗粒组成的，微服务与微服务之前存在互相调用，甚至多个链路访问的情况。所以他们之间是需要通信的，通信方式继承于SOA，包含同步与异步两种模式。</p>
<p><strong>3.4.1 同步访问方式</strong></p>
<p>1、RPC 访问模式</p>
<p>Remote Procedure Call Protocol，远程过程调用协议，一般使用在分布式业务或者微服务架构风格中。像调用本地函数一样，去调用一个远端服务。本质上是请求链的底层，维护同一个端口，进行socket通信。常见的RPC技术包含 gRPC、Dubbo、Thrift 等。</p>
<p><img src="/images/blog/engineering/microservice-image_1_5.png" alt="image_1_5.png"></p>
<p>2、REST 访问模式</p>
<p>这个应该大家最常用，可以通过一套统一风格的接口模式，为Web，iOS和Android等提供接口服务。</p>
<p><strong>3.4.2 异步访问方式</strong></p>
<p>消息中间件：RabbitMQ、Kafka、RocketMQ之类，对于实时性要求不那么严格的服务请求和计算。</p>
<h4>3.5 服务治理 <a href="#scroller-28" id="scroller-28"></a></h4>
<p>常见的服务治理手段有如下几种：</p>
<p><strong>3.5.1 节点管理</strong></p>
<p>服务调用失败时可能是服务提供者自身出现，也可能是网络发生故障，我们一般有两种处理手段。</p>
<p>1. 注册中心主动摘除机制 这种机制要求服务提供者定时向注册中心汇报心跳，如果超时，就认为服务提供者出现问题，并将节点从服务列表中摘除。</p>
<p>2. 服务消费者摘除机制 当服务提供者网络出现异常，服务消费者调用就会失败，如果持续错误就可以将它从服务提供者节点列表中移除。</p>
<p><strong>3.5.2 负载均衡</strong></p>
<p>服务消费者在从服务列表中选取可用节点时，如果能让性能较好的服务机多承担一些流量的话，就能充分利用机器的性能。这就需要对负载均衡算法做一些调整。</p>
<p>常用的负载均衡算法主要包括以下几种：</p>
<p>1. Radom 随机算法 从可用的服务节点中随机选取一个节点。一般情况下，随机算法是均匀的，也就是说后端服务节点无论配置好坏，最终得到的调用量都差不多。</p>
<p>2. Round Robin 轮询算法（加权重） 就是按照固定的权重，对可用服务节点进行轮询。如果所有服务节点的权重都是相同的，则每个节点的调用量也是差不多的。但可以给性能较好的节点的权重调大些，充分发挥其性能优势，提高整体调用的平均性能。</p>
<p>3. Least Conn 最少活跃调用算法 这种算法是在服务消费者这一端的内存里动态维护着同每一个服务节点之间的连接数，选择连接数最小的节点发起调用，也就是选择了调用量最小的服务节点，性能理论上也是最优的。</p>
<p>4. 一致性 Hash 算法 指相同参数的请求总是发到同一服务节点。当某一个服务节点出现故障时，原本发往该节点的请求，基于虚拟节点机制，平摊到其他节点上，不会引起剧烈变动。</p>
<p><strong>3.5.3 服务路由</strong></p>
<p>所谓的路由规则，就是通过一定的规则如条件表达式或者正则表达式来限定服务节点的选择范围。</p>
<p>制定路由规则主要有两个原因。</p>
<p>1. 业务存在灰度发布、多版本ABTesting的需求</p>
<p>功能逐步开放发布或者灰度测试的场景。</p>
<p>2. 多机房就近访问的需求</p>
<p>一般可以通过 IP 段规则来控制访问，在选择服务节点时，优先选择同一 IP 段的节点。这个也是算力靠近的优先原则。</p>
<p><strong>3.5.4 服务容错</strong></p>
<p>在分布式系统中，分区容错性是很重要的一个话题，要知道，服务间的调用调用并不总是成功，服务提供者程序bug、异常退出 或者 消费者与提供者之间的网络故障。而服务调用失败之后，我们需要一些方法来保证调用的正常。</p>
<p>常用的方式有以下几种：</p>
<p>FailOver 失败自动切换。就是服务消费者发现调用失败或者超时后，自动从可用的服务节点列表中选择下一个节点重新发起调用，也可以设置重试的次数。</p>
<p>FailBack 失败通知。就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。</p>
<p>FailCache 失败缓存。就是服务消费者调用失败或者超时后，不立即发起重试，而是隔一段时间后再次尝试发起调用。</p>
<p>FailFast 快速失败。就是服务消费者调用一次失败后，不再重试。</p>
<p>服务治理的手段是从不同角度来确保服务调用的成功率。节点管理是从服务节点健康状态角度来考虑，负载均衡和服务路由是从服务节点访问优先级角度来考虑，而服务容错是从调用的健康状态角度来考虑。</p>
<h4>3.6 服务监控 <a href="#scroller-33" id="scroller-33"></a></h4>
<p><img src="/images/blog/engineering/microservice-image_1_6.png" alt="image_1_6.png"></p>
<p>常见的开发监控报警技术有 ELK、InfluxData的TICK、Promethues 等。</p>
<p>在分布式系统中，微服务一般都具有复杂的链路调用，对于链路之间的状态、服务可用性、调用情况的监控，是需要一套完整的服务监控系统去保障的。</p>
<p>如我们上面的那个图所示， 服务系统主要由哪几部分构成：</p>
<p>1、数据采集部分，包含性能指标信息、日志信息（一般是服务埋点日志或者sidecar的inbound、outbound信息）、端到端的Trace信息。</p>
<p>2、采集上来的监控数据通过传输系统，或者使用消息中间件来异步传输，或者调用服务端接口推送监控数据。并把这些数据持久化到我们的数据服务层中。</p>
<p>3、制定一套规则，对于采集到的数据进行清理、计算、分级等，处理好的数据，通过提前设置好的报警策略，来判断它是否触发了这些报警。</p>
<p>4、梳理完的数据可以进行查询展示（有一个日志查询界面）、分级报警、分析趋势报表推送等。</p>
<h4>3.7 服务追踪 <a href="#scroller-34" id="scroller-34"></a></h4>
<p>服务追踪的原理主要包括下面两个关键点。</p>
<p>1、为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的 Trace ID。</p>
<p>通过 Trace ID 的记录，我们就能将所有请求过程的日志关联起来。</p>
<p>2、为了统计各处理单元的时间延迟，当请求到达各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是前文中提到的 Span ID。对于每个 Span 来说，它必须有开始和结束两个节点，</p>
<p>通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如事件名称、请求信息等。</p>
<p><img src="/images/blog/engineering/microservice-image_1_7.png" alt="image_1_7.png"></p>
<p>上图显示了Trace ID 和 Spand ID 在链路中的传输过程，它把服务调用的一个时序结构给展现出来了。</p>
<p>常见的服务链路追踪的技术有Zipkin、Pinpoint、SkyWalking 等。后面讲到Service Mesh的时候会详细说下Zipkin的x-b3 header头传递，以及流量染色的使用，非常给力。</p>
<h3>4 总结 <a href="#scroller-35" id="scroller-35"></a></h3>
<p>微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。</p>
<p>后续我们围绕它的核心模块：服务注册与发现、API 网关服务、分布式配置中心、服务通信、服务治理、分布式服务追踪与监控等，从原理到实践，一步步展开来研究。</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],[["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/architecture/page/1","className":"text-blue-600 hover:text-blue-700 transition-colors","children":"架构设计"}]]]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-03-19","children":"2024年03月19日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"微服务及其演进史"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","微服务",{"href":"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"微服务"}],["$","$L13","架构演进",{"href":"/blog/tag/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"架构演进"}],["$","$L13","分布式系统",{"href":"/blog/tag/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"分布式系统"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"engineering/architecture/微服务架构落地指南：从核心模式到技术选型","title":"微服务架构落地指南：从核心模式到技术选型","description":"系统性地探讨微服务架构设计的核心关注点，包括服务注册发现、API 网关、服务容错、基础设施选型、CI/CD 流水线和可观测性体系，帮助你从 0 到 1 构建一套完整的微服务技术栈。","pubDate":"2024-03-18","tags":["架构设计","微服务","分布式系统","技术选型"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"engineering/architecture/架构师成长路线：从技术深度到架构思维的蜕变","title":"架构师成长路线：从技术深度到架构思维的蜕变","description":"系统梳理架构师的核心能力模型、知识体系全景与成长路径，从架构定义到设计方法论，从分布式理论到架构演进，帮助技术人建立完整的架构认知框架。","pubDate":"2024-03-20","tags":["架构设计","架构师","技术成长","分布式系统","架构方法论"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"微服务":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":{"slug":"engineering/architecture/微服务全景架构","title":"微服务全景架构","description":"微服务架构提倡的单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，实现高效的应用价值，符合我们应用服务开发的发展趋势。","pubDate":"2024-03-20","tags":["微服务","全景架构","分布式系统"],"heroImage":"$undefined","content":"$19"}},"架构演进":{"prev":null,"next":null},"分布式系统":{"prev":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:prev","next":"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next"}}}]}],["$","$L1a",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"微服务及其演进史 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增， 发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。 但是物理服务器的CPU、内存、存储器、连接..."}],["$","meta","2",{"property":"og:title","content":"微服务及其演进史"}],["$","meta","3",{"property":"og:description","content":"在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增， 发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。 但是物理服务器的CPU、内存、存储器、连接..."}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-03-19"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"微服务及其演进史"}],["$","meta","9",{"name":"twitter:description","content":"在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增， 发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。 但是物理服务器的CPU、内存、存储器、连接..."}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

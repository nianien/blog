<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/fffdcdb4fb651185.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>Maven使用技巧 - Skyfalling Blog</title><meta name="description" content="手把手教你如何在工作中巧妙使用Maven，提升开发效率。"/><meta property="og:title" content="Maven使用技巧"/><meta property="og:description" content="手把手教你如何在工作中巧妙使用Maven，提升开发效率。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-04-03"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Maven使用技巧"/><meta name="twitter:description" content="手把手教你如何在工作中巧妙使用Maven，提升开发效率。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/tooling/page/1/">开发工具</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-04-03">2024年04月03日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">Maven使用技巧</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Maven/page/1/">Maven</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Java/page/1/">Java</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/page/1/">构建工具</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>Maven使用技巧</h1>
<h3>1、使用maven.config定制化配置</h3>
<p>Located within the project&#39;s <strong>top level directory</strong>, the files</p>
<ul>
<li><code>maven.config</code></li>
<li><code>jvm.config</code></li>
<li><code>extensions.xml</code></li>
</ul>
<p>contain project specific configuration for running Maven.</p>
<p>This directory is part of the project and may be checked in into your version control.</p>
<blockquote>
<p>ref：<a href="https://maven.apache.org/configure.html">https://maven.apache.org/configure.html</a></p>
</blockquote>
<p>常见配置如：</p>
<pre><code class="language-bash">-Dmaven.test.skip=true
--settings
/Users/skyfalling/.m2/settings.xml
</code></pre>
<p>There must not be a whitespace after <code>--settings,</code>With the introduction of <code>maven 3.9</code>, there was a BREAKING CHANGE that affects the parsing of the <code>maven.config</code> file:</p>
<p>Each line in <code>.mvn/maven.config</code> is now interpreted as a single argument. That is, if the file contains multiple arguments, these must now be placed on separate lines.</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/fffdcdb4fb651185.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"wlOkUxTzHfxl8sQA11M8Z\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"tooling\",\"Maven%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/tooling/Maven%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/fffdcdb4fb651185.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/tooling/Maven%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"23Jk41HSghTFQ-fYYqbcmv\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1a:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T454,\u003ch1\u003eMaven使用技巧\u003c/h1\u003e\n\u003ch3\u003e1、使用maven.config定制化配置\u003c/h3\u003e\n\u003cp\u003eLocated within the project\u0026#39;s \u003cstrong\u003etop level directory\u003c/strong\u003e, the files\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emaven.config\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejvm.config\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eextensions.xml\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003econtain project specific configuration for running Maven.\u003c/p\u003e\n\u003cp\u003eThis directory is part of the project and may be checked in into your version control.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eref：\u003ca href=\"https://maven.apache.org/configure.html\"\u003ehttps://maven.apache.org/configure.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e常见配置如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e-Dmaven.test.skip=true\n--settings\n/Users/skyfalling/.m2/settings.xml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere must not be a whitespace after \u003ccode\u003e--settings,\u003c/code\u003eWith the introduction of \u003ccode\u003emaven 3.9\u003c/code\u003e, there was a BREAKING CHANGE that affects the parsing of the \u003ccode\u003emaven.config\u003c/code\u003e file:\u003c/p\u003e\n\u003cp\u003eEach line in \u003ccode\u003e.mvn/maven.config\u003c/code\u003e is now interpreted as a single argument. That is, if the file contains multiple arguments, these must now be placed on separate lines.\u003c/p\u003e\n17"])</script><script>self.__next_f.push([1,":T2b20,"])</script><script>self.__next_f.push([1,"\u003cp\u003e\u003ca href=\"https://baijiahao.baidu.com/s?id=1769207484615537227\"\u003e转载\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e引言\u003c/h4\u003e\n\u003ch4\u003e1、队列应用场景：\u003c/h4\u003e\n\u003cp\u003eMQ（Message Queue，消息队列）\u003cbr\u003e\u003cstrong\u003e消息队列在实际应用中常用的使用场景（优点）\u003c/strong\u003e：\u003ccode\u003e异步处理\u003c/code\u003e，\u003ccode\u003e应用解耦\u003c/code\u003e，\u003ccode\u003e流量削锋\u003c/code\u003e和\u003ccode\u003e消息通讯\u003c/code\u003e四个场景。\u003c/p\u003e\n\u003ch4\u003e2、目前使用较多的消息队列：\u003c/h4\u003e\n\u003cp\u003e有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ。\u003c/p\u003e\n\u003ch4\u003e3、如何选型（目前现状）：\u003c/h4\u003e\n\u003cp\u003eActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。最早大家都用 ActiveMQ，但是现在确实大家用的不多了，社区也不是很活跃，不推荐用这个了；\u003c/p\u003e\n\u003cp\u003e后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，可视化的管理界面比较友好；\u003c/p\u003e\n\u003cp\u003e不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），它是纯Java开发，它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则老老实实用 RabbitMQ 吧，毕竟RabbitMQ有活跃的开源社区，绝对不会黄。\u003c/p\u003e\n\u003cp\u003e所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。\u003c/p\u003e\n\u003cp\u003e如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，适合产生大量数据的互联网服务的数据收集业务等。社区活跃度很高，何况几乎是全世界这个领域的事实性规范。kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。\u003c/p\u003e\n\u003ch4\u003e4、使用消息队列缺点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，整套系统崩溃了。\u003c/li\u003e\n\u003cli\u003e系统复杂性提高：加MQ进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？\u003c/li\u003e\n\u003cli\u003e一致性问题：A系统处理完了直接返回成功了，后面的如果失败了，这数据就不一致了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e一、RabbitMQ\u003c/h4\u003e\n\u003ch4\u003e1、RabbitMQ概述\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eAMQP\u003c/code\u003e，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层\u003cstrong\u003e标准高级消息队列协议\u003c/strong\u003e，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。\u003cbr\u003eAMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eRabbitMQ\u003c/code\u003e是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。\u003c/p\u003e\n\u003cp\u003eRabbitMQ 是比较有代表性的，因为是\u003ccode\u003e基于主从（非分布式）做高可用性\u003c/code\u003e的。\u003c/p\u003e\n\u003ch4\u003e2、RabbitMQ原理图\u003c/h4\u003e\n\u003cp\u003eRabbitMQ通过\u003ccode\u003e信道\u003c/code\u003e的方式传输数据，将消息发布到交换机上，消息拥有一个路邮键，由消息创建时设定，通过队列路由键，可以把队列绑定到交换机上，消息到达交换机后，RabbitMQ将消息的路由键与队列的路由键进行匹配（不同的交换机有不同的路由规则），匹配到相应的队列，消息投递到队列的队列中供消费者消费。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e多个消费者可以订阅同一个Queue，消息将以\u003ccode\u003e循环（round-robin）\u003c/code\u003e的方式发送给消费者，每条消息只会发给一个订阅的消费者，而不是每个消费者都收到所有的消息并处理。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e每个Channel运行在独立的线程上，多个线程共享同一个socket。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/dfde605794cc90a31ce1223c54218372.jpeg@c_1,w_901,h_315,x_0,y_0\" alt=\"\"\u003e\u003cbr\u003e\u003cstrong\u003e相关概念：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；\u003c/li\u003e\n\u003cli\u003eBroker：简单来说就是消息队列服务器实体。\u003c/li\u003e\n\u003cli\u003eChannel（信道）：消息推送使用的通道；\u003c/li\u003e\n\u003cli\u003eExchange（交换器）：用于接受、分配消息；\u003c/li\u003e\n\u003cli\u003eQueue（队列）：用于存储生产者的消息；\u003c/li\u003e\n\u003cli\u003eRoutingKey（路由键）：用于把生成者的数据分配到交换器上；【最大255个字节】\u003c/li\u003e\n\u003cli\u003eBindingKey（绑定键）：用于把交换器的消息绑定到队列上；【最大255个字节】\u003c/li\u003e\n\u003cli\u003evhost（虚拟主机）每个Rabbit都能创建很多vhost，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e3、RabbitMQ常用的三种交换机\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eRabbitMQ常用的三种Exchange\u003c/strong\u003e：fanout,direct,topic\u003c/p\u003e\n\u003ch4\u003e（1）Direct Exchange ：\u003c/h4\u003e\n\u003cp\u003e直连型交换机，根据消息携带的路由键将消息投递给对应队列。\u003cbr\u003e　　大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key。　然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。\u003c/p\u003e\n\u003ch4\u003e（2）Fanout Exchange：\u003c/h4\u003e\n\u003cp\u003e扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。\u003c/p\u003e\n\u003ch4\u003e（3）Topic Exchange：\u003c/h4\u003e\n\u003cp\u003e主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。\u003cbr\u003e　　\u003cbr\u003e\u003cstrong\u003e性能排序\u003c/strong\u003e：fanout \u0026gt; direct \u0026gt;\u0026gt; topic。\u003c/p\u003e\n\u003ch4\u003e4、 RabbitMQ集群元数据\u003c/h4\u003e\n\u003cp\u003eRabbitMQ集群会始终同步四种类型的内部元数据：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea. 队列元数据：队列名称和它的属性\u003c/li\u003e\n\u003cli\u003eb. 交换器元数据：交换器名称、类型和属性\u003c/li\u003e\n\u003cli\u003ec. 绑定元数据：一张简单的表格展示了如何将消息路由到队列\u003c/li\u003e\n\u003cli\u003ed. vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e5、RabbitMQ镜像集群\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eRabbitMQ 有三种模式\u003c/strong\u003e：单机模式、普通集群模式（无高可用性）、\u003ccode\u003e镜像集群模式\u003c/code\u003e（高可用性）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e镜像队列\u003c/code\u003e将需要消费的队列变成镜像队列，存在于多个节点，实现RabbitMQ的高可用，保证 100% 数据不丢失。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在消费者消费数据时临时拉取，缺点就是集群内部的\u003ccode\u003e同步通讯\u003c/code\u003e会占去大量的网络带宽。\u003cbr\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/53a92fdedade9355420e866bbdb51be1.jpeg@c_1,w_613,h_390,x_0,y_0\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch4\u003e二、RocketMQ\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eRocketMQ\u003c/code\u003e是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目。用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRocketMQ缺点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单机支持1万以上持久化队列；\u003c/li\u003e\n\u003cli\u003eRocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。\u003c/li\u003e\n\u003cli\u003e模型简单，接口易用（JMS的接口很多场合并不太实用）；\u003c/li\u003e\n\u003cli\u003e性能非常好，可以允许大量堆积消息在Broker中；\u003c/li\u003e\n\u003cli\u003e支持多种消费模式，包括集群消费、广播消费等；\u003c/li\u003e\n\u003cli\u003e各个环节分布式扩展设计，支持主从和高可用；\u003c/li\u003e\n\u003cli\u003e开发度较活跃，版本更新很快。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eRocketMQ缺点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟\u003c/li\u003e\n\u003cli\u003e维护RocketMQ需要专业的团队\u003c/li\u003e\n\u003cli\u003e商业版收费，有许多功能是不对外提供的。\u003c/li\u003e\n\u003cli\u003e没有在MQ核心里实现JMS等接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e三、kafka\u003c/h4\u003e\n\u003ch4\u003e1、kafka概述\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ekafka\u003c/code\u003e是Linkedin于2010年12月份开源的\u003ccode\u003e消息发布订阅\u003c/code\u003e系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。作为hadoop生态系统的一部分，被各种商业公司广泛应用。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ekafka优点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒\u003c/li\u003e\n\u003cli\u003e可扩展性：kafka集群支持热扩展\u003c/li\u003e\n\u003cli\u003e持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失\u003c/li\u003e\n\u003cli\u003e容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）\u003c/li\u003e\n\u003cli\u003e高并发：支持数千个客户端同时读写\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003ekafka缺点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e快速持久化：可以在O(1)的系统开销下进行消息持久化；\u003c/li\u003e\n\u003cli\u003e高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；\u003c/li\u003e\n\u003cli\u003e完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；\u003c/li\u003e\n\u003cli\u003e支持同步和异步复制两种高可用机制；\u003c/li\u003e\n\u003cli\u003e支持数据批量发送和拉取；\u003c/li\u003e\n\u003cli\u003e零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；\u003c/li\u003e\n\u003cli\u003e数据迁移、扩容对用户透明；\u003c/li\u003e\n\u003cli\u003e无需停机即可扩展机器；\u003c/li\u003e\n\u003cli\u003e其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2、kafka原理图\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/3d90e1705de49c669f22628af2f6004a.jpeg@c_1,w_1010,h_651,x_0,y_0\" alt=\"\"\u003e\u003cbr\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/a5531d658050ce7abecb5ad4242d92ab.jpeg@c_1,w_1002,h_300,x_0,y_0\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch4\u003e四、总结\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/middleware-img_20250723_04.png\" alt=\"img_20250723_04.png\"\u003e{: .full-width}\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"18:T3dc2,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e首先强调一下，Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。其中，最”简单”的方式是通过\u003c/em\u003e\u003ca href=\"https://central.sonatype.org/pages/ossrh-guide.html\"\u003eSonatype OSSRH\u003c/a\u003e\u003cem\u003e仓库来发布jar包。所以，接下来主要介绍如何将jar包发布到Sonatype OSSRH。\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先，先说一下大体的步骤：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e注册Sonatype账号\u003c/li\u003e\n\u003cli\u003e创建Issue，验证域名\u003c/li\u003e\n\u003cli\u003e安装GPG，发布密钥\u003c/li\u003e\n\u003cli\u003e配置Maven，发布构件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里面比较重要和容易出错的是第二步和第三步，下面一一详细介绍。\u003c/p\u003e\n\u003ch4\u003e1、注册Sonatype账号 \u003ca href=\"#bojci\" id=\"bojci\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e第一步很简单，登录官网，注册账号就好了\u003ca href=\"https://issues.sonatype.org/secure/Signup!default.jspa\"\u003eSign up for Jira - Sonatype JIRA\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e注册完成，登陆后的界面如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_60.png\" alt=\"image_60.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2、创建Issue \u003ca href=\"#omwqz\" id=\"omwqz\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这里项目选择：Community Support - Open Source Project Repository Hosting (OSSRH)，问题 类型选择：New Project\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_67.png\" alt=\"image_67.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.1、补充项目信息\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_62.png\" alt=\"image_62.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.2、验证域名 \u003ca href=\"#snbg0\" id=\"snbg0\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e我们需要使用域名作为Group Id，如果你拥有域\u0026#x540D;\u003cem\u003e\u0026#x65;xample.com，则能够使用com.example开头作为Group Id，例如：com.example.myproject。其他一些栗子如下：\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eexample.com -\u0026gt; com.example.domain\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.springframework.org/\"\u003ewww.springframework.org\u003c/a\u003e -\u0026gt; org.springframework\u003c/li\u003e\n\u003cli\u003esubdomain.example.com -\u0026gt; example.com\u003c/li\u003e\n\u003cli\u003egithub.com/yourusername -\u0026gt; io.github.yourusername\u003c/li\u003e\n\u003cli\u003emy-domain.com -\u0026gt; com.my-domain\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e要想使用某个域名作为Group Id，你需要证明拥有该域名，至于如何证明，详见官方文档：\u003ca href=\"https://central.sonatype.org/faq/how-to-set-txt-record\"\u003ehttps://central.sonatype.org/faq/how-to-set-txt-record/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e如果你没有自己的域名，则可以通过代码托管平台的账号关联子域名。假设你托管平台账户名为myusername，那么你可以通过以下托管平台验证Group Id ：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_63.png\" alt=\"image_63.png\"\u003e\u003c/p\u003e\n\u003cp\u003e由于我没有自己的域名，这里我选择使用github账号验证Group Id。点击“新建”按钮，完成提交，之后你的注册邮箱会收到一封邮件，显示创建项目信息：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_65.png\" alt=\"image_65.png\"\u003e\u003c/p\u003e\n\u003cp\u003e稍后还会收到一封审核邮件，提示你进行域名验证，时间延迟大概在十分钟以内。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.3、人工审核及确认\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_66.png\" alt=\"image_66.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我使用的是github账户，按邮件提示，需要在github平台上创建一个指定的临时工程。创建完成之后，可以在issue下面添加评论，触发验证。验证成功后，你会收到一份邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_68.png\" alt=\"image_68.png\"\u003e\u003c/p\u003e\n\u003cp\u003e收到上述邮件，就表示完成了Group Id的验证，此时你就可以使用该Group Id或者子Group Id发布Maven构件了。如上，我填写的Group Id是 “io.github.nianien”，因此，我可以使用 “io.github.nianien”或者 “io.github.nianien.xxx” 作为项目的GroupId发布Maven构件。\u003c/p\u003e\n\u003cp\u003e在通过Maven发布构件之前，我们需要进行Maven配置，这里还需要一些前置工作。\u003c/p\u003e\n\u003ch4\u003e3、安装GPG，创建密钥 \u003ca href=\"#dcxco\" id=\"dcxco\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e安装GPG的方式有多种，这里推荐图形化安装，因为通过命令行安装，由于找不到合适的密钥服务器，发布密钥时会失败。这里给出Mac版本的下载地址：\u003ca href=\"https://releases.gpgtools.org/GPG_Suite-2022.1.dmg\"\u003ehttps://releases.gpgtools.org/GPG_Suite-2022.1.dmg\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建密钥\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_69.png\" alt=\"image_69.png\"\u003e\u003c/p\u003e\n\u003cp\u003e3.1、发布密钥\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_70.png\" alt=\"image_70.png\"\u003e\u003c/p\u003e\n\u003cp\u003e发布成功后，收到一份邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_71.png\" alt=\"image_71.png\"\u003e\u003c/p\u003e\n\u003cp\u003e按照邮件指示操作，完成密钥发布。密钥发布成功之后，下一步就是配置maven settings.xml和工程pom.xml文件。\u003c/p\u003e\n\u003ch4\u003e4、配置Maven，发布构件 \u003ca href=\"#amad1\" id=\"amad1\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e第一步，配置setting.xml文件，添加server节点：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;servers\u0026gt;\n\u0026lt;server\u0026gt;\n    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n    \u0026lt;username\u0026gt;sonatype账户名\u0026lt;/username\u0026gt;\n    \u0026lt;password\u0026gt;sonatype账户密码\u0026lt;/password\u0026gt;\n\u0026lt;/server\u0026gt;\n\u0026lt;/servers\u0026gt;\n\u0026lt;profile\u0026gt;\n  \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n  \u0026lt;properties\u0026gt;\n    \u0026lt;gpg.executable\u0026gt;gpg\u0026lt;/gpg.executable\u0026gt;\n    \u0026lt;gpg.passphrase\u0026gt;创建密钥时使用的密码\u0026lt;/gpg.passphrase\u0026gt;\n    \u0026lt;gpg.homedir\u0026gt;/Users/yourname/.gnupg\u0026lt;/gpg.homedir\u0026gt;\n   \u0026lt;/properties\u0026gt;\n\u0026lt;/profile\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e第二步，配置pom.xml文件，添加必填项\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\n         xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\n    \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\u0026lt;!--已经验证的Group Id--\u0026gt;\n    \u0026lt;groupId\u0026gt;io.github.nianien\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;cudrania\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;1.0.1\u0026lt;/version\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;name\u0026gt;io.github.nianien:cudrania\u0026lt;/name\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;description\u0026gt;support tools for java development\u0026lt;/description\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;url\u0026gt;https://github.com/nianien/cudrania\u0026lt;/url\u0026gt;\n    \u0026lt;properties\u0026gt;\n        \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt;\n        \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt;\n    \u0026lt;/properties\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;licenses\u0026gt;\n        \u0026lt;license\u0026gt;\n            \u0026lt;name\u0026gt;The Apache Software License, Version 2.0\u0026lt;/name\u0026gt;\n            \u0026lt;url\u0026gt;https://www.apache.org/licenses/LICENSE-2.0.txt\u0026lt;/url\u0026gt;\n        \u0026lt;/license\u0026gt;\n    \u0026lt;/licenses\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;developers\u0026gt;\n        \u0026lt;developer\u0026gt;\n            \u0026lt;id\u0026gt;nianien\u0026lt;/id\u0026gt;\n            \u0026lt;name\u0026gt;nianien\u0026lt;/name\u0026gt;\n            \u0026lt;email\u0026gt;nianien@126.com\u0026lt;/email\u0026gt;\n        \u0026lt;/developer\u0026gt;\n    \u0026lt;/developers\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;scm\u0026gt;\n        \u0026lt;connection\u0026gt;https://github.com/nianien/cudrania.git\u0026lt;/connection\u0026gt;\n        \u0026lt;developerConnection\u0026gt;scm:git:ssh://git@github.com:nianien/cudrania.git\n        \u0026lt;/developerConnection\u0026gt;\n        \u0026lt;url\u0026gt;https://github.com/nianien/cudrania\u0026lt;/url\u0026gt;\n    \u0026lt;/scm\u0026gt;\n    \u0026lt;build\u0026gt;\n        \u0026lt;pluginManagement\u0026gt;\n            \u0026lt;plugins\u0026gt;\n                \u0026lt;plugin\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt;\n                    \u0026lt;configuration\u0026gt;\n                        \u0026lt;source\u0026gt;${java.version}\u0026lt;/source\u0026gt;\n                        \u0026lt;target\u0026gt;${java.version}\u0026lt;/target\u0026gt;\n                    \u0026lt;/configuration\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n                \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;jar-no-fork\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n                \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt; \n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.5.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                            \u0026lt;configuration\u0026gt;\n                                \u0026lt;additionalparam\u0026gt;\n                                    -Xdoclint:none\n                                \u0026lt;/additionalparam\u0026gt;\n                            \u0026lt;/configuration\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                \u0026lt;plugin\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;sign-artifacts\u0026lt;/id\u0026gt;\n                            \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;sign\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n            \u0026lt;/plugins\u0026gt;\n        \u0026lt;/pluginManagement\u0026gt;\n        \u0026lt;plugins\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n        \u0026lt;/plugins\u0026gt;\n    \u0026lt;/build\u0026gt;\n\n    \u0026lt;profiles\u0026gt;\u0026lt;!--必填--\u0026gt;\n        \u0026lt;profile\u0026gt;\n            \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n            \u0026lt;build\u0026gt;\n                \u0026lt;plugins\u0026gt;\n                    \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                        \u0026lt;groupId\u0026gt;org.sonatype.plugins\u0026lt;/groupId\u0026gt;\n                        \u0026lt;artifactId\u0026gt;nexus-staging-maven-plugin\u0026lt;/artifactId\u0026gt;\n                        \u0026lt;version\u0026gt;1.6.13\u0026lt;/version\u0026gt;\n                        \u0026lt;extensions\u0026gt;true\u0026lt;/extensions\u0026gt;\n                        \u0026lt;configuration\u0026gt;\n                            \u0026lt;serverId\u0026gt;ossrh\u0026lt;/serverId\u0026gt;\n                            \u0026lt;nexusUrl\u0026gt;https://s01.oss.sonatype.org/\u0026lt;/nexusUrl\u0026gt; \n                          \u0026lt;autoReleaseAfterClose\u0026gt;true\u0026lt;/autoReleaseAfterClose\u0026gt;\n                        \u0026lt;/configuration\u0026gt;\n                    \u0026lt;/plugin\u0026gt;\n                    \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                        \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                        \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;/plugin\u0026gt;\n                \u0026lt;/plugins\u0026gt;\n            \u0026lt;/build\u0026gt;\u0026lt;!--必填--\u0026gt;\n            \u0026lt;distributionManagement\u0026gt;\n                \u0026lt;snapshotRepository\u0026gt;\n                    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n                  \u0026lt;url\u0026gt;https://s01.oss.sonatype.org/content/repositories/snapshots\n                    \u0026lt;/url\u0026gt;\n                \u0026lt;/snapshotRepository\u0026gt;\n                \u0026lt;repository\u0026gt;\n                    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n                    \u0026lt;url\u0026gt;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/\n                    \u0026lt;/url\u0026gt;\n                \u0026lt;/repository\u0026gt;\n            \u0026lt;/distributionManagement\u0026gt;\n        \u0026lt;/profile\u0026gt;\n    \u0026lt;/profiles\u0026gt;\n\n    \u0026lt;dependencies\u0026gt;\u0026lt;!--maven依赖--\u0026gt;\u0026lt;/dependencies\u0026gt;\n\n\u0026lt;/project\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面已经是最精简的pom配置了，我已经把必选项标注好了。这里主要包含两部分内容，一部分是snoatype要求的必备信息，包括：证书、开发者信息、仓库地址和发布地址；另一部分是deploy需要的maven插件列表，大家可以根据实际情况酌情修改。\u003c/p\u003e\n\u003cp\u003e需要说明的是，为了不用默认打包冲突，专门定义了用于发布中央仓库的profile：ossrh，这里只需要添加额外的两个插件：nexus-staging-maven-plugin和maven-gpg-plugin，前者用于jar上传，后者用于密钥签名。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第三步，执行maven命令，发布构件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e配置好pom文件，可以执行maven命令：“mvn clean deploy -Possrh” 进行发布。如果版本号带SNAPSHOT后缀，会发布到snapshots仓库，否则发布到release仓库。\u003c/p\u003e\n\u003cp\u003e这里nexus-staging-maven-plugin插件有一个配置项：autoReleaseAfterClose，如果设置为true的话，推送完成会自动release。第一次发布成功后，会收到一封邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_72.png\" alt=\"image_72.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e\u003cstrong\u003e最后，让jar包更快的在中央仓库被搜索到\u003c/strong\u003e\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e根据邮件提示，Jar包成功发布成功后，大约30分钟后会推到中央仓库，我们可以从仓库地址看到我们发布的Jar包：\u003ca href=\"https://repo1.maven.org/maven2\"\u003ehttps://repo1.maven.org/maven2/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_73.png\" alt=\"image_73.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，其他项目就可以通过maven依赖引用我们的构件了，但是这时候通过中央仓库仍然搜不到我们的Maven构件。按照邮件提示可能会需要四小时，实际情况是我等了5个小时依然搜不到。如果遇到这种情况，我们可以通过在对issue添加评论反馈，会有人工回复进行解决：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_74.png\" alt=\"image_74.png\"\u003e\u003c/p\u003e\n\u003cp\u003e另外，关于mvnrepository与Maven Central的关系，有人咨询，官方也做了解答：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_75.png\" alt=\"image_75.png\"\u003e\u003c/p\u003e\n\u003cp\u003e根据我的实际经验判断，mvnrepository应该是定时同步的，我发布成功后，第二天才能搜到：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_76.png\" alt=\"image_76.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下面是官方指导文档，介绍非常详细，基本上不用在网上搜索其他教程了。\u003c/p\u003e\n\u003ch4\u003e官方参考文档 \u003ca href=\"#dzquo\" id=\"dzquo\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://central.sonatype.org/publish/publish-guide\"\u003ehttps://central.sonatype.org/publish/publish-guide/\u003c/a\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"19:T5870,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003eJava 中的大部分同步工具（ReentrantLock、Semaphore、CountDownLatch、ReentrantReadWriteLock 等）都基于 AbstractQueuedSynchronizer（AQS）实现。理解 AQS，就等于掌握了 Java 并发编程的底层脉络。本文从设计思想出发，逐层深入 AQS 的数据结构、核心流程和源码实现，并通过 ReentrantLock 串联全局，最后梳理 AQS 在 JUC 中的应用全景。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eAQS 是什么？\u003c/h2\u003e\n\u003cp\u003eAQS（AbstractQueuedSynchronizer）是 \u003ccode\u003ejava.util.concurrent.locks\u003c/code\u003e 包中的一个\u003cstrong\u003e抽象类\u003c/strong\u003e，是构建锁和同步器的基础框架。Doug Lea 设计 AQS 的核心目标是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e降低构建锁和同步器的工作量\u003c/li\u003e\n\u003cli\u003e避免在多个位置处理竞争问题\u003c/li\u003e\n\u003cli\u003e在基于 AQS 的同步器中，阻塞只可能在一个时刻发生，降低上下文切换开销，提高吞吐量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAQS 支持两种工作模式：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003cth\u003e典型实现\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e独占模式（Exclusive）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e同一时刻只能有一个线程获取到锁\u003c/td\u003e\n\u003ctd\u003eReentrantLock\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e共享模式（Shared）\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e同一时刻可以有多个线程同时获取\u003c/td\u003e\n\u003ctd\u003eCountDownLatch、ReadWriteLock、Semaphore\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e无论哪种模式，本质上都是对 AQS 内部一个 \u003cstrong\u003e\u003ccode\u003estate\u003c/code\u003e 变量\u003c/strong\u003e的获取和释放。\u003c/p\u003e\n\u003ch2\u003eAQS 的整体架构\u003c/h2\u003e\n\u003cp\u003eAQS 框架共分为\u003cstrong\u003e五层\u003c/strong\u003e，自上而下由浅入深：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e层次\u003c/th\u003e\n\u003cth\u003e内容\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e第一层\u003c/td\u003e\n\u003ctd\u003eAPI 层\u003c/td\u003e\n\u003ctd\u003e自定义同步器需重写的方法（tryAcquire、tryRelease 等）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第二层\u003c/td\u003e\n\u003ctd\u003e获取/释放方法\u003c/td\u003e\n\u003ctd\u003eacquire、release、acquireShared、releaseShared\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第三层\u003c/td\u003e\n\u003ctd\u003e队列操作\u003c/td\u003e\n\u003ctd\u003eaddWaiter、acquireQueued、shouldParkAfterFailedAcquire\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第四层\u003c/td\u003e\n\u003ctd\u003e线程阻塞/唤醒\u003c/td\u003e\n\u003ctd\u003eLockSupport.park / unpark\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e第五层\u003c/td\u003e\n\u003ctd\u003e基础数据\u003c/td\u003e\n\u003ctd\u003estate、Node、CLH 变体队列\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e当接入自定义同步器时，\u003cstrong\u003e只需重写第一层的部分方法即可\u003c/strong\u003e，不需要关注底层实现。当加锁或解锁操作触发时，沿着第一层到第五层逐层深入。\u003c/p\u003e\n\u003ch2\u003e核心数据结构\u003c/h2\u003e\n\u003ch3\u003e同步状态 State\u003c/h3\u003e\n\u003cp\u003eAQS 使用一个 \u003ccode\u003evolatile int\u003c/code\u003e 类型的成员变量 \u003ccode\u003estate\u003c/code\u003e 来表示同步状态：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate volatile int state;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eState 的含义由具体的同步器定义，例如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eReentrantLock\u003c/strong\u003e：state 表示锁被重入的次数，0 表示未被持有\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e：state 表示可用许可的数量\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e：state 表示计数器的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAQS 提供三个方法操作 state，均为 \u003ccode\u003efinal\u003c/code\u003e 修饰，子类不可重写：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003egetState()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e获取当前 state 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003esetState(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e设置 state 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecompareAndSetState(int, int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eCAS 方式更新 state\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eCLH 变体队列与 Node 节点\u003c/h3\u003e\n\u003cp\u003eAQS 的核心思想是：如果请求的共享资源空闲，就将当前线程设置为有效的工作线程，并将资源设置为锁定状态；\u003cstrong\u003e如果资源被占用，就通过一个 CLH 变体的 FIFO 双向队列来管理等待线程\u003c/strong\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCLH 队列以其发明者 Craig、Landin 和 Hagersten 命名，原始 CLH 是单向链表。AQS 中的变体是虚拟双向队列，通过将每条请求线程封装成 Node 节点来实现锁的分配。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNode 节点的关键属性：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethread\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e该节点代表的线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ewaitStatus\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e当前节点在队列中的等待状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eprev\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e前驱指针\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enext\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e后继指针\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003enextWaiter\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e指向下一个处于 CONDITION 状态的节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003ewaitStatus\u003c/code\u003e 的枚举值：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e值\u003c/th\u003e\n\u003cth\u003e名称\u003c/th\u003e\n\u003cth\u003e含义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e默认值\u003c/td\u003e\n\u003ctd\u003eNode 初始化时的状态\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003eCANCELLED\u003c/td\u003e\n\u003ctd\u003e线程获取锁的请求已取消\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-1\u003c/td\u003e\n\u003ctd\u003eSIGNAL\u003c/td\u003e\n\u003ctd\u003e后继节点的线程需要被唤醒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-2\u003c/td\u003e\n\u003ctd\u003eCONDITION\u003c/td\u003e\n\u003ctd\u003e节点在条件队列中，等待 Condition 唤醒\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e-3\u003c/td\u003e\n\u003ctd\u003ePROPAGATE\u003c/td\u003e\n\u003ctd\u003e共享模式下，释放操作需要向后传播\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eAQS 内部还维护了\u003cstrong\u003e两种队列\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e同步队列（Sync Queue）\u003c/strong\u003e：获取资源失败的线程进入此队列自旋等待，当前驱节点是头节点时尝试获取资源\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e条件队列（Condition Queue）\u003c/strong\u003e：基于 \u003ccode\u003eCondition\u003c/code\u003e 实现，调用 \u003ccode\u003eawait()\u003c/code\u003e 时线程进入条件队列，调用 \u003ccode\u003esignal()\u003c/code\u003e 时转移到同步队列\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意：双向链表的\u003cstrong\u003e头节点是一个虚节点\u003c/strong\u003e（不存储实际线程信息），真正的第一个有效节点从第二个开始。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e自定义同步器需要重写的方法\u003c/h2\u003e\n\u003cp\u003eAQS 采用\u003cstrong\u003e模板方法模式\u003c/strong\u003e，自定义同步器只需根据需要重写以下方法：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e模式\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryAcquire(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e尝试获取资源，成功返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryRelease(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e尝试释放资源，成功返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryAcquireShared(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e尝试获取资源，负数=失败，0=成功但无剩余，正数=成功且有剩余\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003etryReleaseShared(int)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e共享\u003c/td\u003e\n\u003ctd\u003e尝试释放资源，如果释放后允许唤醒后续节点返回 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eisHeldExclusively()\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e独占\u003c/td\u003e\n\u003ctd\u003e当前线程是否独占资源，用到 Condition 时需实现\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e独占模式实现 \u003ccode\u003etryAcquire-tryRelease\u003c/code\u003e，共享模式实现 \u003ccode\u003etryAcquireShared-tryReleaseShared\u003c/code\u003e。AQS 也支持同时实现两种模式，如 \u003ccode\u003eReentrantReadWriteLock\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003e通过 ReentrantLock 理解加锁流程\u003c/h2\u003e\n\u003cp\u003eReentrantLock 是 AQS 独占模式最典型的实现。我们以\u003cstrong\u003e非公平锁\u003c/strong\u003e为例，完整追踪加锁流程。\u003c/p\u003e\n\u003ch3\u003e第一步：lock()\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock.NonfairSync\nfinal void lock() {\n    if (compareAndSetState(0, 1))           // 直接 CAS 尝试获取锁\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);                          // 失败则进入 AQS 框架流程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e非公平锁上来就尝试 CAS 抢锁（不管队列中有没有等待线程），这是它\u0026quot;非公平\u0026quot;的体现。\u003c/p\u003e\n\u003ch3\u003e第二步：acquire()\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// AbstractQueuedSynchronizer\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026amp;\u0026amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这一行代码浓缩了整个加锁流程的四个步骤：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etryAcquire → addWaiter → acquireQueued → selfInterrupt\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003etryAcquire\u003c/strong\u003e：尝试获取锁（由子类实现）\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eaddWaiter\u003c/strong\u003e：获取失败，将当前线程封装为 Node 加入队列尾部\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eacquireQueued\u003c/strong\u003e：在队列中自旋等待，直到获取到锁\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eselfInterrupt\u003c/strong\u003e：如果等待过程中被中断过，补上中断\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e第三步：tryAcquire（公平 vs 非公平）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e非公平锁\u003c/strong\u003e的实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {   // 直接 CAS，不检查队列\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {  // 可重入逻辑\n        int nextc = c + acquires;\n        if (nextc \u0026lt; 0) throw new Error(\u0026quot;Maximum lock count exceeded\u0026quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e公平锁\u003c/strong\u003e的区别仅在于多了一个 \u003ccode\u003ehasQueuedPredecessors()\u003c/code\u003e 检查：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (c == 0) {\n    if (!hasQueuedPredecessors() \u0026amp;\u0026amp;   // 公平锁：先检查队列中是否有等待线程\n        compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e锁类型\u003c/th\u003e\n\u003cth\u003estate == 0 时的行为\u003c/th\u003e\n\u003cth\u003e可重入逻辑\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e非公平锁\u003c/td\u003e\n\u003ctd\u003e直接 CAS 抢锁\u003c/td\u003e\n\u003ctd\u003e相同：state + 1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e公平锁\u003c/td\u003e\n\u003ctd\u003e先检查队列再 CAS\u003c/td\u003e\n\u003ctd\u003e相同：state + 1\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e第四步：addWaiter — 入队\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Node addWaiter(Node mode) {\n    Node node = new Node(Thread.currentThread(), mode);\n    Node pred = tail;\n    if (pred != null) {            // 队列已初始化，尝试快速入队\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);                     // 快速入队失败或队列未初始化\n    return node;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eenq()\u003c/code\u003e 方法通过\u003cstrong\u003e自旋 + CAS\u003c/strong\u003e 确保入队成功：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) {                         // 队列为空，初始化\n            if (compareAndSetHead(new Node()))    // 创建虚拟头节点\n                tail = head;\n        } else {\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e线程获取锁的过程可以形象理解为：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程1获取锁成功 → 线程2申请锁失败 → 线程2入队等待 → 线程3申请失败 → 线程3排在线程2后面 → ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e第五步：acquireQueued — 自旋获取锁\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {   // 前驱是头节点，尝试获取锁\n                setHead(node);                     // 获取成功，当前节点成为新的头节点\n                p.next = null;                     // help GC\n                failed = false;\n                return interrupted;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp;\n                parkAndCheckInterrupt())           // 获取失败，判断是否需要挂起\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e核心逻辑：\u003cstrong\u003e只有前驱节点是头节点的线程才有资格尝试获取锁\u003c/strong\u003e。获取失败后，通过 \u003ccode\u003eshouldParkAfterFailedAcquire\u003c/code\u003e 判断是否需要挂起（将前驱节点的 waitStatus 设为 SIGNAL），然后通过 \u003ccode\u003eLockSupport.park()\u003c/code\u003e 挂起线程，避免空转浪费 CPU。\u003c/p\u003e\n\u003ch3\u003eshouldParkAfterFailedAcquire 的三种情况\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)        // 前驱已经是 SIGNAL，可以安全挂起\n        return true;\n    if (ws \u0026gt; 0) {                 // 前驱已取消，向前找到有效节点\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus \u0026gt; 0);\n        pred.next = node;\n    } else {                      // 前驱状态为 0 或 PROPAGATE，设为 SIGNAL\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e前驱 waitStatus\u003c/th\u003e\n\u003cth\u003e处理\u003c/th\u003e\n\u003cth\u003e是否挂起\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eSIGNAL (-1)\u003c/td\u003e\n\u003ctd\u003e直接返回 true\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCANCELLED (\u0026gt;0)\u003c/td\u003e\n\u003ctd\u003e跳过所有取消节点，重新链接\u003c/td\u003e\n\u003ctd\u003e否，下次循环再判断\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e0 或 PROPAGATE\u003c/td\u003e\n\u003ctd\u003eCAS 设为 SIGNAL\u003c/td\u003e\n\u003ctd\u003e否，下次循环再判断\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e解锁流程\u003c/h2\u003e\n\u003cp\u003eReentrantLock 解锁时\u003cstrong\u003e不区分公平和非公平\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock\npublic void unlock() {\n    sync.release(1);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// AbstractQueuedSynchronizer\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null \u0026amp;\u0026amp; h.waitStatus != 0)\n            unparkSuccessor(h);          // 唤醒后继节点\n        return true;\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003etryRelease — 可重入锁的释放\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// ReentrantLock.Sync\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;       // state 减 1\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {                         // 只有 state 减到 0，锁才真正释放\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c);\n    return free;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eunparkSuccessor — 唤醒后继线程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void unparkSuccessor(Node node) {\n    int ws = node.waitStatus;\n    if (ws \u0026lt; 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    Node s = node.next;\n    if (s == null || s.waitStatus \u0026gt; 0) {\n        s = null;\n        // 从尾部向前遍历，找到第一个非取消状态的节点\n        for (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev)\n            if (t.waitStatus \u0026lt;= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);    // 唤醒线程\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e为什么要从后向前遍历？\u003c/strong\u003e 两个原因：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eaddWaiter\u003c/code\u003e 中节点入队不是原子操作——\u003ccode\u003enode.prev = pred\u003c/code\u003e 和 \u003ccode\u003ecompareAndSetTail\u003c/code\u003e 完成后，\u003ccode\u003epred.next = node\u003c/code\u003e 可能还未执行。此时从前向后遍历会断链。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecancelAcquire\u003c/code\u003e 产生 CANCELLED 节点时，先断开的是 next 指针，prev 指针未断开。因此从后向前遍历才能保证遍历完整。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eCANCELLED 节点的处理\u003c/h2\u003e\n\u003cp\u003e当 \u003ccode\u003eacquireQueued\u003c/code\u003e 中发生异常时，会执行 \u003ccode\u003ecancelAcquire(node)\u003c/code\u003e 将节点标记为 CANCELLED。处理逻辑根据节点位置分为三种情况：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e节点位置\u003c/th\u003e\n\u003cth\u003e处理方式\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e尾节点\u003c/td\u003e\n\u003ctd\u003e将前驱设为新的 tail，其 next 置为 null\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e头节点的后继\u003c/td\u003e\n\u003ctd\u003e唤醒当前节点的后继线程（unparkSuccessor）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e中间节点\u003c/td\u003e\n\u003ctd\u003e将前驱的 next 指向当前节点的后继，跳过当前节点\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003ecancelAcquire\u003c/code\u003e 只操作 next 指针，不操作 prev 指针。因为执行 cancel 时前驱可能已经出队，修改 prev 不安全。prev 指针的清理留给 \u003ccode\u003eshouldParkAfterFailedAcquire\u003c/code\u003e——此方法在获取锁失败时执行，此时共享资源已被占用，前方节点不会变化，修改 prev 是安全的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e中断处理机制\u003c/h2\u003e\n\u003cp\u003eAQS 的 \u003ccode\u003eacquire\u003c/code\u003e 方法是\u003cstrong\u003e不可中断\u003c/strong\u003e的——线程在等待过程中不会响应中断，而是记录中断状态，等获取到锁后再\u0026quot;补上\u0026quot;中断：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final void acquire(int arg) {\n    if (!tryAcquire(arg) \u0026amp;\u0026amp;\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 返回 true 说明被中断过\n        selfInterrupt();                                  // 补上中断\n}\n\nstatic void selfInterrupt() {\n    Thread.currentThread().interrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种设计的考量是：线程被唤醒时并不知道原因（可能是前驱释放了锁，也可能是被中断），所以通过 \u003ccode\u003eThread.interrupted()\u003c/code\u003e 检查并清除中断标记，记录下来，最后在获取锁成功后统一补上。\u003c/p\u003e\n\u003ch2\u003epark / unpark 机制\u003c/h2\u003e\n\u003cp\u003eAQS 中线程的阻塞和唤醒通过 \u003ccode\u003eLockSupport\u003c/code\u003e 实现：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e方法\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLockSupport.park(this)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e阻塞当前线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eLockSupport.unpark(thread)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e唤醒指定线程\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e它们的底层实现是通过 \u003ccode\u003eUnsafe\u003c/code\u003e 类调用 CPU 原语。相比 \u003ccode\u003eObject.wait/notify\u003c/code\u003e，park/unpark 的优势在于：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不需要在同步块中使用\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eunpark\u003c/code\u003e 可以先于 \u003ccode\u003epark\u003c/code\u003e 调用（基于许可机制）\u003c/li\u003e\n\u003cli\u003e可以精确唤醒指定线程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在 AQS 中使用 park 的主要目的是：\u003cstrong\u003e让排队等待的线程挂起，停止自旋以避免浪费 CPU 资源\u003c/strong\u003e，并在需要时通过 unpark 精确唤醒。\u003c/p\u003e\n\u003ch2\u003eAQS 在 JUC 中的应用场景\u003c/h2\u003e\n\u003cp\u003eAQS 是 JUC 包的基石，几乎所有同步工具都构建在它之上：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e同步工具\u003c/th\u003e\n\u003cth\u003e如何使用 AQS\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eReentrantLock\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示锁的重入次数。获取锁时 state+1，释放时 state-1。state 为 0 表示锁空闲。同时记录持有锁的线程用于重入检测。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eSemaphore\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示可用许可数。\u003ccode\u003eacquireShared\u003c/code\u003e 减少计数，\u003ccode\u003etryReleaseShared\u003c/code\u003e 增加计数。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eCountDownLatch\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 表示计数器。每次 \u003ccode\u003ecountDown()\u003c/code\u003e 减 1，\u003ccode\u003eawait()\u003c/code\u003e 等待 state 变为 0 后所有线程被唤醒。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eReentrantReadWriteLock\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003estate 的高 16 位保存读锁持有次数，低 16 位保存写锁持有次数。读锁用共享模式，写锁用独占模式。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eThreadPoolExecutor\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eWorker 内部类继承 AQS，利用独占模式实现对工作线程的状态管理。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eState 在不同同步器中的语义\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eReentrantLock:       state = 重入次数 (0 = 空闲)\nSemaphore:           state = 可用许可数\nCountDownLatch:      state = 剩余计数 (0 = 所有线程放行)\nReadWriteLock:       state = [高16位:读锁次数][低16位:写锁次数]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e自定义同步器示例\u003c/h2\u003e\n\u003cp\u003e理解 AQS 后，我们可以用极少的代码实现一个简单的互斥锁：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class SimpleLock {\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n    private final Sync sync = new Sync();\n\n    public void lock()   { sync.acquire(1); }\n    public void unlock() { sync.release(1); }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void main(String[] args) throws InterruptedException {\n    SimpleLock lock = new SimpleLock();\n    int[] count = {0};\n\n    Runnable task = () -\u0026gt; {\n        lock.lock();\n        try {\n            for (int i = 0; i \u0026lt; 10000; i++) count[0]++;\n        } finally {\n            lock.unlock();\n        }\n    };\n\n    Thread t1 = new Thread(task);\n    Thread t2 = new Thread(task);\n    t1.start(); t2.start();\n    t1.join();  t2.join();\n    System.out.println(count[0]);  // 始终输出 20000\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只需重写 \u003ccode\u003etryAcquire\u003c/code\u003e 和 \u003ccode\u003etryRelease\u003c/code\u003e，AQS 就接管了排队、阻塞、唤醒、中断处理等全部复杂逻辑。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eAQS 的设计精髓可以归纳为以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e一个 state 变量统一抽象\u003c/strong\u003e：不同的同步器通过赋予 state 不同的语义（重入次数、许可数、计数器等），复用同一套框架\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCLH 变体双向队列管理等待线程\u003c/strong\u003e：通过 FIFO 队列保证公平性，通过 CAS + 自旋保证入队的线程安全\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e模板方法模式降低接入成本\u003c/strong\u003e：自定义同步器只需实现 tryAcquire/tryRelease 等少量方法，框架处理全部排队和唤醒逻辑\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epark/unpark 精确控制线程状态\u003c/strong\u003e：避免自旋空转浪费 CPU，同时支持精确唤醒\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从后向前遍历保证正确性\u003c/strong\u003e：在非原子入队操作和 CANCELLED 节点处理中，始终保证能遍历到所有有效节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAQS 是 Doug Lea 在并发编程领域的杰作。理解了 AQS，就理解了 JUC 包中绝大部分同步工具的底层运作方式。它不仅是面试的高频考点，更是我们在实际工程中设计自定义同步器时可以直接借鉴的框架。\u003c/p\u003e\n\u003c/blockquote\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/tooling/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"开发工具\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-04-03\",\"children\":\"2024年04月03日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"Maven使用技巧\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"Maven\",{\"href\":\"/blog/tag/Maven/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Maven\"}],[\"$\",\"$L13\",\"Java\",{\"href\":\"/blog/tag/Java/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Java\"}],[\"$\",\"$L13\",\"构建工具\",{\"href\":\"/blog/tag/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"构建工具\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/middleware/RabbitMQ、RocketMQ、Kafka区别\",\"title\":\"RabbitMQ、RocketMQ、Kafka区别\",\"description\":\"MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ\",\"pubDate\":\"2024-03-31\",\"tags\":[\"消息队列\",\"中间件\",\"技术选型\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/tooling/Java构件发布到中央仓库\",\"title\":\"Java构件发布到中央仓库\",\"description\":\"Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。其中，最”简单”的方式是通过...\",\"pubDate\":\"2024-04-04\",\"tags\":[\"Maven\",\"Java\",\"开源发布\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"Maven\":{\"prev\":null,\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"Java\":{\"prev\":{\"slug\":\"engineering/middleware/深入理解AQS：Java并发的基石\",\"title\":\"深入理解AQS：Java并发的基石\",\"description\":\"系统性剖析 AbstractQueuedSynchronizer（AQS）的设计思想、核心数据结构、加锁解锁流程，并通过 ReentrantLock 源码深入理解其工作原理，最后梳理 AQS 在 JUC 中的典型应用场景。\",\"pubDate\":\"2024-03-25\",\"tags\":[\"Java\",\"并发编程\",\"AQS\",\"ReentrantLock\",\"JUC\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"},\"next\":\"$5:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"构建工具\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L1a\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Maven使用技巧 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"手把手教你如何在工作中巧妙使用Maven，提升开发效率。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Maven使用技巧\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"手把手教你如何在工作中巧妙使用Maven，提升开发效率。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-04-03\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Maven使用技巧\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"手把手教你如何在工作中巧妙使用Maven，提升开发效率。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/232416e7c3a1ca7e.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-142e67ac4336647c.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>Git 常用命令速查手册 - Skyfalling Blog</title><meta name="description" content="一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。"/><meta property="og:title" content="Git 常用命令速查手册"/><meta property="og:description" content="一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-04-05"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Git 常用命令速查手册"/><meta name="twitter:description" content="一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><nav class="flex items-center gap-1 text-sm mb-4"><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/page/1/">博客</a><span class="text-gray-300">/</span><a class="text-gray-500 hover:text-blue-600 transition-colors" href="/blog/category/engineering/page/1/">Engineering</a><span class="text-gray-300">/</span><a class="text-blue-600 hover:text-blue-700 transition-colors" href="/blog/category/engineering/tooling/page/1/">开发工具</a></nav><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-04-05">2024年04月05日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">Git 常用命令速查手册</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/Git/page/1/">Git</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/page/1/">版本控制</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/page/1/">开发工具</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h1>Git 常用命令速查手册</h1>
<blockquote>
<p>本文按使用场景组织，覆盖日常开发中最常用的 Git 操作。每条命令附带简要说明，部分附有使用示例。</p>
</blockquote>
<hr>
<h2>1. 配置</h2>
<pre><code class="language-bash"># 查看当前配置
git config --list

# 设置用户信息（全局）
git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;your@email.com&quot;

# 仅对当前仓库设置（去掉 --global）
git config user.name &quot;Your Name&quot;

# 设置默认编辑器
git config --global core.editor &quot;vim&quot;

# 设置默认分支名
git config --global init.defaultBranch main

# 配置命令别名
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.lg &quot;log --oneline --graph --all&quot;
</code></pre>
<hr>
<h2>2. 仓库初始化与克隆</h2>
<pre><code class="language-bash"># 初始化新仓库
git init

# 克隆远程仓库
git clone &lt;url&gt;

# 克隆指定分支
git clone -b &lt;branch&gt; &lt;url&gt;

# 浅克隆（只拉最近 1 次提交，适合大仓库）
git clone --depth 1 &lt;url&gt;

# 克隆并指定本地目录名
git clone &lt;url&gt; my-project
</code></pre>
<hr>
<h2>3. 文件追踪与暂存</h2>
<pre><code class="language-bash"># 查看工作区状态
git status

# 简洁模式
git status -s

# 添加文件到暂存区
git add &lt;file&gt;
git add .                    # 当前目录所有变更
git add -A                   # 整个仓库所有变更
git add -p                   # 交互式选择要暂存的代码块

# 取消暂存（保留工作区修改）
git restore --staged &lt;file&gt;
git reset HEAD &lt;file&gt;        # 旧写法，效果相同

# 丢弃工作区修改（危险操作，不可恢复）
git restore &lt;file&gt;
git checkout -- &lt;file&gt;       # 旧写法
</code></pre>
<h3>取消跟踪已版本控制的文件</h3>
<pre><code class="language-bash"># 不再追踪文件改动（文件保留在仓库中，但本地修改不再显示为 dirty）
git update-index --assume-unchanged &lt;filePath&gt;

# 恢复追踪
git update-index --no-assume-unchanged &lt;filePath&gt;

# 查看所有被 assume-unchanged 的文件
git ls-files -v | grep &#39;^h&#39;

# 从版本控制中删除文件（但保留本地文件）
git rm --cached &lt;filePath&gt;

# 从版本控制中删除文件夹
git rm -r -f --cached &lt;dirPath&gt;
</code></pre>
<blockquote>
<p><strong><code>--assume-unchanged</code> vs <code>--skip-worktree</code></strong>：两者都能让 Git 忽略本地修改，但语义不同。<code>--assume-unchanged</code> 是性能优化提示（告诉 Git &quot;这个文件不会变&quot;），<code>--skip-worktree</code> 是明确的意图声明（&quot;我故意修改了这个文件，但不想提交&quot;）。对于本地配置文件的修改，推荐使用 <code>--skip-worktree</code>。</p>
</blockquote>
<pre><code class="language-bash">git update-index --skip-worktree &lt;filePath&gt;
git update-index --no-skip-worktree &lt;filePath&gt;
git ls-files -v | grep &#39;^S&#39;    # 查看所有 skip-worktree 文件
</code></pre>
<hr>
<h2>4. 提交</h2>
<pre><code class="language-bash"># 提交暂存区内容
git commit -m &quot;commit message&quot;

# 添加并提交所有已跟踪文件的修改（不含新文件）
git commit -am &quot;commit message&quot;

# 修改最近一次提交的信息（未推送到远程时使用）
git commit --amend -m &quot;new message&quot;

# 修改最近一次提交，追加文件但不改消息
git commit --amend --no-edit

# 创建空提交（可用于触发 CI）
git commit --allow-empty -m &quot;trigger build&quot;
</code></pre>
<hr>
<h2>5. 分支管理</h2>
<pre><code class="language-bash"># 查看本地分支
git branch

# 查看所有分支（含远程）
git branch -a

# 查看分支及最后一次提交
git branch -v

# 创建分支
git branch &lt;name&gt;

# 创建并切换
git checkout -b &lt;name&gt;
git switch -c &lt;name&gt;         # 推荐新写法

# 切换分支
git checkout &lt;name&gt;
git switch &lt;name&gt;            # 推荐新写法

# 重命名当前分支
git branch -m &lt;new-name&gt;

# 删除本地分支（已合并）
git branch -d &lt;name&gt;

# 强制删除本地分支（未合并也删）
git branch -D &lt;name&gt;

# 删除远程分支
git push origin --delete &lt;name&gt;

# 查看已合并到当前分支的分支
git branch --merged

# 查看未合并到当前分支的分支
git branch --no-merged
</code></pre>
<hr>
<h2>6. 合并与变基</h2>
<pre><code class="language-bash"># 合并指定分支到当前分支
git merge &lt;branch&gt;

# 合并时不使用 fast-forward（保留合并提交记录）
git merge --no-ff &lt;branch&gt;

# 只生成一个合并提交（压缩对方所有提交）
git merge --squash &lt;branch&gt;

# 变基（将当前分支的提交移到目标分支的最新提交之后）
git rebase &lt;branch&gt;

# 交互式变基（修改/合并/删除/排序最近 N 次提交）
git rebase -i HEAD~N

# 变基冲突后继续 / 跳过 / 终止
git rebase --continue
git rebase --skip
git rebase --abort

# 合并冲突后终止合并
git merge --abort
</code></pre>
<h3>Cherry-pick</h3>
<pre><code class="language-bash"># 将某个提交应用到当前分支
git cherry-pick &lt;commit-hash&gt;

# 连续多个提交
git cherry-pick &lt;hash1&gt; &lt;hash2&gt;

# 只暂存不提交
git cherry-pick &lt;hash&gt; --no-commit
</code></pre>
<hr>
<h2>7. 远程协作</h2>
<pre><code class="language-bash"># 查看远程仓库
git remote -v

# 添加远程仓库
git remote add origin &lt;url&gt;

# 修改远程仓库地址
git remote set-url origin &lt;new-url&gt;

# 拉取远程更新（不合并）
git fetch
git fetch --all              # 拉取所有远程
git fetch --prune            # 同时清理已删除的远程分支引用

# 拉取并合并（= fetch + merge）
git pull

# 拉取并变基（= fetch + rebase，保持线性历史）
git pull --rebase

# 推送
git push
git push origin &lt;branch&gt;

# 首次推送并建立追踪关系
git push -u origin &lt;branch&gt;

# 强制推送（覆盖远程历史，团队协作慎用）
git push --force

# 安全的强制推送（远程有新提交时会拒绝）
git push --force-with-lease

# 推送所有分支
git push --all

# 推送所有标签
git push --tags
</code></pre>
<hr>
<h2>8. 暂存工作区（Stash）</h2>
<pre><code class="language-bash"># 暂存当前工作区和暂存区的修改
git stash

# 带描述信息
git stash save &quot;work in progress: feature X&quot;
git stash push -m &quot;description&quot;   # 推荐新写法

# 暂存时包含未跟踪的文件
git stash -u

# 暂存时包含所有文件（含 .gitignore 忽略的）
git stash -a

# 查看 stash 列表
git stash list

# 恢复最近的 stash（保留 stash 记录）
git stash apply

# 恢复并删除最近的 stash
git stash pop

# 恢复指定的 stash
git stash apply stash@{2}

# 删除指定 stash
git stash drop stash@{0}

# 清空所有 stash
git stash clear

# 查看某个 stash 的内容
git stash show -p stash@{0}
</code></pre>
<hr>
<h2>9. 日志与差异</h2>
<pre><code class="language-bash"># 查看提交日志
git log

# 简洁单行显示
git log --oneline

# 图形化显示分支合并历史
git log --oneline --graph --all

# 显示每次提交的文件变更统计
git log --stat

# 显示每次提交的具体修改
git log -p

# 最近 N 次提交
git log -n 5

# 按作者过滤
git log --author=&quot;name&quot;

# 按时间范围过滤
git log --since=&quot;2024-01-01&quot; --until=&quot;2024-06-30&quot;

# 按提交信息关键字搜索
git log --grep=&quot;fix bug&quot;

# 搜索某段代码的变更历史
git log -S &quot;functionName&quot;

# 查看某个文件的提交历史
git log -- &lt;file&gt;
git log --follow -- &lt;file&gt;   # 包含重命名前的历史
</code></pre>
<h3>差异对比</h3>
<pre><code class="language-bash"># 工作区 vs 暂存区
git diff

# 暂存区 vs 最新提交
git diff --staged
git diff --cached            # 同义

# 两个分支之间的差异
git diff &lt;branch1&gt;..&lt;branch2&gt;

# 两个提交之间的差异
git diff &lt;commit1&gt;..&lt;commit2&gt;

# 只看文件名列表
git diff --name-only

# 查看文件改动统计
git diff --stat
</code></pre>
<hr>
<h2>10. 撤销与回退</h2>
<pre><code class="language-bash"># 撤销工作区修改（未暂存）
git restore &lt;file&gt;

# 撤销暂存（保留工作区修改）
git restore --staged &lt;file&gt;

# 回退到某个提交（保留修改在工作区）
git reset --soft &lt;commit&gt;

# 回退到某个提交（保留修改在暂存区）
git reset --mixed &lt;commit&gt;     # 默认模式

# 回退到某个提交（丢弃所有修改，危险操作）
git reset --hard &lt;commit&gt;

# 回退最近 N 次提交
git reset --soft HEAD~N

# 创建一个新提交来撤销指定提交（安全的回退方式，不改写历史）
git revert &lt;commit&gt;

# 撤销多个连续提交
git revert &lt;older-commit&gt;..&lt;newer-commit&gt;

# 只修改工作区不自动提交
git revert --no-commit &lt;commit&gt;
</code></pre>
<blockquote>
<p><strong><code>reset</code> vs <code>revert</code></strong>：<code>reset</code> 改写提交历史（适合未推送的本地提交），<code>revert</code> 创建新提交来撤销（适合已推送的公共分支）。在多人协作的分支上，永远优先使用 <code>revert</code>。</p>
</blockquote>
<hr>
<h2>11. 标签</h2>
<pre><code class="language-bash"># 查看所有标签
git tag

# 按模式过滤
git tag -l &quot;v1.*&quot;

# 创建轻量标签
git tag &lt;tag-name&gt;

# 创建附注标签（推荐）
git tag -a &lt;tag-name&gt; -m &quot;description&quot;

# 给历史提交打标签
git tag -a &lt;tag-name&gt; &lt;commit-hash&gt;

# 查看标签详情
git show &lt;tag-name&gt;

# 推送单个标签到远程
git push origin &lt;tag-name&gt;

# 推送所有标签
git push origin --tags

# 删除本地标签
git tag -d &lt;tag-name&gt;

# 删除远程标签
git push origin --delete &lt;tag-name&gt;
</code></pre>
<hr>
<h2>12. 子模块</h2>
<pre><code class="language-bash"># 添加子模块
git submodule add &lt;url&gt; &lt;path&gt;

# 克隆含子模块的仓库
git clone --recurse-submodules &lt;url&gt;

# 已克隆后初始化子模块
git submodule init
git submodule update

# 一步到位
git submodule update --init --recursive

# 更新所有子模块到最新
git submodule update --remote

# 删除子模块
git submodule deinit &lt;path&gt;
git rm &lt;path&gt;
rm -rf .git/modules/&lt;path&gt;
</code></pre>
<hr>
<h2>13. Worktree（多工作目录）</h2>
<pre><code class="language-bash"># 为指定分支创建一个独立的工作目录（无需 stash 即可同时处理多个分支）
git worktree add &lt;path&gt; &lt;branch&gt;

# 创建新分支并建立 worktree
git worktree add -b &lt;new-branch&gt; &lt;path&gt;

# 查看所有 worktree
git worktree list

# 删除 worktree
git worktree remove &lt;path&gt;

# 清理无效的 worktree 引用
git worktree prune
</code></pre>
<hr>
<h2>14. 查找与定位</h2>
<pre><code class="language-bash"># 查找引入 bug 的提交（二分法）
git bisect start
git bisect bad                # 当前版本有 bug
git bisect good &lt;commit&gt;      # 某个已知正常的版本
# Git 自动切换到中间版本，测试后标记 good/bad，直到定位到具体提交
git bisect reset              # 结束 bisect

# 查看某行代码的最后修改人和提交
git blame &lt;file&gt;
git blame -L 10,20 &lt;file&gt;    # 只看第 10-20 行

# 在所有提交中搜索内容
git grep &quot;pattern&quot;
git grep &quot;pattern&quot; &lt;branch&gt;
</code></pre>
<hr>
<h2>15. 清理</h2>
<pre><code class="language-bash"># 预览将被清理的未跟踪文件
git clean -n

# 删除未跟踪的文件
git clean -f

# 删除未跟踪的文件和目录
git clean -fd

# 删除未跟踪的文件（含 .gitignore 忽略的文件）
git clean -fdx

# 垃圾回收（压缩历史，清理悬空对象）
git gc

# 清理远程已删除的分支引用
git remote prune origin
git fetch --prune             # 等价
</code></pre>
<hr>
<h2>16. 常见场景速查</h2>
<h3>撤销最近一次提交但保留代码</h3>
<pre><code class="language-bash">git reset --soft HEAD~1
</code></pre>
<h3>合并多次提交为一个</h3>
<pre><code class="language-bash">git rebase -i HEAD~3
# 编辑器中将后两个 pick 改为 squash (或 s)，保存退出
</code></pre>
<h3>从其他分支拿一个文件</h3>
<pre><code class="language-bash">git checkout &lt;branch&gt; -- &lt;file&gt;
git restore --source &lt;branch&gt; -- &lt;file&gt;   # 推荐新写法
</code></pre>
<h3>找回误删的分支或提交</h3>
<pre><code class="language-bash"># 查看所有引用变更记录（包括已删除的）
git reflog

# 基于 reflog 中的哈希恢复
git checkout -b recovered-branch &lt;hash&gt;
</code></pre>
<h3>修改历史提交的作者信息</h3>
<pre><code class="language-bash">git rebase -i &lt;commit&gt;^
# 将目标提交标记为 edit，保存退出
git commit --amend --author=&quot;Name &lt;email&gt;&quot; --no-edit
git rebase --continue
</code></pre>
<h3>统计代码贡献</h3>
<pre><code class="language-bash"># 按作者统计提交数
git shortlog -sn

# 统计某人的代码行数增删
git log --author=&quot;name&quot; --numstat --pretty=&quot;%H&quot; | awk &#39;NF==3 {add+=$1; del+=$2} END {print &quot;+&quot;add, &quot;-&quot;del}&#39;
</code></pre>
<h3>临时切到其他分支修 bug，不想 stash</h3>
<pre><code class="language-bash"># 用 worktree 在另一个目录打开 hotfix 分支，互不干扰
git worktree add ../hotfix-dir hotfix/issue-123

# 修完后删除
git worktree remove ../hotfix-dir
</code></pre>
<h3>只克隆仓库的某个子目录（Sparse Checkout）</h3>
<pre><code class="language-bash">git clone --filter=blob:none --sparse &lt;url&gt;
cd &lt;repo&gt;
git sparse-checkout set path/to/subdir
</code></pre>
<h3>把未提交的修改生成补丁发给别人</h3>
<pre><code class="language-bash"># 生成补丁文件
git diff &gt; my-changes.patch

# 对方应用补丁
git apply my-changes.patch
</code></pre>
<h3>把已提交的 commit 生成补丁</h3>
<pre><code class="language-bash"># 生成最近 3 次提交的补丁文件（每个提交一个 .patch 文件）
git format-patch -3

# 对方应用
git am *.patch
</code></pre>
<hr>
<h2>17. .gitignore</h2>
<pre><code class="language-bash"># .gitignore 文件常用模式

# 忽略所有 .log 文件
*.log

# 但保留 important.log
!important.log

# 忽略根目录下的 build 文件夹（不影响子目录中的 build）
/build/

# 忽略所有目录下的 node_modules
node_modules/

# 忽略所有 .env 文件（防止泄露密钥）
.env
.env.*

# 忽略 IDE 配置
.idea/
.vscode/
*.swp
*.swo
*~

# 忽略操作系统文件
.DS_Store
Thumbs.db
</code></pre>
<pre><code class="language-bash"># .gitignore 已经添加规则，但文件之前已被跟踪？需要先从缓存中移除
git rm --cached &lt;file&gt;
git commit -m &quot;stop tracking &lt;file&gt;&quot;

# 检查某个文件为什么被忽略
git check-ignore -v &lt;file&gt;

# 列出所有被忽略的文件
git status --ignored

# 全局 gitignore（对所有仓库生效）
git config --global core.excludesfile ~/.gitignore_global
</code></pre>
<hr>
<h2>18. Git Hooks</h2>
<p>Git Hooks 是在特定事件（提交、推送等）发生时自动执行的脚本，存放在 <code>.git/hooks/</code> 目录下。</p>
<h3>常用 Hook 类型</h3>
<table>
<thead>
<tr>
<th>Hook</th>
<th>触发时机</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>pre-commit</code></td>
<td><code>git commit</code> 执行前</td>
<td>代码格式检查、lint、单元测试</td>
</tr>
<tr>
<td><code>commit-msg</code></td>
<td>提交信息写入后</td>
<td>校验 commit message 格式</td>
</tr>
<tr>
<td><code>pre-push</code></td>
<td><code>git push</code> 执行前</td>
<td>运行测试、阻止推送到 main</td>
</tr>
<tr>
<td><code>post-merge</code></td>
<td><code>git merge</code> 完成后</td>
<td>自动安装依赖</td>
</tr>
<tr>
<td><code>pre-rebase</code></td>
<td><code>git rebase</code> 执行前</td>
<td>阻止对公共分支变基</td>
</tr>
<tr>
<td><code>post-checkout</code></td>
<td><code>git checkout</code> 完成后</td>
<td>环境初始化</td>
</tr>
</tbody></table>
<h3>示例：pre-commit 检查是否有 console.log</h3>
<pre><code class="language-bash">#!/bin/sh
# .git/hooks/pre-commit

if git diff --cached --name-only | grep -E &#39;\.(js|ts|tsx)$&#39; | xargs grep -l &#39;console\.log&#39; 2&gt;/dev/null; then
    echo &quot;Error: console.log found in staged files&quot;
    exit 1
fi
</code></pre>
<h3>使用 Husky 管理 Hooks（推荐）</h3>
<p><code>.git/hooks/</code> 不会被提交到仓库，团队共享不方便。<a href="https://typicode.github.io/husky/">Husky</a> 解决了这个问题：</p>
<pre><code class="language-bash"># 安装
npm install husky -D
npx husky init

# 添加 pre-commit hook
echo &quot;npm run lint&quot; &gt; .husky/pre-commit
</code></pre>
<hr>
<h2>19. Git LFS（大文件存储）</h2>
<p>Git 不擅长处理大文件（二进制、模型文件、设计稿等），Git LFS 用指针文件替代大文件，实际内容存储在单独的 LFS 服务器上。</p>
<pre><code class="language-bash"># 安装（macOS）
brew install git-lfs

# 在仓库中启用
git lfs install

# 追踪特定类型的大文件
git lfs track &quot;*.psd&quot;
git lfs track &quot;*.zip&quot;
git lfs track &quot;models/**&quot;

# 追踪规则保存在 .gitattributes 中，需要提交
git add .gitattributes
git commit -m &quot;track large files with LFS&quot;

# 后续正常 add/commit/push，LFS 文件会自动走 LFS 通道
git add large-file.psd
git commit -m &quot;add design file&quot;
git push

# 查看当前 LFS 追踪的文件模式
git lfs track

# 查看 LFS 管理的文件列表
git lfs ls-files

# 拉取所有 LFS 文件（克隆后可能需要）
git lfs pull
</code></pre>
<hr>
<h2>20. Git Archive（导出代码）</h2>
<pre><code class="language-bash"># 导出当前 HEAD 为 zip
git archive --format=zip HEAD -o project.zip

# 导出指定分支
git archive --format=tar.gz release/v1.0 -o release-v1.0.tar.gz

# 只导出某个子目录
git archive HEAD --prefix=src/ -- src/ -o src-only.zip

# 导出两个版本之间的差异文件
git diff --name-only v1.0 v2.0 | xargs git archive HEAD -o diff-files.zip --
</code></pre>
<hr>
<h2>21. 交互式变基详解</h2>
<p><code>git rebase -i</code> 是最强大的提交历史编辑工具，编辑器中每行一个提交，支持以下操作：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>pick</code></td>
<td><code>p</code></td>
<td>保留该提交（默认）</td>
</tr>
<tr>
<td><code>reword</code></td>
<td><code>r</code></td>
<td>保留提交但修改提交信息</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>e</code></td>
<td>暂停在该提交，允许修改内容</td>
</tr>
<tr>
<td><code>squash</code></td>
<td><code>s</code></td>
<td>合并到上一个提交，合并提交信息</td>
</tr>
<tr>
<td><code>fixup</code></td>
<td><code>f</code></td>
<td>合并到上一个提交，丢弃本条提交信息</td>
</tr>
<tr>
<td><code>drop</code></td>
<td><code>d</code></td>
<td>删除该提交</td>
</tr>
</tbody></table>
<h3>典型场景</h3>
<pre><code class="language-bash"># 合并最近 4 次提交为 1 个
git rebase -i HEAD~4
# 编辑器中：第一个保持 pick，其余改为 squash 或 fixup

# 调整提交顺序：直接在编辑器中拖动行的位置

# 拆分一个提交为多个
git rebase -i HEAD~3
# 将目标提交标记为 edit，保存退出
git reset HEAD~1              # 撤回提交但保留文件修改
git add file1 &amp;&amp; git commit -m &quot;part 1&quot;
git add file2 &amp;&amp; git commit -m &quot;part 2&quot;
git rebase --continue
</code></pre>
<hr>
<h2>22. 签名与验证</h2>
<pre><code class="language-bash"># 配置 GPG 签名
git config --global user.signingkey &lt;GPG-KEY-ID&gt;
git config --global commit.gpgsign true    # 默认对所有提交签名

# 签名提交
git commit -S -m &quot;signed commit&quot;

# 签名标签
git tag -s v1.0 -m &quot;signed release&quot;

# 验证提交签名
git log --show-signature

# 验证标签签名
git tag -v v1.0
</code></pre>
<hr>
<h2>23. 高级配置技巧</h2>
<pre><code class="language-bash"># 自动纠正拼写错误的命令（如 git stauts → git status）
git config --global help.autocorrect 10   # 1 秒后自动执行

# 启用 rerere（记住冲突解决方式，下次自动应用）
git config --global rerere.enabled true

# diff 时使用更好的算法（对函数移动更友好）
git config --global diff.algorithm histogram

# 全局忽略文件权限变更（在 macOS/Windows 上避免无意义的 diff）
git config --global core.fileMode false

# 设置 pull 默认使用 rebase（保持线性历史）
git config --global pull.rebase true

# 推送时自动设置上游分支
git config --global push.autoSetupRemote true

# 多行 commit message 使用 heredoc
git commit -m &quot;$(cat &lt;&lt;&#39;EOF&#39;
feat: add user authentication

- Add JWT token generation
- Add login/logout endpoints
- Add middleware for protected routes
EOF
)&quot;
</code></pre>
<hr>
<h2>24. 速查表</h2>
<table>
<thead>
<tr>
<th>想做什么</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看状态</td>
<td><code>git status</code></td>
</tr>
<tr>
<td>添加所有修改</td>
<td><code>git add -A</code></td>
</tr>
<tr>
<td>提交</td>
<td><code>git commit -m &quot;msg&quot;</code></td>
</tr>
<tr>
<td>拉取 + 变基</td>
<td><code>git pull --rebase</code></td>
</tr>
<tr>
<td>推送</td>
<td><code>git push</code></td>
</tr>
<tr>
<td>新建分支并切换</td>
<td><code>git switch -c feat/xxx</code></td>
</tr>
<tr>
<td>合并分支</td>
<td><code>git merge --no-ff feat/xxx</code></td>
</tr>
<tr>
<td>暂存工作区</td>
<td><code>git stash -u</code></td>
</tr>
<tr>
<td>恢复暂存</td>
<td><code>git stash pop</code></td>
</tr>
<tr>
<td>查看简洁日志</td>
<td><code>git log --oneline --graph</code></td>
</tr>
<tr>
<td>撤销最近提交</td>
<td><code>git reset --soft HEAD~1</code></td>
</tr>
<tr>
<td>安全回退已推送的提交</td>
<td><code>git revert &lt;hash&gt;</code></td>
</tr>
<tr>
<td>找回误删内容</td>
<td><code>git reflog</code></td>
</tr>
<tr>
<td>查看某行代码作者</td>
<td><code>git blame &lt;file&gt;</code></td>
</tr>
<tr>
<td>二分法查 bug</td>
<td><code>git bisect start</code></td>
</tr>
<tr>
<td>只拿某个提交</td>
<td><code>git cherry-pick &lt;hash&gt;</code></td>
</tr>
<tr>
<td>导出代码压缩包</td>
<td><code>git archive HEAD -o out.zip</code></td>
</tr>
</tbody></table>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 lg:px-8"><p class="text-center text-xs leading-5 text-gray-400">© <!-- -->2026<!-- --> Skyfalling</p></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-142e67ac4336647c.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n6:I[59665,[],\"OutletBoundary\"]\n9:I[74911,[],\"AsyncMetadataOutlet\"]\nb:I[59665,[],\"ViewportBoundary\"]\nd:I[59665,[],\"MetadataBoundary\"]\nf:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/232416e7c3a1ca7e.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"Ugi13mxW3xqx8EX5Ds9lw\",\"p\":\"\",\"c\":[\"\",\"blog\",\"engineering\",\"tooling\",\"Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"engineering/tooling/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/232416e7c3a1ca7e.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 lg:px-8\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":[\"© \",2026,\" Skyfalling\"]}]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"engineering/tooling/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",\"$L8\",[\"$\",\"$L9\",null,{\"promise\":\"$@a\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"M7hEtJbqZ5bF1pLY4gZfav\",{\"children\":[[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Ld\",null,{\"children\":\"$Le\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:\"$Sreact.suspense\"\n11:I[74911,[],\"AsyncMetadata\"]\n13:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n19:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\ne:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$10\",null,{\"fallback\":null,\"children\":[\"$\",\"$L11\",null,{\"promise\":\"$@12\"}]}]}]\n15:T59f6,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eGit 常用命令速查手册\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本文按使用场景组织，覆盖日常开发中最常用的 Git 操作。每条命令附带简要说明，部分附有使用示例。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e1. 配置\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看当前配置\ngit config --list\n\n# 设置用户信息（全局）\ngit config --global user.name \u0026quot;Your Name\u0026quot;\ngit config --global user.email \u0026quot;your@email.com\u0026quot;\n\n# 仅对当前仓库设置（去掉 --global）\ngit config user.name \u0026quot;Your Name\u0026quot;\n\n# 设置默认编辑器\ngit config --global core.editor \u0026quot;vim\u0026quot;\n\n# 设置默认分支名\ngit config --global init.defaultBranch main\n\n# 配置命令别名\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.st status\ngit config --global alias.lg \u0026quot;log --oneline --graph --all\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e2. 仓库初始化与克隆\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 初始化新仓库\ngit init\n\n# 克隆远程仓库\ngit clone \u0026lt;url\u0026gt;\n\n# 克隆指定分支\ngit clone -b \u0026lt;branch\u0026gt; \u0026lt;url\u0026gt;\n\n# 浅克隆（只拉最近 1 次提交，适合大仓库）\ngit clone --depth 1 \u0026lt;url\u0026gt;\n\n# 克隆并指定本地目录名\ngit clone \u0026lt;url\u0026gt; my-project\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e3. 文件追踪与暂存\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看工作区状态\ngit status\n\n# 简洁模式\ngit status -s\n\n# 添加文件到暂存区\ngit add \u0026lt;file\u0026gt;\ngit add .                    # 当前目录所有变更\ngit add -A                   # 整个仓库所有变更\ngit add -p                   # 交互式选择要暂存的代码块\n\n# 取消暂存（保留工作区修改）\ngit restore --staged \u0026lt;file\u0026gt;\ngit reset HEAD \u0026lt;file\u0026gt;        # 旧写法，效果相同\n\n# 丢弃工作区修改（危险操作，不可恢复）\ngit restore \u0026lt;file\u0026gt;\ngit checkout -- \u0026lt;file\u0026gt;       # 旧写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e取消跟踪已版本控制的文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 不再追踪文件改动（文件保留在仓库中，但本地修改不再显示为 dirty）\ngit update-index --assume-unchanged \u0026lt;filePath\u0026gt;\n\n# 恢复追踪\ngit update-index --no-assume-unchanged \u0026lt;filePath\u0026gt;\n\n# 查看所有被 assume-unchanged 的文件\ngit ls-files -v | grep \u0026#39;^h\u0026#39;\n\n# 从版本控制中删除文件（但保留本地文件）\ngit rm --cached \u0026lt;filePath\u0026gt;\n\n# 从版本控制中删除文件夹\ngit rm -r -f --cached \u0026lt;dirPath\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e--assume-unchanged\u003c/code\u003e vs \u003ccode\u003e--skip-worktree\u003c/code\u003e\u003c/strong\u003e：两者都能让 Git 忽略本地修改，但语义不同。\u003ccode\u003e--assume-unchanged\u003c/code\u003e 是性能优化提示（告诉 Git \u0026quot;这个文件不会变\u0026quot;），\u003ccode\u003e--skip-worktree\u003c/code\u003e 是明确的意图声明（\u0026quot;我故意修改了这个文件，但不想提交\u0026quot;）。对于本地配置文件的修改，推荐使用 \u003ccode\u003e--skip-worktree\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit update-index --skip-worktree \u0026lt;filePath\u0026gt;\ngit update-index --no-skip-worktree \u0026lt;filePath\u0026gt;\ngit ls-files -v | grep \u0026#39;^S\u0026#39;    # 查看所有 skip-worktree 文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e4. 提交\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 提交暂存区内容\ngit commit -m \u0026quot;commit message\u0026quot;\n\n# 添加并提交所有已跟踪文件的修改（不含新文件）\ngit commit -am \u0026quot;commit message\u0026quot;\n\n# 修改最近一次提交的信息（未推送到远程时使用）\ngit commit --amend -m \u0026quot;new message\u0026quot;\n\n# 修改最近一次提交，追加文件但不改消息\ngit commit --amend --no-edit\n\n# 创建空提交（可用于触发 CI）\ngit commit --allow-empty -m \u0026quot;trigger build\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e5. 分支管理\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看本地分支\ngit branch\n\n# 查看所有分支（含远程）\ngit branch -a\n\n# 查看分支及最后一次提交\ngit branch -v\n\n# 创建分支\ngit branch \u0026lt;name\u0026gt;\n\n# 创建并切换\ngit checkout -b \u0026lt;name\u0026gt;\ngit switch -c \u0026lt;name\u0026gt;         # 推荐新写法\n\n# 切换分支\ngit checkout \u0026lt;name\u0026gt;\ngit switch \u0026lt;name\u0026gt;            # 推荐新写法\n\n# 重命名当前分支\ngit branch -m \u0026lt;new-name\u0026gt;\n\n# 删除本地分支（已合并）\ngit branch -d \u0026lt;name\u0026gt;\n\n# 强制删除本地分支（未合并也删）\ngit branch -D \u0026lt;name\u0026gt;\n\n# 删除远程分支\ngit push origin --delete \u0026lt;name\u0026gt;\n\n# 查看已合并到当前分支的分支\ngit branch --merged\n\n# 查看未合并到当前分支的分支\ngit branch --no-merged\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e6. 合并与变基\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 合并指定分支到当前分支\ngit merge \u0026lt;branch\u0026gt;\n\n# 合并时不使用 fast-forward（保留合并提交记录）\ngit merge --no-ff \u0026lt;branch\u0026gt;\n\n# 只生成一个合并提交（压缩对方所有提交）\ngit merge --squash \u0026lt;branch\u0026gt;\n\n# 变基（将当前分支的提交移到目标分支的最新提交之后）\ngit rebase \u0026lt;branch\u0026gt;\n\n# 交互式变基（修改/合并/删除/排序最近 N 次提交）\ngit rebase -i HEAD~N\n\n# 变基冲突后继续 / 跳过 / 终止\ngit rebase --continue\ngit rebase --skip\ngit rebase --abort\n\n# 合并冲突后终止合并\ngit merge --abort\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCherry-pick\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 将某个提交应用到当前分支\ngit cherry-pick \u0026lt;commit-hash\u0026gt;\n\n# 连续多个提交\ngit cherry-pick \u0026lt;hash1\u0026gt; \u0026lt;hash2\u0026gt;\n\n# 只暂存不提交\ngit cherry-pick \u0026lt;hash\u0026gt; --no-commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e7. 远程协作\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看远程仓库\ngit remote -v\n\n# 添加远程仓库\ngit remote add origin \u0026lt;url\u0026gt;\n\n# 修改远程仓库地址\ngit remote set-url origin \u0026lt;new-url\u0026gt;\n\n# 拉取远程更新（不合并）\ngit fetch\ngit fetch --all              # 拉取所有远程\ngit fetch --prune            # 同时清理已删除的远程分支引用\n\n# 拉取并合并（= fetch + merge）\ngit pull\n\n# 拉取并变基（= fetch + rebase，保持线性历史）\ngit pull --rebase\n\n# 推送\ngit push\ngit push origin \u0026lt;branch\u0026gt;\n\n# 首次推送并建立追踪关系\ngit push -u origin \u0026lt;branch\u0026gt;\n\n# 强制推送（覆盖远程历史，团队协作慎用）\ngit push --force\n\n# 安全的强制推送（远程有新提交时会拒绝）\ngit push --force-with-lease\n\n# 推送所有分支\ngit push --all\n\n# 推送所有标签\ngit push --tags\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e8. 暂存工作区（Stash）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 暂存当前工作区和暂存区的修改\ngit stash\n\n# 带描述信息\ngit stash save \u0026quot;work in progress: feature X\u0026quot;\ngit stash push -m \u0026quot;description\u0026quot;   # 推荐新写法\n\n# 暂存时包含未跟踪的文件\ngit stash -u\n\n# 暂存时包含所有文件（含 .gitignore 忽略的）\ngit stash -a\n\n# 查看 stash 列表\ngit stash list\n\n# 恢复最近的 stash（保留 stash 记录）\ngit stash apply\n\n# 恢复并删除最近的 stash\ngit stash pop\n\n# 恢复指定的 stash\ngit stash apply stash@{2}\n\n# 删除指定 stash\ngit stash drop stash@{0}\n\n# 清空所有 stash\ngit stash clear\n\n# 查看某个 stash 的内容\ngit stash show -p stash@{0}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e9. 日志与差异\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看提交日志\ngit log\n\n# 简洁单行显示\ngit log --oneline\n\n# 图形化显示分支合并历史\ngit log --oneline --graph --all\n\n# 显示每次提交的文件变更统计\ngit log --stat\n\n# 显示每次提交的具体修改\ngit log -p\n\n# 最近 N 次提交\ngit log -n 5\n\n# 按作者过滤\ngit log --author=\u0026quot;name\u0026quot;\n\n# 按时间范围过滤\ngit log --since=\u0026quot;2024-01-01\u0026quot; --until=\u0026quot;2024-06-30\u0026quot;\n\n# 按提交信息关键字搜索\ngit log --grep=\u0026quot;fix bug\u0026quot;\n\n# 搜索某段代码的变更历史\ngit log -S \u0026quot;functionName\u0026quot;\n\n# 查看某个文件的提交历史\ngit log -- \u0026lt;file\u0026gt;\ngit log --follow -- \u0026lt;file\u0026gt;   # 包含重命名前的历史\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e差异对比\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 工作区 vs 暂存区\ngit diff\n\n# 暂存区 vs 最新提交\ngit diff --staged\ngit diff --cached            # 同义\n\n# 两个分支之间的差异\ngit diff \u0026lt;branch1\u0026gt;..\u0026lt;branch2\u0026gt;\n\n# 两个提交之间的差异\ngit diff \u0026lt;commit1\u0026gt;..\u0026lt;commit2\u0026gt;\n\n# 只看文件名列表\ngit diff --name-only\n\n# 查看文件改动统计\ngit diff --stat\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e10. 撤销与回退\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 撤销工作区修改（未暂存）\ngit restore \u0026lt;file\u0026gt;\n\n# 撤销暂存（保留工作区修改）\ngit restore --staged \u0026lt;file\u0026gt;\n\n# 回退到某个提交（保留修改在工作区）\ngit reset --soft \u0026lt;commit\u0026gt;\n\n# 回退到某个提交（保留修改在暂存区）\ngit reset --mixed \u0026lt;commit\u0026gt;     # 默认模式\n\n# 回退到某个提交（丢弃所有修改，危险操作）\ngit reset --hard \u0026lt;commit\u0026gt;\n\n# 回退最近 N 次提交\ngit reset --soft HEAD~N\n\n# 创建一个新提交来撤销指定提交（安全的回退方式，不改写历史）\ngit revert \u0026lt;commit\u0026gt;\n\n# 撤销多个连续提交\ngit revert \u0026lt;older-commit\u0026gt;..\u0026lt;newer-commit\u0026gt;\n\n# 只修改工作区不自动提交\ngit revert --no-commit \u0026lt;commit\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003ereset\u003c/code\u003e vs \u003ccode\u003erevert\u003c/code\u003e\u003c/strong\u003e：\u003ccode\u003ereset\u003c/code\u003e 改写提交历史（适合未推送的本地提交），\u003ccode\u003erevert\u003c/code\u003e 创建新提交来撤销（适合已推送的公共分支）。在多人协作的分支上，永远优先使用 \u003ccode\u003erevert\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2\u003e11. 标签\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看所有标签\ngit tag\n\n# 按模式过滤\ngit tag -l \u0026quot;v1.*\u0026quot;\n\n# 创建轻量标签\ngit tag \u0026lt;tag-name\u0026gt;\n\n# 创建附注标签（推荐）\ngit tag -a \u0026lt;tag-name\u0026gt; -m \u0026quot;description\u0026quot;\n\n# 给历史提交打标签\ngit tag -a \u0026lt;tag-name\u0026gt; \u0026lt;commit-hash\u0026gt;\n\n# 查看标签详情\ngit show \u0026lt;tag-name\u0026gt;\n\n# 推送单个标签到远程\ngit push origin \u0026lt;tag-name\u0026gt;\n\n# 推送所有标签\ngit push origin --tags\n\n# 删除本地标签\ngit tag -d \u0026lt;tag-name\u0026gt;\n\n# 删除远程标签\ngit push origin --delete \u0026lt;tag-name\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e12. 子模块\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 添加子模块\ngit submodule add \u0026lt;url\u0026gt; \u0026lt;path\u0026gt;\n\n# 克隆含子模块的仓库\ngit clone --recurse-submodules \u0026lt;url\u0026gt;\n\n# 已克隆后初始化子模块\ngit submodule init\ngit submodule update\n\n# 一步到位\ngit submodule update --init --recursive\n\n# 更新所有子模块到最新\ngit submodule update --remote\n\n# 删除子模块\ngit submodule deinit \u0026lt;path\u0026gt;\ngit rm \u0026lt;path\u0026gt;\nrm -rf .git/modules/\u0026lt;path\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e13. Worktree（多工作目录）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 为指定分支创建一个独立的工作目录（无需 stash 即可同时处理多个分支）\ngit worktree add \u0026lt;path\u0026gt; \u0026lt;branch\u0026gt;\n\n# 创建新分支并建立 worktree\ngit worktree add -b \u0026lt;new-branch\u0026gt; \u0026lt;path\u0026gt;\n\n# 查看所有 worktree\ngit worktree list\n\n# 删除 worktree\ngit worktree remove \u0026lt;path\u0026gt;\n\n# 清理无效的 worktree 引用\ngit worktree prune\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e14. 查找与定位\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查找引入 bug 的提交（二分法）\ngit bisect start\ngit bisect bad                # 当前版本有 bug\ngit bisect good \u0026lt;commit\u0026gt;      # 某个已知正常的版本\n# Git 自动切换到中间版本，测试后标记 good/bad，直到定位到具体提交\ngit bisect reset              # 结束 bisect\n\n# 查看某行代码的最后修改人和提交\ngit blame \u0026lt;file\u0026gt;\ngit blame -L 10,20 \u0026lt;file\u0026gt;    # 只看第 10-20 行\n\n# 在所有提交中搜索内容\ngit grep \u0026quot;pattern\u0026quot;\ngit grep \u0026quot;pattern\u0026quot; \u0026lt;branch\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e15. 清理\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 预览将被清理的未跟踪文件\ngit clean -n\n\n# 删除未跟踪的文件\ngit clean -f\n\n# 删除未跟踪的文件和目录\ngit clean -fd\n\n# 删除未跟踪的文件（含 .gitignore 忽略的文件）\ngit clean -fdx\n\n# 垃圾回收（压缩历史，清理悬空对象）\ngit gc\n\n# 清理远程已删除的分支引用\ngit remote prune origin\ngit fetch --prune             # 等价\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e16. 常见场景速查\u003c/h2\u003e\n\u003ch3\u003e撤销最近一次提交但保留代码\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit reset --soft HEAD~1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e合并多次提交为一个\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit rebase -i HEAD~3\n# 编辑器中将后两个 pick 改为 squash (或 s)，保存退出\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e从其他分支拿一个文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit checkout \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt;\ngit restore --source \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt;   # 推荐新写法\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e找回误删的分支或提交\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看所有引用变更记录（包括已删除的）\ngit reflog\n\n# 基于 reflog 中的哈希恢复\ngit checkout -b recovered-branch \u0026lt;hash\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e修改历史提交的作者信息\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit rebase -i \u0026lt;commit\u0026gt;^\n# 将目标提交标记为 edit，保存退出\ngit commit --amend --author=\u0026quot;Name \u0026lt;email\u0026gt;\u0026quot; --no-edit\ngit rebase --continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e统计代码贡献\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 按作者统计提交数\ngit shortlog -sn\n\n# 统计某人的代码行数增删\ngit log --author=\u0026quot;name\u0026quot; --numstat --pretty=\u0026quot;%H\u0026quot; | awk \u0026#39;NF==3 {add+=$1; del+=$2} END {print \u0026quot;+\u0026quot;add, \u0026quot;-\u0026quot;del}\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e临时切到其他分支修 bug，不想 stash\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 用 worktree 在另一个目录打开 hotfix 分支，互不干扰\ngit worktree add ../hotfix-dir hotfix/issue-123\n\n# 修完后删除\ngit worktree remove ../hotfix-dir\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e只克隆仓库的某个子目录（Sparse Checkout）\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egit clone --filter=blob:none --sparse \u0026lt;url\u0026gt;\ncd \u0026lt;repo\u0026gt;\ngit sparse-checkout set path/to/subdir\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e把未提交的修改生成补丁发给别人\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 生成补丁文件\ngit diff \u0026gt; my-changes.patch\n\n# 对方应用补丁\ngit apply my-changes.patch\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e把已提交的 commit 生成补丁\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 生成最近 3 次提交的补丁文件（每个提交一个 .patch 文件）\ngit format-patch -3\n\n# 对方应用\ngit am *.patch\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e17. .gitignore\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# .gitignore 文件常用模式\n\n# 忽略所有 .log 文件\n*.log\n\n# 但保留 important.log\n!important.log\n\n# 忽略根目录下的 build 文件夹（不影响子目录中的 build）\n/build/\n\n# 忽略所有目录下的 node_modules\nnode_modules/\n\n# 忽略所有 .env 文件（防止泄露密钥）\n.env\n.env.*\n\n# 忽略 IDE 配置\n.idea/\n.vscode/\n*.swp\n*.swo\n*~\n\n# 忽略操作系统文件\n.DS_Store\nThumbs.db\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# .gitignore 已经添加规则，但文件之前已被跟踪？需要先从缓存中移除\ngit rm --cached \u0026lt;file\u0026gt;\ngit commit -m \u0026quot;stop tracking \u0026lt;file\u0026gt;\u0026quot;\n\n# 检查某个文件为什么被忽略\ngit check-ignore -v \u0026lt;file\u0026gt;\n\n# 列出所有被忽略的文件\ngit status --ignored\n\n# 全局 gitignore（对所有仓库生效）\ngit config --global core.excludesfile ~/.gitignore_global\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e18. Git Hooks\u003c/h2\u003e\n\u003cp\u003eGit Hooks 是在特定事件（提交、推送等）发生时自动执行的脚本，存放在 \u003ccode\u003e.git/hooks/\u003c/code\u003e 目录下。\u003c/p\u003e\n\u003ch3\u003e常用 Hook 类型\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eHook\u003c/th\u003e\n\u003cth\u003e触发时机\u003c/th\u003e\n\u003cth\u003e典型用途\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-commit\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit commit\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e代码格式检查、lint、单元测试\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ecommit-msg\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e提交信息写入后\u003c/td\u003e\n\u003ctd\u003e校验 commit message 格式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-push\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit push\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e运行测试、阻止推送到 main\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epost-merge\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit merge\u003c/code\u003e 完成后\u003c/td\u003e\n\u003ctd\u003e自动安装依赖\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epre-rebase\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit rebase\u003c/code\u003e 执行前\u003c/td\u003e\n\u003ctd\u003e阻止对公共分支变基\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epost-checkout\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit checkout\u003c/code\u003e 完成后\u003c/td\u003e\n\u003ctd\u003e环境初始化\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e示例：pre-commit 检查是否有 console.log\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/sh\n# .git/hooks/pre-commit\n\nif git diff --cached --name-only | grep -E \u0026#39;\\.(js|ts|tsx)$\u0026#39; | xargs grep -l \u0026#39;console\\.log\u0026#39; 2\u0026gt;/dev/null; then\n    echo \u0026quot;Error: console.log found in staged files\u0026quot;\n    exit 1\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e使用 Husky 管理 Hooks（推荐）\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e.git/hooks/\u003c/code\u003e 不会被提交到仓库，团队共享不方便。\u003ca href=\"https://typicode.github.io/husky/\"\u003eHusky\u003c/a\u003e 解决了这个问题：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装\nnpm install husky -D\nnpx husky init\n\n# 添加 pre-commit hook\necho \u0026quot;npm run lint\u0026quot; \u0026gt; .husky/pre-commit\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e19. Git LFS（大文件存储）\u003c/h2\u003e\n\u003cp\u003eGit 不擅长处理大文件（二进制、模型文件、设计稿等），Git LFS 用指针文件替代大文件，实际内容存储在单独的 LFS 服务器上。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装（macOS）\nbrew install git-lfs\n\n# 在仓库中启用\ngit lfs install\n\n# 追踪特定类型的大文件\ngit lfs track \u0026quot;*.psd\u0026quot;\ngit lfs track \u0026quot;*.zip\u0026quot;\ngit lfs track \u0026quot;models/**\u0026quot;\n\n# 追踪规则保存在 .gitattributes 中，需要提交\ngit add .gitattributes\ngit commit -m \u0026quot;track large files with LFS\u0026quot;\n\n# 后续正常 add/commit/push，LFS 文件会自动走 LFS 通道\ngit add large-file.psd\ngit commit -m \u0026quot;add design file\u0026quot;\ngit push\n\n# 查看当前 LFS 追踪的文件模式\ngit lfs track\n\n# 查看 LFS 管理的文件列表\ngit lfs ls-files\n\n# 拉取所有 LFS 文件（克隆后可能需要）\ngit lfs pull\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e20. Git Archive（导出代码）\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 导出当前 HEAD 为 zip\ngit archive --format=zip HEAD -o project.zip\n\n# 导出指定分支\ngit archive --format=tar.gz release/v1.0 -o release-v1.0.tar.gz\n\n# 只导出某个子目录\ngit archive HEAD --prefix=src/ -- src/ -o src-only.zip\n\n# 导出两个版本之间的差异文件\ngit diff --name-only v1.0 v2.0 | xargs git archive HEAD -o diff-files.zip --\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e21. 交互式变基详解\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003egit rebase -i\u003c/code\u003e 是最强大的提交历史编辑工具，编辑器中每行一个提交，支持以下操作：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003cth\u003e缩写\u003c/th\u003e\n\u003cth\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003epick\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ep\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留该提交（默认）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ereword\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003er\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e保留提交但修改提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eedit\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ee\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e暂停在该提交，允许修改内容\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003esquash\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003es\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并到上一个提交，合并提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003efixup\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ef\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e合并到上一个提交，丢弃本条提交信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003edrop\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ed\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e删除该提交\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003e典型场景\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 合并最近 4 次提交为 1 个\ngit rebase -i HEAD~4\n# 编辑器中：第一个保持 pick，其余改为 squash 或 fixup\n\n# 调整提交顺序：直接在编辑器中拖动行的位置\n\n# 拆分一个提交为多个\ngit rebase -i HEAD~3\n# 将目标提交标记为 edit，保存退出\ngit reset HEAD~1              # 撤回提交但保留文件修改\ngit add file1 \u0026amp;\u0026amp; git commit -m \u0026quot;part 1\u0026quot;\ngit add file2 \u0026amp;\u0026amp; git commit -m \u0026quot;part 2\u0026quot;\ngit rebase --continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e22. 签名与验证\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 配置 GPG 签名\ngit config --global user.signingkey \u0026lt;GPG-KEY-ID\u0026gt;\ngit config --global commit.gpgsign true    # 默认对所有提交签名\n\n# 签名提交\ngit commit -S -m \u0026quot;signed commit\u0026quot;\n\n# 签名标签\ngit tag -s v1.0 -m \u0026quot;signed release\u0026quot;\n\n# 验证提交签名\ngit log --show-signature\n\n# 验证标签签名\ngit tag -v v1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e23. 高级配置技巧\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 自动纠正拼写错误的命令（如 git stauts → git status）\ngit config --global help.autocorrect 10   # 1 秒后自动执行\n\n# 启用 rerere（记住冲突解决方式，下次自动应用）\ngit config --global rerere.enabled true\n\n# diff 时使用更好的算法（对函数移动更友好）\ngit config --global diff.algorithm histogram\n\n# 全局忽略文件权限变更（在 macOS/Windows 上避免无意义的 diff）\ngit config --global core.fileMode false\n\n# 设置 pull 默认使用 rebase（保持线性历史）\ngit config --global pull.rebase true\n\n# 推送时自动设置上游分支\ngit config --global push.autoSetupRemote true\n\n# 多行 commit message 使用 heredoc\ngit commit -m \u0026quot;$(cat \u0026lt;\u0026lt;\u0026#39;EOF\u0026#39;\nfeat: add user authentication\n\n- Add JWT token generation\n- Add login/logout endpoints\n- Add middleware for protected routes\nEOF\n)\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003ch2\u003e24. 速查表\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e想做什么\u003c/th\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e查看状态\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit status\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e添加所有修改\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit add -A\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit commit -m \u0026quot;msg\u0026quot;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e拉取 + 变基\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit pull --rebase\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e推送\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit push\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e新建分支并切换\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit switch -c feat/xxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e合并分支\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit merge --no-ff feat/xxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e暂存工作区\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit stash -u\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e恢复暂存\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit stash pop\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e查看简洁日志\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit log --oneline --graph\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e撤销最近提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit reset --soft HEAD~1\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全回退已推送的提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit revert \u0026lt;hash\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e找回误删内容\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit reflog\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e查看某行代码作者\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit blame \u0026lt;file\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e二分法查 bug\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit bisect start\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e只拿某个提交\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit cherry-pick \u0026lt;hash\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e导出代码压缩包\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003egit archive HEAD -o out.zip\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n"])</script><script>self.__next_f.push([1,"17:T3dc2,"])</script><script>self.__next_f.push([1,"\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e首先强调一下，Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。其中，最”简单”的方式是通过\u003c/em\u003e\u003ca href=\"https://central.sonatype.org/pages/ossrh-guide.html\"\u003eSonatype OSSRH\u003c/a\u003e\u003cem\u003e仓库来发布jar包。所以，接下来主要介绍如何将jar包发布到Sonatype OSSRH。\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先，先说一下大体的步骤：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e注册Sonatype账号\u003c/li\u003e\n\u003cli\u003e创建Issue，验证域名\u003c/li\u003e\n\u003cli\u003e安装GPG，发布密钥\u003c/li\u003e\n\u003cli\u003e配置Maven，发布构件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里面比较重要和容易出错的是第二步和第三步，下面一一详细介绍。\u003c/p\u003e\n\u003ch4\u003e1、注册Sonatype账号 \u003ca href=\"#bojci\" id=\"bojci\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e第一步很简单，登录官网，注册账号就好了\u003ca href=\"https://issues.sonatype.org/secure/Signup!default.jspa\"\u003eSign up for Jira - Sonatype JIRA\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e注册完成，登陆后的界面如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_60.png\" alt=\"image_60.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2、创建Issue \u003ca href=\"#omwqz\" id=\"omwqz\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这里项目选择：Community Support - Open Source Project Repository Hosting (OSSRH)，问题 类型选择：New Project\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_67.png\" alt=\"image_67.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.1、补充项目信息\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_62.png\" alt=\"image_62.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.2、验证域名 \u003ca href=\"#snbg0\" id=\"snbg0\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e我们需要使用域名作为Group Id，如果你拥有域\u0026#x540D;\u003cem\u003e\u0026#x65;xample.com，则能够使用com.example开头作为Group Id，例如：com.example.myproject。其他一些栗子如下：\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eexample.com -\u0026gt; com.example.domain\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.springframework.org/\"\u003ewww.springframework.org\u003c/a\u003e -\u0026gt; org.springframework\u003c/li\u003e\n\u003cli\u003esubdomain.example.com -\u0026gt; example.com\u003c/li\u003e\n\u003cli\u003egithub.com/yourusername -\u0026gt; io.github.yourusername\u003c/li\u003e\n\u003cli\u003emy-domain.com -\u0026gt; com.my-domain\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e要想使用某个域名作为Group Id，你需要证明拥有该域名，至于如何证明，详见官方文档：\u003ca href=\"https://central.sonatype.org/faq/how-to-set-txt-record\"\u003ehttps://central.sonatype.org/faq/how-to-set-txt-record/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e如果你没有自己的域名，则可以通过代码托管平台的账号关联子域名。假设你托管平台账户名为myusername，那么你可以通过以下托管平台验证Group Id ：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_63.png\" alt=\"image_63.png\"\u003e\u003c/p\u003e\n\u003cp\u003e由于我没有自己的域名，这里我选择使用github账号验证Group Id。点击“新建”按钮，完成提交，之后你的注册邮箱会收到一封邮件，显示创建项目信息：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_65.png\" alt=\"image_65.png\"\u003e\u003c/p\u003e\n\u003cp\u003e稍后还会收到一封审核邮件，提示你进行域名验证，时间延迟大概在十分钟以内。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2.3、人工审核及确认\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_66.png\" alt=\"image_66.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我使用的是github账户，按邮件提示，需要在github平台上创建一个指定的临时工程。创建完成之后，可以在issue下面添加评论，触发验证。验证成功后，你会收到一份邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_68.png\" alt=\"image_68.png\"\u003e\u003c/p\u003e\n\u003cp\u003e收到上述邮件，就表示完成了Group Id的验证，此时你就可以使用该Group Id或者子Group Id发布Maven构件了。如上，我填写的Group Id是 “io.github.nianien”，因此，我可以使用 “io.github.nianien”或者 “io.github.nianien.xxx” 作为项目的GroupId发布Maven构件。\u003c/p\u003e\n\u003cp\u003e在通过Maven发布构件之前，我们需要进行Maven配置，这里还需要一些前置工作。\u003c/p\u003e\n\u003ch4\u003e3、安装GPG，创建密钥 \u003ca href=\"#dcxco\" id=\"dcxco\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e安装GPG的方式有多种，这里推荐图形化安装，因为通过命令行安装，由于找不到合适的密钥服务器，发布密钥时会失败。这里给出Mac版本的下载地址：\u003ca href=\"https://releases.gpgtools.org/GPG_Suite-2022.1.dmg\"\u003ehttps://releases.gpgtools.org/GPG_Suite-2022.1.dmg\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e创建密钥\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_69.png\" alt=\"image_69.png\"\u003e\u003c/p\u003e\n\u003cp\u003e3.1、发布密钥\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_70.png\" alt=\"image_70.png\"\u003e\u003c/p\u003e\n\u003cp\u003e发布成功后，收到一份邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_71.png\" alt=\"image_71.png\"\u003e\u003c/p\u003e\n\u003cp\u003e按照邮件指示操作，完成密钥发布。密钥发布成功之后，下一步就是配置maven settings.xml和工程pom.xml文件。\u003c/p\u003e\n\u003ch4\u003e4、配置Maven，发布构件 \u003ca href=\"#amad1\" id=\"amad1\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e第一步，配置setting.xml文件，添加server节点：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;servers\u0026gt;\n\u0026lt;server\u0026gt;\n    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n    \u0026lt;username\u0026gt;sonatype账户名\u0026lt;/username\u0026gt;\n    \u0026lt;password\u0026gt;sonatype账户密码\u0026lt;/password\u0026gt;\n\u0026lt;/server\u0026gt;\n\u0026lt;/servers\u0026gt;\n\u0026lt;profile\u0026gt;\n  \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n  \u0026lt;properties\u0026gt;\n    \u0026lt;gpg.executable\u0026gt;gpg\u0026lt;/gpg.executable\u0026gt;\n    \u0026lt;gpg.passphrase\u0026gt;创建密钥时使用的密码\u0026lt;/gpg.passphrase\u0026gt;\n    \u0026lt;gpg.homedir\u0026gt;/Users/yourname/.gnupg\u0026lt;/gpg.homedir\u0026gt;\n   \u0026lt;/properties\u0026gt;\n\u0026lt;/profile\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e第二步，配置pom.xml文件，添加必填项\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\n\u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot;\n         xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt;\n    \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt;\u0026lt;!--已经验证的Group Id--\u0026gt;\n    \u0026lt;groupId\u0026gt;io.github.nianien\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;cudrania\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;1.0.1\u0026lt;/version\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;name\u0026gt;io.github.nianien:cudrania\u0026lt;/name\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;description\u0026gt;support tools for java development\u0026lt;/description\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;url\u0026gt;https://github.com/nianien/cudrania\u0026lt;/url\u0026gt;\n    \u0026lt;properties\u0026gt;\n        \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt;\n        \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt;\n    \u0026lt;/properties\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;licenses\u0026gt;\n        \u0026lt;license\u0026gt;\n            \u0026lt;name\u0026gt;The Apache Software License, Version 2.0\u0026lt;/name\u0026gt;\n            \u0026lt;url\u0026gt;https://www.apache.org/licenses/LICENSE-2.0.txt\u0026lt;/url\u0026gt;\n        \u0026lt;/license\u0026gt;\n    \u0026lt;/licenses\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;developers\u0026gt;\n        \u0026lt;developer\u0026gt;\n            \u0026lt;id\u0026gt;nianien\u0026lt;/id\u0026gt;\n            \u0026lt;name\u0026gt;nianien\u0026lt;/name\u0026gt;\n            \u0026lt;email\u0026gt;nianien@126.com\u0026lt;/email\u0026gt;\n        \u0026lt;/developer\u0026gt;\n    \u0026lt;/developers\u0026gt;\u0026lt;!--必填--\u0026gt;\n    \u0026lt;scm\u0026gt;\n        \u0026lt;connection\u0026gt;https://github.com/nianien/cudrania.git\u0026lt;/connection\u0026gt;\n        \u0026lt;developerConnection\u0026gt;scm:git:ssh://git@github.com:nianien/cudrania.git\n        \u0026lt;/developerConnection\u0026gt;\n        \u0026lt;url\u0026gt;https://github.com/nianien/cudrania\u0026lt;/url\u0026gt;\n    \u0026lt;/scm\u0026gt;\n    \u0026lt;build\u0026gt;\n        \u0026lt;pluginManagement\u0026gt;\n            \u0026lt;plugins\u0026gt;\n                \u0026lt;plugin\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.11.0\u0026lt;/version\u0026gt;\n                    \u0026lt;configuration\u0026gt;\n                        \u0026lt;source\u0026gt;${java.version}\u0026lt;/source\u0026gt;\n                        \u0026lt;target\u0026gt;${java.version}\u0026lt;/target\u0026gt;\n                    \u0026lt;/configuration\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n                \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;attach-sources\u0026lt;/id\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;jar-no-fork\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n                \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt; \n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.5.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;attach-javadocs\u0026lt;/id\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;jar\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                            \u0026lt;configuration\u0026gt;\n                                \u0026lt;additionalparam\u0026gt;\n                                    -Xdoclint:none\n                                \u0026lt;/additionalparam\u0026gt;\n                            \u0026lt;/configuration\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                \u0026lt;plugin\u0026gt;\n                    \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                    \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt;\n                    \u0026lt;executions\u0026gt;\n                        \u0026lt;execution\u0026gt;\n                            \u0026lt;id\u0026gt;sign-artifacts\u0026lt;/id\u0026gt;\n                            \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt;\n                            \u0026lt;goals\u0026gt;\n                                \u0026lt;goal\u0026gt;sign\u0026lt;/goal\u0026gt;\n                            \u0026lt;/goals\u0026gt;\n                        \u0026lt;/execution\u0026gt;\n                    \u0026lt;/executions\u0026gt;\n                \u0026lt;/plugin\u0026gt;\n            \u0026lt;/plugins\u0026gt;\n        \u0026lt;/pluginManagement\u0026gt;\n        \u0026lt;plugins\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-source-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n            \u0026lt;plugin\u0026gt;\n                \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                \u0026lt;artifactId\u0026gt;maven-javadoc-plugin\u0026lt;/artifactId\u0026gt;\n            \u0026lt;/plugin\u0026gt;\n        \u0026lt;/plugins\u0026gt;\n    \u0026lt;/build\u0026gt;\n\n    \u0026lt;profiles\u0026gt;\u0026lt;!--必填--\u0026gt;\n        \u0026lt;profile\u0026gt;\n            \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n            \u0026lt;build\u0026gt;\n                \u0026lt;plugins\u0026gt;\n                    \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                        \u0026lt;groupId\u0026gt;org.sonatype.plugins\u0026lt;/groupId\u0026gt;\n                        \u0026lt;artifactId\u0026gt;nexus-staging-maven-plugin\u0026lt;/artifactId\u0026gt;\n                        \u0026lt;version\u0026gt;1.6.13\u0026lt;/version\u0026gt;\n                        \u0026lt;extensions\u0026gt;true\u0026lt;/extensions\u0026gt;\n                        \u0026lt;configuration\u0026gt;\n                            \u0026lt;serverId\u0026gt;ossrh\u0026lt;/serverId\u0026gt;\n                            \u0026lt;nexusUrl\u0026gt;https://s01.oss.sonatype.org/\u0026lt;/nexusUrl\u0026gt; \n                          \u0026lt;autoReleaseAfterClose\u0026gt;true\u0026lt;/autoReleaseAfterClose\u0026gt;\n                        \u0026lt;/configuration\u0026gt;\n                    \u0026lt;/plugin\u0026gt;\n                    \u0026lt;plugin\u0026gt;\u0026lt;!--必填--\u0026gt;\n                        \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;\n                        \u0026lt;artifactId\u0026gt;maven-gpg-plugin\u0026lt;/artifactId\u0026gt;\n                    \u0026lt;/plugin\u0026gt;\n                \u0026lt;/plugins\u0026gt;\n            \u0026lt;/build\u0026gt;\u0026lt;!--必填--\u0026gt;\n            \u0026lt;distributionManagement\u0026gt;\n                \u0026lt;snapshotRepository\u0026gt;\n                    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n                  \u0026lt;url\u0026gt;https://s01.oss.sonatype.org/content/repositories/snapshots\n                    \u0026lt;/url\u0026gt;\n                \u0026lt;/snapshotRepository\u0026gt;\n                \u0026lt;repository\u0026gt;\n                    \u0026lt;id\u0026gt;ossrh\u0026lt;/id\u0026gt;\n                    \u0026lt;url\u0026gt;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/\n                    \u0026lt;/url\u0026gt;\n                \u0026lt;/repository\u0026gt;\n            \u0026lt;/distributionManagement\u0026gt;\n        \u0026lt;/profile\u0026gt;\n    \u0026lt;/profiles\u0026gt;\n\n    \u0026lt;dependencies\u0026gt;\u0026lt;!--maven依赖--\u0026gt;\u0026lt;/dependencies\u0026gt;\n\n\u0026lt;/project\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面已经是最精简的pom配置了，我已经把必选项标注好了。这里主要包含两部分内容，一部分是snoatype要求的必备信息，包括：证书、开发者信息、仓库地址和发布地址；另一部分是deploy需要的maven插件列表，大家可以根据实际情况酌情修改。\u003c/p\u003e\n\u003cp\u003e需要说明的是，为了不用默认打包冲突，专门定义了用于发布中央仓库的profile：ossrh，这里只需要添加额外的两个插件：nexus-staging-maven-plugin和maven-gpg-plugin，前者用于jar上传，后者用于密钥签名。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第三步，执行maven命令，发布构件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e配置好pom文件，可以执行maven命令：“mvn clean deploy -Possrh” 进行发布。如果版本号带SNAPSHOT后缀，会发布到snapshots仓库，否则发布到release仓库。\u003c/p\u003e\n\u003cp\u003e这里nexus-staging-maven-plugin插件有一个配置项：autoReleaseAfterClose，如果设置为true的话，推送完成会自动release。第一次发布成功后，会收到一封邮件：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_72.png\" alt=\"image_72.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003e\u003cstrong\u003e最后，让jar包更快的在中央仓库被搜索到\u003c/strong\u003e\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e根据邮件提示，Jar包成功发布成功后，大约30分钟后会推到中央仓库，我们可以从仓库地址看到我们发布的Jar包：\u003ca href=\"https://repo1.maven.org/maven2\"\u003ehttps://repo1.maven.org/maven2/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_73.png\" alt=\"image_73.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，其他项目就可以通过maven依赖引用我们的构件了，但是这时候通过中央仓库仍然搜不到我们的Maven构件。按照邮件提示可能会需要四小时，实际情况是我等了5个小时依然搜不到。如果遇到这种情况，我们可以通过在对issue添加评论反馈，会有人工回复进行解决：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_74.png\" alt=\"image_74.png\"\u003e\u003c/p\u003e\n\u003cp\u003e另外，关于mvnrepository与Maven Central的关系，有人咨询，官方也做了解答：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_75.png\" alt=\"image_75.png\"\u003e\u003c/p\u003e\n\u003cp\u003e根据我的实际经验判断，mvnrepository应该是定时同步的，我发布成功后，第二天才能搜到：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/engineering/practice-image_76.png\" alt=\"image_76.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下面是官方指导文档，介绍非常详细，基本上不用在网上搜索其他教程了。\u003c/p\u003e\n\u003ch4\u003e官方参考文档 \u003ca href=\"#dzquo\" id=\"dzquo\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://central.sonatype.org/publish/publish-guide\"\u003ehttps://central.sonatype.org/publish/publish-guide/\u003c/a\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"18:T4fc0,"])</script><script>self.__next_f.push([1,"\u003cp\u003e你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。\u003c/p\u003e\n\u003cp\u003e另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) \nand name in(sql\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缩略下印如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004,...) \nand name in(\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,...)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -\u0026gt; ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver -\u0026gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从\u003cstrong\u003eDataSource  -\u0026gt; Connection -\u0026gt; Driver\u003c/strong\u003e三个环节进行入手：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e一、SQL Profile监控\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1、驱动层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\u0026amp;logger=Slf4JLogger\u0026amp;profileSQL=true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2、连接层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如\u003ca href=\"https://p6spy.readthedocs.io/en/latest/\"\u003eP6Spy\u003c/a\u003e、\u003ca href=\"https://github.com/arthurblake/log4jdbc\"\u003elog4jdbc\u003c/a\u003e 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epyspy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:p6spy:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3、数据源层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e可以通过对DataSource进行代理实现SQL监控\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eP6Spy：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Bean\n@Primary\npublic DataSource spyDataSource(@Autowired DataSource dataSource) {\n  // wrap a datasource using P6SpyDataSource\n  return new P6DataSource(dataSource);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic DataSource spyDataSource(DataSource dataSource) {\n    // wrap the provided dataSource\n  return new DataSource() {\n    @Override\n    public Connection getConnection() throws SQLException {\n      // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection());\n    }\n      \n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n       // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection(username, password));\n     }\n      //...\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。\u003c/p\u003e\n\u003cp\u003e第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。\u003c/p\u003e\n\u003cp\u003e第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。\u003c/p\u003e\n\u003cp\u003e排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface DataSourceConfig extends HasBizDef {\n\n    /**\n     * 数据源名称，必须与KDB申请时填写的一致\n     */String bizName();\n\n    /**\n     * 获取当前可用区单库只读的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate read() {\n        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), \u0026quot;read\u0026quot;);\n    }   \n\n    /**\n     * 获取当前可用区单库读写的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate write() {\n        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), \u0026quot;write\u0026quot;);\n    }\t\n  //....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eenum class AdDataSources(\n    private val bizDef: BizDef,\n    private val forTest: AdDataSources? = null,\n    private val usingNewZk: Boolean = false\n) : DataSourceConfig{\n    adFansTopProfileDashboardTest,\n    adFansTopProfileDashboard,\n    adChargeTest,\n    adCharge,\n    adChargeReadOnly,\n    adDspReadOnlyTest,\n    adDspReadOnly;\n    public open fun bizName(): String {\n        return bizDef.bizName\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？\u003c/p\u003e\n\u003cp\u003e具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static ListenableDataSource\u0026lt;Failover\u0026lt;Instance\u0026gt;\u0026gt; create(Instance i) {\n   //...\n   try {\n       return supplyWithRetry(\n        DATA_SOURCE_BUILD_RETRY,\n        DATA_SOURCE_BUILD_RETRY_DELAY,\n        () -\u0026gt; new ListenableDataSource\u0026lt;\u0026gt;(\n              bizName, \n              new HikariDataSource(config), ds -\u0026gt; i.toString(), i),\n              DataSourceFactory::needRetry);\n                               \n  } catch (Throwable e) {/**/}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e二、动态修改加载类\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e成本最低的方式就是直接修改这段代码，将其中\u0026#x7684;\u003cem\u003e\u0026#x6E;ew HikariDataSource(config)\u003c/em\u003e\u0026#x4FEE;改\u0026#x6210;\u003cem\u003e\u0026#x6E;ew P6DataSource(new HikariDataSource(config))，\u003c/em\u003e\u0026#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？\u003c/p\u003e\n\u003cp\u003e首先我们来分析一下，有哪些手段可以修改Java字节码？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案一、编译时修改，需要开发maven插件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（不使用maven插件的同学咋办？）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案二、加载时修改，重写类加载器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要在代码中指定特定的类加载器，用有一定的侵入式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案三、运行时修改，使用JavaAgent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要修改应用启动参数，运维成本有点高\u003c/p\u003e\n\u003cp\u003e首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下面是对动态启动Java Agent技术的解释\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSee \u003ca href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description\"\u003ethe java.lang.instrument package documentation\u003c/a\u003e…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGetting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. \u003ca href=\"https://stackoverflow.com/a/19912148/2711488\"\u003eThis answer\u003c/a\u003e demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAs mentioned in \u003ca href=\"https://stackoverflow.com/questions/56787777/?noredirect=1\u0026lq=1#comment100160373_56787777\"\u003ethis comment\u003c/a\u003e, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e字节码工具对比\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用bytebuddy修改字节码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在实现代码之前，我们回过头来再看一下快手的数据源生成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ListenableDataSource\u0026lt;\u0026gt;(bizName, new HikariDataSource(config), ds -\u0026gt; i.toString());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DelegatingDataSource implements DataSource {\n   //...\n  public DelegatingDataSource(DataSource targetDataSource) {\n    this.setTargetDataSource(targetDataSource);\n   }\n\n  public void setTargetDataSource(@Nullable DataSource targetDataSource) {\n      this.targetDataSource = targetDataSource;\n  }\n  //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n        this.targetDataSource = new P6DataSource(targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么具体如何修改字节码呢？这里是\u003ca href=\"https://bytebuddy.net/#/tutorial\"\u003e官方文档\u003c/a\u003e，原理我们不做赘述，直接介绍实现了。实现方式有三种：\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1、类文件替换\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n  .redefine(NewDelegatingDataSource.class)\n  .name(DelegatingDataSource.class.getName())\n  .make()\n  .load(Thread.currentThread().getContextClassLoader(), \n        ClassReloadingStrategy.fromInstalledAgent());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2、操作字节码：\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .redefine(DelegatingDataSource.class)\n    //重写DelegatingDataSource#setTargetDataSource方法\n    .method(named(\u0026quot;setTargetDataSource\u0026quot;))\n    .intercept(MyImplementation.INSTANCE)\n    .make()\n    .load(Thread.currentThread().getContextClassLoader(),\n          ClassReloadingStrategy.fromInstalledAgent());\n\nenum MyImplementation implements Implementation {\n\nINSTANCE; // singleton\n\n  @Override\n  public InstrumentedType prepare(InstrumentedType instrumentedType) {\n  return instrumentedType;\n  }\n  \n  @Override\n  public ByteCodeAppender appender(Target implementationTarget) {\n  return MyAppender.INSTANCE;\n  }\n  \n}\n//字节码定义\nenum MyAppender implements ByteCodeAppender {\n\nINSTANCE; // singleton\n\n@Override\npublic Size apply(MethodVisitor methodVisitor,\n        Implementation.Context implementationContext,\n        MethodDescription instrumentedMethod) {\n  Label label0 = new Label();\n  methodVisitor.visitLabel(label0);\n  methodVisitor.visitLineNumber(70, label0);\n  methodVisitor.visitVarInsn(ALOAD, 0);\n  methodVisitor.visitTypeInsn(NEW, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;);\n  methodVisitor.visitInsn(DUP);\n  methodVisitor.visitVarInsn(ALOAD, 1);\n  methodVisitor.visitMethodInsn(INVOKESPECIAL, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;, \u0026quot;\u0026lt;init\u0026gt;\u0026quot;, \u0026quot;(Ljavax/sql/DataSource;)V\u0026quot;, false);\n  methodVisitor.visitFieldInsn(PUTFIELD, \u0026quot;org/springframework/jdbc/datasource/DelegatingDataSource\u0026quot;, \u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;);\n  Label label1 = new Label();\n  methodVisitor.visitLabel(label1);\n  methodVisitor.visitLineNumber(71, label1);\n  methodVisitor.visitInsn(RETURN);\n  Label label2 = new Label();\n  methodVisitor.visitLabel(label2);\n  methodVisitor.visitLocalVariable(\u0026quot;this\u0026quot;, \u0026quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;\u0026quot;, null, label0, label2, 0);\n  methodVisitor.visitLocalVariable(\u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;, null, label0, label2, 1);\n  methodVisitor.visitMaxs(4, 2);\n  return new Size(4, 2);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？\u003c/p\u003e\n\u003cp\u003e我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e3、利用byte-buddy的Advice\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public static void redefine() {\n   new ByteBuddy()\n     .redefine(DelegatingDataSource.class)\n     .visit(Advice.to(Decorator.class)\n            .on(ElementMatchers.named(\u0026quot;setTargetDataSource\u0026quot;)))\n     .make()\n     .load(Thread.currentThread().getContextClassLoader(),\n           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();\n }\n\nstatic class Decorator {\n\n  //在方法开始插入代码\n  @Advice.OnMethodEnter\n    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {\n    dataSource = new P6DataSource(dataSource);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebyte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n  //插入的代码\n  targetDataSource = new P6DataSource(targetDataSource);\n  this.targetDataSource = targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。\u003c/li\u003e\n\u003cli\u003e使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e三、自动生效\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;dependency\u0026gt;\n  \u0026lt;groupId\u0026gt;com.kuaishou.ad\u0026lt;/groupId\u0026gt;\n  \u0026lt;artifactId\u0026gt;sqllog-spring-boot-starter\u0026lt;/artifactId\u0026gt;\n  \u0026lt;version\u0026gt;制品库查询最新版\u0026lt;/version\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static String[] getConfigurations(File file) {\n  @EnableAutoConfiguration\n  class NoScan {\n    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载\n  }\n  FileClassLoader classLoader = new FileClassLoader(file);\n  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();\n  selector.setBeanClassLoader(classLoader);\n  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));\n  selector.setEnvironment(new StandardEnvironment());\n  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));\n  return configurations;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e四、SQL打印效果\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003esqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eSQL的打印内容分为三部分：\u003c/p\u003e\n\u003cp\u003e第一行，显示执行时间、耗时、SQL操作、数据库连接等信息\u003c/p\u003e\n\u003cp\u003e第二行，显示参数化SQL\u003c/p\u003e\n\u003cp\u003e第三行，显示绑定参数后的实际执行的SQL\u003c/p\u003e\n\u003cp\u003e通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"nav\",null,{\"className\":\"flex items-center gap-1 text-sm mb-4\",\"children\":[[\"$\",\"$L13\",null,{\"href\":\"/blog/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"博客\"}],[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/page/1\",\"className\":\"text-gray-500 hover:text-blue-600 transition-colors\",\"children\":\"Engineering\"}],[[\"$\",\"span\",null,{\"className\":\"text-gray-300\",\"children\":\"/\"}],[\"$\",\"$L13\",null,{\"href\":\"/blog/category/engineering/tooling/page/1\",\"className\":\"text-blue-600 hover:text-blue-700 transition-colors\",\"children\":\"开发工具\"}]]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-04-05\",\"children\":\"2024年04月05日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"Git 常用命令速查手册\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L13\",\"Git\",{\"href\":\"/blog/tag/Git/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"Git\"}],[\"$\",\"$L13\",\"版本控制\",{\"href\":\"/blog/tag/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"版本控制\"}],[\"$\",\"$L13\",\"开发工具\",{\"href\":\"/blog/tag/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"开发工具\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$10\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"engineering/tooling/Java构件发布到中央仓库\",\"title\":\"Java构件发布到中央仓库\",\"description\":\"Maven中央仓库并不支持直接发布jar包。我们需要将jar包发布到一些指定的第三方Maven仓库，然后该仓库再将jar包同步到Maven中央仓库。其中，最”简单”的方式是通过...\",\"pubDate\":\"2024-04-04\",\"tags\":[\"Maven\",\"Java\",\"开源发布\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"engineering/middleware/非侵入式SQL监控\",\"title\":\"非侵入式SQL监控\",\"description\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\",\"pubDate\":\"2024-04-07\",\"tags\":[\"SQL监控\",\"Java\",\"非侵入式\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"Git\":{\"prev\":null,\"next\":null},\"版本控制\":{\"prev\":null,\"next\":null},\"开发工具\":{\"prev\":null,\"next\":null}}}]}],[\"$\",\"$L19\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"8:null\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"a:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Git 常用命令速查手册 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"Git 常用命令速查手册\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-04-05\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Git 常用命令速查手册\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"一份面向日常开发的 Git 命令速查手册，覆盖分支管理、暂存与恢复、提交操作、远程协作、文件追踪控制、子模块、日志查询与常见问题处理等场景，适合收藏备用。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n12:{\"metadata\":\"$a:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
1:"$Sreact.fragment"
2:I[10616,["6874","static/chunks/6874-7791217feaf05c17.js","7177","static/chunks/app/layout-142e67ac4336647c.js"],"default"]
3:I[87555,[],""]
4:I[31295,[],""]
6:I[59665,[],"OutletBoundary"]
9:I[74911,[],"AsyncMetadataOutlet"]
b:I[59665,[],"ViewportBoundary"]
d:I[59665,[],"MetadataBoundary"]
f:I[26614,[],""]
:HL["/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/66b421ed9771e9de.css","style"]
0:{"P":null,"b":"C33gYo3klV3feVWcJcf5W","p":"","c":["","blog","engineering","algorithm","%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","engineering/algorithm/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/66b421ed9771e9de.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_f367f3","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-[var(--background)]","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 lg:px-8","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":["© ",2026," Skyfalling"]}]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","engineering/algorithm/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%82%B9%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5",null,["$","$L6",null,{"children":["$L7","$L8",["$","$L9",null,{"promise":"$@a"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","sxo2pjgCdnTLy3HQNxb2kv",{"children":[["$","$Lb",null,{"children":"$Lc"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Ld",null,{"children":"$Le"}]]}],false]],"m":"$undefined","G":["$f","$undefined"],"s":false,"S":true}
10:"$Sreact.suspense"
11:I[74911,[],"AsyncMetadata"]
13:I[6874,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],""]
14:I[32923,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
16:I[40780,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
1a:I[85300,["6874","static/chunks/6874-7791217feaf05c17.js","968","static/chunks/968-d7155a2506e36f1d.js","6909","static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js"],"default"]
e:["$","div",null,{"hidden":true,"children":["$","$10",null,{"fallback":null,"children":["$","$L11",null,{"promise":"$@12"}]}]}]
15:T4ac3,<h2>引言：一个看似简单的几何问题</h2>
<p>给定一个二维平面上的点和一个多边形，判断该点是否位于多边形内部——这是计算几何中最基础也是最重要的问题之一。</p>
<p>这个问题的应用场景远比想象中广泛。在 GIS（地理信息系统）领域，地理围栏需要判断一个 GPS 坐标是否落在某个行政区划或配送区域内；在游戏引擎中，碰撞检测的核心步骤之一就是判断角色是否进入了某个不规则区域；在图形渲染中，扫描线填充算法需要逐像素判断哪些点落在多边形内部以进行着色。</p>
<p>尽管问题描述简洁，但一旦考虑凹多边形、自交多边形、射线穿过顶点等边界情况，实现一个工程上鲁棒的算法并非易事。本文将系统讲解两种经典算法——<strong>射线法（Ray Casting）</strong> 与<strong>回转数法（Winding Number）</strong>，深入分析其数学原理、边界处理策略与工程优化方法。</p>
<hr>
<h2>问题定义与数学基础</h2>
<h3>多边形的分类</h3>
<p>在讨论算法之前，有必要明确多边形的分类，因为不同类型的多边形对算法的适用性有直接影响。</p>
<p><strong>简单多边形（Simple Polygon）：</strong> 边与边之间除了在顶点处相连外不存在交叉。简单多边形又可细分为凸多边形（任意内角小于 180 度）和凹多边形（存在内角大于 180 度的顶点）。凸多边形的判定可以利用叉积在 O(log n) 时间内完成，但凹多边形无法利用这一性质。</p>
<p><strong>复杂多边形（Complex Polygon）：</strong> 边与边之间存在交叉（自交），形成的区域可能存在重叠。自交多边形的&quot;内部&quot;定义取决于填充规则的选择，这正是射线法与回转数法在语义上产生分歧的关键场景。</p>
<h3>Jordan 曲线定理</h3>
<p>射线法的数学基础是 Jordan 曲线定理：<strong>平面上任何一条简单闭曲线将平面划分为恰好两个区域——一个有界的内部区域和一个无界的外部区域。</strong> 从内部任意一点出发的射线，在到达无穷远处（外部）的过程中，必须穿过曲线奇数次；从外部出发的射线则穿过偶数次（包括零次）。</p>
<p>这个定理直觉上显而易见，但严格证明并不简单。对于多边形这一特殊的分段线性闭曲线，我们可以在离散层面上精确计算射线与每条边的交点，从而将连续几何问题转化为可计算的算法。</p>
<hr>
<h2>射线法（Ray Casting Algorithm）</h2>
<h3>核心原理：奇偶规则</h3>
<p>射线法的核心思路极为简洁：从测试点 P 向任意方向发射一条射线（通常选择水平向右方向，即正 x 方向），统计该射线与多边形所有边的交点数量。根据 Jordan 曲线定理：</p>
<ul>
<li><strong>交点数为奇数</strong> -&gt; 点在多边形内部</li>
<li><strong>交点数为偶数</strong> -&gt; 点在多边形外部</li>
</ul>
<p>直观理解：当测试点在多边形内部时，射线从内部出发，第一次穿越边界即&quot;出去&quot;，随后每一对穿越都对应一次&quot;进入-出去&quot;的循环。整个过程产生 1 + 2k（奇数）个交点。当测试点在外部时，每次穿越都是&quot;进入-出去&quot;成对出现，产生 2k（偶数）个交点。</p>
<h3>算法流程</h3>
<p>对于一个由 n 个顶点 V_0, V_1, ..., V_{n-1} 定义的多边形和测试点 P(x, y)：</p>
<ol>
<li>初始化交点计数器 count = 0</li>
<li>遍历多边形的每条边 (V_i, V_{i+1})（其中 V_n = V_0 构成闭合）</li>
<li>对于每条边，判断水平射线是否与该边相交</li>
<li>若相交，count 加 1</li>
<li>若 count 为奇数，则点在多边形内</li>
</ol>
<p>判断射线与边是否相交的具体条件为：边的两个端点必须分布在射线所在水平线的两侧（一个在上方，一个在下方或恰好在线上），且交点的 x 坐标位于测试点的右侧。</p>
<h3>边界情况的严格处理</h3>
<p>射线法的优雅之处在于其概念的简洁性，但工程实现的难点在于边界情况的处理。以下逐一分析。</p>
<p><strong>射线穿过多边形顶点：</strong> 当射线恰好经过多边形的某个顶点时，该顶点同时是两条边的端点，如果简单地对两条边分别判断交点，可能会将同一个交叉点计数两次或零次，导致奇偶性错误。</p>
<p>解决方案是采用<strong>半开区间约定（half-open interval）</strong>：对于每条边，只有当边的一个端点严格位于射线下方（y &lt; P_y），另一个端点位于射线上方或恰好在射线上（y &gt;= P_y）时，才视为相交。这样，对于穿过顶点的情况：如果该顶点连接的两条边分别位于射线的两侧（一条边从下方来，另一条边向上方去），则恰好产生一个交点；如果两条边位于射线的同一侧（如一条边从下方来到顶点，又向下方去），则交点计数为零或二，对奇偶性无影响。</p>
<p><strong>边与射线重合：</strong> 当多边形的某条边恰好与射线共线（即水平且 y 坐标等于 P_y）时，该边上的所有点都是&quot;交点&quot;。处理策略同样依赖半开区间约定：水平边的两个端点 y 坐标相同，均不满足&quot;一上一下&quot;的条件，因此整条水平边不产生任何交点。这在数学上等价于将水平边&quot;忽略&quot;。</p>
<p><strong>自交多边形：</strong> 射线法天然适用于自交多边形，此时它实际上遵循的是<strong>奇偶填充规则（Even-Odd Rule）</strong>。自交区域被穿过偶数次的边界包围，在奇偶规则下被视为&quot;外部&quot;——即重叠区域通过 XOR 操作被剔除。这在某些场景下是期望的行为（如 SVG 的 <code>fill-rule: evenodd</code>），但在另一些场景下可能不符合预期。</p>
<h3>算法实现</h3>
<p>以下是射线法的 C 语言实现，采用水平向右射线与半开区间约定：</p>
<pre><code class="language-c">bool pointInPolygon(double x, double y,
                    double *polyX, double *polyY, int polySides) {
    int i, j = polySides - 1;
    bool oddNodes = false;

    for (i = 0; i &lt; polySides; i++) {
        if ((polyY[i] &lt; y &amp;&amp; polyY[j] &gt;= y)
        ||  (polyY[j] &lt; y &amp;&amp; polyY[i] &gt;= y)) {
            if (polyX[i] + (y - polyY[i]) / (polyY[j] - polyY[i])
                * (polyX[j] - polyX[i]) &lt; x) {
                oddNodes = !oddNodes;
            }
        }
        j = i;
    }
    return oddNodes;
}
</code></pre>
<p>逐行解析：</p>
<ul>
<li>外层 <code>for</code> 循环遍历多边形每条边 <code>(V_i, V_j)</code>，其中 <code>j</code> 始终指向前一个顶点，形成循环遍历</li>
<li>第一个 <code>if</code> 判断：边的两个端点是否分布在水平射线的两侧（采用半开区间 <code>&lt;</code> 和 <code>&gt;=</code>）</li>
<li>第二个 <code>if</code> 判断：计算射线与边的交点 x 坐标，判断交点是否在测试点的左侧（即测试点在交点右侧），若是则翻转 <code>oddNodes</code> 标志</li>
</ul>
<p>交点 x 坐标的计算基于线性插值：给定边的两个端点 (x_i, y_i) 和 (x_j, y_j)，射线 y = P_y 与该边的交点 x 坐标为：</p>
<pre><code>x_intersect = x_i + (P_y - y_i) / (y_j - y_i) * (x_j - x_i)
</code></pre>
<h3>复杂度分析</h3>
<ul>
<li><strong>时间复杂度：O(n)</strong>，其中 n 为多边形的边数。算法仅需遍历所有边一次，每条边的计算为常数时间</li>
<li><strong>空间复杂度：O(1)</strong>，仅使用常数个辅助变量</li>
</ul>
<h3>边界点的归属</h3>
<p>需要特别说明的是，当测试点恰好位于多边形边上时，射线法的返回值是不确定的——可能返回&quot;内&quot;也可能返回&quot;外&quot;，取决于浮点运算的精度和具体的边方位。在工程实践中，由于边在数学上是无面积的一维对象，这种不确定性在绝大多数场景下可以忽略。如果应用需要对边界点做确定性判断，需要额外增加点到边的距离判断逻辑。</p>
<hr>
<h2>回转数法（Winding Number Algorithm）</h2>
<h3>原理：绕测试点的回转数</h3>
<p>回转数法从另一个视角定义&quot;内部&quot;：计算多边形边界绕测试点旋转的总角度。具体而言，<strong>回转数（Winding Number）</strong> 定义为：沿多边形边界按顶点顺序遍历一圈时，从测试点观察，边界总共绕测试点逆时针旋转了多少圈。</p>
<ul>
<li><strong>回转数不为零</strong> -&gt; 点在多边形内部</li>
<li><strong>回转数为零</strong> -&gt; 点在多边形外部</li>
</ul>
<p>对于简单多边形，回转数只可能是 +1、-1 或 0，此时回转数法与射线法的结果完全一致。两者的差异体现在<strong>自交多边形</strong>上。</p>
<h3>与射线法的语义差异</h3>
<p>考虑一个&quot;8&quot;字形自交多边形，其两个环重叠区域的回转数为 +2 或 -2。在回转数法下，重叠区域属于&quot;内部&quot;（回转数非零）；在射线法（奇偶规则）下，重叠区域属于&quot;外部&quot;（射线穿过偶数条边）。</p>
<p>这两种语义分别对应图形学中的两种填充规则：</p>
<ul>
<li><strong>奇偶规则（Even-Odd Rule）：</strong> 射线法的行为，自交区域被 XOR 剔除</li>
<li><strong>非零规则（Non-Zero Rule）：</strong> 回转数法的行为，只要回转数非零即为内部</li>
</ul>
<p>SVG 和 CSS 中的 <code>fill-rule</code> 属性正是控制这一行为的：<code>evenodd</code> 对应射线法语义，<code>nonzero</code> 对应回转数法语义。</p>
<h3>实现思路</h3>
<p>直观的实现是逐边累加角度变化量，但涉及反三角函数计算，效率较低。高效的实现方法同样基于边与水平线的交叉计数，但区分方向：</p>
<pre><code>function windingNumber(P, polygon):
    wn = 0
    for each edge (V_i, V_{i+1}):
        if V_i.y &lt;= P.y:
            if V_{i+1}.y &gt; P.y:                // 向上穿越
                if isLeft(V_i, V_{i+1}, P) &gt; 0: // P 在边的左侧
                    wn += 1
        else:
            if V_{i+1}.y &lt;= P.y:               // 向下穿越
                if isLeft(V_i, V_{i+1}, P) &lt; 0: // P 在边的右侧
                    wn -= 1
    return wn != 0
</code></pre>
<p>其中 <code>isLeft</code> 函数通过叉积判断点 P 相对于有向边 (V_i, V_{i+1}) 的方位：</p>
<pre><code>isLeft(V_i, V_{i+1}, P) =
    (V_{i+1}.x - V_i.x) * (P.y - V_i.y) -
    (P.x - V_i.x) * (V_{i+1}.y - V_i.y)
</code></pre>
<p>该实现的时间复杂度同样为 O(n)，且不涉及三角函数运算，全部计算基于加减乘运算，在性能上与射线法相当。</p>
<h3>射线法与回转数法的对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>射线法</th>
<th>回转数法</th>
</tr>
</thead>
<tbody><tr>
<td>填充规则</td>
<td>奇偶规则（Even-Odd）</td>
<td>非零规则（Non-Zero）</td>
</tr>
<tr>
<td>简单多边形</td>
<td>结果一致</td>
<td>结果一致</td>
</tr>
<tr>
<td>自交多边形</td>
<td>重叠区域视为外部</td>
<td>重叠区域视为内部</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>实现难度</td>
<td>较低</td>
<td>略高（需处理方向）</td>
</tr>
<tr>
<td>数值稳定性</td>
<td>涉及除法</td>
<td>仅涉及乘法（叉积）</td>
</tr>
</tbody></table>
<p>在大多数工程场景中，如果处理的是简单多边形，两种算法可以互换使用。对于自交多边形，需要根据业务语义选择合适的填充规则。</p>
<hr>
<h2>算法优化</h2>
<h3>包围盒预检测（Bounding Box）</h3>
<p>最直接的优化是在执行射线法之前，先判断测试点是否落在多边形的轴对齐包围盒（AABB）内。包围盒通过预计算多边形所有顶点的 x、y 坐标极值得到：</p>
<pre><code>if (x &lt; minX || x &gt; maxX || y &lt; minY || y &gt; maxY)
    return false;  // 点在包围盒之外，必定不在多边形内
</code></pre>
<p>包围盒预计算为 O(n)，一次计算后可复用。后续每次判定的预检测为 O(1)，能快速排除大量明显在多边形外部的点。</p>
<h3>边的早期跳过优化</h3>
<p>在射线法的实现中，Nathan Mercer 提出了一种优化：在判断边的两端点是否跨越水平线之后，增加一个额外条件 <code>polyX[i] &lt;= x || polyX[j] &lt;= x</code>，用于跳过那些完全位于测试点右侧的边——这些边不可能与向右发射的射线产生在测试点左侧的交点。</p>
<pre><code class="language-c">if ((polyY[i] &lt; y &amp;&amp; polyY[j] &gt;= y)
||  (polyY[j] &lt; y &amp;&amp; polyY[i] &gt;= y)) {
    if (polyX[i] &lt;= x || polyX[j] &lt;= x) {  // 新增条件
        if (polyX[i] + (y - polyY[i]) / (polyY[j] - polyY[i])
            * (polyX[j] - polyX[i]) &lt; x) {
            oddNodes = !oddNodes;
        }
    }
}
</code></pre>
<p>这一优化避免了对完全位于右侧的边执行浮点除法和乘法运算，在多边形边数较多且测试点靠近多边形中心时效果显著。</p>
<h3>空间索引加速</h3>
<p>当需要对同一个多边形进行大量点的判定（如 GIS 服务中的批量坐标归属查询），O(n) 的逐边遍历会成为性能瓶颈。此时可以引入空间索引进行预处理：</p>
<p><strong>网格法（Grid）：</strong> 将多边形的包围盒划分为 m x m 的均匀网格。预处理阶段，计算每个网格单元与多边形的关系：完全在内部、完全在外部、或与边界相交。查询时，先定位测试点所在的网格单元，若为完全内部或完全外部则直接返回，仅对边界单元执行射线法。预处理复杂度为 O(n * m)，查询复杂度降至 O(1)（最优情况）到 O(n/m)（最坏情况）。</p>
<p><strong>梯形分解（Trapezoidal Decomposition）：</strong> 将多边形分解为若干梯形区域，构建搜索结构。预处理复杂度 O(n log n)，单次查询复杂度 O(log n)。适用于对查询延迟有严格要求的场景。</p>
<p><strong>R-Tree 索引：</strong> 将多边形的边组织为 R-Tree。查询时，先通过 R-Tree 筛选出与水平射线可能相交的边，再对这些边执行精确判断。当多边形边数达到数千甚至数万级别时，R-Tree 能将实际需要检查的边数降低一到两个数量级。</p>
<h3>批量判定的预处理策略</h3>
<p>在实际工程中，常见的场景是：多边形固定不变，需要对海量动态点进行判定。典型如地理围栏服务——行政区划多边形固定，而 GPS 坐标持续涌入。</p>
<p>此时最高效的策略是<strong>基于扫描线的预处理</strong>：将包围盒在 y 方向上分为若干水平带（slab），每个水平带内记录穿过该带的边集合。查询时先通过 y 坐标定位到水平带，再只对该带内的边执行射线法。这种方法将每次查询的平均边检查数量从 n 降低到 n/k（k 为水平带数量），是 GIS 工程实践中常用的优化手段。</p>
<hr>
<h2>工程应用</h2>
<h3>GIS 地理围栏</h3>
<p>地理围栏（Geofencing）是点在多边形内判定最典型的工程应用。在物流配送中，需要判断用户地址是否在配送区域内；在出行服务中，需要判断车辆是否驶入或驶出电子围栏；在气象服务中，需要判断某个坐标属于哪个气象分区。</p>
<p>GIS 场景的特殊性在于坐标系。GPS 坐标是经纬度（球面坐标），而射线法假设平面直角坐标系。对于小范围区域（如城市级别），可以直接将经纬度视为平面坐标进行计算，误差可控。对于大范围区域（如跨越数千公里的国界），需要先进行墨卡托投影或其他地图投影，将球面坐标转换为平面坐标后再执行算法。</p>
<p>此外，GIS 中的多边形边数通常较大——一个省级行政区划的边界可能由数万个顶点组成。此时空间索引（如 R-Tree）和网格预处理几乎是必需的优化手段。PostGIS 中的 <code>ST_Contains</code> 函数内部正是采用了 R-Tree 索引加速的射线法实现。</p>
<h3>地图服务：行政区划归属查询</h3>
<p>大型地图服务需要支持&quot;根据经纬度查询所属行政区划&quot;的高频请求。其本质是对数百个行政区划多边形的批量点包含测试。工程实现通常分为两级：</p>
<ol>
<li><strong>粗筛：</strong> 使用 R-Tree 对所有行政区划的包围盒建立索引，根据查询点快速定位到候选区划（通常只有 1-3 个）</li>
<li><strong>精确判定：</strong> 对候选区划执行射线法或回转数法</li>
</ol>
<p>这种两级架构将原本 O(N * n) 的问题（N 个区划，每个区划 n 条边）降低到接近 O(log N + n&#39;) 的复杂度，其中 n&#39; 是候选区划的平均边数。</p>
<h3>游戏引擎碰撞检测</h3>
<p>在游戏开发中，碰撞检测通常采用多阶段策略：</p>
<ol>
<li><strong>宽阶段（Broad Phase）：</strong> 使用包围盒（AABB 或 OBB）快速排除不可能碰撞的物体对</li>
<li><strong>窄阶段（Narrow Phase）：</strong> 对宽阶段筛选出的候选对执行精确碰撞检测</li>
</ol>
<p>点在多边形内判定在窄阶段发挥作用，尤其对于不规则形状的碰撞区域（如地形边界、不规则触发区域）。对于凸多边形，通常使用 GJK（Gilbert-Johnson-Keerthi）算法，但对于凹多边形区域，射线法仍然是最直接可靠的方案。</p>
<h3>数据可视化：区域着色与热力图</h3>
<p>在前端数据可视化中，Choropleth Map（分级统色地图）需要将数据点分配到对应的地理区域。例如，将每个用户的坐标归属到对应的省份，再根据各省份的用户密度进行着色。这本质上就是大规模的点在多边形内批量判定。</p>
<p>D3.js 和 ECharts 等可视化库内部均实现了射线法。在 Canvas 渲染场景中，<code>CanvasRenderingContext2D.isPointInPath()</code> 方法底层也是基于类似的算法实现。</p>
<hr>
<h2>总结</h2>
<p>点在多边形内判定是计算几何中的基石问题。射线法以其概念简洁、实现高效的特点成为工程实践中的首选方案，其 O(n) 的时间复杂度和对凹多边形的天然支持使其适用于绝大多数场景。回转数法在处理自交多边形时提供了不同的语义选择（非零填充规则 vs 奇偶填充规则），是理解图形填充行为的关键。</p>
<p>在工程应用中，算法本身的效率往往不是瓶颈——真正的挑战在于如何通过包围盒预检测、空间索引、网格预处理等手段，将海量查询的平均复杂度从 O(n) 降低到接近 O(1)。理解算法原理是基础，而将其融入具体的工程架构中进行系统性优化，才是将理论转化为生产力的关键。</p>
17:T1e19,<h2>一只蚂蚁什么都不知道</h2>
<p>一只蚂蚁的行为规则极其简单：感知信息素浓度，跟随梯度移动，遇到食物释放化学信号。没有蚂蚁知道巢穴的蓝图，没有蚂蚁理解物流调度，没有蚂蚁担任&quot;总指挥&quot;。</p>
<p>然而，当数十万只蚂蚁按照这些简单规则交互时，一个惊人的结构浮现了：具有温控系统的地下巢穴、高效的食物采集网络、精确的劳动分工。蚁群展现出的&quot;智慧&quot;远超任何单只蚂蚁的能力边界。</p>
<p>这就是<strong>涌现</strong>（Emergence）--复杂系统科学中最核心、最反直觉的概念。</p>
<h2>什么是涌现</h2>
<p>涌现指的是：<strong>系统整体呈现出其组成部分所不具备的性质或行为</strong>。这些性质不是某个部分&quot;拥有&quot;的，也不能通过加总各部分的属性来推导。它们是大量组件在特定规则下交互的结果，是关系的产物，而非实体的属性。</p>
<p>涌现需要满足三个条件。<strong>其一，微观规则是局部的。</strong> 蚂蚁只感知周围几厘米的信息素，神经元只与突触连接的其他神经元通信，交易者只关注自己能获取的有限信息。<strong>其二，宏观模式是全局的。</strong> 蚁群的巢穴、大脑的意识、市场的价格信号，这些模式在任何局部都看不到完整形态。<strong>其三，层级之间存在不可还原性。</strong> 知道每只蚂蚁的行为规则，不等于能预测蚁群的巢穴形态；知道每个神经元的放电模式，不等于能理解一段记忆。</p>
<p>亚里士多德两千多年前就觉察到了这一点：&quot;整体大于部分之和。&quot;但直到二十世纪下半叶，复杂系统科学才赋予这句话严格的理论含义。</p>
<h2>涌现无处不在</h2>
<h3>神经元与意识</h3>
<p>单个神经元是简单的电化学装置：接收信号，达到阈值则放电，否则沉默。但约 860 亿个神经元通过 100 万亿个突触连接形成的网络，产生了意识、情感和抽象推理。没有哪个神经元&quot;拥有&quot;意识，意识是系统层面的涌现属性。</p>
<h3>城市与市场</h3>
<p>没有人&quot;设计&quot;了一座城市的全部--街区的文化氛围、商业区的自发聚集、交通流的潮汐模式，这些都是数百万居民日复一日做出局部决策的累积结果。</p>
<p>市场经济同理。亚当·斯密的&quot;看不见的手&quot;本质上就是对涌现的直觉描述：每个参与者追求自身利益，却无意中形成了高效的资源配置机制。价格信号编码了分散在无数人头脑中的供需信息，没有任何中央处理器在做汇总计算。</p>
<h2>弱涌现与强涌现</h2>
<p><strong>弱涌现</strong>指涌现性质在原则上可以从微观规则推导，只是计算复杂度太高，实践中无法完成。康威的生命游戏是典型案例--规则极简，却能产生滑翔机、振荡器乃至图灵完备的计算结构。宏观模式由微观规则完全决定，但只有运行模拟才能知道结果。其核心是<strong>计算不可约性</strong>--系统没有比&quot;完整模拟&quot;更快的预测方式，必须一步一步算下去。</p>
<p><strong>强涌现</strong>则声称某些涌现性质在原则上不可还原。即使拥有完备的微观信息和无限算力，仍无法从底层推导出高层性质。意识是最常被引用的候选--即使记录了每个神经元的每次放电，是否就能解释&quot;红色看起来是什么感觉&quot;？</p>
<p>强涌现的存在仍有争议。但有一点确定：<strong>在工程实践中，我们面对的几乎总是弱涌现带来的计算不可约性，而这已经足够让人谦卑了。</strong></p>
<h2>涌现与软件系统</h2>
<p>作为长期从事架构设计的工程师，我发现涌现是理解大规模软件系统行为的关键视角。</p>
<h3>微服务的涌现行为</h3>
<p>一个微服务架构可能由数百个独立服务组成，每个都经过精心设计和充分测试。但当它们通过网络连接成整体，系统会出现单个服务文档中未曾描述的行为。</p>
<p><strong>级联故障</strong>是典型的涌现现象。一个服务响应变慢，导致上游线程池耗尽，进而导致更上游超时，最终整条调用链雪崩。没有任何服务&quot;设计&quot;了雪崩行为，它是依赖关系在特定负载下的涌现结果。分布式数据一致性问题也类似--每个节点严格执行本地事务，但在网络分区和时钟漂移下，全局状态可能进入任何单节点都未预见的不一致状态。</p>
<h3>从规格到行为的鸿沟</h3>
<p><strong>系统的规格说明描述的是组件，但系统的行为来自交互。</strong> 你可以为每个服务编写详尽文档，却无法用文档预测极端条件下的整体行为。</p>
<p>这就是混沌工程存在的原因。Netflix 的 Chaos Monkey 随机杀死生产环境中的服务实例来测试韧性，本质上是在探索涌现行为空间。涌现行为无法从设计文档推导，只能通过&quot;运行并观察&quot;来发现。</p>
<h3>涌现式架构思维</h3>
<p>传统自上而下设计试图精确规定系统每个层面的行为，但在分布式系统中，这种控制幻觉反而带来脆弱性。更务实的做法是：<strong>设计局部规则和约束，而不是试图控制全局结果。</strong></p>
<p>断路器模式就是好例子：每个服务本地执行简单规则--下游失败率超阈值就断开连接，定期试探恢复。局部规则在全局层面涌现出自愈能力和故障隔离。Kubernetes 的声明式架构同理：你声明期望终态，各控制器通过局部调谐循环趋近目标，全局秩序是大量局部调谐的涌现结果。</p>
<h2>还原论为什么不够</h2>
<p>还原论主张理解整体的方式是拆解为部分、逐一理解、重新组装。这在物理和化学中成就辉煌，但面对复杂系统时遇到结构性困难。</p>
<p><strong>组合爆炸</strong>：当组件间存在非线性交互，状态空间指数级增长，&quot;重新组装&quot;在计算上不可行。<strong>丢失关系</strong>：拆解过程破坏了组件间的关系，而关系恰恰是涌现的载体。把大脑切片成单个神经元研究，你了解了电化学性质，却丢失了突触拓扑--后者才是思维的基础。<strong>层级错配</strong>：不同层级有不同规律，用夸克方程解释经济衰退是范畴错误。</p>
<p>这不是说还原论无用，而是说<strong>还原论需要与整体论互补</strong>。理解系统既需要自下而上分析组件，也需要自上而下观察结构。二者是认识复杂世界的两只眼睛。</p>
<h2>与涌现共处</h2>
<p>涌现提供了一种思维方式：<strong>不要只盯着零件看，要看零件之间的连接方式。</strong></p>
<p>对于工程师而言：<strong>敬畏复杂度</strong>，大规模系统永远会产生未曾预见的行为；<strong>设计局部规则而非全局蓝图</strong>，让系统自发涌现出期望的全局属性；<strong>拥抱可观测性</strong>，日志、指标、链路追踪是认识涌现的必要工具；<strong>跨层级思考</strong>，单一层级的优化可能在另一个层级制造灾难。</p>
<p>从蚁群到大脑，从城市到市场，从微服务到分布式系统，涌现是连接这些领域的底层逻辑。世界的复杂性不是组件复杂性的简单叠加，而是关系复杂性的非线性放大。理解这一点，不会让系统变得更简单，但会让我们对复杂保持正确的敬畏。</p>
18:T29e1,<h2>引言：被正态分布驯化的直觉</h2>
<p>我们从中学开始接受正态分布的训练。考试成绩、身高体重、测量误差，几乎所有教科书上的例子都在告诉我们：大多数值聚集在平均值附近，极端值极其罕见，越极端越不可能。这条优美的钟形曲线塑造了我们对世界的基本直觉——<strong>事物倾向于「正常」，偏差是暂时的，均值是可靠的</strong>。</p>
<p>这个直觉在很多场景下确实成立。但如果你把同样的直觉带到财富分配、互联网流量、城市人口规模、甚至系统故障的分析中，你会被现实狠狠教训。</p>
<p>在阿里做风控系统的那几年，我反复遇到一个问题：线上故障的严重程度分布，根本不像正态分布。大多数故障影响很小，但偶尔出现的极端故障，其影响量级可以是普通故障的几百倍甚至上千倍。我们为「平均故障」准备的应急方案，在面对那些尾部事件时几乎形同虚设。后来我才意识到，这些现象背后有一个统一的数学结构——<strong>幂律分布</strong>。</p>
<h2>什么是幂律分布</h2>
<p>幂律分布的核心特征可以用一句话概括：<strong>事件的频率与其规模之间存在幂次关系</strong>。用数学语言表达，一个随机变量 X 服从幂律分布，意味着：</p>
<blockquote>
<p>P(X &gt; x) ~ x^(-alpha)</p>
</blockquote>
<p>其中 alpha 是幂律指数。alpha 越小，极端事件出现的概率越高，分布的「尾巴」越厚。</p>
<p>与正态分布最本质的区别在于尾部行为。正态分布的尾部以指数速度衰减——偏离均值 3 个标准差的事件概率已经低到千分之三，6 个标准差几乎不可能发生。而幂律分布的尾部衰减速度远慢于指数，这意味着<strong>极端事件的概率被系统性地低估了</strong>。</p>
<p>一个直觉化的理解方式：在正态分布的世界里，如果平均身高是 170cm，你几乎不可能见到 3 米高的人。但在幂律分布的世界里，如果平均财富是 10 万元，你不仅会见到拥有 1 亿的人，还会见到拥有 1000 亿的人——而且这些超级富豪对整个系统的统计特征有决定性影响。</p>
<p>这就是所谓的**「肥尾」(fat tail)**。</p>
<h2>幂律无处不在</h2>
<p>幂律分布并非学术上的边缘概念。一旦你学会辨认它，就会发现它几乎渗透到所有复杂系统中。</p>
<p><strong>财富分布</strong>是最经典的例子。意大利经济学家帕累托在 19 世纪末就发现，80% 的财富集中在 20% 的人手中。这个「二八法则」的背后正是幂律。在当今全球经济中，前 1% 的人拥有的财富超过后 50% 的总和。如果财富服从正态分布，这种程度的不平等在数学上几乎不可能出现。</p>
<p><strong>城市规模</strong>同样服从幂律。如果你把中国所有城市按人口排序，会发现排名第一的城市（上海）人口大约是排名第二的城市（北京）的某个倍数，而排名第十的城市人口又是排名第一百的城市的某个倍数，这个比例关系在整个排名中保持惊人的稳定。这就是著名的齐普夫定律（Zipf&#39;s Law）。</p>
<p><strong>互联网世界</strong>更是幂律的天然栖息地。网站的访问量分布、社交网络中的粉丝数分布、搜索引擎中的查询词频率，都呈现典型的幂律特征。少数节点（如微博大V、头部网站）占据了绝大部分的流量和注意力，而长尾中存在海量的低频节点。</p>
<p><strong>自然灾害</strong>也遵循幂律。地震的能量释放（古登堡-里克特定律）、森林火灾的面积、洪水的规模，都不是正态分布。小地震每天都有，但偶尔出现的大地震释放的能量可以是小地震的百万倍。</p>
<p>这些例子的共同点是：<strong>均值不再是一个有意义的描述指标，因为少数极端事件对系统总量的贡献远超所有「普通」事件的总和</strong>。</p>
<h2>工程世界中的幂律</h2>
<p>作为技术架构师，我更关心幂律在工程系统中的表现。事实上，几乎所有大规模分布式系统的运维数据都在尖叫着同一个事实：<strong>故障不是均匀分布的，它们服从幂律</strong>。</p>
<p><strong>系统故障的严重程度</strong>是典型的幂律分布。翻看任何一家大型互联网公司的故障复盘记录，你会发现：绝大多数故障影响很小（一个服务短暂抖动、几十个请求超时），但极少数故障的影响是灾难性的（全站不可用、数据丢失、资金损失）。如果你用平均故障影响来做容量规划，就会在那些极端故障面前毫无准备。</p>
<p><strong>流量的时间分布</strong>也是幂律性质的。在电商系统中，双十一零点的瞬时流量可以是日常峰值的 10 到 50 倍。如果你用过去一年的「平均流量」来规划系统容量，你的系统在大促时必然崩溃。这不是简单的「高峰」，而是幂律分布中的尾部事件——它出现的频率低，但一旦出现，量级完全不在你的日常经验范围内。</p>
<p><strong>安全攻击</strong>的分布同样如此。大多数攻击是低级的扫描和试探，但偶尔出现的高级持续性威胁（APT），其破坏力可能比所有低级攻击加起来还大。DDoS 攻击的流量分布、漏洞利用的影响范围、数据泄露的规模，全都呈现幂律特征。</p>
<p><strong>API 调用的延迟分布</strong>也不是正态的。大部分请求在毫秒级完成，但总有少量请求的延迟是平均值的几十倍甚至几百倍。这些长尾延迟在微服务架构中会被级联放大——如果一个请求链路涉及 10 个服务，每个服务有 1% 的概率出现长尾延迟，那么整个链路出现异常延迟的概率就接近 10%。这就是为什么 P99 延迟比平均延迟更值得关注。</p>
<h2>Taleb 的忠告：不要在肥尾世界里用薄尾思维</h2>
<p>纳西姆-塔勒布（Nassim Nicholas Taleb）大概是把幂律和肥尾思维推向公众视野最有力的人。他在《黑天鹅》和《反脆弱》中反复强调的核心观点其实很简单：<strong>我们的统计工具和风险模型大多建立在正态分布的假设之上，但现实世界中最重要的那些事件——金融崩盘、技术革命、地缘政治冲击——恰恰服从肥尾分布</strong>。</p>
<p>Taleb 区分了两类世界：「平均斯坦」（Mediocristan）和「极端斯坦」（Extremistan）。在平均斯坦里，单个样本对总体的影响有限——一个人的身高不会显著改变全国平均身高。但在极端斯坦里，单个样本可以改变一切——一个贝佐斯就能把一个城镇的「人均财富」拉高几个数量级。</p>
<p>这个区分对工程实践有深刻的启示：<strong>你的系统运行在哪个世界里？</strong> 如果是平均斯坦（比如用户的阅读时长分布），用均值和标准差做规划是合理的。但如果是极端斯坦（比如故障影响、流量峰值、安全事件），基于均值的规划就是在自欺欺人。</p>
<p>Taleb 还有一个很尖锐的批评：很多所谓的「风险管理」，本质上是在正态分布假设下计算出一个让人心安的数字，然后宣称风险「可控」。但真正的风险恰恰来自那些模型认为「不可能发生」的尾部事件。2008 年的全球金融危机，在许多银行的风控模型中是「25 个标准差」以外的事件——这在正态分布下比宇宙年龄还要不可能。但它就是发生了。</p>
<h2>对系统设计的启示</h2>
<p>理解幂律分布之后，系统设计的思路需要发生根本性的转变。</p>
<p><strong>第一，放弃对「平均值」的执念。</strong> 在幂律世界中，平均值是一个危险的统计量。它既不代表典型情况，也不代表极端情况，只是一个数学上的中间态。设计系统容量时，不应该基于平均负载，而应该基于你能承受的最大冲击。监控系统时，不应该只看平均延迟，而应该关注 P99 甚至 P999。</p>
<p><strong>第二，为极端事件预留不对称的资源。</strong> 在正态分布的世界里，你可以线性地扩展资源来应对增长。但在幂律世界里，极端事件的规模与普通事件之间不是线性关系，而是幂次关系。这意味着你需要某种「弹性储备」——平时看起来浪费，但在尾部事件到来时能救命。阿里的全链路压测和弹性伸缩体系，本质上就是在为幂律尾部做准备。</p>
<p><strong>第三，建立反脆弱机制。</strong> Taleb 提出的「反脆弱」概念在工程中非常实用。一个反脆弱的系统，不仅能在冲击中存活，还能从冲击中受益。具体到技术实践中，这意味着：混沌工程（主动注入故障来暴露脆弱点）、熔断降级（在极端负载下优雅退化而非全面崩溃）、以及故障复盘文化（从每次极端事件中提取系统性改进）。</p>
<p><strong>第四，重新定义「异常」。</strong> 在正态分布思维下，极端事件是「异常」，可以被忽略或排除。但在幂律分布下，极端事件虽然稀少，却是系统行为的核心组成部分。你不能把它们当作噪声过滤掉，而应该把它们当作信号认真对待。每一次线上的极端故障，都不应该被归结为「运气不好」，而应该被视为系统结构性问题的显性化。</p>
<p><strong>第五，接受不可预测性。</strong> 幂律分布的一个深刻含义是：你无法精确预测下一个极端事件的时间和规模。你能做的不是预测，而是确保系统在面对未知规模的冲击时仍能维持核心功能。这是一种从「预测-控制」到「感知-响应」的范式转换。</p>
<h2>结语：与不确定性共处</h2>
<p>正态分布给了我们确定性的幻觉：只要数据量够大，一切都会回归均值。幂律分布则告诉我们一个更诚实的现实：<strong>在复杂系统中，极端事件不是偶然的扰动，而是系统本身运行逻辑的必然产物</strong>。</p>
<p>理解幂律，不是为了恐惧极端事件，而是为了用正确的模型来认识世界。当你知道你面对的是一个肥尾世界时，你就不会再用均值来安慰自己，不会再用正态假设来低估风险，不会再在极端事件发生后说「谁能想到」。</p>
<p>你能想到。因为数学早已告诉你，在幂律的世界里，黑天鹅不是意外。它只是在等一个出场的时机。</p>
19:T72ad,<blockquote>
<p>字符串匹配是计算机科学中最基础也最重要的问题之一。从文本编辑器的查找替换，到搜索引擎的全文检索，再到网络安全中的入侵检测与敏感词过滤，字符串匹配算法无处不在。本文系统梳理从朴素匹配到 AC 自动机的完整算法演进脉络，深入分析各算法的设计思想、预处理策略与工程适用场景。</p>
</blockquote>
<h2>问题定义与分类</h2>
<p>字符串匹配问题的形式化定义如下：给定文本串 T（长度为 n）和模式串 P（长度为 m），在 T 中查找 P 出现的所有位置。</p>
<p>根据模式串的数量，字符串匹配问题可分为两类：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
<th>典型算法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单模式匹配</strong></td>
<td>在文本串中查找一个模式串</td>
<td>BF、BM、Horspool、Sunday、KMP、Rabin-Karp</td>
</tr>
<tr>
<td><strong>多模式匹配</strong></td>
<td>在文本串中同时查找多个模式串</td>
<td>AC 自动机、Wu-Manber</td>
</tr>
</tbody></table>
<p>单模式匹配算法又可按匹配方向进一步划分：</p>
<ul>
<li><strong>前缀匹配</strong>（从左到右）：KMP</li>
<li><strong>后缀匹配</strong>（从右到左）：BM、Horspool</li>
<li><strong>特定方向优化</strong>：Sunday（从左到右匹配，但利用窗口后一位字符跳转）</li>
<li><strong>基于哈希</strong>：Rabin-Karp（不依赖字符逐一比较）</li>
</ul>
<p>理解这一分类体系，是掌握各算法设计动机的前提。</p>
<h2>朴素匹配算法（Brute Force）</h2>
<p>朴素匹配是最直观的策略：将模式串与文本串逐位对齐，逐字符比较。一旦某个位置失配，模式串整体右移一位，重新从头比较。</p>
<pre><code>文本串 T:  A B C A B C A B D
模式串 P:  A B C A B D
                     ↑ 失配

文本串 T:  A B C A B C A B D
模式串 P:    A B C A B D
             ↑ 失配

... 逐位右移，重复比较
</code></pre>
<p>其核心逻辑可以用伪代码表示：</p>
<pre><code>BruteForce(T, P):
    for i = 0 to n - m:
        for j = 0 to m - 1:
            if T[i + j] != P[j]:
                break
        if j == m:
            report match at position i
</code></pre>
<p><strong>复杂度分析</strong>：最坏情况下，每次比较 m 个字符后失配，共需比较 (n - m + 1) 次，时间复杂度为 O(n * m)。典型的最坏用例是 T = &quot;AAAAAAAAB&quot;、P = &quot;AAAAB&quot;，每次比较到最后一位才失配。</p>
<p>朴素算法的核心缺陷在于：<strong>失配后丢弃了所有已匹配的信息</strong>，导致大量冗余比较。后续的所有优化算法，本质上都在解决同一个问题——如何利用已知信息，在失配时尽可能多地跳过无效比较。</p>
<h2>基于后缀匹配的算法族</h2>
<h3>BM 算法：坏字符规则与好后缀规则</h3>
<p>Boyer-Moore（BM）算法由 Robert S. Boyer 和 J Strother Moore 于 1977 年提出，是实际工程中应用最广泛的单模式匹配算法之一。Unix/Linux 系统中的 <code>grep</code> 命令在内部实现中即采用了 BM 算法的变体。</p>
<p>BM 算法的核心设计思想有两点：<strong>从右到左比较</strong>（后缀匹配），以及<strong>通过两条跳转规则最大化移动距离</strong>。</p>
<h4>匹配方向</h4>
<p>与朴素算法从左到右逐字符比较不同，BM 将模式串与文本串对齐后，从模式串的末尾开始向左比较。这一设计的直觉来源是：如果文本串中某个字符完全不出现在模式串中，从右侧发现这一点后可以直接跳过整个模式串长度，而从左侧发现则只能跳过一位。</p>
<h4>坏字符规则（Bad Character Rule）</h4>
<p>当从右向左比较过程中，文本串中某个字符 c 与模式串中对应位置的字符不匹配时，该字符 c 即为&quot;坏字符&quot;。此时按以下策略决定移动距离：</p>
<ol>
<li><strong>字符 c 不在模式串中出现</strong>：模式串直接跳过整个窗口，移动距离为当前比较位置到模式串起始位置的距离加一。</li>
<li><strong>字符 c 在模式串中出现</strong>：将模式串向右滑动，使模式串中最右侧的字符 c 与文本串中的坏字符对齐。</li>
</ol>
<pre><code>文本串: ... X C B A B ...
模式串:     A B C A B
                ↑ 比较位置 j=2, T 中字符为 &#39;B&#39;
                  &#39;B&#39; 在模式串中最右出现位置为 j=4
                  → 但此时对齐会导致左移，取 1

坏字符规则实质：skip = j - last_occurrence(c)
若 skip &lt;= 0，则至少移动 1 位
</code></pre>
<p>预处理阶段需要构建 <strong>MakeSkip 表</strong>（坏字符表），记录字符表中每个字符在模式串中最后一次出现的位置。未出现的字符标记为 -1。时间复杂度为 O(|Sigma| + m)，其中 |Sigma| 为字符集大小。</p>
<h4>好后缀规则（Good Suffix Rule）</h4>
<p>当从右到左比较的过程中，已经有若干字符匹配成功（形成&quot;好后缀&quot;），但在某个位置失配时，好后缀规则提供了另一种跳转策略。设好后缀为 t，则有三种情况：</p>
<p><strong>情况一：模式串中存在另一个子串等于好后缀 t。</strong> 将模式串右移，使该子串与好后缀在文本串中的位置对齐。需要注意的是，该子串的前一个字符必须与好后缀前的字符不同，否则移动后仍会在同一位置失配。</p>
<pre><code>模式串: C A B C A B
好后缀:       A B
              ↑ 模式串中 CAB 的 AB 可以对齐
移动后: ... C A B C A B
</code></pre>
<p><strong>情况二：模式串中没有完整的子串匹配好后缀，但模式串的某个前缀等于好后缀的某个后缀。</strong> 此时将模式串右移，使该前缀与好后缀的对应后缀对齐。</p>
<pre><code>模式串: A B C D A B
好后缀:     D A B
模式串前缀 AB = 好后缀后缀 AB
→ 将模式串的前缀 AB 与好后缀的后缀 AB 对齐
</code></pre>
<p><strong>情况三：模式串中既无子串匹配好后缀，前缀也无法匹配好后缀的任何后缀。</strong> 此时模式串直接移动 m 位。</p>
<p>预处理阶段需要构建 <strong>MakeShift 表</strong>（好后缀表），记录每种好后缀情况下的移动距离。该表的构建较为复杂，通常借助后缀数组或前缀函数辅助完成，时间复杂度为 O(m)。</p>
<h4>BM 的移动策略</h4>
<p>每次失配时，BM 算法同时计算坏字符规则和好后缀规则给出的移动距离，取二者中的<strong>较大值</strong>作为实际移动距离。这是 BM 算法高效的关键——两条规则互相补充，确保了在各种情况下都能获得尽可能大的跳转。</p>
<p><strong>复杂度分析</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>最好情况</td>
<td>O(n / (m + 1))</td>
<td>每次比较第一个字符就跳过整个模式串</td>
</tr>
<tr>
<td>最坏情况</td>
<td>O(n * m)</td>
<td>退化为朴素匹配，如 T = &quot;AAAA...&quot;、P = &quot;AAA&quot;</td>
</tr>
<tr>
<td>平均情况</td>
<td>亚线性</td>
<td>实际文本中表现优异，通常远快于 O(n)</td>
</tr>
</tbody></table>
<p>BM 算法在处理自然语言文本时尤为高效，因为坏字符规则在字符集较大时跳转距离更长。</p>
<h3>Horspool 算法：BM 的工程化简化</h3>
<p>Horspool 算法（1980）是 BM 算法的简化版本。它的核心观察是：BM 的好后缀规则实现复杂，而在实际应用中，坏字符规则已经能提供足够好的跳转效果。因此 Horspool 直接舍弃了好后缀规则，仅保留并改进了坏字符规则。</p>
<p>Horspool 的改进在于：<strong>始终以当前匹配窗口中文本串最末尾的字符</strong>作为坏字符参考，而非 BM 中以实际失配位置的字符作为参考。无论在哪个位置失配，都用窗口最右侧对应的文本字符来查表决定移动距离。</p>
<pre><code>文本串: ... A B C D E F ...
模式串:     X X X X
                  ↑ 无论在哪失配，都以 D（窗口最末字符）查表
</code></pre>
<p><strong>预处理</strong>：构建一个移动距离表，记录每个字符在模式串中距离最右端的距离。对于模式串 P[0..m-1]：</p>
<pre><code>shift[c] = m                           （c 不在 P[0..m-2] 中出现）
shift[c] = m - 1 - max{j : P[j] = c, 0 &lt;= j &lt;= m-2}  （c 在 P[0..m-2] 中出现）
</code></pre>
<p>注意最后一个字符 P[m-1] 不参与计算，因为它就是窗口末尾本身。</p>
<p><strong>示例</strong>：模式串 P = &quot;BARBER&quot;，m = 6</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>B</th>
<th>A</th>
<th>R</th>
<th>E</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td>shift</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>6</td>
</tr>
</tbody></table>
<p>B 在位置 0 和 4 出现（排除最后位置 5），最右为位置 4，shift = 6 - 1 - 4 = 1。</p>
<p>Horspool 算法的最坏时间复杂度仍为 O(n * m)，但在实际应用中的平均性能与 BM 非常接近，且实现简洁得多，是许多工程场景下的首选。</p>
<h3>Sunday 算法：面向实际场景的进一步优化</h3>
<p>Sunday 算法由 Daniel M. Sunday 于 1990 年提出，从设计理念上看，它走了一条与 BM/Horspool 不同的路径：<strong>匹配方向从左到右</strong>（与朴素算法一致），但在失配时利用了一个独特的观察。</p>
<p>Sunday 的核心思想：当匹配失败时，不关注失配位置本身，而是关注<strong>文本串中参与当前匹配窗口的最末位字符的下一位字符</strong>，即 T[i + m]（i 为当前窗口起始位置）。</p>
<p>判断逻辑：</p>
<ol>
<li><strong>T[i + m] 不在模式串中出现</strong>：模式串直接跳过 m + 1 位（因为包含该字符的任何对齐都不可能匹配）。</li>
<li><strong>T[i + m] 在模式串中出现</strong>：将模式串向右移动，使模式串中最右侧的该字符与 T[i + m] 对齐。</li>
</ol>
<pre><code>文本串: A B C E D A B C D
模式串: A B C D
            ↑ 失配（C != D）
关注 T[i+m] = T[4] = &#39;E&#39;
&#39;E&#39; 不在模式串中 → 跳过 m+1 = 5 位

文本串: A B C E D A B C D
模式串:           A B C D
                  → 匹配成功
</code></pre>
<p><strong>预处理</strong>：与 Horspool 类似，构建一个移动距离表。不同的是，Sunday 的表需要包含模式串的最后一个字符（因为参考的是窗口外的下一个字符）：</p>
<pre><code>shift[c] = m + 1                       （c 不在 P 中出现）
shift[c] = m - max{j : P[j] = c, 0 &lt;= j &lt;= m-1}  （c 在 P 中出现）
</code></pre>
<p>Sunday 算法的优势在于最大跳转距离为 m + 1（比 BM 的 m 还多一位），且实现极其简洁。在短模式串和字符集较大的场景下（如英文文本搜索），Sunday 通常表现最优。但在最坏情况下（如二进制文本中搜索重复模式），其复杂度同样退化为 O(n * m)。</p>
<h3>后缀匹配算法族小结</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>匹配方向</th>
<th>跳转依据</th>
<th>预处理复杂度</th>
<th>实现复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>BM</td>
<td>右→左</td>
<td>坏字符 + 好后缀</td>
<td>O(|Sigma| + m)</td>
<td>较高</td>
</tr>
<tr>
<td>Horspool</td>
<td>右→左</td>
<td>窗口末尾字符</td>
<td>O(|Sigma| + m)</td>
<td>低</td>
</tr>
<tr>
<td>Sunday</td>
<td>左→右</td>
<td>窗口下一位字符</td>
<td>O(|Sigma| + m)</td>
<td>最低</td>
</tr>
</tbody></table>
<p>三者的共性是：都通过预处理模式串，在失配时尽可能地跳过更多的比较位置。差异在于跳转参考字符的选取策略和实现复杂度之间的权衡。</p>
<h2>基于前缀匹配的算法</h2>
<h3>KMP 算法：部分匹配表与无回溯匹配</h3>
<p>Knuth-Morris-Pratt（KMP）算法由 Donald Knuth、James Morris 和 Vaughan Pratt 于 1977 年提出，与 BM 算法同年发表，但走了一条完全不同的技术路线。KMP 的设计目标非常明确：<strong>文本串指针永远不回溯</strong>。</p>
<p>在朴素算法中，每次失配后文本串指针要退回到本次匹配开始位置的下一位。KMP 的核心洞察是：当在位置 j 处失配时，模式串的前 j 个字符（P[0..j-1]）已经与文本串匹配成功。如果 P[0..j-1] 自身存在&quot;前缀等于后缀&quot;的结构，那么可以直接将模式串滑动到该前缀位置继续比较，而无需回退文本串指针。</p>
<h4>next 数组（部分匹配表）</h4>
<p>next 数组（也称失败函数或部分匹配表）是 KMP 算法的核心数据结构。对于模式串 P，next[j] 的含义是：P[0..j-1] 这个子串中，最长的&quot;真前缀等于真后缀&quot;的长度。</p>
<p>以模式串 P = &quot;ABCABD&quot; 为例：</p>
<table>
<thead>
<tr>
<th>j</th>
<th>子串</th>
<th>最长公共前后缀</th>
<th>next[j]</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>&quot;&quot;</td>
<td>无</td>
<td>-1（特殊标记）</td>
</tr>
<tr>
<td>1</td>
<td>&quot;A&quot;</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>&quot;AB&quot;</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>&quot;ABC&quot;</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>&quot;ABCA&quot;</td>
<td>&quot;A&quot;</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>&quot;ABCAB&quot;</td>
<td>&quot;AB&quot;</td>
<td>2</td>
</tr>
</tbody></table>
<h4>next 数组的构建过程</h4>
<p>next 数组的构建本身就是一次&quot;模式串对自身的匹配&quot;过程，其思想与 KMP 匹配过程完全一致：</p>
<pre><code>BuildNext(P):
    m = length(P)
    next[0] = -1
    j = 0, k = -1
    while j &lt; m - 1:
        if k == -1 or P[j] == P[k]:
            j++, k++
            next[j] = k
        else:
            k = next[k]    // 利用已计算的 next 值回溯
</code></pre>
<p>这段逻辑的关键在于 <code>k = next[k]</code> 这一步。当 P[j] 与 P[k] 不匹配时，不是简单地将 k 重置为 0，而是利用 next 数组已经计算好的部分，跳转到下一个可能匹配的位置。这正是 KMP 思想在预处理阶段的自我应用。</p>
<p>构建过程的时间复杂度为 O(m)，因为 j 单调递增且 k 的回退次数有上界。</p>
<h4>匹配过程</h4>
<pre><code>KMP_Match(T, P):
    i = 0, j = 0
    while i &lt; n and j &lt; m:
        if j == -1 or T[i] == P[j]:
            i++, j++
        else:
            j = next[j]    // 文本串指针 i 不回溯
    if j == m:
        report match at position i - m
</code></pre>
<p>匹配过程中，文本串指针 i 始终向前移动，永不回溯。每次失配时，仅调整模式串指针 j 到 next[j] 的位置，相当于将模式串向右滑动 j - next[j] 位。</p>
<p><strong>复杂度分析</strong>：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>预处理（构建 next）</td>
<td>O(m)</td>
<td>O(m)</td>
</tr>
<tr>
<td>匹配</td>
<td>O(n)</td>
<td>-</td>
</tr>
<tr>
<td>总计</td>
<td>O(n + m)</td>
<td>O(m)</td>
</tr>
</tbody></table>
<p>KMP 的时间复杂度是严格的 O(n + m)，不存在退化为 O(n * m) 的最坏情况，这是它相对于 BM 系列算法的理论优势。然而在实际工程中，BM 及其变体在大字符集文本上的平均表现往往优于 KMP，因为 BM 的跳转距离通常更大。</p>
<h4>next 数组的优化</h4>
<p>标准 next 数组存在一个可优化的场景：当 P[j] 失配后跳转到 next[j] = k，若 P[k] == P[j]，则在位置 k 必然还会失配，这次跳转是浪费的。优化版本在构建时做如下修正：</p>
<pre><code>if P[j] == P[k]:
    next[j] = next[k]    // 跳过必然失败的比较
else:
    next[j] = k
</code></pre>
<p>该优化不改变渐进复杂度，但能减少实际比较次数。</p>
<h2>基于哈希的匹配</h2>
<h3>Rabin-Karp 算法：滚动哈希</h3>
<p>Rabin-Karp（RK）算法由 Michael Rabin 和 Richard Karp 于 1987 年提出，采用了一种与上述算法截然不同的思路：不逐字符比较，而是<strong>比较哈希值</strong>。</p>
<h4>基本思想</h4>
<p>将模式串 P 计算出一个哈希值 h(P)，然后对文本串 T 中每个长度为 m 的子串计算哈希值，与 h(P) 比较。若哈希值相等，再逐字符验证以排除哈希冲突。</p>
<p>朴素地实现这一思想，每个子串的哈希计算需要 O(m) 时间，总复杂度仍为 O(n * m)，并无改善。RK 算法的精妙之处在于<strong>滚动哈希</strong>（Rolling Hash）。</p>
<h4>滚动哈希</h4>
<p>选取一个基数 d（通常取字符集大小）和一个素数 q（用于取模防止溢出），定义哈希函数：</p>
<pre><code>h(S[i..i+m-1]) = (S[i] * d^(m-1) + S[i+1] * d^(m-2) + ... + S[i+m-1]) mod q
</code></pre>
<p>当窗口从 T[i..i+m-1] 滑动到 T[i+1..i+m] 时，新哈希值可以通过 O(1) 的算术运算从旧值递推得出：</p>
<pre><code>h(T[i+1..i+m]) = (d * (h(T[i..i+m-1]) - T[i] * d^(m-1)) + T[i+m]) mod q
</code></pre>
<p>即：移除最高位字符的贡献，整体左移一位（乘以 d），加上新进入窗口的字符。整个过程仅涉及常数次乘法、加法和取模运算。</p>
<h4>哈希冲突处理</h4>
<p>当 h(T[i..i+m-1]) == h(P) 时，存在两种可能：真正匹配，或哈希冲突。因此必须进行逐字符验证。选择合适的素数 q 可以降低冲突概率。在理论分析中，若 q 足够大且随机选取，冲突概率为 O(1/q)。</p>
<p><strong>复杂度分析</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>期望情况</td>
<td>O(n + m)</td>
<td>冲突次数少，验证开销可忽略</td>
</tr>
<tr>
<td>最坏情况</td>
<td>O(n * m)</td>
<td>所有窗口哈希均冲突（如 q 选择不当）</td>
</tr>
</tbody></table>
<h4>RK 的独特优势</h4>
<p>RK 算法在单模式匹配中并不比 BM/KMP 更优，但它有一个独特的应用场景：<strong>多模式串的同时匹配</strong>。当需要在文本中同时搜索 k 个等长的模式串时，可以将所有模式串的哈希值存入哈希表，每次窗口滑动后查表比较，时间复杂度为 O(n + k * m)，远优于逐一匹配。此外，RK 算法天然适合二维模式匹配（在矩阵中搜索子矩阵）等扩展场景。</p>
<h2>多模式匹配</h2>
<h3>AC 自动机：Trie + 失败指针</h3>
<p>前面讨论的算法都针对单模式匹配问题。当需要在一个文本串中同时搜索多个模式串时（如敏感词过滤需要同时检测数千个关键词），逐一应用单模式算法的效率极低。Aho-Corasick（AC）自动机正是为解决这一问题而设计的。</p>
<p>AC 自动机由 Alfred Aho 和 Margaret Corasick 于 1975 年提出，是多模式匹配的经典算法。其核心思想是将多个模式串构建为一个有限状态自动机，使文本串只需扫描一遍即可找到所有模式串的所有出现位置。</p>
<h4>三个核心函数</h4>
<p>AC 自动机由三个函数协同工作：</p>
<p><strong>1. goto 函数（转移函数）</strong></p>
<p>goto 函数本质上是一棵 <strong>Trie 树</strong>（字典树），由所有模式串构建而成。Trie 的每条边代表一个字符，从根节点到某个节点的路径表示某个模式串的前缀。</p>
<p>以模式串集合 {&quot;he&quot;, &quot;she&quot;, &quot;his&quot;, &quot;hers&quot;} 为例，构建的 Trie 结构如下：</p>
<pre><code>        root
       /    \
      h      s
     / \      \
    e   i      h
    |   |      |
    r   s      e
    |
    s
</code></pre>
<p>goto(s, c) 表示在状态 s 下输入字符 c 后转移到的下一个状态。若当前状态没有字符 c 对应的子节点，则 goto 返回失败（fail）。根节点是特殊的：对于根节点，任何不匹配的字符都转移回根节点本身（而非失败），这保证了自动机始终可以继续运行。</p>
<p><strong>2. failure 函数（失败指针）</strong></p>
<p>failure 函数是 AC 自动机的精髓所在，其设计理念与 KMP 的 next 数组一脉相承。当在某个状态 s 下无法通过 goto 函数继续前进时，failure(s) 指向另一个状态 s&#39;，使得从根到 s&#39; 的路径所代表的字符串是从根到 s 的路径所代表的字符串的<strong>最长真后缀</strong>，且 s&#39; 是 Trie 中的一个有效状态。</p>
<p>直观理解：failure 指针利用了&quot;已匹配部分的后缀可能是另一个模式串的前缀&quot;这一信息，避免了文本串指针的回溯。</p>
<p>以上例为例，部分 failure 指针：</p>
<ul>
<li>状态 &quot;sh&quot; 的 failure 指向状态 &quot;h&quot;（因为 &quot;h&quot; 是 &quot;sh&quot; 的最长真后缀且在 Trie 中存在）</li>
<li>状态 &quot;she&quot; 的 failure 指向状态 &quot;he&quot;（因为 &quot;he&quot; 是 &quot;she&quot; 的最长真后缀且在 Trie 中存在）</li>
</ul>
<p><strong>3. output 函数（输出函数）</strong></p>
<p>output(s) 记录在状态 s 处可以报告的所有匹配模式串。一个状态可能对应多个输出，因为到达某个状态时，不仅该状态本身可能对应一个完整的模式串，其 failure 链上的祖先状态也可能对应完整的模式串。</p>
<p>例如，到达状态 &quot;she&quot; 时，output 不仅包含 &quot;she&quot;，还需沿 failure 链检查：failure(&quot;she&quot;) = &quot;he&quot;，而 &quot;he&quot; 也是一个完整模式串，因此 output(&quot;she&quot;) = {&quot;she&quot;, &quot;he&quot;}。</p>
<h4>构建过程</h4>
<p>AC 自动机的构建分为两个阶段：</p>
<p><strong>阶段一：构建 Trie 树（goto 函数 + 初始 output 函数）</strong></p>
<p>将所有模式串逐一插入 Trie 树。每插入一个完整的模式串后，在其终止节点的 output 集合中记录该模式串。时间复杂度为 O(所有模式串总长度之和)。</p>
<p><strong>阶段二：BFS 构建 failure 指针（同时完善 output 函数）</strong></p>
<p>使用广度优先搜索（BFS）逐层计算 failure 指针：</p>
<pre><code>BuildFailure():
    queue = new Queue()

    // 第一层节点的 failure 指向根
    for each child c of root:
        failure(c) = root
        queue.enqueue(c)

    // BFS 逐层构建
    while queue is not empty:
        current = queue.dequeue()
        for each child node via character a:
            // 核心逻辑：沿 failure 链找可行转移
            state = failure(current)
            while state != root and goto(state, a) == fail:
                state = failure(state)
            failure(child) = goto(state, a)   // 若 goto(root, a) 也 fail，则为 root

            // 合并 output：当前节点的 output 需包含 failure 指向节点的 output
            output(child) = output(child) ∪ output(failure(child))

            queue.enqueue(child)
</code></pre>
<p>BFS 保证了在计算某个节点的 failure 指针时，其所有更浅层节点的 failure 指针已经计算完成。合并 output 的操作保证了匹配过程中不会遗漏任何模式串。</p>
<h4>匹配过程</h4>
<pre><code>AC_Match(T):
    state = root
    for i = 0 to n - 1:
        while state != root and goto(state, T[i]) == fail:
            state = failure(state)
        state = goto(state, T[i])
        if state == fail:
            state = root

        // 报告当前状态的所有匹配
        temp = state
        while temp != root:
            if output(temp) is not empty:
                report output(temp) at position i
            temp = failure(temp)
</code></pre>
<p>文本串的每个字符只被读取一次，指针始终向前。对于每个位置，沿 failure 链检查所有可能的匹配输出。</p>
<p><strong>复杂度分析</strong>：</p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>构建 Trie</td>
<td>O(L)</td>
<td>L 为所有模式串总长度之和</td>
</tr>
<tr>
<td>构建 failure</td>
<td>O(L)</td>
<td>BFS 遍历所有节点</td>
</tr>
<tr>
<td>匹配</td>
<td>O(n + z)</td>
<td>n 为文本长度，z 为匹配结果总数</td>
</tr>
<tr>
<td>空间</td>
<td>O(L * |Sigma|)</td>
<td>可通过链表或哈希优化</td>
</tr>
</tbody></table>
<h4>工程应用场景</h4>
<p>AC 自动机在工业界有广泛的应用：</p>
<ul>
<li><strong>敏感词过滤</strong>：将敏感词库构建为 AC 自动机，对用户输入文本进行一次扫描即可检出所有敏感词。典型的敏感词库包含数万个词条，使用 AC 自动机可以在毫秒级完成检测。</li>
<li><strong>病毒特征码扫描</strong>：杀毒软件将病毒特征码库构建为 AC 自动机，扫描文件时一次遍历即可匹配所有已知特征。</li>
<li><strong>网络入侵检测系统（IDS）</strong>：如 Snort，利用 AC 自动机在网络数据包中实时检测攻击特征。</li>
<li><strong>搜索引擎</strong>：对查询词进行多关键词高亮标注。</li>
<li><strong>DNA 序列分析</strong>：在基因组序列中搜索多个目标片段。</li>
</ul>
<h2>算法选型指南</h2>
<p>字符串匹配算法的选型不存在&quot;银弹&quot;，需要根据具体场景的特征进行权衡：</p>
<h3>复杂度对比</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>预处理时间</th>
<th>匹配时间（最优）</th>
<th>匹配时间（最差）</th>
<th>空间</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Brute Force</td>
<td>无</td>
<td>O(n)</td>
<td>O(n * m)</td>
<td>O(1)</td>
<td>极短模式串、一次性匹配</td>
</tr>
<tr>
<td>BM</td>
<td>O(|Sigma| + m)</td>
<td>O(n / m)</td>
<td>O(n * m)</td>
<td>O(|Sigma| + m)</td>
<td>长文本、大字符集</td>
</tr>
<tr>
<td>Horspool</td>
<td>O(|Sigma| + m)</td>
<td>O(n / m)</td>
<td>O(n * m)</td>
<td>O(|Sigma|)</td>
<td>BM 的工程简化替代</td>
</tr>
<tr>
<td>Sunday</td>
<td>O(|Sigma| + m)</td>
<td>O(n / (m+1))</td>
<td>O(n * m)</td>
<td>O(|Sigma|)</td>
<td>短模式串、交互式搜索</td>
</tr>
<tr>
<td>KMP</td>
<td>O(m)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>需要最坏保证的场景</td>
</tr>
<tr>
<td>Rabin-Karp</td>
<td>O(m)</td>
<td>O(n)</td>
<td>O(n * m)</td>
<td>O(1)</td>
<td>多模式等长匹配、二维匹配</td>
</tr>
<tr>
<td>AC 自动机</td>
<td>O(L)</td>
<td>O(n + z)</td>
<td>O(n + z)</td>
<td>O(L * |Sigma|)</td>
<td>多模式匹配</td>
</tr>
</tbody></table>
<h3>场景决策路径</h3>
<p><strong>单模式短文本（m 较小，n 较小）</strong>：朴素算法或 Sunday 算法。预处理开销在短文本上不划算，Sunday 的实现简单且跳转距离大。</p>
<p><strong>单模式长文本（大字符集，如自然语言）</strong>：BM 算法或 Horspool 算法。大字符集意味着坏字符规则的跳转距离更大，BM 系列算法的亚线性性能优势最为明显。Linux 的 <code>grep</code> 正是基于这一判断选择了 BM 变体。</p>
<p><strong>单模式长文本（小字符集，如 DNA 序列）</strong>：KMP 算法。小字符集下 BM 系列的跳转距离有限，KMP 的 O(n) 最坏保证更有价值。</p>
<p><strong>需要严格最坏复杂度保证</strong>：KMP 算法。在安全相关场景中（如正则表达式引擎的实现），算法的最坏性能不可接受为 O(n * m)，此时 KMP 是唯一的选择。</p>
<p><strong>多个等长模式串</strong>：Rabin-Karp 算法。通过哈希表存储所有模式串的哈希值，一次滚动扫描即可完成。</p>
<p><strong>大规模多模式匹配</strong>：AC 自动机。模式串数量从几十到数万，AC 自动机的匹配时间与模式串数量无关（仅与文本长度和匹配结果数相关），是唯一可行的方案。</p>
<h3>工程实践中的补充考量</h3>
<p>算法选择不仅取决于渐进复杂度，还需考虑以下工程因素：</p>
<ul>
<li><strong>缓存友好性</strong>：BM/Horspool 的跳跃式访问模式对 CPU 缓存不太友好，KMP 的顺序访问模式在某些场景下可能因缓存命中率更高而表现更好。</li>
<li><strong>预处理开销</strong>：如果文本很短或匹配只执行一次，预处理的固定开销可能超过它带来的收益。此时朴素算法反而最优。</li>
<li><strong>实现复杂度与可维护性</strong>：BM 的完整实现（包括好后缀规则）相当复杂，Horspool 和 Sunday 在牺牲极少理论性能的前提下大幅降低了实现难度。</li>
<li><strong>并行化潜力</strong>：Rabin-Karp 的哈希计算具有天然的可并行性，适合 GPU 或 SIMD 加速。</li>
</ul>
<p>字符串匹配算法的演进史，实质上是一部<strong>信息利用效率</strong>的进化史。从朴素算法的&quot;零信息利用&quot;，到 KMP/BM 的&quot;利用已匹配字符信息&quot;，再到 AC 自动机的&quot;利用多模式串间的共享前缀信息&quot;，每一步跨越都建立在对问题结构更深入的理解之上。理解这些算法的设计思想，远比记忆它们的具体实现更有价值。</p>
5:["$","article",null,{"className":"min-h-screen","children":["$","div",null,{"className":"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8","children":["$","div",null,{"className":"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12","children":[["$","header",null,{"className":"mb-8","children":[["$","nav",null,{"className":"flex items-center gap-1 text-sm mb-4","children":[["$","$L13",null,{"href":"/blog/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"博客"}],["$","span",null,{"className":"text-gray-300","children":"/"}],["$","$L13",null,{"href":"/blog/category/engineering/page/1","className":"text-gray-500 hover:text-blue-600 transition-colors","children":"Engineering"}],"$undefined"]}],["$","div",null,{"className":"flex items-center mb-6","children":["$","div",null,{"className":"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal","children":[["$","svg",null,{"className":"w-4 h-4 mr-2 text-gray-400","fill":"none","stroke":"currentColor","viewBox":"0 0 24 24","children":["$","path",null,{"strokeLinecap":"round","strokeLinejoin":"round","strokeWidth":2,"d":"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"}]}],["$","time",null,{"dateTime":"2024-07-25","children":"2024年07月25日"}]]}]}],["$","h1",null,{"className":"text-4xl font-bold text-gray-900 mb-6 text-center","children":"计算几何基础：点在多边形内判定算法详解"}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-6 justify-center","children":[["$","$L13","算法",{"href":"/blog/tag/%E7%AE%97%E6%B3%95/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"算法"}],["$","$L13","计算几何",{"href":"/blog/tag/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"计算几何"}],["$","$L13","多边形",{"href":"/blog/tag/%E5%A4%9A%E8%BE%B9%E5%BD%A2/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"多边形"}],["$","$L13","GIS",{"href":"/blog/tag/GIS/page/1/","className":"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors","children":"GIS"}]]}]]}],["$","div",null,{"className":"max-w-5xl mx-auto","children":["$","$L14",null,{"content":"$15"}]}],["$","$10",null,{"fallback":["$","div",null,{"className":"mt-12 pt-8 border-t border-gray-200","children":"加载导航中..."}],"children":["$","$L16",null,{"globalNav":{"prev":{"slug":"science/complexity/涌现：为什么整体大于部分之和","title":"涌现：为什么整体大于部分之和","description":"蚁群没有指挥官却能建造复杂巢穴，神经元没有意识却产生了思维，简单规则的局部交互如何产生全局的复杂秩序？涌现是复杂系统最迷人也最反直觉的特性。","pubDate":"2024-06-20","tags":["复杂系统","涌现","自组织","系统思维"],"heroImage":"$undefined","content":"$17"},"next":{"slug":"science/complexity/幂律分布：为什么极端事件比你想象的更常见","title":"幂律分布：为什么极端事件比你想象的更常见","description":"正态分布训练了我们对「平均值」的直觉，但现实世界中大量现象服从幂律分布——财富、城市规模、网络连接、系统故障。理解幂律，就是理解为什么黑天鹅不是意外。","pubDate":"2024-08-12","tags":["幂律分布","复杂系统","风险管理","统计学"],"heroImage":"$undefined","content":"$18"}},"tagNav":{"算法":{"prev":{"slug":"engineering/algorithm/字符串匹配算法全景：从BM到AC自动机的演进之路","title":"字符串匹配算法全景：从BM到AC自动机的演进之路","description":"系统梳理字符串模式匹配算法族：BM、Horspool、Sunday、KMP、KR及AC自动机，涵盖算法原理、预处理策略、复杂度分析与工程选型","pubDate":"2023-09-20","tags":["算法","字符串匹配","KMP","AC自动机"],"heroImage":"$undefined","content":"$19"},"next":null},"计算几何":{"prev":null,"next":null},"多边形":{"prev":null,"next":null},"GIS":{"prev":null,"next":null}}}]}],["$","$L1a",null,{}]]}]}]}]
8:null
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
a:{"metadata":[["$","title","0",{"children":"计算几何基础：点在多边形内判定算法详解 - Skyfalling Blog"}],["$","meta","1",{"name":"description","content":"系统讲解点在多边形内判定的经典算法——射线法与回转数法，涵盖边界情况处理、算法优化及在GIS与图形学中的工程应用"}],["$","meta","2",{"property":"og:title","content":"计算几何基础：点在多边形内判定算法详解"}],["$","meta","3",{"property":"og:description","content":"系统讲解点在多边形内判定的经典算法——射线法与回转数法，涵盖边界情况处理、算法优化及在GIS与图形学中的工程应用"}],["$","meta","4",{"property":"og:type","content":"article"}],["$","meta","5",{"property":"article:published_time","content":"2024-07-25"}],["$","meta","6",{"property":"article:author","content":"Skyfalling"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"计算几何基础：点在多边形内判定算法详解"}],["$","meta","9",{"name":"twitter:description","content":"系统讲解点在多边形内判定的经典算法——射线法与回转数法，涵盖边界情况处理、算法优化及在GIS与图形学中的工程应用"}],["$","link","10",{"rel":"shortcut icon","href":"/favicon.png"}],["$","link","11",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}],["$","link","12",{"rel":"icon","href":"/favicon.png"}],["$","link","13",{"rel":"apple-touch-icon","href":"/favicon.png"}]],"error":null,"digest":"$undefined"}
12:{"metadata":"$a:metadata","error":null,"digest":"$undefined"}

<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/9e71a912f7c3be7c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-51baccc14cf1da9e.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>服务注册与发现 - Skyfalling Blog</title><meta name="description" content="我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。"/><meta property="og:title" content="服务注册与发现"/><meta property="og:description" content="我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-03-23"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="服务注册与发现"/><meta name="twitter:description" content="我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-03-23">2024年03月23日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">服务注册与发现</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/page/1/">微服务架构</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/page/1/">技术专题</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><h2>1 微服务的注册与发现 <a href="#scroller-1" id="scroller-1"></a></h2>
<p>我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。</p>
<p>微服务注册与发现类似于生活中的&quot;电话通讯录&quot;的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。</p>
<p>步骤如下：</p>
<p>1、你先要把&quot;好友某某&quot;记录在通讯录中。</p>
<p>2、拨打电话的时候通过通讯录中找到&quot;好友某某&quot;，并拨通回电话。</p>
<p>3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。</p>
<p>从这个过程中我们看到了一些特点：</p>
<p>1、把 &quot;好友某某&quot; 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。</p>
<p>2、后续我们通过&quot;好友某某&quot;就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。</p>
<p>而我们微服务架构中的服务注册与发现结构如下图所示：</p>
<p><img src="/images/blog/tech/microservice/image_6_1.png" alt="image_6_1.png"></p>
<p>图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：</p>
<p>provider - 服务提供者</p>
<p>consumer - 服务消费者</p>
<p>register center - 注册中心</p>
<p>它们之间的关系大致如下：</p>
<p>1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。</p>
<p>2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。</p>
<p>3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。</p>
<p>优点如下：</p>
<p>1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响</p>
<p>2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响</p>
<p>3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。</p>
<p>从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。</p>
<h3>1.1 服务注册 <a href="#scroller-2" id="scroller-2"></a></h3>
<p>如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。</p>
<p><img src="/images/blog/tech/microservice/image_6_2.png" alt="image_6_2.png"></p>
<p>服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：</p>
<p>1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。</p>
<p>2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。</p>
<p>3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。</p>
<p>可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。</p>
<p><img src="/images/blog/tech/microservice/image_6_3.png" alt="image_6_3.png"></p>
<h3>1.2 服务发现 <a href="#scroller-3" id="scroller-3"></a></h3>
<p>服务发现实际就是我们查询已经注册好的服务提供者，比如 p-&gt;p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，</p>
<p>返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。</p>
<p>这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。</p>
<p>服务发现的方式一般有两种：</p>
<p>1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。</p>
<p>2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。</p>
<h3>1.3 注册中心 <a href="#scroller-4" id="scroller-4"></a></h3>
<p>注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。</p>
<p>服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。</p>
<p>主要的检查方式包括：</p>
<p>1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。</p>
<p>2、注册中心主动检查服务Provider接口。</p>
<p>综合我们前面的内容，可以总结下注册中心有如下几种能力：</p>
<p>1、高可用</p>
<p>这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的</p>
<p>2、可视化操作</p>
<p>常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。</p>
<p>3、高效运维</p>
<p>注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。</p>
<p>4、权限控制</p>
<p>数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求</p>
<p>5、服务注册推、拉能力</p>
<p>这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。</p>
<p><img src="/images/blog/tech/microservice/image_6_4.png" alt="image_6_4.png"></p>
<h2>2 现下的主流注册中心 <a href="#scroller-5" id="scroller-5"></a></h2>
<h3>2.1 Eureka <a href="#scroller-6" id="scroller-6"></a></h3>
<h4>2.1.1 介绍 <a href="#scroller-7" id="scroller-7"></a></h4>
<p>Eureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。</p>
<p>目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 <a href="https://github.com/Netflix/eureka/wiki">Eureka 2.0已经停止维护</a>，所以新的微服务架构设计中，不再建议使用。</p>
<p>Spring Cloud Netflix主要分为两个部分：</p>
<p>1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。</p>
<p>2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。</p>
<p><img src="/images/blog/tech/microservice/image_6_5.png" alt="image_6_5.png"></p>
<p>Eureka有比较友好的管理界面，如上图所示：</p>
<p>1、System Status：显示当前Eureka Server信息。</p>
<p>2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。</p>
<p>3、General Info：基本信息，如cpu、内存、环境等。</p>
<h4>2.1.2 整体架构 <a href="#scroller-8" id="scroller-8"></a></h4>
<p><img src="/images/blog/tech/microservice/image_6_6.png" alt="image_6_6.png"></p>
<p>Eureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。</p>
<p>所以他有如下特点：</p>
<p>1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p>
<p>2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。</p>
<p>3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p>
<p>同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。</p>
<p>4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。</p>
<h4>2.1.3 接入Spring Cloud <a href="#scroller-9" id="scroller-9"></a></h4>
<p><img src="/images/blog/tech/microservice/image_6_7.png" alt="image_6_7.png"></p>
<p>如上图所示：</p>
<p>1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -&gt; 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。</p>
<p>所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。</p>
<p>2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。</p>
<p>3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。</p>
<h3>2.2 ZooKeeper <a href="#scroller-10" id="scroller-10"></a></h3>
<h4>2.2.1 介绍 <a href="#scroller-11" id="scroller-11"></a></h4>
<p>作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。</p>
<p>这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。</p>
<p><img src="/images/blog/tech/microservice/image_6_8.png" alt="image_6_8.png"></p>
<p>在数据模型上，类似于传统的文件系统，节点类型分为：</p>
<p>1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。</p>
<p>2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。</p>
<p>在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。</p>
<p><img src="/images/blog/tech/microservice/image_6_9.png" alt="image_6_9.png"></p>
<p>Zookeeper有如下特点：</p>
<p>1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。</p>
<h4>2.2.2 整体架构 <a href="#scroller-12" id="scroller-12"></a></h4>
<p><img src="/images/blog/tech/microservice/image_6_10.png" alt="image_6_10.png"></p>
<p>上图是Zookeeper 的服务架构，他有如下流程：</p>
<p>1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；</p>
<p>2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。</p>
<p>3、Leader负责处理数据更新等操作（Zab协议）；</p>
<h4>2.2.3 接入Dubbo生态 <a href="#scroller-13" id="scroller-13"></a></h4>
<p><img src="/images/blog/tech/microservice/image_6_11.png" alt="image_6_11.png"></p>
<p>上图中的角色如下：</p>
<p>Provider：提供者,服务发布方</p>
<p>Consumer：消费者, 调用服务方</p>
<p>Container：Dubbo容器.依赖于Spring容器</p>
<p>Registry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置</p>
<p>Monitor:监听器</p>
<p>说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。</p>
<p>服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。</p>
<p>这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。</p>
<h3>2.3 Consul <a href="#scroller-14" id="scroller-14"></a></h3>
<h4>2.3.1 介绍 <a href="#scroller-15" id="scroller-15"></a></h4>
<p>Consul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：</p>
<p>1、Service Discovery（服务发现）</p>
<p>2、Configuration（配置化）</p>
<p>3、Segmentation Functionality</p>
<p>这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。</p>
<p>Consul提供的关键功能如下：</p>
<p>1、Service Discovery：服务注册/发现功能。</p>
<p>2、Health Checking：健康检查，丰富的健康检查方式；</p>
<p>3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。</p>
<p>4、Multi DataCenter：多数据中心。</p>
<h4>2.3.2 整体架构 <a href="#scroller-16" id="scroller-16"></a></h4>
<p><img src="/images/blog/tech/microservice/image_6_12.png" alt="image_6_12.png"></p>
<p>如上图为Consul的架构，这边对技术点做一下说明：</p>
<p>1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式</p>
<p>2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。</p>
<p>3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。</p>
<p>4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。</p>
<p>5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。</p>
<p>6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。</p>
<p>7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。</p>
<p>8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。</p>
<p>9、RPC: 远程过程调用，用于服务之间的通信。</p>
<p>10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。</p>
<p>所以是典型的CP模式。</p>
<p><img src="/images/blog/tech/microservice/image_6_13.png" alt="image_6_13.png"></p>
<p>根据Consul 的选举机制和服务原理，我们有两个注意点 ：</p>
<p>1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。</p>
<p>2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。</p>
<p>有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。</p>
<h4>2.3.3 生态对接 <a href="#scroller-17" id="scroller-17"></a></h4>
<p><strong>对接Spring Cloud生态</strong></p>
<p><img src="/images/blog/tech/microservice/image_6_14.png" alt="image_6_14.png"></p>
<p>Consul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。</p>
<p>但是这边的健康检查更丰富，可以有多种不同的的Check方式：</p>
<ul>
<li>Script check（Script+ Interval）</li>
<li>基于HTTP请求</li>
<li>基于tcp请求</li>
<li>基于grpc请求</li>
</ul>
<h3>2.4 总结对比 <a href="#scroller-19" id="scroller-19"></a></h3>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>Eureka</strong></th>
<th><strong>Zookeeper</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Etcd</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一致性协议</td>
<td>AP</td>
<td>CP（Paxos算法）</td>
<td>CP（Raft算法）</td>
<td>CP（Raft算法）</td>
</tr>
<tr>
<td>健康检查</td>
<td>TTL(Time To Live)</td>
<td>TCP Keep Alive</td>
<td>TTL\HTTP\TCP\Script</td>
<td>Lease TTL KeepAlive</td>
</tr>
<tr>
<td>watch/long polling</td>
<td>不支持</td>
<td>watch</td>
<td>long polling</td>
<td>watch</td>
</tr>
<tr>
<td>雪崩保护</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>安全与权限</td>
<td>不支持</td>
<td>ACL</td>
<td>ACL</td>
<td>RBAC</td>
</tr>
<tr>
<td>是否支持多数据中心</td>
<td>是</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有管理界面</td>
<td>是</td>
<td>否（可用第三方ZkTools）</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Spring Cloud 集成</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Dubbo 集成</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>K8S 集成</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。</p>
<p>当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。</p>
<p>如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-600 hover:text-gray-800" href="/about/">关于</a><a class="text-gray-600 hover:text-gray-800" href="/blog/">博客</a><a class="text-gray-600 hover:text-gray-800" href="/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-600">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-51baccc14cf1da9e.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n5:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[59665,[],\"MetadataBoundary\"]\n10:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/9e71a912f7c3be7c.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"oifuJy_Vv3P2t-5QCGKHG\",\"p\":\"\",\"c\":[\"\",\"blog\",\"technique\",\"microservice\",\"%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"technique/microservice/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/9e71a912f7c3be7c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-600\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"technique/microservice/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"6SnP5MewU8t0ImN6gFvS7v\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[74911,[],\"AsyncMetadata\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n19:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n15:T500e,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e1 微服务的注册与发现 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。\u003c/p\u003e\n\u003cp\u003e微服务注册与发现类似于生活中的\u0026quot;电话通讯录\u0026quot;的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。\u003c/p\u003e\n\u003cp\u003e步骤如下：\u003c/p\u003e\n\u003cp\u003e1、你先要把\u0026quot;好友某某\u0026quot;记录在通讯录中。\u003c/p\u003e\n\u003cp\u003e2、拨打电话的时候通过通讯录中找到\u0026quot;好友某某\u0026quot;，并拨通回电话。\u003c/p\u003e\n\u003cp\u003e3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。\u003c/p\u003e\n\u003cp\u003e从这个过程中我们看到了一些特点：\u003c/p\u003e\n\u003cp\u003e1、把 \u0026quot;好友某某\u0026quot; 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。\u003c/p\u003e\n\u003cp\u003e2、后续我们通过\u0026quot;好友某某\u0026quot;就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。\u003c/p\u003e\n\u003cp\u003e而我们微服务架构中的服务注册与发现结构如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_1.png\" alt=\"image_6_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：\u003c/p\u003e\n\u003cp\u003eprovider - 服务提供者\u003c/p\u003e\n\u003cp\u003econsumer - 服务消费者\u003c/p\u003e\n\u003cp\u003eregister center - 注册中心\u003c/p\u003e\n\u003cp\u003e它们之间的关系大致如下：\u003c/p\u003e\n\u003cp\u003e1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。\u003c/p\u003e\n\u003cp\u003e2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。\u003c/p\u003e\n\u003cp\u003e3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。\u003c/p\u003e\n\u003cp\u003e优点如下：\u003c/p\u003e\n\u003cp\u003e1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响\u003c/p\u003e\n\u003cp\u003e2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响\u003c/p\u003e\n\u003cp\u003e3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。\u003c/p\u003e\n\u003cp\u003e从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。\u003c/p\u003e\n\u003ch3\u003e1.1 服务注册 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_2.png\" alt=\"image_6_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：\u003c/p\u003e\n\u003cp\u003e1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。\u003c/p\u003e\n\u003cp\u003e2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。\u003c/p\u003e\n\u003cp\u003e3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。\u003c/p\u003e\n\u003cp\u003e可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_3.png\" alt=\"image_6_3.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e1.2 服务发现 \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e服务发现实际就是我们查询已经注册好的服务提供者，比如 p-\u0026gt;p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，\u003c/p\u003e\n\u003cp\u003e返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。\u003c/p\u003e\n\u003cp\u003e这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。\u003c/p\u003e\n\u003cp\u003e服务发现的方式一般有两种：\u003c/p\u003e\n\u003cp\u003e1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。\u003c/p\u003e\n\u003cp\u003e2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。\u003c/p\u003e\n\u003ch3\u003e1.3 注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。\u003c/p\u003e\n\u003cp\u003e服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。\u003c/p\u003e\n\u003cp\u003e主要的检查方式包括：\u003c/p\u003e\n\u003cp\u003e1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。\u003c/p\u003e\n\u003cp\u003e2、注册中心主动检查服务Provider接口。\u003c/p\u003e\n\u003cp\u003e综合我们前面的内容，可以总结下注册中心有如下几种能力：\u003c/p\u003e\n\u003cp\u003e1、高可用\u003c/p\u003e\n\u003cp\u003e这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的\u003c/p\u003e\n\u003cp\u003e2、可视化操作\u003c/p\u003e\n\u003cp\u003e常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。\u003c/p\u003e\n\u003cp\u003e3、高效运维\u003c/p\u003e\n\u003cp\u003e注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。\u003c/p\u003e\n\u003cp\u003e4、权限控制\u003c/p\u003e\n\u003cp\u003e数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求\u003c/p\u003e\n\u003cp\u003e5、服务注册推、拉能力\u003c/p\u003e\n\u003cp\u003e这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_4.png\" alt=\"image_6_4.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e2 现下的主流注册中心 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3\u003e2.1 Eureka \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.1.1 介绍 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eEureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。\u003c/p\u003e\n\u003cp\u003e目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 \u003ca href=\"https://github.com/Netflix/eureka/wiki\"\u003eEureka 2.0已经停止维护\u003c/a\u003e，所以新的微服务架构设计中，不再建议使用。\u003c/p\u003e\n\u003cp\u003eSpring Cloud Netflix主要分为两个部分：\u003c/p\u003e\n\u003cp\u003e1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。\u003c/p\u003e\n\u003cp\u003e2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_5.png\" alt=\"image_6_5.png\"\u003e\u003c/p\u003e\n\u003cp\u003eEureka有比较友好的管理界面，如上图所示：\u003c/p\u003e\n\u003cp\u003e1、System Status：显示当前Eureka Server信息。\u003c/p\u003e\n\u003cp\u003e2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。\u003c/p\u003e\n\u003cp\u003e3、General Info：基本信息，如cpu、内存、环境等。\u003c/p\u003e\n\u003ch4\u003e2.1.2 整体架构 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_6.png\" alt=\"image_6_6.png\"\u003e\u003c/p\u003e\n\u003cp\u003eEureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。\u003c/p\u003e\n\u003cp\u003e所以他有如下特点：\u003c/p\u003e\n\u003cp\u003e1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。\u003c/p\u003e\n\u003cp\u003e2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。\u003c/p\u003e\n\u003cp\u003e3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。\u003c/p\u003e\n\u003cp\u003e同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。\u003c/p\u003e\n\u003cp\u003e4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。\u003c/p\u003e\n\u003ch4\u003e2.1.3 接入Spring Cloud \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_7.png\" alt=\"image_6_7.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示：\u003c/p\u003e\n\u003cp\u003e1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -\u0026gt; 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。\u003c/p\u003e\n\u003cp\u003e所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。\u003c/p\u003e\n\u003cp\u003e2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。\u003c/p\u003e\n\u003cp\u003e3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。\u003c/p\u003e\n\u003ch3\u003e2.2 ZooKeeper \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.2.1 介绍 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。\u003c/p\u003e\n\u003cp\u003e这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_8.png\" alt=\"image_6_8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在数据模型上，类似于传统的文件系统，节点类型分为：\u003c/p\u003e\n\u003cp\u003e1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。\u003c/p\u003e\n\u003cp\u003e2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。\u003c/p\u003e\n\u003cp\u003e在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_9.png\" alt=\"image_6_9.png\"\u003e\u003c/p\u003e\n\u003cp\u003eZookeeper有如下特点：\u003c/p\u003e\n\u003cp\u003e1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。\u003c/p\u003e\n\u003ch4\u003e2.2.2 整体架构 \u003ca href=\"#scroller-12\" id=\"scroller-12\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_10.png\" alt=\"image_6_10.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图是Zookeeper 的服务架构，他有如下流程：\u003c/p\u003e\n\u003cp\u003e1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；\u003c/p\u003e\n\u003cp\u003e2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。\u003c/p\u003e\n\u003cp\u003e3、Leader负责处理数据更新等操作（Zab协议）；\u003c/p\u003e\n\u003ch4\u003e2.2.3 接入Dubbo生态 \u003ca href=\"#scroller-13\" id=\"scroller-13\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_11.png\" alt=\"image_6_11.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图中的角色如下：\u003c/p\u003e\n\u003cp\u003eProvider：提供者,服务发布方\u003c/p\u003e\n\u003cp\u003eConsumer：消费者, 调用服务方\u003c/p\u003e\n\u003cp\u003eContainer：Dubbo容器.依赖于Spring容器\u003c/p\u003e\n\u003cp\u003eRegistry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置\u003c/p\u003e\n\u003cp\u003eMonitor:监听器\u003c/p\u003e\n\u003cp\u003e说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。\u003c/p\u003e\n\u003cp\u003e服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。\u003c/p\u003e\n\u003cp\u003e这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。\u003c/p\u003e\n\u003ch3\u003e2.3 Consul \u003ca href=\"#scroller-14\" id=\"scroller-14\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4\u003e2.3.1 介绍 \u003ca href=\"#scroller-15\" id=\"scroller-15\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eConsul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：\u003c/p\u003e\n\u003cp\u003e1、Service Discovery（服务发现）\u003c/p\u003e\n\u003cp\u003e2、Configuration（配置化）\u003c/p\u003e\n\u003cp\u003e3、Segmentation Functionality\u003c/p\u003e\n\u003cp\u003e这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。\u003c/p\u003e\n\u003cp\u003eConsul提供的关键功能如下：\u003c/p\u003e\n\u003cp\u003e1、Service Discovery：服务注册/发现功能。\u003c/p\u003e\n\u003cp\u003e2、Health Checking：健康检查，丰富的健康检查方式；\u003c/p\u003e\n\u003cp\u003e3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。\u003c/p\u003e\n\u003cp\u003e4、Multi DataCenter：多数据中心。\u003c/p\u003e\n\u003ch4\u003e2.3.2 整体架构 \u003ca href=\"#scroller-16\" id=\"scroller-16\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_12.png\" alt=\"image_6_12.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图为Consul的架构，这边对技术点做一下说明：\u003c/p\u003e\n\u003cp\u003e1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式\u003c/p\u003e\n\u003cp\u003e2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。\u003c/p\u003e\n\u003cp\u003e3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。\u003c/p\u003e\n\u003cp\u003e4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。\u003c/p\u003e\n\u003cp\u003e5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。\u003c/p\u003e\n\u003cp\u003e6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。\u003c/p\u003e\n\u003cp\u003e7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。\u003c/p\u003e\n\u003cp\u003e8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。\u003c/p\u003e\n\u003cp\u003e9、RPC: 远程过程调用，用于服务之间的通信。\u003c/p\u003e\n\u003cp\u003e10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。\u003c/p\u003e\n\u003cp\u003e所以是典型的CP模式。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_13.png\" alt=\"image_6_13.png\"\u003e\u003c/p\u003e\n\u003cp\u003e根据Consul 的选举机制和服务原理，我们有两个注意点 ：\u003c/p\u003e\n\u003cp\u003e1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。\u003c/p\u003e\n\u003cp\u003e2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。\u003c/p\u003e\n\u003cp\u003e有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。\u003c/p\u003e\n\u003ch4\u003e2.3.3 生态对接 \u003ca href=\"#scroller-17\" id=\"scroller-17\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e对接Spring Cloud生态\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_6_14.png\" alt=\"image_6_14.png\"\u003e\u003c/p\u003e\n\u003cp\u003eConsul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。\u003c/p\u003e\n\u003cp\u003e但是这边的健康检查更丰富，可以有多种不同的的Check方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScript check（Script+ Interval）\u003c/li\u003e\n\u003cli\u003e基于HTTP请求\u003c/li\u003e\n\u003cli\u003e基于tcp请求\u003c/li\u003e\n\u003cli\u003e基于grpc请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2.4 总结对比 \u003ca href=\"#scroller-19\" id=\"scroller-19\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e指标\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEureka\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eZookeeper\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eConsul\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEtcd\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e一致性协议\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003ctd\u003eCP（Paxos算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e健康检查\u003c/td\u003e\n\u003ctd\u003eTTL(Time To Live)\u003c/td\u003e\n\u003ctd\u003eTCP Keep Alive\u003c/td\u003e\n\u003ctd\u003eTTL\\HTTP\\TCP\\Script\u003c/td\u003e\n\u003ctd\u003eLease TTL KeepAlive\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewatch/long polling\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003ctd\u003elong polling\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e雪崩保护\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全与权限\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eRBAC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持多数据中心\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否有管理界面\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否（可用第三方ZkTools）\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud 集成\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDubbo 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eK8S 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。\u003c/p\u003e\n\u003cp\u003e当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。\u003c/p\u003e\n\u003cp\u003e如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T1476,"])</script><script>self.__next_f.push([1,"\u003cp\u003e关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。\u003c/p\u003e\n\u003cp\u003e1. AKF扩展立方体\u003c/p\u003e\n\u003cp\u003eAKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一个维度（见下图），分别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eX轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代表无差别的克隆服务和数据，工作可以很均匀的分散在不同的服务实例上\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eY轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关注应用中职责的划分，比如数据类型、交易执行类型的划分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eZ轴\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关注服务和数据的优先级划分，如分地域划\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_5_1.png\" alt=\"image_5_1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e以上X、Y和Z轴的划分可以概括为X 轴关注水平复制，Z 轴类似数据分区，而Y 轴则强调基于不同的业务拆分。理论上按照这三个扩展维度，可以将一个单体系统进行无限扩展。举例来说，比如用户预约挂号应用，一个集群撑不住时，分了多个集群，后来用户激增还是不够用，经过分析发现是用户和医生访问量很大，就将预约挂号应用拆成了患者服务、医生服务、支付服务等三个服务。三个服务的业务特点各不相同，独立维护，各自都可以再次按需扩展。\u003c/p\u003e\n\u003cp\u003e在上图中，Y轴就是我们所说的微服务的拆分模式，即基于不同的业务进行拆分。但在进行业务拆分过程中，我们发现业务往往与数据有较大耦合性，所以接下去我们把业务和数据结合起来对服务拆分的维度展开讨论。\u003c/p\u003e\n\u003cp\u003e2. 业务与数据\u003c/p\u003e\n\u003cp\u003e服务拆分存在两大维度，即业务与数据。业务体现在各种功能代码中，通过确定业务的边界，并使用领域与界限上下文、领域事件等技术手段可以实现拆分。而数据的拆分则体现在如何将集中式的中心化数据转变为各个微服务各自拥有的独立数据，这部分工作同样十分具有挑战性。\u003c/p\u003e\n\u003cp\u003e关于业务和数据谁应该先拆分的问题，可以是先数据库后业务代码，也可以是先业务代码后数据库。然而在拆分中遇到的最大挑战可能会是数据层的拆分，因为在数据库中，可能会存在各种跨表连接查询、跨库连接查询以及不同业务模块的代码与数据耦合得非常紧密的场景，这会导致服务的拆分非常的困难。因此在拆分步骤上我们更多的推荐数据库先行。数据模型能否彻底分开，很大程度上决定了微服务的边界功能是否彻底划清。\u003c/p\u003e\n\u003cp\u003e服务拆分的方法需要根据系统自身的特点和运行状态，通常分为绞杀者与修缮者两种模式。\u003c/p\u003e\n\u003cp\u003e1. 绞杀者模式\u003c/p\u003e\n\u003cp\u003e绞杀者模式（Strangler Pattern）最早由\u003ca href=\"https://www.martinfowler.com/\"\u003eMartin Fowler\u003c/a\u003e提出，指的是在现有系统外围将新功能用新的方式构建为新的服务的策略，通过将新功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。采用这种策略，随着时间的推移，新的服务就会逐渐“绞杀”老的系统。对于那些规模很大而又难以对现有架构进行修改的遗留系统，推荐采用绞杀者模式。\u003c/p\u003e\n\u003cp\u003e绞杀者模式的示意图如下图所示，我们可以看到随着功能演进和时间的不断推移，老的遗留系统功能被逐步削弱，而采用微服务架构的新功能越积越多，最终会形成从量变到质变的过程。绞杀者模式在具体实施过程中，所需要把握的最主要一点原则就是对于任何需要开发的功能一定要完整的采用微服务架构，对于完全独立的新功能这点比较容易把握，而对于涉及到老业务变更的新功能则需要通过重构达到这一目标。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_5_2.png\" alt=\"image_5_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e2. 修缮者模式\u003c/p\u003e\n\u003cp\u003e修缮者模式就如修房或修路一样，将老旧待修缮的部分进行隔离，用新的方式对其进行单独修复。修复的同时，需保证与其他部分仍能协同功能。从这种思路出发，修缮者模式更多表现为一种重构技术。修缮者模式在具体实现上可以参考Martine Fowler的BranchByAbstraction重构方法，该重构方法的示意图如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_5_3.png\" alt=\"image_5_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e从上图中，可以看到这种模式的实现方式可以分成三个主要步骤。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层提取\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先通过识别内部的待拆分功能，对其增加抽象接口层，同时对原有代码进行改造，确保其同样实现该抽象层。这样在依赖关系上就添加了一个中间层。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层实现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为抽象层提供新的实现，新的实现采用微服务方式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e抽象层替换\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e采用新的实现对原有的各个抽象层实现进行逐步替换，直至原有实现被完全废弃，从而完成新老实现方式之间的替换。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"18:T4826,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e服务注册中心 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。\u003c/p\u003e\n\u003cp\u003e并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景下做正确的技术选型。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e指标\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEureka\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eZookeeper\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eConsul\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEtcd\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e一致性协议\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003ctd\u003eCP（Paxos算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e健康检查\u003c/td\u003e\n\u003ctd\u003eTTL(Time To Live)\u003c/td\u003e\n\u003ctd\u003eTCP Keep Alive\u003c/td\u003e\n\u003ctd\u003eTTL\\HTTP\\TCP\\Script\u003c/td\u003e\n\u003ctd\u003eLease TTL KeepAlive\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewatch/long polling\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003ctd\u003elong polling\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e雪崩保护\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全与权限\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eRBAC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持多数据中心\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否有管理界面\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否（可用第三方ZkTools）\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud 集成\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDubbo 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eK8S 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e我们可以看出，四种技术类型对Spring Cloud的支持度都很高。Spring Cloud是微服务架构的一站式解决方案，我们平时构建微服务的过程中需要做的的如 配置管理、服务发现、负载均衡、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作。Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。\u003c/p\u003e\n\u003cp\u003eSpring Cloud包含了多个不同开源产品，来保证一站式的微服务解决方案，如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。\u003c/p\u003e\n\u003ch2\u003eSpring Cloud 框架下实现 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSpring Cloud为服务治理做了一层抽象，这样能够支持多种不同的服务治理框架，比如：Netflix Eureka、Consul。我们这边就以这两个为例子，看看服务治理是如何实现。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e在Spring Cloud服务治理抽象层的作用下，可以无缝地切换服务治理实现，且不影响任何其他的服务注册、发现、调用逻辑。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e所以，下面我们通过介绍这两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e2.Spring Cloud Eureka \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSpring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。\u003c/p\u003e\n\u003cp\u003e通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。\u003c/p\u003e\n\u003cp\u003e下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。\u003c/p\u003e\n\u003ch4\u003e2.1.创建注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e创建一个Spring Cloud项目，我们命名为micro-service-center，并在\u003ccode\u003epom.xml\u003c/code\u003e中引入需要的依赖内容：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e表明这个项目中可以没有Java代码，也不执行任何代码，只是为了聚合工程或者传递依赖，所以可以把src文件夹删了。这是一个父级项目，因为我们还要在下面建立Eureka的注册中心、客户端等多个子项目 。\u003c/p\u003e\n\u003cp\u003e在micro-service-center下，新建一个命名为 eureka-service 的Module，依旧是Spring Cloud 项目，建完之后，pom.xml做如下改动：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n    \u0026lt;!--在子工程中添加父工程名称--\u0026gt;\n    \u0026lt;parent\u0026gt;\n        \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n        \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;/parent\u0026gt;\n    \u0026lt;dependencies\u0026gt;\n        \u0026lt;!--加入 eureka 服务 --\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;spring-cloud-netflix-eureka-server\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n    \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e改完之后，回到父项目micro-service-center，修改pom中的信息：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n    \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n    \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;name\u0026gt;center\u0026lt;/name\u0026gt;\n    \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt;\n    \u0026lt;!--在父工程添加子工程名称--\u0026gt;\n    \u0026lt;modules\u0026gt;\n        \u0026lt;module\u0026gt;eureka-service\u0026lt;/module\u0026gt;\n        \u0026lt;module\u0026gt;eureka-client\u0026lt;/module\u0026gt;\n    \u0026lt;/modules\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对两个项目进行clean + install，应该是成功的。\u003c/p\u003e\n\u003cp\u003eeureka-service我们是作为注册中心来用的，所以在它的主类Application中加入\u003ccode\u003e@EnableEurekaServer\u003c/code\u003e注解，就能开启注册中心功能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableEurekaServer\npublic class ServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceApplication.class, args);\n        System.out.println(\u0026quot;Start Eureka Service\u0026quot;);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是默认情况下，该注册中心也会把自己当做客户端，那就变成自己注册自己了，这个是可以剔除的，我们看一下它的YAML中的详细配置，注释比较清楚：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e  server:\n    port: 1000\n  spring:\n    application:\n      name: eureka-server\n  eureka:\n    instance:\n      hostname: localhost\n    client:\n    register-with-eureka: false  # 不作为客户端进行注册\n    fetch-registry: false  # 不获取注册列表\n    service-url:  # 注册地址，客户端需要注册到该地址中\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e文中的注释还是比较清楚的。 这边可以看到，端口号是1000，所以当工程启动之后，访问 \u003ca href=\"http://localhost:1000/\"\u003ehttp://localhost:1000/\u003c/a\u003e 是可以看到Eureka注册中心页面的。其中还没有发现任何服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_1.png\" alt=\"image_7_1.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.1.创建客户端 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e目前服务中心还是空的，所以我们创建一个能够提供服务的客户端，并将其注册到注册中心去。\u003c/p\u003e\n\u003cp\u003e同样的，我们创建一个Spring Cloud的子项目，命名为\u003ccode\u003eeureka-client\u003c/code\u003e，\u003ccode\u003epom.xml\u003c/code\u003e中的配置如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e  \n\u0026lt;xml\u0026gt;\n    \u0026lt;!--在子工程中添加父工程名称--\u0026gt;\n    \u0026lt;parent\u0026gt;\n        \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n        \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;/parent\u0026gt;\n    \u0026lt;dependencies\u0026gt;\n        \u0026lt;!--加入 eureka 服务 --\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;spring-cloud-netflix-eureka-server\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n    \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在应用主类Application文件中通过加上\u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e注解，该注解保证当前服务被Eureka当成provider发现。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ClientApplication.class, args);\n        System.out.println(\u0026quot;start client!\u0026quot;);\n    }\n}jC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在YAML文件上加上如下配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eserver:\n  port: 1001\nspring:\n  application:\n    name: eureka-client\neureka:\n  client:\n    service-url:  # 这边就保证了注册到 eureka-service 这个注册中心去\n      defaultZone: http://localhost:1000/eureka/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003espring.application.name\u003c/code\u003e属性，指定了微服务的名称，在调用的时候可以通过该名称进行服务访问。\u003ccode\u003eeureka.client.serviceUrl.defaultZone\u003c/code\u003e属性对应服务注册中心的配置内容，指定服务注册中心的位置。\u003c/p\u003e\n\u003cp\u003e大家看到，这边端口设置为1001，那是因为要在本机上测试 服务提供方 和 服务注册中心，所以\u003ccode\u003eserver的port\u003c/code\u003e属性需设置不同的端口。\u003c/p\u003e\n\u003cp\u003e最后，我们再写一个接口，通过DiscoveryClient对象，在客户端中获取注册中心的所有服务信息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  @Controller\n  @RequestMapping(\u0026quot;/eurekacenter\u0026quot;)\n  public class EuServiceController {\n  \n    @Autowired\n    DiscoveryClient discoveryClient;\n    \n    @RequestMapping(value = \u0026quot;/service\u0026quot;, method = {RequestMethod.GET})\n    @ResponseBody\n    public String getServiceInfo() {\n       return  \u0026quot;service:\u0026quot;+discoveryClient.getServices()+\u0026quot; , memo:\u0026quot;+discoveryClient.description();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时候跑一下试试看，继续访问之前的地址：\u003ca href=\"http://localhost:1000/\"\u003ehttp://localhost:1000/\u003c/a\u003e ，可以看到Eureka注册中心页面已经包含一个我们定义的服务了，就是上面新建的 100端口的服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_2.png\" alt=\"image_7_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同样，我们可以调用上面的那个获取注册服务信息的接口，从服务发现的角度看看有多少个服务被注册到注册中心去。 \u003ca href=\"http://localhost:1001/eurekacenter/service\"\u003ehttp://localhost:1001/eurekacenter/service\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_3.png\" alt=\"image_7_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示，方括号中的\u003ccode\u003eeureka-client\u003c/code\u003e通过Spring Cloud定义的 getServiceInfo 接口在eureka的实现中获取到的所有服务清单，他是一个String的List，如果注册了多个提供者，就会全部显示。\u003c/p\u003e\n\u003ch3\u003e2.Spring Cloud Consul \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eConsul 用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更具“一站式”特征，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 之类的）。\u003c/p\u003e\n\u003cp\u003e而Spring Cloud Consul ，是将其作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。\u003c/p\u003e\n\u003ch4\u003e2.2.Consul 的优势 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接。\u003c/p\u003e\n\u003cp\u003e2、支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持，上面表格中有体现。\u003c/p\u003e\n\u003cp\u003e3、支持健康检查。\u003c/p\u003e\n\u003cp\u003e4、支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。\u003c/p\u003e\n\u003cp\u003e5、官方提供 web 管理界面, etcd 无此功能。\u003c/p\u003e\n\u003ch4\u003e2.2.Consul的特性 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、服务发现\u003c/p\u003e\n\u003cp\u003e2、健康检查\u003c/p\u003e\n\u003cp\u003e3、Key/Value存储\u003c/p\u003e\n\u003cp\u003e4、多数据中心\u003c/p\u003e\n\u003ch4\u003e2.2.安装Consul注册中心 \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、官方下载64版本 ：\u003ca href=\"https://www.consul.io/downloads.html\"\u003ehttps://www.consul.io/downloads.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e2、解压后复制到目录 /usr/local/bin 下\u003c/p\u003e\n\u003cp\u003e3、启动终端，先看下啥版本的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eliyifei@MacPro ~ % consul --version\nConsul v1.10.4\nRevision 7bbad6fe\nProtocol spoken by default, understands to (agent will automatically use protocol \u0026gt;when speaking to compatible agents)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e4、执行安装命令，可以看到他的 Client Addr 的端口为8500。所以访问 8500端口站点，\u003ca href=\"http://127.0.0.1:8500/ui/dc1/services\"\u003ehttp://127.0.0.1:8500/ui/dc1/services\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e  liyifei@MacPro ~ % consul agent -dev\n  ==\u0026gt; Starting Consul agent...\n             Version: \u0026#39;1.10.4\u0026#39;\n             Node ID: \u0026#39;6db154b4-62ff-e67d-e745-1a7270fa1ce8\u0026#39;\n           Node name: \u0026#39;B000000147796DS\u0026#39;\n          Datacenter: \u0026#39;dc1\u0026#39; (Segment: \u0026#39;\u0026lt;all\u0026gt;\u0026#39;)\n              Server: true (Bootstrap: false)\n         Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)\n        Cluster Addr: 127.0.0.(LAN: 8301, WAN: 8302)\n           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_4.png\" alt=\"image_7_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我们可以看到，现在没有客户端注册上来，只有一个自身的实例。\u003c/p\u003e\n\u003ch4\u003e2.2.创建服务提供者 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。\u003c/p\u003e\n\u003cp\u003e我们在micro-service-center下新建一个cloud项目consul-client，该项目pom文件添加如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n  \u0026lt;!--    在子工程中添加父工程名称--\u0026gt;\n  \u0026lt;parent\u0026gt;\n    \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n  \u0026lt;/parent\u0026gt;\n  \n  \u0026lt;dependencies\u0026gt;\n    \u0026lt;!--        Consul服务发现--\u0026gt;\n    \u0026lt;dependency\u0026gt;\n        \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt;\n    \u0026lt;/dependency\u0026gt;\n    \u0026lt;!--        Consul健康检查--\u0026gt;\n    \u0026lt;dependency\u0026gt;\n        \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt;\n    \u0026lt;/dependency\u0026gt;\n  \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后修改一下\u003ccode\u003eapplication.yml的配置信息\u003c/code\u003e，将consul配置写入，注释应该很清楚了，如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003espring:\n  application:\n    name: consul-producer # 当前服务的名称\n  cloud:\n    consul: # 以下为Consuk注册中心的地址，如果安装的不是这个host和port，这边可以调整\n      host: localhost\n      port: 8500\nserver:\n  port: 850# 当前服务的端口\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同样的，我们要在应用主类Application文件中通过加上\u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e注解，该注解保证当前服务被Consul当成provider发现。\u003c/p\u003e\n\u003cp\u003e大家看到这个做法跟Eureka一样，因为Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，\u003c/p\u003e\n\u003cp\u003e程序上不需要做改变，只需要引入不同的服务治理依赖，并配置相关的配置属性 就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ClientApplication.class, args);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改完成之后，我们就可以把这个服务提供者启动了，然后再去注册中心查看服务的注册情况，就可以看到被注册进来的Provider（consul-producer）：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_5.png\" alt=\"image_7_5.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e总结 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e除了 Eureka、Consul，还有其他的的注册中心技术，如Zookeeper、Nocas等。但无论何种注册中心技术，本质上都是为了解决微服务中的如下问题：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解耦服务之间相互依赖的细节\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们知道服务之间的远程调用必须要知道对方的IP、端口信息。我们可以在调用方直接配置被调用方的IP、端口，这种调用方直接依赖IP、端口的方式存在明显的问题，如被调用的IP、端口变化后，调用方法也要同步修改。\u003c/p\u003e\n\u003cp\u003e通过服务发现，将服务之间IP与端口的依赖转化为服务名的依赖，服务名可以根据具微服务业务来做标识，因此，屏蔽、解耦服务之间的依赖细节是服务发现与注册解决的第一个问题。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对微服务进行动态管理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构中，服务众多，服务之间的相互依赖也错综复杂，无论是服务主动停止，意外挂掉，还是因为流量增加对服务实现进行扩容，这些服务数据或状态上的动态变化，都需要尽快的通知到被调用方，被调用方才采取相应的措施。因此，对于服务注册与发现要实时管理者服务的数据与状态，包括服务的注册上线、服务主动下线，异常服务的剔除。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-03-23\",\"children\":\"2024年03月23日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"服务注册与发现\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L5\",\"微服务架构\",{\"href\":\"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"微服务架构\"}],[\"$\",\"$L5\",\"技术专题\",{\"href\":\"/blog/tag/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"技术专题\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$11\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"technique/microservice/微服务拆分策略（附加篇）\",\"title\":\"微服务拆分策略（附加篇）\",\"description\":\"关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。 1. AKF扩展立方体 AKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一...\",\"pubDate\":\"2024-03-22\",\"tags\":[\"微服务架构\",\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"technique/microservice/服务注册与发现（实践篇）\",\"title\":\"服务注册与发现（实践篇）\",\"description\":\"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景...\",\"pubDate\":\"2024-03-24\",\"tags\":[\"微服务架构\",\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"微服务架构\":{\"prev\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:next\"},\"技术专题\":{\"prev\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:next\"}}}]}],[\"$\",\"$L19\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"服务注册与发现 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"服务注册与发现\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-03-23\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"服务注册与发现\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
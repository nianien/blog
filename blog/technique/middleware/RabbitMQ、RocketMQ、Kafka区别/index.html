<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/62d123c7e24ed574.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-51baccc14cf1da9e.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js" async=""></script><meta name="next-size-adjust" content=""/><title>RabbitMQ、RocketMQ、Kafka区别 - Skyfalling Blog</title><meta name="description" content="MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ"/><meta property="og:title" content="RabbitMQ、RocketMQ、Kafka区别"/><meta property="og:description" content="MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-03-31"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="RabbitMQ、RocketMQ、Kafka区别"/><meta name="twitter:description" content="MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ"/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-03-31">2024年03月31日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">RabbitMQ、RocketMQ、Kafka区别</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/page/1/">消息队列</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/page/1/">技术专题</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-li:text-gray-700 prose-hr:border-gray-300"><p><a href="https://baijiahao.baidu.com/s?id=1769207484615537227">转载</a></p>
<h4>引言</h4>
<h4>1、队列应用场景：</h4>
<p>MQ（Message Queue，消息队列）<br><strong>消息队列在实际应用中常用的使用场景（优点）</strong>：<code>异步处理</code>，<code>应用解耦</code>，<code>流量削锋</code>和<code>消息通讯</code>四个场景。</p>
<h4>2、目前使用较多的消息队列：</h4>
<p>有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ。</p>
<h4>3、如何选型（目前现状）：</h4>
<p>ActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。最早大家都用 ActiveMQ，但是现在确实大家用的不多了，社区也不是很活跃，不推荐用这个了；</p>
<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，可视化的管理界面比较友好；</p>
<p>不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），它是纯Java开发，它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则老老实实用 RabbitMQ 吧，毕竟RabbitMQ有活跃的开源社区，绝对不会黄。</p>
<p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>
<p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，适合产生大量数据的互联网服务的数据收集业务等。社区活跃度很高，何况几乎是全世界这个领域的事实性规范。kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。</p>
<h4>4、使用消息队列缺点：</h4>
<ul>
<li>系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，整套系统崩溃了。</li>
<li>系统复杂性提高：加MQ进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</li>
<li>一致性问题：A系统处理完了直接返回成功了，后面的如果失败了，这数据就不一致了。</li>
</ul>
<h4>一、RabbitMQ</h4>
<h4>1、RabbitMQ概述</h4>
<p><code>AMQP</code>，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层<strong>标准高级消息队列协议</strong>，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。<br>AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p>
<p><code>RabbitMQ</code>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。</p>
<p>RabbitMQ 是比较有代表性的，因为是<code>基于主从（非分布式）做高可用性</code>的。</p>
<h4>2、RabbitMQ原理图</h4>
<p>RabbitMQ通过<code>信道</code>的方式传输数据，将消息发布到交换机上，消息拥有一个路邮键，由消息创建时设定，通过队列路由键，可以把队列绑定到交换机上，消息到达交换机后，RabbitMQ将消息的路由键与队列的路由键进行匹配（不同的交换机有不同的路由规则），匹配到相应的队列，消息投递到队列的队列中供消费者消费。</p>
<blockquote>
<p>多个消费者可以订阅同一个Queue，消息将以<code>循环（round-robin）</code>的方式发送给消费者，每条消息只会发给一个订阅的消费者，而不是每个消费者都收到所有的消息并处理。</p>
</blockquote>
<blockquote>
<p>每个Channel运行在独立的线程上，多个线程共享同一个socket。</p>
</blockquote>
<p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/dfde605794cc90a31ce1223c54218372.jpeg@c_1,w_901,h_315,x_0,y_0" alt=""><br><strong>相关概念：</strong></p>
<ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；</li>
<li>Broker：简单来说就是消息队列服务器实体。</li>
<li>Channel（信道）：消息推送使用的通道；</li>
<li>Exchange（交换器）：用于接受、分配消息；</li>
<li>Queue（队列）：用于存储生产者的消息；</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上；【最大255个字节】</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上；【最大255个字节】</li>
<li>vhost（虚拟主机）每个Rabbit都能创建很多vhost，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。</li>
</ul>
<h4>3、RabbitMQ常用的三种交换机</h4>
<p><strong>RabbitMQ常用的三种Exchange</strong>：fanout,direct,topic</p>
<h4>（1）Direct Exchange ：</h4>
<p>直连型交换机，根据消息携带的路由键将消息投递给对应队列。<br>　　大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key。　然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。</p>
<h4>（2）Fanout Exchange：</h4>
<p>扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。</p>
<h4>（3）Topic Exchange：</h4>
<p>主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。<br>　　<br><strong>性能排序</strong>：fanout &gt; direct &gt;&gt; topic。</p>
<h4>4、 RabbitMQ集群元数据</h4>
<p>RabbitMQ集群会始终同步四种类型的内部元数据：</p>
<ul>
<li>a. 队列元数据：队列名称和它的属性</li>
<li>b. 交换器元数据：交换器名称、类型和属性</li>
<li>c. 绑定元数据：一张简单的表格展示了如何将消息路由到队列</li>
<li>d. vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性</li>
</ul>
<h4>5、RabbitMQ镜像集群</h4>
<p><strong>RabbitMQ 有三种模式</strong>：单机模式、普通集群模式（无高可用性）、<code>镜像集群模式</code>（高可用性）。</p>
<p><code>镜像队列</code>将需要消费的队列变成镜像队列，存在于多个节点，实现RabbitMQ的高可用，保证 100% 数据不丢失。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在消费者消费数据时临时拉取，缺点就是集群内部的<code>同步通讯</code>会占去大量的网络带宽。<br><img src="https://pic.rmb.bdstatic.com/bjh/beautify/53a92fdedade9355420e866bbdb51be1.jpeg@c_1,w_613,h_390,x_0,y_0" alt=""></p>
<h4>二、RocketMQ</h4>
<p><code>RocketMQ</code>是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目。用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p>
<p><strong>RocketMQ缺点：</strong></p>
<ul>
<li>单机支持1万以上持久化队列；</li>
<li>RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。</li>
<li>模型简单，接口易用（JMS的接口很多场合并不太实用）；</li>
<li>性能非常好，可以允许大量堆积消息在Broker中；</li>
<li>支持多种消费模式，包括集群消费、广播消费等；</li>
<li>各个环节分布式扩展设计，支持主从和高可用；</li>
<li>开发度较活跃，版本更新很快。</li>
</ul>
<p><strong>RocketMQ缺点：</strong></p>
<ul>
<li>支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟</li>
<li>维护RocketMQ需要专业的团队</li>
<li>商业版收费，有许多功能是不对外提供的。</li>
<li>没有在MQ核心里实现JMS等接口</li>
</ul>
<h4>三、kafka</h4>
<h4>1、kafka概述</h4>
<p><code>kafka</code>是Linkedin于2010年12月份开源的<code>消息发布订阅</code>系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。作为hadoop生态系统的一部分，被各种商业公司广泛应用。</p>
<p><strong>kafka优点：</strong></p>
<ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</li>
<li>可扩展性：kafka集群支持热扩展</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li>容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li>高并发：支持数千个客户端同时读写</li>
</ul>
<p><strong>kafka缺点：</strong></p>
<ul>
<li>快速持久化：可以在O(1)的系统开销下进行消息持久化；</li>
<li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li>
<li>完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；</li>
<li>支持同步和异步复制两种高可用机制；</li>
<li>支持数据批量发送和拉取；</li>
<li>零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；</li>
<li>数据迁移、扩容对用户透明；</li>
<li>无需停机即可扩展机器；</li>
<li>其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制</li>
</ul>
<h4>2、kafka原理图</h4>
<p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/3d90e1705de49c669f22628af2f6004a.jpeg@c_1,w_1010,h_651,x_0,y_0" alt=""><br><img src="https://pic.rmb.bdstatic.com/bjh/beautify/a5531d658050ce7abecb5ad4242d92ab.jpeg@c_1,w_1002,h_300,x_0,y_0" alt=""></p>
<h4>四、总结</h4>
<p><img src="/images/blog/tech/middleware/img_20250723_04.png" alt="img_20250723_04.png">{: .full-width}</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-600 hover:text-gray-800" href="/about/">关于</a><a class="text-gray-600 hover:text-gray-800" href="/blog/">博客</a><a class="text-gray-600 hover:text-gray-800" href="/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-600">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-51baccc14cf1da9e.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n5:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[59665,[],\"MetadataBoundary\"]\n10:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/62d123c7e24ed574.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"999JsOdl-PerUHwbUymLM\",\"p\":\"\",\"c\":[\"\",\"blog\",\"technique\",\"middleware\",\"RabbitMQ%E3%80%81RocketMQ%E3%80%81Kafka%E5%8C%BA%E5%88%AB\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"technique/middleware/RabbitMQ%E3%80%81RocketMQ%E3%80%81Kafka%E5%8C%BA%E5%88%AB\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/62d123c7e24ed574.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-600\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"technique/middleware/RabbitMQ%E3%80%81RocketMQ%E3%80%81Kafka%E5%8C%BA%E5%88%AB\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"P4iI4WvxQVNpEYwrvTbVrv\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[74911,[],\"AsyncMetadata\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\n1a:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-3137b04d8f9ed325.js\"],\"default\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n15:T2b19,"])</script><script>self.__next_f.push([1,"\u003cp\u003e\u003ca href=\"https://baijiahao.baidu.com/s?id=1769207484615537227\"\u003e转载\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e引言\u003c/h4\u003e\n\u003ch4\u003e1、队列应用场景：\u003c/h4\u003e\n\u003cp\u003eMQ（Message Queue，消息队列）\u003cbr\u003e\u003cstrong\u003e消息队列在实际应用中常用的使用场景（优点）\u003c/strong\u003e：\u003ccode\u003e异步处理\u003c/code\u003e，\u003ccode\u003e应用解耦\u003c/code\u003e，\u003ccode\u003e流量削锋\u003c/code\u003e和\u003ccode\u003e消息通讯\u003c/code\u003e四个场景。\u003c/p\u003e\n\u003ch4\u003e2、目前使用较多的消息队列：\u003c/h4\u003e\n\u003cp\u003e有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ。\u003c/p\u003e\n\u003ch4\u003e3、如何选型（目前现状）：\u003c/h4\u003e\n\u003cp\u003eActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。最早大家都用 ActiveMQ，但是现在确实大家用的不多了，社区也不是很活跃，不推荐用这个了；\u003c/p\u003e\n\u003cp\u003e后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，可视化的管理界面比较友好；\u003c/p\u003e\n\u003cp\u003e不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），它是纯Java开发，它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则老老实实用 RabbitMQ 吧，毕竟RabbitMQ有活跃的开源社区，绝对不会黄。\u003c/p\u003e\n\u003cp\u003e所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。\u003c/p\u003e\n\u003cp\u003e如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，适合产生大量数据的互联网服务的数据收集业务等。社区活跃度很高，何况几乎是全世界这个领域的事实性规范。kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。\u003c/p\u003e\n\u003ch4\u003e4、使用消息队列缺点：\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，整套系统崩溃了。\u003c/li\u003e\n\u003cli\u003e系统复杂性提高：加MQ进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？\u003c/li\u003e\n\u003cli\u003e一致性问题：A系统处理完了直接返回成功了，后面的如果失败了，这数据就不一致了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e一、RabbitMQ\u003c/h4\u003e\n\u003ch4\u003e1、RabbitMQ概述\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eAMQP\u003c/code\u003e，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层\u003cstrong\u003e标准高级消息队列协议\u003c/strong\u003e，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。\u003cbr\u003eAMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eRabbitMQ\u003c/code\u003e是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。\u003c/p\u003e\n\u003cp\u003eRabbitMQ 是比较有代表性的，因为是\u003ccode\u003e基于主从（非分布式）做高可用性\u003c/code\u003e的。\u003c/p\u003e\n\u003ch4\u003e2、RabbitMQ原理图\u003c/h4\u003e\n\u003cp\u003eRabbitMQ通过\u003ccode\u003e信道\u003c/code\u003e的方式传输数据，将消息发布到交换机上，消息拥有一个路邮键，由消息创建时设定，通过队列路由键，可以把队列绑定到交换机上，消息到达交换机后，RabbitMQ将消息的路由键与队列的路由键进行匹配（不同的交换机有不同的路由规则），匹配到相应的队列，消息投递到队列的队列中供消费者消费。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e多个消费者可以订阅同一个Queue，消息将以\u003ccode\u003e循环（round-robin）\u003c/code\u003e的方式发送给消费者，每条消息只会发给一个订阅的消费者，而不是每个消费者都收到所有的消息并处理。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e每个Channel运行在独立的线程上，多个线程共享同一个socket。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/dfde605794cc90a31ce1223c54218372.jpeg@c_1,w_901,h_315,x_0,y_0\" alt=\"\"\u003e\u003cbr\u003e\u003cstrong\u003e相关概念：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；\u003c/li\u003e\n\u003cli\u003eBroker：简单来说就是消息队列服务器实体。\u003c/li\u003e\n\u003cli\u003eChannel（信道）：消息推送使用的通道；\u003c/li\u003e\n\u003cli\u003eExchange（交换器）：用于接受、分配消息；\u003c/li\u003e\n\u003cli\u003eQueue（队列）：用于存储生产者的消息；\u003c/li\u003e\n\u003cli\u003eRoutingKey（路由键）：用于把生成者的数据分配到交换器上；【最大255个字节】\u003c/li\u003e\n\u003cli\u003eBindingKey（绑定键）：用于把交换器的消息绑定到队列上；【最大255个字节】\u003c/li\u003e\n\u003cli\u003evhost（虚拟主机）每个Rabbit都能创建很多vhost，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e3、RabbitMQ常用的三种交换机\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eRabbitMQ常用的三种Exchange\u003c/strong\u003e：fanout,direct,topic\u003c/p\u003e\n\u003ch4\u003e（1）Direct Exchange ：\u003c/h4\u003e\n\u003cp\u003e直连型交换机，根据消息携带的路由键将消息投递给对应队列。\u003cbr\u003e　　大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key。　然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。\u003c/p\u003e\n\u003ch4\u003e（2）Fanout Exchange：\u003c/h4\u003e\n\u003cp\u003e扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。\u003c/p\u003e\n\u003ch4\u003e（3）Topic Exchange：\u003c/h4\u003e\n\u003cp\u003e主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。\u003cbr\u003e　　\u003cbr\u003e\u003cstrong\u003e性能排序\u003c/strong\u003e：fanout \u0026gt; direct \u0026gt;\u0026gt; topic。\u003c/p\u003e\n\u003ch4\u003e4、 RabbitMQ集群元数据\u003c/h4\u003e\n\u003cp\u003eRabbitMQ集群会始终同步四种类型的内部元数据：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea. 队列元数据：队列名称和它的属性\u003c/li\u003e\n\u003cli\u003eb. 交换器元数据：交换器名称、类型和属性\u003c/li\u003e\n\u003cli\u003ec. 绑定元数据：一张简单的表格展示了如何将消息路由到队列\u003c/li\u003e\n\u003cli\u003ed. vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e5、RabbitMQ镜像集群\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eRabbitMQ 有三种模式\u003c/strong\u003e：单机模式、普通集群模式（无高可用性）、\u003ccode\u003e镜像集群模式\u003c/code\u003e（高可用性）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e镜像队列\u003c/code\u003e将需要消费的队列变成镜像队列，存在于多个节点，实现RabbitMQ的高可用，保证 100% 数据不丢失。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在消费者消费数据时临时拉取，缺点就是集群内部的\u003ccode\u003e同步通讯\u003c/code\u003e会占去大量的网络带宽。\u003cbr\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/53a92fdedade9355420e866bbdb51be1.jpeg@c_1,w_613,h_390,x_0,y_0\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch4\u003e二、RocketMQ\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eRocketMQ\u003c/code\u003e是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目。用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRocketMQ缺点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单机支持1万以上持久化队列；\u003c/li\u003e\n\u003cli\u003eRocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。\u003c/li\u003e\n\u003cli\u003e模型简单，接口易用（JMS的接口很多场合并不太实用）；\u003c/li\u003e\n\u003cli\u003e性能非常好，可以允许大量堆积消息在Broker中；\u003c/li\u003e\n\u003cli\u003e支持多种消费模式，包括集群消费、广播消费等；\u003c/li\u003e\n\u003cli\u003e各个环节分布式扩展设计，支持主从和高可用；\u003c/li\u003e\n\u003cli\u003e开发度较活跃，版本更新很快。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eRocketMQ缺点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟\u003c/li\u003e\n\u003cli\u003e维护RocketMQ需要专业的团队\u003c/li\u003e\n\u003cli\u003e商业版收费，有许多功能是不对外提供的。\u003c/li\u003e\n\u003cli\u003e没有在MQ核心里实现JMS等接口\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e三、kafka\u003c/h4\u003e\n\u003ch4\u003e1、kafka概述\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003ekafka\u003c/code\u003e是Linkedin于2010年12月份开源的\u003ccode\u003e消息发布订阅\u003c/code\u003e系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。作为hadoop生态系统的一部分，被各种商业公司广泛应用。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ekafka优点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒\u003c/li\u003e\n\u003cli\u003e可扩展性：kafka集群支持热扩展\u003c/li\u003e\n\u003cli\u003e持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失\u003c/li\u003e\n\u003cli\u003e容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）\u003c/li\u003e\n\u003cli\u003e高并发：支持数千个客户端同时读写\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003ekafka缺点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e快速持久化：可以在O(1)的系统开销下进行消息持久化；\u003c/li\u003e\n\u003cli\u003e高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；\u003c/li\u003e\n\u003cli\u003e完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；\u003c/li\u003e\n\u003cli\u003e支持同步和异步复制两种高可用机制；\u003c/li\u003e\n\u003cli\u003e支持数据批量发送和拉取；\u003c/li\u003e\n\u003cli\u003e零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；\u003c/li\u003e\n\u003cli\u003e数据迁移、扩容对用户透明；\u003c/li\u003e\n\u003cli\u003e无需停机即可扩展机器；\u003c/li\u003e\n\u003cli\u003e其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e2、kafka原理图\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/3d90e1705de49c669f22628af2f6004a.jpeg@c_1,w_1010,h_651,x_0,y_0\" alt=\"\"\u003e\u003cbr\u003e\u003cimg src=\"https://pic.rmb.bdstatic.com/bjh/beautify/a5531d658050ce7abecb5ad4242d92ab.jpeg@c_1,w_1002,h_300,x_0,y_0\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch4\u003e四、总结\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/middleware/img_20250723_04.png\" alt=\"img_20250723_04.png\"\u003e{: .full-width}\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T4826,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e服务注册中心 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。\u003c/p\u003e\n\u003cp\u003e并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景下做正确的技术选型。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003cstrong\u003e指标\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEureka\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eZookeeper\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eConsul\u003c/strong\u003e\u003c/th\u003e\n\u003cth\u003e\u003cstrong\u003eEtcd\u003c/strong\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e一致性协议\u003c/td\u003e\n\u003ctd\u003eAP\u003c/td\u003e\n\u003ctd\u003eCP（Paxos算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003ctd\u003eCP（Raft算法）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e健康检查\u003c/td\u003e\n\u003ctd\u003eTTL(Time To Live)\u003c/td\u003e\n\u003ctd\u003eTCP Keep Alive\u003c/td\u003e\n\u003ctd\u003eTTL\\HTTP\\TCP\\Script\u003c/td\u003e\n\u003ctd\u003eLease TTL KeepAlive\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ewatch/long polling\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003ctd\u003elong polling\u003c/td\u003e\n\u003ctd\u003ewatch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e雪崩保护\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e安全与权限\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eACL\u003c/td\u003e\n\u003ctd\u003eRBAC\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持多数据中心\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否有管理界面\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否（可用第三方ZkTools）\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpring Cloud 集成\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDubbo 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eK8S 集成\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e不支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003ctd\u003e支持\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e我们可以看出，四种技术类型对Spring Cloud的支持度都很高。Spring Cloud是微服务架构的一站式解决方案，我们平时构建微服务的过程中需要做的的如 配置管理、服务发现、负载均衡、断路器、智能路由、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作。Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。\u003c/p\u003e\n\u003cp\u003eSpring Cloud包含了多个不同开源产品，来保证一站式的微服务解决方案，如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。\u003c/p\u003e\n\u003ch2\u003eSpring Cloud 框架下实现 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSpring Cloud为服务治理做了一层抽象，这样能够支持多种不同的服务治理框架，比如：Netflix Eureka、Consul。我们这边就以这两个为例子，看看服务治理是如何实现。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e在Spring Cloud服务治理抽象层的作用下，可以无缝地切换服务治理实现，且不影响任何其他的服务注册、发现、调用逻辑。\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e所以，下面我们通过介绍这两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e2.Spring Cloud Eureka \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSpring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。\u003c/p\u003e\n\u003cp\u003e通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。\u003c/p\u003e\n\u003cp\u003e下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。\u003c/p\u003e\n\u003ch4\u003e2.1.创建注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e创建一个Spring Cloud项目，我们命名为micro-service-center，并在\u003ccode\u003epom.xml\u003c/code\u003e中引入需要的依赖内容：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e表明这个项目中可以没有Java代码，也不执行任何代码，只是为了聚合工程或者传递依赖，所以可以把src文件夹删了。这是一个父级项目，因为我们还要在下面建立Eureka的注册中心、客户端等多个子项目 。\u003c/p\u003e\n\u003cp\u003e在micro-service-center下，新建一个命名为 eureka-service 的Module，依旧是Spring Cloud 项目，建完之后，pom.xml做如下改动：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n    \u0026lt;!--在子工程中添加父工程名称--\u0026gt;\n    \u0026lt;parent\u0026gt;\n        \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n        \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;/parent\u0026gt;\n    \u0026lt;dependencies\u0026gt;\n        \u0026lt;!--加入 eureka 服务 --\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;spring-cloud-netflix-eureka-server\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n    \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e改完之后，回到父项目micro-service-center，修改pom中的信息：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n    \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n    \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt;\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;name\u0026gt;center\u0026lt;/name\u0026gt;\n    \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt;\n    \u0026lt;!--在父工程添加子工程名称--\u0026gt;\n    \u0026lt;modules\u0026gt;\n        \u0026lt;module\u0026gt;eureka-service\u0026lt;/module\u0026gt;\n        \u0026lt;module\u0026gt;eureka-client\u0026lt;/module\u0026gt;\n    \u0026lt;/modules\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e对两个项目进行clean + install，应该是成功的。\u003c/p\u003e\n\u003cp\u003eeureka-service我们是作为注册中心来用的，所以在它的主类Application中加入\u003ccode\u003e@EnableEurekaServer\u003c/code\u003e注解，就能开启注册中心功能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableEurekaServer\npublic class ServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceApplication.class, args);\n        System.out.println(\u0026quot;Start Eureka Service\u0026quot;);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是默认情况下，该注册中心也会把自己当做客户端，那就变成自己注册自己了，这个是可以剔除的，我们看一下它的YAML中的详细配置，注释比较清楚：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e  server:\n    port: 1000\n  spring:\n    application:\n      name: eureka-server\n  eureka:\n    instance:\n      hostname: localhost\n    client:\n    register-with-eureka: false  # 不作为客户端进行注册\n    fetch-registry: false  # 不获取注册列表\n    service-url:  # 注册地址，客户端需要注册到该地址中\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e文中的注释还是比较清楚的。 这边可以看到，端口号是1000，所以当工程启动之后，访问 \u003ca href=\"http://localhost:1000/\"\u003ehttp://localhost:1000/\u003c/a\u003e 是可以看到Eureka注册中心页面的。其中还没有发现任何服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_1.png\" alt=\"image_7_1.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e2.1.创建客户端 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e目前服务中心还是空的，所以我们创建一个能够提供服务的客户端，并将其注册到注册中心去。\u003c/p\u003e\n\u003cp\u003e同样的，我们创建一个Spring Cloud的子项目，命名为\u003ccode\u003eeureka-client\u003c/code\u003e，\u003ccode\u003epom.xml\u003c/code\u003e中的配置如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e  \n\u0026lt;xml\u0026gt;\n    \u0026lt;!--在子工程中添加父工程名称--\u0026gt;\n    \u0026lt;parent\u0026gt;\n        \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n        \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n    \u0026lt;/parent\u0026gt;\n    \u0026lt;dependencies\u0026gt;\n        \u0026lt;!--加入 eureka 服务 --\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;spring-cloud-netflix-eureka-server\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n        \u0026lt;dependency\u0026gt;\n            \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\n            \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\n        \u0026lt;/dependency\u0026gt;\n    \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在应用主类Application文件中通过加上\u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e注解，该注解保证当前服务被Eureka当成provider发现。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableDiscoveryClient\npublic class ClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ClientApplication.class, args);\n        System.out.println(\u0026quot;start client!\u0026quot;);\n    }\n}jC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在YAML文件上加上如下配置：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eserver:\n  port: 1001\nspring:\n  application:\n    name: eureka-client\neureka:\n  client:\n    service-url:  # 这边就保证了注册到 eureka-service 这个注册中心去\n      defaultZone: http://localhost:1000/eureka/\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003espring.application.name\u003c/code\u003e属性，指定了微服务的名称，在调用的时候可以通过该名称进行服务访问。\u003ccode\u003eeureka.client.serviceUrl.defaultZone\u003c/code\u003e属性对应服务注册中心的配置内容，指定服务注册中心的位置。\u003c/p\u003e\n\u003cp\u003e大家看到，这边端口设置为1001，那是因为要在本机上测试 服务提供方 和 服务注册中心，所以\u003ccode\u003eserver的port\u003c/code\u003e属性需设置不同的端口。\u003c/p\u003e\n\u003cp\u003e最后，我们再写一个接口，通过DiscoveryClient对象，在客户端中获取注册中心的所有服务信息。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  @Controller\n  @RequestMapping(\u0026quot;/eurekacenter\u0026quot;)\n  public class EuServiceController {\n  \n    @Autowired\n    DiscoveryClient discoveryClient;\n    \n    @RequestMapping(value = \u0026quot;/service\u0026quot;, method = {RequestMethod.GET})\n    @ResponseBody\n    public String getServiceInfo() {\n       return  \u0026quot;service:\u0026quot;+discoveryClient.getServices()+\u0026quot; , memo:\u0026quot;+discoveryClient.description();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时候跑一下试试看，继续访问之前的地址：\u003ca href=\"http://localhost:1000/\"\u003ehttp://localhost:1000/\u003c/a\u003e ，可以看到Eureka注册中心页面已经包含一个我们定义的服务了，就是上面新建的 100端口的服务。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_2.png\" alt=\"image_7_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e同样，我们可以调用上面的那个获取注册服务信息的接口，从服务发现的角度看看有多少个服务被注册到注册中心去。 \u003ca href=\"http://localhost:1001/eurekacenter/service\"\u003ehttp://localhost:1001/eurekacenter/service\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_3.png\" alt=\"image_7_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示，方括号中的\u003ccode\u003eeureka-client\u003c/code\u003e通过Spring Cloud定义的 getServiceInfo 接口在eureka的实现中获取到的所有服务清单，他是一个String的List，如果注册了多个提供者，就会全部显示。\u003c/p\u003e\n\u003ch3\u003e2.Spring Cloud Consul \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eConsul 用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更具“一站式”特征，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 之类的）。\u003c/p\u003e\n\u003cp\u003e而Spring Cloud Consul ，是将其作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。\u003c/p\u003e\n\u003ch4\u003e2.2.Consul 的优势 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接。\u003c/p\u003e\n\u003cp\u003e2、支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持，上面表格中有体现。\u003c/p\u003e\n\u003cp\u003e3、支持健康检查。\u003c/p\u003e\n\u003cp\u003e4、支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。\u003c/p\u003e\n\u003cp\u003e5、官方提供 web 管理界面, etcd 无此功能。\u003c/p\u003e\n\u003ch4\u003e2.2.Consul的特性 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、服务发现\u003c/p\u003e\n\u003cp\u003e2、健康检查\u003c/p\u003e\n\u003cp\u003e3、Key/Value存储\u003c/p\u003e\n\u003cp\u003e4、多数据中心\u003c/p\u003e\n\u003ch4\u003e2.2.安装Consul注册中心 \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、官方下载64版本 ：\u003ca href=\"https://www.consul.io/downloads.html\"\u003ehttps://www.consul.io/downloads.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e2、解压后复制到目录 /usr/local/bin 下\u003c/p\u003e\n\u003cp\u003e3、启动终端，先看下啥版本的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eliyifei@MacPro ~ % consul --version\nConsul v1.10.4\nRevision 7bbad6fe\nProtocol spoken by default, understands to (agent will automatically use protocol \u0026gt;when speaking to compatible agents)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e4、执行安装命令，可以看到他的 Client Addr 的端口为8500。所以访问 8500端口站点，\u003ca href=\"http://127.0.0.1:8500/ui/dc1/services\"\u003ehttp://127.0.0.1:8500/ui/dc1/services\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e  liyifei@MacPro ~ % consul agent -dev\n  ==\u0026gt; Starting Consul agent...\n             Version: \u0026#39;1.10.4\u0026#39;\n             Node ID: \u0026#39;6db154b4-62ff-e67d-e745-1a7270fa1ce8\u0026#39;\n           Node name: \u0026#39;B000000147796DS\u0026#39;\n          Datacenter: \u0026#39;dc1\u0026#39; (Segment: \u0026#39;\u0026lt;all\u0026gt;\u0026#39;)\n              Server: true (Bootstrap: false)\n         Client Addr: [127.0.0.1] (HTTP: 8500, HTTPS: -1, gRPC: 8502, DNS: 8600)\n        Cluster Addr: 127.0.0.(LAN: 8301, WAN: 8302)\n           Encrypt: Gossip: false, TLS-Outgoing: false, TLS-Incoming: false, Auto-Encrypt-TLS: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_4.png\" alt=\"image_7_4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我们可以看到，现在没有客户端注册上来，只有一个自身的实例。\u003c/p\u003e\n\u003ch4\u003e2.2.创建服务提供者 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。\u003c/p\u003e\n\u003cp\u003e我们在micro-service-center下新建一个cloud项目consul-client，该项目pom文件添加如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;xml\u0026gt;\n  \u0026lt;!--    在子工程中添加父工程名称--\u0026gt;\n  \u0026lt;parent\u0026gt;\n    \u0026lt;groupId\u0026gt;com.microservice\u0026lt;/groupId\u0026gt;\n    \u0026lt;artifactId\u0026gt;center\u0026lt;/artifactId\u0026gt;\n    \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;\n  \u0026lt;/parent\u0026gt;\n  \n  \u0026lt;dependencies\u0026gt;\n    \u0026lt;!--        Consul服务发现--\u0026gt;\n    \u0026lt;dependency\u0026gt;\n        \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;spring-cloud-starter-consul-discovery\u0026lt;/artifactId\u0026gt;\n    \u0026lt;/dependency\u0026gt;\n    \u0026lt;!--        Consul健康检查--\u0026gt;\n    \u0026lt;dependency\u0026gt;\n        \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;\n        \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt;\n    \u0026lt;/dependency\u0026gt;\n  \u0026lt;/dependencies\u0026gt;\n\u0026lt;/xml\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后修改一下\u003ccode\u003eapplication.yml的配置信息\u003c/code\u003e，将consul配置写入，注释应该很清楚了，如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003espring:\n  application:\n    name: consul-producer # 当前服务的名称\n  cloud:\n    consul: # 以下为Consuk注册中心的地址，如果安装的不是这个host和port，这边可以调整\n      host: localhost\n      port: 8500\nserver:\n  port: 850# 当前服务的端口\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同样的，我们要在应用主类Application文件中通过加上\u003ccode\u003e@EnableDiscoveryClient\u003c/code\u003e注解，该注解保证当前服务被Consul当成provider发现。\u003c/p\u003e\n\u003cp\u003e大家看到这个做法跟Eureka一样，因为Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，\u003c/p\u003e\n\u003cp\u003e程序上不需要做改变，只需要引入不同的服务治理依赖，并配置相关的配置属性 就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ClientApplication.class, args);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e修改完成之后，我们就可以把这个服务提供者启动了，然后再去注册中心查看服务的注册情况，就可以看到被注册进来的Provider（consul-producer）：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_7_5.png\" alt=\"image_7_5.png\"\u003e\u003c/p\u003e\n\u003ch2\u003e总结 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e除了 Eureka、Consul，还有其他的的注册中心技术，如Zookeeper、Nocas等。但无论何种注册中心技术，本质上都是为了解决微服务中的如下问题：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解耦服务之间相互依赖的细节\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们知道服务之间的远程调用必须要知道对方的IP、端口信息。我们可以在调用方直接配置被调用方的IP、端口，这种调用方直接依赖IP、端口的方式存在明显的问题，如被调用的IP、端口变化后，调用方法也要同步修改。\u003c/p\u003e\n\u003cp\u003e通过服务发现，将服务之间IP与端口的依赖转化为服务名的依赖，服务名可以根据具微服务业务来做标识，因此，屏蔽、解耦服务之间的依赖细节是服务发现与注册解决的第一个问题。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对微服务进行动态管理\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在微服务架构中，服务众多，服务之间的相互依赖也错综复杂，无论是服务主动停止，意外挂掉，还是因为流量增加对服务实现进行扩容，这些服务数据或状态上的动态变化，都需要尽快的通知到被调用方，被调用方才采取相应的措施。因此，对于服务注册与发现要实时管理者服务的数据与状态，包括服务的注册上线、服务主动下线，异常服务的剔除。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"18:T454,\u003ch1\u003eMaven使用技巧\u003c/h1\u003e\n\u003ch3\u003e1、使用maven.config定制化配置\u003c/h3\u003e\n\u003cp\u003eLocated within the project\u0026#39;s \u003cstrong\u003etop level directory\u003c/strong\u003e, the files\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emaven.config\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejvm.config\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eextensions.xml\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003econtain project specific configuration for running Maven.\u003c/p\u003e\n\u003cp\u003eThis directory is part of the project and may be checked in into your version control.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eref：\u003ca href=\"https://maven.apache.org/configure.html\"\u003ehttps://maven.apache.org/configure.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e常见配置如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e-Dmaven.test.skip=true\n--settings\n/Users/skyfalling/.m2/settings.xml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere must not be a whitespace after \u003ccode\u003e--settings,\u003c/code\u003eWith the introduction of \u003ccode\u003emaven 3.9\u003c/code\u003e, there was a BREAKING CHANGE that affects the parsing of the \u003ccode\u003emaven.config\u003c/code\u003e file:\u003c/p\u003e\n\u003cp\u003eEach line in \u003ccode\u003e.mvn/maven.config\u003c/code\u003e is now interpreted as a single argument. That is, if the file contains multiple arguments, these must now be placed on separate lines.\u003c/p\u003e\n19:T1245,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e微服务系列\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E6%BC%94%E8%BF%9B%E5%8F%B2/\"\u003e微服务及其演进史\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%9E%B6%E6%9E%84/\"\u003e微服务全景架构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5/\"\u003e微服务拆分策略\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5%EF%BC%88%E9%99%84%E5%8A%A0%E7%AF%87%EF%BC%89/\"\u003e微服务拆分策略（附加篇）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/\"\u003e服务注册与发现\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89/\"\u003e服务注册与发现（实践篇）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e中间件\u003c/h2\u003e\n\u003ch3\u003e消息队列\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../middleware/RabbitMQ%E3%80%81RocketMQ%E3%80%81Kafka%E5%8C%BA%E5%88%AB/\"\u003eRabbitMQ、RocketMQ、Kafka区别\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../middleware/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E3%80%81%E4%B8%89%E9%98%B6%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE/\"\u003e分布式事务之两阶段、三阶提交协议\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e架构设计\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../system/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/\"\u003e架构设计模板\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E6%9E%B6%E6%9E%84/\"\u003e从0开始做一个后台架构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/\"\u003e一个秒杀系统的设计思考\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%8415%E4%B8%AA%E9%94%A6%E5%9B%8A/\"\u003e高并发系统设计的15个锦囊\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E9%A2%86%E7%95%A5SET%E5%8C%96%E6%9E%B6%E6%9E%84%E8%A1%8D%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/\"\u003e领略SET化架构衍化与设计\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e大数据\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../bigdata/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B9%8BBitmap%E7%AF%87/\"\u003e大数据分析常用去重算法分析之Bitmap篇\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../bigdata/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B9%8BHyperLogLog%E7%AF%87/\"\u003e大数据分析常用去重算法分析之HyperLogLog篇\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e业务架构\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../business/%E5%85%B3%E4%BA%8E%E4%B8%9A%E5%8A%A1%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83/\"\u003e关于业务平台架构的思考\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E8%A7%A3%E6%9E%90%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%BB%BA%E7%AB%8B%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B/\"\u003e解析三户模型及建立账户模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%B8%89%E9%87%8D%E8%A7%86%E8%A7%92%E2%80%94%E2%80%94%E6%80%8E%E6%A0%B7%E7%AE%97%E6%87%82%E4%B8%9A%E5%8A%A1/\"\u003e业务的三重视角——怎样算懂业务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E4%B8%9A%E5%8A%A1%E4%B8%89%E9%87%8D%E8%A7%86%E8%A7%92%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B/\"\u003e业务三重视角——业务模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E4%B8%9A%E5%8A%A1%E4%B8%89%E9%87%8D%E8%A7%86%E8%A7%92%E2%80%94%E2%80%94%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/\"\u003e业务三重视角——商业模式\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%B8%89%E5%B1%82%E8%BA%AB%E4%BB%BD%E6%A8%A1%E5%9E%8B/\"\u003e用户系统设计——三户模型及三层身份模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/\"\u003e权限系统方案设计\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E7%94%B5%E5%95%86%E5%88%86%E6%9E%90%E5%BF%85%E6%87%82%E7%9A%84%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/\"\u003e电商分析必懂的指标体系\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e技术实战\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../practice/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7/\"\u003e非侵入式SQL监控\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../practice/Java%E6%9E%84%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/\"\u003eJava构件发布到中央仓库\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../practice/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/\"\u003eGit常用命令\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../practice/Maven%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/\"\u003eMaven使用技巧\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-03-31\",\"children\":\"2024年03月31日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"RabbitMQ、RocketMQ、Kafka区别\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L5\",\"消息队列\",{\"href\":\"/blog/tag/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"消息队列\"}],[\"$\",\"$L5\",\"技术专题\",{\"href\":\"/blog/tag/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"技术专题\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$11\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"technique/microservice/服务注册与发现（实践篇）\",\"title\":\"服务注册与发现（实践篇）\",\"description\":\"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景...\",\"pubDate\":\"2024-03-24\",\"tags\":[\"微服务架构\",\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"technique/practice/Maven使用技巧\",\"title\":\"Maven使用技巧\",\"description\":\"手把手教你如何在工作中巧妙使用Maven，提升开发效率。\",\"pubDate\":\"2024-04-03\",\"tags\":[\"技术实战\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"消息队列\":{\"prev\":null,\"next\":null},\"技术专题\":{\"prev\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":{\"slug\":\"technique/SUMMARY\",\"title\":\"技术专题\",\"description\":\"* [微服务系列].[系统架构].[业务架构].[技术实战]\",\"pubDate\":\"2024-04-10\",\"tags\":[\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"}}}}]}],[\"$\",\"$L1a\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"RabbitMQ、RocketMQ、Kafka区别 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"RabbitMQ、RocketMQ、Kafka区别\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-03-31\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"RabbitMQ、RocketMQ、Kafka区别\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"MQ（Message Queue，消息队列） 在实际应用中常用的使用场景：异步处理，应用解耦，流量削锋和消息通讯四个场景。目前使用较多的消息队列有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/0a7d53676a1eb136.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-42d55485b4428e47.js"/><script src="/_next/static/chunks/4bd1b696-8ec333fca6b38e39.js" async=""></script><script src="/_next/static/chunks/1684-a2aac8a674e5d38c.js" async=""></script><script src="/_next/static/chunks/main-app-2791dc86ed05573e.js" async=""></script><script src="/_next/static/chunks/6874-7791217feaf05c17.js" async=""></script><script src="/_next/static/chunks/app/layout-51baccc14cf1da9e.js" async=""></script><script src="/_next/static/chunks/968-d7155a2506e36f1d.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-1a068657a275b968.js" async=""></script><meta name="next-size-adjust" content=""/><title>非侵入式SQL监控 - Skyfalling Blog</title><meta name="description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><meta property="og:title" content="非侵入式SQL监控"/><meta property="og:description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-04-07"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="非侵入式SQL监控"/><meta name="twitter:description" content="你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？..."/><link rel="shortcut icon" href="/favicon.png"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.png"/><link rel="apple-touch-icon" href="/favicon.png"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-04-07">2024年04月07日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">非侵入式SQL监控</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/page/1/">技术实战</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-blockquote:border-l-4 prose-blockquote:border-blue-500 prose-blockquote:bg-blue-50 prose-blockquote:py-2 prose-blockquote:px-4 prose-blockquote:rounded-r-lg prose-ul:list-disc prose-ol:list-decimal prose-li:text-gray-700 prose-hr:border-gray-300"><p>你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。</p>
<p>另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) 
and name in(sql
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;)
)
</code></pre>
<p>缩略下印如下：</p>
<pre><code class="language-sql">select * from user 
where id in (1001,1001, 1002, 1003, 1004,...) 
and name in(
select name from whitelist 
where name in(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,...)
)
</code></pre>
<p>既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -&gt; ORM -&gt; DataSource  -&gt; Connection -&gt; Driver -&gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -&gt; DataSource  -&gt; Connection -&gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从<strong>DataSource  -&gt; Connection -&gt; Driver</strong>三个环节进行入手：</p>
<h3><strong>一、SQL Profile监控</strong></h3>
<h4><strong>1、驱动层监控</strong></h4>
<p>如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：</p>
<pre><code class="language-properties">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;logger=Slf4JLogger&amp;profileSQL=true
</code></pre>
<p>基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。</p>
<h4><strong>2、连接层监控</strong></h4>
<p>如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如<a href="https://p6spy.readthedocs.io/en/latest/">P6Spy</a>、<a href="https://github.com/arthurblake/log4jdbc">log4jdbc</a> 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：</p>
<ul>
<li>pyspy</li>
</ul>
<pre><code class="language-properties">jdbc:p6spy:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-properties">jdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC
</code></pre>
<h4><strong>3、数据源层监控</strong></h4>
<p>可以通过对DataSource进行代理实现SQL监控</p>
<ul>
<li>P6Spy：</li>
</ul>
<pre><code class="language-java">@Bean
@Primary
public DataSource spyDataSource(@Autowired DataSource dataSource) {
  // wrap a datasource using P6SpyDataSource
  return new P6DataSource(dataSource);
}
</code></pre>
<ul>
<li>log4jdbc</li>
</ul>
<pre><code class="language-java">public DataSource spyDataSource(DataSource dataSource) {
    // wrap the provided dataSource
  return new DataSource() {
    @Override
    public Connection getConnection() throws SQLException {
      // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection());
    }
      
    @Override
    public Connection getConnection(String username, String password) throws SQLException {
       // wrap the connection with log4jdbc
      return new ConnectionSpy(dataSource.getConnection(username, password));
     }
      //...
  };
}
</code></pre>
<p>上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。</p>
<p>第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。</p>
<p>第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。</p>
<p>排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。</p>
<pre><code class="language-java">public interface DataSourceConfig extends HasBizDef {

    /**
     * 数据源名称，必须与KDB申请时填写的一致
     */String bizName();

    /**
     * 获取当前可用区单库只读的JdbcTemplate
     */
    default NamedParameterJdbcTemplate read() {
        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), &quot;read&quot;);
    }   

    /**
     * 获取当前可用区单库读写的JdbcTemplate
     */
    default NamedParameterJdbcTemplate write() {
        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), &quot;write&quot;);
    }	
  //....
}
</code></pre>
<p>DefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:</p>
<pre><code class="language-kotlin">enum class AdDataSources(
    private val bizDef: BizDef,
    private val forTest: AdDataSources? = null,
    private val usingNewZk: Boolean = false
) : DataSourceConfig{
    adFansTopProfileDashboardTest,
    adFansTopProfileDashboard,
    adChargeTest,
    adCharge,
    adChargeReadOnly,
    adDspReadOnlyTest,
    adDspReadOnly;
    public open fun bizName(): String {
        return bizDef.bizName
    }
}
</code></pre>
<p>如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？</p>
<p>具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：</p>
<pre><code class="language-java">public static ListenableDataSource&lt;Failover&lt;Instance&gt;&gt; create(Instance i) {
   //...
   try {
       return supplyWithRetry(
        DATA_SOURCE_BUILD_RETRY,
        DATA_SOURCE_BUILD_RETRY_DELAY,
        () -&gt; new ListenableDataSource&lt;&gt;(
              bizName, 
              new HikariDataSource(config), ds -&gt; i.toString(), i),
              DataSourceFactory::needRetry);
                               
  } catch (Throwable e) {/**/}
}
</code></pre>
<p>由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?</p>
<h3><strong>二、动态修改加载类</strong></h3>
<p>成本最低的方式就是直接修改这段代码，将其中&#x7684;<em>&#x6E;ew HikariDataSource(config)</em>&#x4FEE;改&#x6210;<em>&#x6E;ew P6DataSource(new HikariDataSource(config))，</em>&#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？</p>
<p>首先我们来分析一下，有哪些手段可以修改Java字节码？</p>
<ul>
<li>方案一、编译时修改，需要开发maven插件</li>
</ul>
<p>（不使用maven插件的同学咋办？）</p>
<ul>
<li>方案二、加载时修改，重写类加载器</li>
</ul>
<p>需要在代码中指定特定的类加载器，用有一定的侵入式</p>
<ul>
<li>方案三、运行时修改，使用JavaAgent</li>
</ul>
<p>需要修改应用启动参数，运维成本有点高</p>
<p>首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。</p>
<p><em>下面是对动态启动Java Agent技术的解释</em></p>
<blockquote>
<p>Note that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.</p>
</blockquote>
<blockquote>
<p>See <a href="https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description">the java.lang.instrument package documentation</a>…</p>
</blockquote>
<blockquote>
<p>Getting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. <a href="https://stackoverflow.com/a/19912148/2711488">This answer</a> demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.</p>
</blockquote>
<blockquote>
<p>However, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.</p>
</blockquote>
<blockquote>
<p>As mentioned in <a href="https://stackoverflow.com/questions/56787777/?noredirect=1&lq=1#comment100160373_56787777">this comment</a>, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.</p>
</blockquote>
<ul>
<li>字节码工具对比</li>
</ul>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png" alt="图片"></p>
<ul>
<li>使用bytebuddy修改字节码</li>
</ul>
<p>在实现代码之前，我们回过头来再看一下快手的数据源生成：</p>
<pre><code class="language-java">new ListenableDataSource&lt;&gt;(bizName, new HikariDataSource(config), ds -&gt; i.toString());
</code></pre>
<p>这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：</p>
<pre><code class="language-java">public class DelegatingDataSource implements DataSource {
   //...
  public DelegatingDataSource(DataSource targetDataSource) {
    this.setTargetDataSource(targetDataSource);
   }

  public void setTargetDataSource(@Nullable DataSource targetDataSource) {
      this.targetDataSource = targetDataSource;
  }
  //...
}
</code></pre>
<p>因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
        this.targetDataSource = new P6DataSource(targetDataSource;
}
</code></pre>
<p>那么具体如何修改字节码呢？这里是<a href="https://bytebuddy.net/#/tutorial">官方文档</a>，原理我们不做赘述，直接介绍实现了。实现方式有三种：</p>
<h4><strong>1、类文件替换</strong></h4>
<p>假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：</p>
<pre><code class="language-java">new ByteBuddy()
  .redefine(NewDelegatingDataSource.class)
  .name(DelegatingDataSource.class.getName())
  .make()
  .load(Thread.currentThread().getContextClassLoader(), 
        ClassReloadingStrategy.fromInstalledAgent());
</code></pre>
<h4><strong>2、操作字节码：</strong></h4>
<pre><code class="language-java">new ByteBuddy()
    .redefine(DelegatingDataSource.class)
    //重写DelegatingDataSource#setTargetDataSource方法
    .method(named(&quot;setTargetDataSource&quot;))
    .intercept(MyImplementation.INSTANCE)
    .make()
    .load(Thread.currentThread().getContextClassLoader(),
          ClassReloadingStrategy.fromInstalledAgent());

enum MyImplementation implements Implementation {

INSTANCE; // singleton

  @Override
  public InstrumentedType prepare(InstrumentedType instrumentedType) {
  return instrumentedType;
  }
  
  @Override
  public ByteCodeAppender appender(Target implementationTarget) {
  return MyAppender.INSTANCE;
  }
  
}
//字节码定义
enum MyAppender implements ByteCodeAppender {

INSTANCE; // singleton

@Override
public Size apply(MethodVisitor methodVisitor,
        Implementation.Context implementationContext,
        MethodDescription instrumentedMethod) {
  Label label0 = new Label();
  methodVisitor.visitLabel(label0);
  methodVisitor.visitLineNumber(70, label0);
  methodVisitor.visitVarInsn(ALOAD, 0);
  methodVisitor.visitTypeInsn(NEW, &quot;com/p6spy/engine/spy/P6DataSource&quot;);
  methodVisitor.visitInsn(DUP);
  methodVisitor.visitVarInsn(ALOAD, 1);
  methodVisitor.visitMethodInsn(INVOKESPECIAL, &quot;com/p6spy/engine/spy/P6DataSource&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljavax/sql/DataSource;)V&quot;, false);
  methodVisitor.visitFieldInsn(PUTFIELD, &quot;org/springframework/jdbc/datasource/DelegatingDataSource&quot;, &quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;);
  Label label1 = new Label();
  methodVisitor.visitLabel(label1);
  methodVisitor.visitLineNumber(71, label1);
  methodVisitor.visitInsn(RETURN);
  Label label2 = new Label();
  methodVisitor.visitLabel(label2);
  methodVisitor.visitLocalVariable(&quot;this&quot;, &quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;&quot;, null, label0, label2, 0);
  methodVisitor.visitLocalVariable(&quot;targetDataSource&quot;, &quot;Ljavax/sql/DataSource;&quot;, null, label0, label2, 1);
  methodVisitor.visitMaxs(4, 2);
  return new Size(4, 2);
  }
}
</code></pre>
<p>上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？</p>
<p>我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9" alt="图片"></p>
<h4><strong>3、利用byte-buddy的Advice</strong></h4>
<pre><code class="language-java"> public static void redefine() {
   new ByteBuddy()
     .redefine(DelegatingDataSource.class)
     .visit(Advice.to(Decorator.class)
            .on(ElementMatchers.named(&quot;setTargetDataSource&quot;)))
     .make()
     .load(Thread.currentThread().getContextClassLoader(),
           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();
 }

static class Decorator {

  //在方法开始插入代码
  @Advice.OnMethodEnter
    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {
    dataSource = new P6DataSource(dataSource);
  }
}
</code></pre>
<p>byte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：</p>
<pre><code class="language-java">public void setTargetDataSource(@Nullable DataSource targetDataSource) {
  //插入的代码
  targetDataSource = new P6DataSource(targetDataSource);
  this.targetDataSource = targetDataSource;
}
</code></pre>
<p>注：</p>
<ol>
<li>动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。</li>
<li>使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。</li>
</ol>
<h3><strong>三、自动生效</strong></h3>
<p>前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。</p>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.kuaishou.ad&lt;/groupId&gt;
  &lt;artifactId&gt;sqllog-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;制品库查询最新版&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。</p>
<pre><code class="language-java">private static String[] getConfigurations(File file) {
  @EnableAutoConfiguration
  class NoScan {
    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载
  }
  FileClassLoader classLoader = new FileClassLoader(file);
  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();
  selector.setBeanClassLoader(classLoader);
  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));
  selector.setEnvironment(new StandardEnvironment());
  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));
  return configurations;
}
</code></pre>
<h3><strong>四、SQL打印效果</strong></h3>
<p>sqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：</p>
<p><img src="https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44" alt=""></p>
<p>SQL的打印内容分为三部分：</p>
<p>第一行，显示执行时间、耗时、SQL操作、数据库连接等信息</p>
<p>第二行，显示参数化SQL</p>
<p>第三行，显示绑定参数后的实际执行的SQL</p>
<p>通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-600 hover:text-gray-800" href="/about/">关于</a><a class="text-gray-600 hover:text-gray-800" href="/blog/">博客</a><a class="text-gray-600 hover:text-gray-800" href="/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-600">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/_next/static/chunks/webpack-42d55485b4428e47.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"7177\",\"static/chunks/app/layout-51baccc14cf1da9e.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n5:I[6874,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-1a068657a275b968.js\"],\"\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[59665,[],\"MetadataBoundary\"]\n10:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/0a7d53676a1eb136.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"B__hhCIN0XnpLTOdqGevC\",\"p\":\"\",\"c\":[\"\",\"blog\",\"tech\",\"practice\",\"%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"tech/practice/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0a7d53676a1eb136.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-600\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"tech/practice/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"RyDp8E7oyBaKZh91KPKj3v\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[74911,[],\"AsyncMetadata\"]\n14:I[32923,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-1a068657a275b968.js\"],\"default\"]\n16:I[40780,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-1a068657a275b968.js\"],\"default\"]\n19:I[85300,[\"6874\",\"static/chunks/6874-7791217feaf05c17.js\",\"968\",\"static/chunks/968-d7155a2506e36f1d.js\",\"6909\",\"static/chunks/app/blog/%5B...slug%5D/page-1a068657a275b968.js\"],\"default\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n15:T4fc0,"])</script><script>self.__next_f.push([1,"\u003cp\u003e你有没有遇到过因为没有打印SQL导致问题排查困难？如果你使用了成熟ORM框架，那么很容易支撑SQL的拦截和监控，例如Mybatis的Interceptor或JOOQ的Listener都支持SQL执行过程的跟踪监控，但是，如果你的ORM框架不支持SQL监控，那么很不幸，你就只能在代码中手动打印日志了。然而，为了防SQL注入，应用中的SQL语句都是参数化的，直接打印的话，SQL语句未绑定参数，ORM框架一般都提供了SQL参数绑定的功能，原生的JDBC这样就失去了一定的监控价值。\u003c/p\u003e\n\u003cp\u003e另外，在TOB的业务中，有些场景SQL参数超长，如大IN查询，SQL语句会长达到几万甚至十几万，此时，我们又需要对SQL语句进行缩略打印。注意，这里的SQL缩略打印不是简单的对SQL语句进行截断，而是对SQL语句中的参数列表进行截断，例如下面的SQL\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004, 1005, 1006, 1007) \nand name in(sql\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;g\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;j\u0026#39;,\u0026#39;k\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;m\u0026#39;)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e缩略下印如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect * from user \nwhere id in (1001,1001, 1002, 1003, 1004,...) \nand name in(\nselect name from whitelist \nwhere name in(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,...)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e既然SQL 监控很重要，那么对于应用层的SQL监控都有哪些手段呢？一个SQL请求的执行链路，一般从DAO层开始：DAO -\u0026gt; ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver -\u0026gt; DB，那么在这个链路上有哪些环节可以切入监控呢？ DAO层是数据访问层的入口，而我们的目标是应用层监控，因此，能够实现SQL监控的环节只有：ORM -\u0026gt; DataSource  -\u0026gt; Connection -\u0026gt; Driver，而要实现通用的非侵入式监控，则应该独立于ORM，因此我们可以从\u003cstrong\u003eDataSource  -\u0026gt; Connection -\u0026gt; Driver\u003c/strong\u003e三个环节进行入手：\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e一、SQL Profile监控\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4\u003e\u003cstrong\u003e1、驱动层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果Driver层支持日志监控，则最方便，例如MySQL，可以在jdbc url中添加logger：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\u0026amp;logger=Slf4JLogger\u0026amp;profileSQL=true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e基于Driver监控的问题在于：一方面强依赖于DB，和ORM层面临一样的问题，不具有通用性上述的问题，且需要厂商的支持，例如Oracle Driver就不支持日志监控；另一方面SQL格式固定，无法进行定制化输出。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e2、连接层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果厂商驱动不支持SQL日志，可以Driver进行代理实现SQL监控功能，常用的开源组件如\u003ca href=\"https://p6spy.readthedocs.io/en/latest/\"\u003eP6Spy\u003c/a\u003e、\u003ca href=\"https://github.com/arthurblake/log4jdbc\"\u003elog4jdbc\u003c/a\u003e 等，其原理都是代理了厂商的驱动，因此只需要修改jdbc url：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epyspy\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:p6spy:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-properties\"\u003ejdbc:log4jdbc:mysql://localhost:3306/test?useUnicode=true\u0026amp;characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;serverTimezone=UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e3、数据源层监控\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e可以通过对DataSource进行代理实现SQL监控\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eP6Spy：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Bean\n@Primary\npublic DataSource spyDataSource(@Autowired DataSource dataSource) {\n  // wrap a datasource using P6SpyDataSource\n  return new P6DataSource(dataSource);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003elog4jdbc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic DataSource spyDataSource(DataSource dataSource) {\n    // wrap the provided dataSource\n  return new DataSource() {\n    @Override\n    public Connection getConnection() throws SQLException {\n      // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection());\n    }\n      \n    @Override\n    public Connection getConnection(String username, String password) throws SQLException {\n       // wrap the connection with log4jdbc\n      return new ConnectionSpy(dataSource.getConnection(username, password));\n     }\n      //...\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述三种方案都可以实现SQL监控，那么在实际应用场景中选择哪种方式更好呢？这和实际的生产方式有关。在我手，数据库是基于KDB的，Java应用是基于KsBoot，其中，数据库连接是在KDB平台配置的，底层的数据源是使用ShardingSphere+HikariDataSource进行魔改的。\u003c/p\u003e\n\u003cp\u003e第一种方案，由于数据库连接是由DBA维护的，升级需求修改数据库连接，因此不建议。\u003c/p\u003e\n\u003cp\u003e第二种方案，同理需要修改数据库连接，且比第一种更容易配错，因此也不建议。\u003c/p\u003e\n\u003cp\u003e排除上述两种方式，剩下的只有第三种方案了，但是第三种方案有很大的挑战，原因在于需要兼容快手kuaishou-framework奇葩的JdbcTemplate使用方式。确切地说，在于使用了DataSourceConfig。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic interface DataSourceConfig extends HasBizDef {\n\n    /**\n     * 数据源名称，必须与KDB申请时填写的一致\n     */String bizName();\n\n    /**\n     * 获取当前可用区单库只读的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate read() {\n        return InternalDatasourceConfig.readForceAz(this, currentAz(), currentPaz(), \u0026quot;read\u0026quot;);\n    }   \n\n    /**\n     * 获取当前可用区单库读写的JdbcTemplate\n     */\n    default NamedParameterJdbcTemplate write() {\n        return InternalDatasourceConfig.writeForceAz(this, currentAz(), currentPaz(), \u0026quot;write\u0026quot;);\n    }\t\n  //....\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefaultDataSourceConfig是一个接口类，默认封装了NamedParameterJdbcTemplate的创建，业务方通过继承该接口来定义数据源:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-kotlin\"\u003eenum class AdDataSources(\n    private val bizDef: BizDef,\n    private val forTest: AdDataSources? = null,\n    private val usingNewZk: Boolean = false\n) : DataSourceConfig{\n    adFansTopProfileDashboardTest,\n    adFansTopProfileDashboard,\n    adChargeTest,\n    adCharge,\n    adChargeReadOnly,\n    adDspReadOnlyTest,\n    adDspReadOnly;\n    public open fun bizName(): String {\n        return bizDef.bizName\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果在业务中直接使用了DataSourceConfig创建的NamedParameterJdbcTemplate，那么我们就需要修改过程中创建的DataSource对象。那么，这里的DataSource究竟是怎么创建的呢？\u003c/p\u003e\n\u003cp\u003e具体扒代码的过程就不赘述了，直接说结果吧，kuaishou-framework的数据源最终是通过DataSourceFactory进行创建的，具体代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static ListenableDataSource\u0026lt;Failover\u0026lt;Instance\u0026gt;\u0026gt; create(Instance i) {\n   //...\n   try {\n       return supplyWithRetry(\n        DATA_SOURCE_BUILD_RETRY,\n        DATA_SOURCE_BUILD_RETRY_DELAY,\n        () -\u0026gt; new ListenableDataSource\u0026lt;\u0026gt;(\n              bizName, \n              new HikariDataSource(config), ds -\u0026gt; i.toString(), i),\n              DataSourceFactory::needRetry);\n                               \n  } catch (Throwable e) {/**/}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由代码可以看到，这里的数据源实际上是通过new HikariDataSource(config)手动创建的，而DataSourceConfig又没有对外暴露创建的数据源，所以，我们该如何对DataSource代理呢?\u003c/p\u003e\n\u003ch3\u003e\u003cstrong\u003e二、动态修改加载类\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e成本最低的方式就是直接修改这段代码，将其中\u0026#x7684;\u003cem\u003e\u0026#x6E;ew HikariDataSource(config)\u003c/em\u003e\u0026#x4FEE;改\u0026#x6210;\u003cem\u003e\u0026#x6E;ew P6DataSource(new HikariDataSource(config))，\u003c/em\u003e\u0026#x90A3;么问题来了，这段代码属于基础组件包中的代码，基础架构组没有动力去修改，而我们又没有修改的权限，要想动这块代码，只能使用黑科技了。黑科技的手段有很多，那么问题又来了，哪种手段更合适呢？\u003c/p\u003e\n\u003cp\u003e首先我们来分析一下，有哪些手段可以修改Java字节码？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案一、编译时修改，需要开发maven插件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（不使用maven插件的同学咋办？）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案二、加载时修改，重写类加载器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要在代码中指定特定的类加载器，用有一定的侵入式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方案三、运行时修改，使用JavaAgent\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e需要修改应用启动参数，运维成本有点高\u003c/p\u003e\n\u003cp\u003e首先要说明的是，这里不是对类方法进行增强，所以想使用cglib动态代理的想法是不可行的。前面三种方案都有一定的局限性：方案一比较麻烦，方案二侵入性强，方案三则需要使用JavaAgent技术，那有没有方案不使用Agent就可以动态修改已经加载的字节码呢？答案是没有，至少理论上没有。不过，好在天无绝人之路，JDK9之后，可以动态启动JavaAgent，这样就不用修改启动参数了。这里，我们选择使用byte-buddy进行字节码重写。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e下面是对动态启动Java Agent技术的解释\u003c/em\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote that starting with Java 9, there is the Launcher-Agent-Class manifest attribute for jar files that can specify the class of a Java Agent to start before the class specified with the Main-Class is launched. That way, you can easily have your Agent collaborating with your application code in your JVM, without the need for any additional command line options. The Agent can be as simple as having an agentmain method in your main class storing the Instrumentation reference in a static variable.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSee \u003ca href=\"https://docs.oracle.com/en/java/javase/15/docs/api/java.instrument/java/lang/instrument/package-summary.html#package.description\"\u003ethe java.lang.instrument package documentation\u003c/a\u003e…\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eGetting hands on an Instrumentation instance when the JVM has not been started with Agents is trickier. It must support launching Agents after startup in general, e.g. via the Attach API. \u003ca href=\"https://stackoverflow.com/a/19912148/2711488\"\u003eThis answer\u003c/a\u003e demonstrates at its end such a self-attach to get hands on the Instrumentation. When you have the necessary manifest attribute in your application jar file, you could even use that as agent jar and omit the creation of a temporary stub file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever, recent JVMs forbid self-attaching unless -Djdk.attach.allowAttachSelf=true has been specified at startup, but I suppose, taking additional steps at startup time, is precisely what you don’t want to do. One way to circumvent this, is to use another process. All this process has to to, is to attach to your original process and tell the JVM to start the Agent. Then, it may already terminate and everything else works the same way as before the introduction of this restriction.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAs mentioned in \u003ca href=\"https://stackoverflow.com/questions/56787777/?noredirect=1\u0026lq=1#comment100160373_56787777\"\u003ethis comment\u003c/a\u003e, Byte-Buddy has already implemented those necessary steps and the stripped-down Byte-Buddy-Agent contains that logic only, so you can use it to build your own logic atop it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e字节码工具对比\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/4223630ea14c6367968188fd52cafa26.png\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用bytebuddy修改字节码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在实现代码之前，我们回过头来再看一下快手的数据源生成：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ListenableDataSource\u0026lt;\u0026gt;(bizName, new HikariDataSource(config), ds -\u0026gt; i.toString());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里实际生成的数据源类型是ListenableDataSource，而ListenableDataSource刚好继承了DelegatingDataSource类，而DelegatingDataSource的构造方法如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class DelegatingDataSource implements DataSource {\n   //...\n  public DelegatingDataSource(DataSource targetDataSource) {\n    this.setTargetDataSource(targetDataSource);\n   }\n\n  public void setTargetDataSource(@Nullable DataSource targetDataSource) {\n      this.targetDataSource = targetDataSource;\n  }\n  //...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因此，我们可以通过改写DelegatingDataSource#setTargetDataSource方法，实现同样的效果，修改后的方法应该如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n        this.targetDataSource = new P6DataSource(targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么具体如何修改字节码呢？这里是\u003ca href=\"https://bytebuddy.net/#/tutorial\"\u003e官方文档\u003c/a\u003e，原理我们不做赘述，直接介绍实现了。实现方式有三种：\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e1、类文件替换\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e假设你已经通过Java代码编译了新的类，现在要替换JVM中类的定义，代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n  .redefine(NewDelegatingDataSource.class)\n  .name(DelegatingDataSource.class.getName())\n  .make()\n  .load(Thread.currentThread().getContextClassLoader(), \n        ClassReloadingStrategy.fromInstalledAgent());\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e\u003cstrong\u003e2、操作字节码：\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003enew ByteBuddy()\n    .redefine(DelegatingDataSource.class)\n    //重写DelegatingDataSource#setTargetDataSource方法\n    .method(named(\u0026quot;setTargetDataSource\u0026quot;))\n    .intercept(MyImplementation.INSTANCE)\n    .make()\n    .load(Thread.currentThread().getContextClassLoader(),\n          ClassReloadingStrategy.fromInstalledAgent());\n\nenum MyImplementation implements Implementation {\n\nINSTANCE; // singleton\n\n  @Override\n  public InstrumentedType prepare(InstrumentedType instrumentedType) {\n  return instrumentedType;\n  }\n  \n  @Override\n  public ByteCodeAppender appender(Target implementationTarget) {\n  return MyAppender.INSTANCE;\n  }\n  \n}\n//字节码定义\nenum MyAppender implements ByteCodeAppender {\n\nINSTANCE; // singleton\n\n@Override\npublic Size apply(MethodVisitor methodVisitor,\n        Implementation.Context implementationContext,\n        MethodDescription instrumentedMethod) {\n  Label label0 = new Label();\n  methodVisitor.visitLabel(label0);\n  methodVisitor.visitLineNumber(70, label0);\n  methodVisitor.visitVarInsn(ALOAD, 0);\n  methodVisitor.visitTypeInsn(NEW, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;);\n  methodVisitor.visitInsn(DUP);\n  methodVisitor.visitVarInsn(ALOAD, 1);\n  methodVisitor.visitMethodInsn(INVOKESPECIAL, \u0026quot;com/p6spy/engine/spy/P6DataSource\u0026quot;, \u0026quot;\u0026lt;init\u0026gt;\u0026quot;, \u0026quot;(Ljavax/sql/DataSource;)V\u0026quot;, false);\n  methodVisitor.visitFieldInsn(PUTFIELD, \u0026quot;org/springframework/jdbc/datasource/DelegatingDataSource\u0026quot;, \u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;);\n  Label label1 = new Label();\n  methodVisitor.visitLabel(label1);\n  methodVisitor.visitLineNumber(71, label1);\n  methodVisitor.visitInsn(RETURN);\n  Label label2 = new Label();\n  methodVisitor.visitLabel(label2);\n  methodVisitor.visitLocalVariable(\u0026quot;this\u0026quot;, \u0026quot;Lorg/springframework/jdbc/datasource/DelegatingDataSource;\u0026quot;, null, label0, label2, 0);\n  methodVisitor.visitLocalVariable(\u0026quot;targetDataSource\u0026quot;, \u0026quot;Ljavax/sql/DataSource;\u0026quot;, null, label0, label2, 1);\n  methodVisitor.visitMaxs(4, 2);\n  return new Size(4, 2);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述代码的核心思想是字节操作字节码，操作字节码是非常复杂和繁重的事情，且无法debug，那么有没有比较方便的方式呢？\u003c/p\u003e\n\u003cp\u003e我们可以手动改写Java代码，然后利用插件生成对应的字节码，然后在其基础上进行修改，研发成本会低很多。这里推荐IDEA的一个插件：Byte-Code-Analyzer，使用该插件可以查看类对应的ASM字节码:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/e31962a90f6598880e78d8254d6c74d9\" alt=\"图片\"\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e3、利用byte-buddy的Advice\u003c/strong\u003e\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e public static void redefine() {\n   new ByteBuddy()\n     .redefine(DelegatingDataSource.class)\n     .visit(Advice.to(Decorator.class)\n            .on(ElementMatchers.named(\u0026quot;setTargetDataSource\u0026quot;)))\n     .make()\n     .load(Thread.currentThread().getContextClassLoader(),\n           ClassReloadingStrategy.fromInstalledAgent()).getLoaded();\n }\n\nstatic class Decorator {\n\n  //在方法开始插入代码\n  @Advice.OnMethodEnter\n    public static void enter(@Advice.Argument(value = 0, readOnly = false) DataSource dataSource) {\n    dataSource = new P6DataSource(dataSource);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebyte-buddy的Advisor和动态代理的原理不一样，他是直接修改方法体的字节码，上面的方法就是表示在方法开始插入一行，其效果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void setTargetDataSource(@Nullable DataSource targetDataSource) {\n  //插入的代码\n  targetDataSource = new P6DataSource(targetDataSource);\n  this.targetDataSource = targetDataSource;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e动态修改已加载的类，是有限制条件的，不能添加方法或者字段，因此通过byte-buddy的Methoddelegation方法修改字节码是不可行的。\u003c/li\u003e\n\u003cli\u003e使用byte-buddy的Advice，可以对非Spring托管的类进行动态增强，因为是直接修改字节码，性能更好。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e\u003cstrong\u003e三、自动生效\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e前面我们讲了如何修改字节码，以提供SQL监控功能，那么如何让SQL监控自动生效呢？我们的目标是非侵入式解决方案：既不能修改业务代码，也不能更改系统配置。鉴于Java世界的事实标准，我们利用了SpringBoot-Starter功能，只需增加一个maven依赖，就自动提供了SQL监控能力。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;dependency\u0026gt;\n  \u0026lt;groupId\u0026gt;com.kuaishou.ad\u0026lt;/groupId\u0026gt;\n  \u0026lt;artifactId\u0026gt;sqllog-spring-boot-starter\u0026lt;/artifactId\u0026gt;\n  \u0026lt;version\u0026gt;制品库查询最新版\u0026lt;/version\u0026gt;\n\u0026lt;/dependency\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e至于SpringBoot-Starter的实现原理，网上资料很多，核心思想就是提供默认配置，开箱即用。需要注意的是，Spring6.0自动配置的方案有了调整，原来基于spring.factories的配置改成了org.springframework.boot.autoconfigure.AutoConfiguration.imports，原有的方式还支持，这对应普通应用没有影响，但是在实现Spring多容器隔离的方案上有一定的影响，后面有时间会展开讲一下。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static String[] getConfigurations(File file) {\n  @EnableAutoConfiguration\n  class NoScan {\n    //用于扫描META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports,该类定义在方法中,是为了避免扫描当前类时被加载\n  }\n  FileClassLoader classLoader = new FileClassLoader(file);\n  AutoConfigurationImportSelector selector = new AutoConfigurationImportSelector();\n  selector.setBeanClassLoader(classLoader);\n  selector.setResourceLoader(new ClassLoaderResourcePatternResolver(classLoader));\n  selector.setEnvironment(new StandardEnvironment());\n  String[] configurations = selector.selectImports(new StandardAnnotationMetadata(NoScan.class));\n  return configurations;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e\u003cstrong\u003e四、SQL打印效果\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003esqllog-spring-boot-starter默认基于p6spy，并对SQL输出提供了扩展，打印SQL日志如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://static.yximgs.com/udata/pkg/EE-KSTACK/28cd44d1451c960cfb982773aab6ec44\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eSQL的打印内容分为三部分：\u003c/p\u003e\n\u003cp\u003e第一行，显示执行时间、耗时、SQL操作、数据库连接等信息\u003c/p\u003e\n\u003cp\u003e第二行，显示参数化SQL\u003c/p\u003e\n\u003cp\u003e第三行，显示绑定参数后的实际执行的SQL\u003c/p\u003e\n\u003cp\u003e通过日志看到，当SQL语句超长时，系统会对参数化SQL进行个性化缩略，而对实际执行的SQL，则保持原样输出，这样可以检索关键信息。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T1245,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e微服务系列\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%8A%E5%85%B6%E6%BC%94%E8%BF%9B%E5%8F%B2/\"\u003e微服务及其演进史\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A8%E6%99%AF%E6%9E%B6%E6%9E%84/\"\u003e微服务全景架构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5/\"\u003e微服务拆分策略\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86%E7%AD%96%E7%95%A5%EF%BC%88%E9%99%84%E5%8A%A0%E7%AF%87%EF%BC%89/\"\u003e微服务拆分策略（附加篇）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/\"\u003e服务注册与发现\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../microservice/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0%EF%BC%88%E5%AE%9E%E8%B7%B5%E7%AF%87%EF%BC%89/\"\u003e服务注册与发现（实践篇）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e中间件\u003c/h2\u003e\n\u003ch3\u003e消息队列\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../middleware/RabbitMQ%E3%80%81RocketMQ%E3%80%81Kafka%E5%8C%BA%E5%88%AB/\"\u003eRabbitMQ、RocketMQ、Kafka区别\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../middleware/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E3%80%81%E4%B8%89%E9%98%B6%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE/\"\u003e分布式事务之两阶段、三阶提交协议\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e架构设计\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../system/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%9D%BF/\"\u003e架构设计模板\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E6%9E%B6%E6%9E%84/\"\u003e从0开始做一个后台架构\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/\"\u003e一个秒杀系统的设计思考\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%8415%E4%B8%AA%E9%94%A6%E5%9B%8A/\"\u003e高并发系统设计的15个锦囊\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../system/%E9%A2%86%E7%95%A5SET%E5%8C%96%E6%9E%B6%E6%9E%84%E8%A1%8D%E5%8C%96%E4%B8%8E%E8%AE%BE%E8%AE%A1/\"\u003e领略SET化架构衍化与设计\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e大数据\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../bigdata/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B9%8BBitmap%E7%AF%87/\"\u003e大数据分析常用去重算法分析之Bitmap篇\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../bigdata/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%8E%BB%E9%87%8D%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B9%8BHyperLogLog%E7%AF%87/\"\u003e大数据分析常用去重算法分析之HyperLogLog篇\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e业务架构\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../business/%E5%85%B3%E4%BA%8E%E4%B8%9A%E5%8A%A1%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83/\"\u003e关于业务平台架构的思考\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E8%A7%A3%E6%9E%90%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%BB%BA%E7%AB%8B%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B/\"\u003e解析三户模型及建立账户模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%B8%89%E9%87%8D%E8%A7%86%E8%A7%92%E2%80%94%E2%80%94%E6%80%8E%E6%A0%B7%E7%AE%97%E6%87%82%E4%B8%9A%E5%8A%A1/\"\u003e业务的三重视角——怎样算懂业务\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E4%B8%9A%E5%8A%A1%E4%B8%89%E9%87%8D%E8%A7%86%E8%A7%92%E2%80%94%E2%80%94%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9E%8B/\"\u003e业务三重视角——业务模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E4%B8%9A%E5%8A%A1%E4%B8%89%E9%87%8D%E8%A7%86%E8%A7%92%E2%80%94%E2%80%94%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/\"\u003e业务三重视角——商业模式\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E7%94%A8%E6%88%B7%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E4%B8%89%E6%88%B7%E6%A8%A1%E5%9E%8B%E5%8F%8A%E4%B8%89%E5%B1%82%E8%BA%AB%E4%BB%BD%E6%A8%A1%E5%9E%8B/\"\u003e用户系统设计——三户模型及三层身份模型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1/\"\u003e权限系统方案设计\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../business/%E7%94%B5%E5%95%86%E5%88%86%E6%9E%90%E5%BF%85%E6%87%82%E7%9A%84%E6%8C%87%E6%A0%87%E4%BD%93%E7%B3%BB/\"\u003e电商分析必懂的指标体系\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e技术实战\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"../practice/%E9%9D%9E%E4%BE%B5%E5%85%A5%E5%BC%8FSQL%E7%9B%91%E6%8E%A7/\"\u003e非侵入式SQL监控\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../practice/Java%E6%9E%84%E4%BB%B6%E5%8F%91%E5%B8%83%E5%88%B0%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/\"\u003eJava构件发布到中央仓库\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../practice/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/\"\u003eGit常用命令\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"../practice/Maven%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/\"\u003eMaven使用技巧\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"18:T4029,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e1. Background\u003c/h2\u003e\n\u003cp\u003eProtocol Buffers (Protobuf) is a language-neutral, platform-neutral, extensible mechanism for serializing structured data. It was developed by Google to efficiently serialize data for use in a variety of applications, including network communication, data storage, and inter-process communication (IPC).  Protobuf messages are smaller and more efficient than text-based formats like JSON and XML ,and provides fast serialization and deserialization, which is crucial for high-performance systems. \u003c/p\u003e\n\u003ch2\u003e2. Protobuf compiler\u003c/h2\u003e\n\u003cp\u003eProtobuf allows you to define the structure of your data (messages) in a .proto file, and then use the Protobuf compiler (protoc) to generate source code in selected programming language that can serialize and deserialize data in the Protobuf format.  Protobuf adds overhead to the development process compared to formats like JSON, where you can directly parse or serialize data without needing code generation. Additionally, any changes to the schema may require re-compiling the code to handle new or modified message types.\u003c/p\u003e\n\u003ch2\u003e3. Dynamic compilation(Dynamic Schema)\u003c/h2\u003e\n\u003cp\u003eTypically, Protobuf schemas are compiled using the protoc compiler ahead of time, which generates source code in various programming languages (such as C++, Java, Python, etc.) for serialization and deserialization. However, in some scenarios, you might need to work with Protobuf messages dynamically without relying on pre-generated codes. \u003c/p\u003e\n\u003cp\u003eThis is especially useful when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou want to work with Protobuf messages dynamically at runtime, where the schema is not known in advance.\u003c/li\u003e\n\u003cli\u003eYou need to handle multiple or evolving Protobuf schemas at runtime without recompiling your code.\u003c/li\u003e\n\u003cli\u003eYou want to dynamically serialize or deserialize Protobuf messages in a generic way, perhaps for applications like plugins, dynamic API handling, or protocol-based communication where the schema might change often.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eKey Concepts for Dynamic Compilation in Protobuf\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDynamic Message (Dynamic Parsing)\u003c/li\u003e\n\u003cli\u003eReflection API in Protobuf\u003c/li\u003e\n\u003cli\u003eDynamic Code Generation\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.1 Dynamic Message (Dynamic Parsing)\u003c/h3\u003e\n\u003cp\u003eIn Protobuf, a Dynamic Message is an object where you can manipulate the message’s fields dynamically, without needing a pre-generated class for the specific message type. This is enabled through Protobuf\u0026#39;s Reflection API.\u003cbr\u003eYou can use dynamic messages when:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe Protobuf schema is available at runtime, but you don\u0026#39;t know the message types ahead of time.\u003c/li\u003e\n\u003cli\u003eYou want to work with messages whose types are determined dynamically (e.g., reading from a file or network stream that specifies the message type).\u003cbr\u003eTo use dynamic messages, you typically:\u003c/li\u003e\n\u003cli\u003eLoad the schema definition (e.g., .proto file) at runtime.\u003c/li\u003e\n\u003cli\u003eUse the Protobuf Reflection API to create message types and set/get fields.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.2 Reflection API\u003c/h3\u003e\n\u003cp\u003eThe Protobuf Reflection API allows you to inspect the structure of Protobuf messages at runtime, and dynamically access their fields. This is the core tool for implementing dynamic compilation because it lets you:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDiscover available fields.\u003c/li\u003e\n\u003cli\u003eInspect field types (e.g., int32, string, nested messages).\u003c/li\u003e\n\u003cli\u003eSet and get field values dynamically.\u003cbr\u003eThe key components of the Reflection API in Protobuf are:\u003c/li\u003e\n\u003cli\u003eDescriptors: These are metadata objects that describe the fields, types, and structure of messages.\u003c/li\u003e\n\u003cli\u003eDynamic Messages: These are messages created dynamically using descriptors, where you can set/get fields without needing a pre-compiled class.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e3.3 Dynamic Code Generation with Protobuf Compiler\u003c/h3\u003e\n\u003cp\u003eIn some use cases, you may need to generate Protobuf code dynamically based on new or unknown schemas. This would involve invoking the Protobuf compiler (protoc) programmatically to generate the code at runtime, either directly from .proto files or from a descriptor or a set of schema definitions.\u003cbr\u003eThis process typically involves the following steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eObtain the .proto files or schema descriptors.\u003c/li\u003e\n\u003cli\u003eRun protoc programmatically to generate source code.\u003c/li\u003e\n\u003cli\u003eUse the generated code within the application to work with dynamic messages.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e4. Code Implementation\u003c/h2\u003e\n\u003ch3\u003e4.1 Code Analysis\u003c/h3\u003e\n\u003cp\u003eThe above method is valid for languages that support dynamic loading such as java, but not for golang. Since golang doesn\u0026#39;t support dynamic loading, we can\u0026#39;t use the generated source code. However, through technical analysis, we know that the conversion path from a text file to a binary message is: file.proto --\u0026gt; FileDescriptor --\u0026gt; proto.message, and there are two key points: \u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ehow to get FileDescriptor from a proto file at runtime?\u003c/li\u003e\n\u003cli\u003ehow to create a proto.message using FileDescriptor?\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor the second point, the solution is not complicated. We can use dynamicpb.message mentioned before. The following code demonstrates how to create a proto.message by dynamicpb.message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-golang\"\u003efunc NeweMessages(fd protoreflect.FileDescriptor, msgName string)proto.Message{\n  fm := fd.Messages()\n  md = fm.ByName(protoreflect.Name(msgName))\n  return dynamicpb.NewMessage(md)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow let\u0026#39;s look at the second question, how to get FileFescriptor from a proto file at runtime? To get the FileFescriptor dynamically in golang, we first need to know how the FileFescriptor is generated. Typically, we can not get FileFescriptor directly from proto file. But we analyzed the source code in google.golang.org/protobuf , and found that FileDescriptor is created from FileDescriptorProto as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-golang\"\u003efdp := new(descriptorpb.FileDescriptorProto)\n//Unmarshal([]byte,fdp)\nfd, err := protodesc.NewFile(fdp, nil)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThus, the conversion path from a text file to a binary message is changed to:  file.proto --\u0026gt; FileDescriptorProto --\u0026gt; FileDescriptor --\u0026gt; proto.message,So the final question is, how do we get the FileDescriptorProto object?\u003cbr\u003eFileDescriptorProto is a proto.message object, so it can be serialized to binary and deserialized from binary. In fact, we can use protoc to generate the binary data of FileDescriptorProto at the same time as the source code with option: --descriptor_set_out=your_file_descriptord_proto.pb.\u003cbr\u003eFurther analyzing the source code of protoc , there are plugins that receive the compiled binary streams from proto file for data processing, including code generation. \u003c/p\u003e\n\u003cp\u003eThe following is the source code analysis, and the highlighted part is the key code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-golang\"\u003efunc main() {\n  //...\n  protogen.Options{\n     ParamFunc: flags.Set,\n  }.Run(func(gen *protogen.Plugin) error {\n     //...\n     for _, f := range gen.Files {\n        if f.Generate {\n           gengo.GenerateFile(gen, f)\n        }\n     }\n     //...\n     return nil\n  })\n}\n//It reads a [pluginpb.CodeGeneratorRequest] message from [os.Stdin], invokes the plugin function, and writes a [pluginpb.CodeGeneratorResponse] message to [os.Stdout].\nfunc (opts Options) Run(f func(*Plugin) error) {\n    if err := run(opts, f); err != nil {\n       fmt.Fprintf(os.Stderr, \u0026quot;%s: %v\\n\u0026quot;, filepath.Base(os.Args[0]), err)\n       os.Exit(1)\n    }\n}\n\nfunc run(opts Options, f func(*Plugin) error) error {\n    if len(os.Args) \u0026gt; 1 {\n       return fmt.Errorf(\u0026quot;unknown argument %q (this program should be run by protoc, not directly)\u0026quot;, os.Args[1])\n    }\n    //Here is the compiled binary stream from protoc\n    in, err := io.ReadAll(os.Stdin)\n    if err != nil {\n       return err\n    }\n    \n    req := \u0026amp;pluginpb.CodeGeneratorRequest{}\n    if err := proto.Unmarshal(in, req); err != nil {\n       return err\n    }\n    gen, err := opts.New(req)\n    if err != nil {\n       return err\n    }\n    //This is the plugin\u0026#39;s custom processing logic\n    if err := f(gen); err != nil {\n       gen.Error(err)\n    }\n    resp := gen.Response()\n    out, err := proto.Marshal(resp)\n    if err != nil {\n       return err\n    }\n    //Write the source code to a file\n    if _, err := os.Stdout.Write(out); err != nil {\n       return err\n    }\n    return nil\n}\n\n//CodeGeneratorRequest defines a FileDescriptorProto field\ntype CodeGeneratorRequest struct {\n    state         protoimpl.MessageState\n    sizeCache     protoimpl.SizeCache\n    unknownFields protoimpl.UnknownFields\n\n    FileToGenerate []string \n    Parameter *string \n    ProtoFile []*desriptorpb.FileDescriptorProto\n    SourceFileDescriptors []*descriptorpb.FileDescriptorProto \n    CompilerVersion *Version\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy analyzing the source code of protoc, we can also implement a custom plugin to output the text-format serialized data of FileDescriptorProto.\u003cbr\u003eActually, there are two text-format serialization schemes for FileDescriptorProto: json/proto-text.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJSON\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor json format, we can serialize/deserialize FileDescriptorProto via protojson.Marshal/Unmarshal.\u003cbr\u003eExample of json-format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026quot;name\u0026quot;:  \u0026quot;protobuf/tns_demo.proto\u0026quot;,\n  \u0026quot;package\u0026quot;:  \u0026quot;tns.search.proto\u0026quot;,\n  \u0026quot;messageType\u0026quot;:  [\n    {\n      \u0026quot;name\u0026quot;:  \u0026quot;TnsDemo\u0026quot;,\n      \u0026quot;field\u0026quot;:  [\n        {\n          \u0026quot;name\u0026quot;:  \u0026quot;id\u0026quot;,\n          \u0026quot;number\u0026quot;:  1,\n          \u0026quot;label\u0026quot;:  \u0026quot;LABEL_OPTIONAL\u0026quot;,\n          \u0026quot;type\u0026quot;:  \u0026quot;TYPE_INT64\u0026quot;,\n          \u0026quot;jsonName\u0026quot;:  \u0026quot;id\u0026quot;\n        },\n        {\n          \u0026quot;name\u0026quot;:  \u0026quot;status\u0026quot;,\n          \u0026quot;number\u0026quot;:  2,\n          \u0026quot;label\u0026quot;:  \u0026quot;LABEL_OPTIONAL\u0026quot;,\n          \u0026quot;type\u0026quot;:  \u0026quot;TYPE_INT32\u0026quot;,\n          \u0026quot;jsonName\u0026quot;:  \u0026quot;status\u0026quot;\n        },\n        {\n          \u0026quot;name\u0026quot;:  \u0026quot;result\u0026quot;,\n          \u0026quot;number\u0026quot;:  3,\n          \u0026quot;label\u0026quot;:  \u0026quot;LABEL_REPEATED\u0026quot;,\n          \u0026quot;type\u0026quot;:  \u0026quot;TYPE_MESSAGE\u0026quot;,\n          \u0026quot;typeName\u0026quot;:  \u0026quot;.tns.search.proto.TnsDemo.ResultEntry\u0026quot;,\n          \u0026quot;jsonName\u0026quot;:  \u0026quot;result\u0026quot;\n        },\n        {\n          \u0026quot;name\u0026quot;:  \u0026quot;reasons\u0026quot;,\n          \u0026quot;number\u0026quot;:  4,\n          \u0026quot;label\u0026quot;:  \u0026quot;LABEL_REPEATED\u0026quot;,\n          \u0026quot;type\u0026quot;:  \u0026quot;TYPE_INT32\u0026quot;,\n          \u0026quot;jsonName\u0026quot;:  \u0026quot;reasons\u0026quot;\n        }\n      ],\n      \u0026quot;nestedType\u0026quot;:  [\n        {\n          \u0026quot;name\u0026quot;:  \u0026quot;ResultEntry\u0026quot;,\n          \u0026quot;field\u0026quot;:  [\n            {\n              \u0026quot;name\u0026quot;:  \u0026quot;key\u0026quot;,\n              \u0026quot;number\u0026quot;:  1,\n              \u0026quot;label\u0026quot;:  \u0026quot;LABEL_OPTIONAL\u0026quot;,\n              \u0026quot;type\u0026quot;:  \u0026quot;TYPE_STRING\u0026quot;,\n              \u0026quot;jsonName\u0026quot;:  \u0026quot;key\u0026quot;\n            },\n            {\n              \u0026quot;name\u0026quot;:  \u0026quot;value\u0026quot;,\n              \u0026quot;number\u0026quot;:  2,\n              \u0026quot;label\u0026quot;:  \u0026quot;LABEL_OPTIONAL\u0026quot;,\n              \u0026quot;type\u0026quot;:  \u0026quot;TYPE_STRING\u0026quot;,\n              \u0026quot;jsonName\u0026quot;:  \u0026quot;value\u0026quot;\n            }\n          ],\n          \u0026quot;options\u0026quot;:  {\n            \u0026quot;mapEntry\u0026quot;:  true\n          }\n        }\n      ]\n    }\n  ],\n  \u0026quot;options\u0026quot;:  {\n    \u0026quot;goPackage\u0026quot;:  \u0026quot;./gen;protobuf\u0026quot;\n  },\n  \u0026quot;syntax\u0026quot;:  \u0026quot;proto3\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eProto-Text\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe Text Format  is a human-readable format used for serializing and displaying protobuf messages in text form. It is often used for debugging or configuration purposes when you want to quickly inspect the contents of a protobuf message.\u003cbr\u003eIn the text format, protobuf messages are represented in a straightforward key-value style, where each field in the message is written in a human-readable way, with the field name followed by the value. This format is defined in the Protocol Buffers specification.\u003cbr\u003eFor text-format, we can serialize/deserialize FileDescriptorProto via prototext.Marshal/Unmarshal\u003cbr\u003eExample of text-format:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-protobuf\"\u003ename:  \u0026quot;protobuf/tns_demo.proto\u0026quot;\npackage:  \u0026quot;tns.search.proto\u0026quot;\nmessage_type:  {\n  name:  \u0026quot;TnsDemo\u0026quot;\n  field:  {\n    name:  \u0026quot;id\u0026quot;\n    number:  1\n    label:  LABEL_OPTIONAL\n    type:  TYPE_INT64\n    json_name:  \u0026quot;id\u0026quot;\n  }\n  field:  {\n    name:  \u0026quot;status\u0026quot;\n    number:  2\n    label:  LABEL_OPTIONAL\n    type:  TYPE_INT32\n    json_name:  \u0026quot;status\u0026quot;\n  }\n  field:  {\n    name:  \u0026quot;result\u0026quot;\n    number:  3\n    label:  LABEL_REPEATED\n    type:  TYPE_MESSAGE\n    type_name:  \u0026quot;.tns.search.proto.TnsDemo.ResultEntry\u0026quot;\n    json_name:  \u0026quot;result\u0026quot;\n  }\n  field:  {\n    name:  \u0026quot;reasons\u0026quot;\n    number:  4\n    label:  LABEL_REPEATED\n    type:  TYPE_INT32\n    json_name:  \u0026quot;reasons\u0026quot;\n  }\n  nested_type:  {\n    name:  \u0026quot;ResultEntry\u0026quot;\n    field:  {\n      name:  \u0026quot;key\u0026quot;\n      number:  1\n      label:  LABEL_OPTIONAL\n      type:  TYPE_STRING\n      json_name:  \u0026quot;key\u0026quot;\n    }\n    field:  {\n      name:  \u0026quot;value\u0026quot;\n      number:  2\n      label:  LABEL_OPTIONAL\n      type:  TYPE_STRING\n      json_name:  \u0026quot;value\u0026quot;\n    }\n    options:  {\n      map_entry:  true\n    }\n  }\n}\noptions:  {\n  go_package:  \u0026quot;./gen;protobuf\u0026quot;\n}\nsyntax:  \u0026quot;proto3\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4.2 protoc-plugin\u003c/h3\u003e\n\u003cp\u003eIn order to keep the generality, we choose the json-format as the serialization solution. \u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-golang\"\u003efunc main() {\n    protogen.Options{}.Run(func(gen *protogen.Plugin) error {\n       gen.SupportedFeatures = SupportedFeatures\n       for _, file := range gen.Files {\n          // Skip files that are not part of the plugin\u0026#39;s current output.\n          if !file.Generate {\n             continue\n          }\n          genJsonFile(file, gen)\n          genExtFile(file, gen)\n       }\n       return nil\n    })\n}\nfunc genJsonFile(file *protogen.File, gen *protogen.Plugin) {\n    fd := file.Proto\n    sci := fd.SourceCodeInfo\n    fd.SourceCodeInfo = nil\n    jsonFile := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+\u0026quot;.json\u0026quot;, \u0026quot;.\u0026quot;)\n    jsonFile.P(protojson.Format(fd))\n    fd.SourceCodeInfo = sci\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce we get serialized content in json format, the rest is easy. We can save the json to tcc and load it later at runtime to marshal/unmarshal proto.Message. If the proto file changes, we can manually compile it offline and then update the new json data in tcc to realize the hot update. \u003c/p\u003e\n\u003ch3\u003e4.3 How to use dynamic schema\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003egenerate json schema with plugin\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eSRC_DIR=$(pwd)\ngo build -o $SRC_DIR/protoc-gen-ext\nprotoc --proto_path=$SRC_DIR \\\n--plugin=protoc-gen-go=$(which protoc-gen-go) \\\n--go_out=$SRC_DIR/protobuf \\\n--fastpb_out=$SRC_DIR/protobuf \\\n--plugin=protoc-gen-ext=$SRC_DIR/protoc-gen-ext \\\n--ext_out=$SRC_DIR/protobuf \\\n$SRC_DIR/protobuf/*.proto\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003emanipulate dynamic schema\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-golang\"\u003e    //jsonData:=getJsonFromTcc(...)\n    fdp := new(descriptorpb.FileDescriptorProto)\n    //load schema from json\n    if err := protojson.Unmarshal([]byte(jsonData), fdp); err != nil {\n       panic(err)\n    }\n    //create FileDescriptorfrom FileDescriptorProto\n    fd, err := protodesc.NewFile(fdp, nil)\n    if err != nil {\n       panic(err)\n    }\n   // find the MessageDescriptor by name\n    md = fd.Messages().ByName(protoreflect.Name(msg))\n   // create dynamicpb message\n    dynamicpb.NewMessage(md)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e5. Conlusion\u003c/h2\u003e\n\u003cp\u003eDynamic compilation of Protobuf is a powerful technique for situations where the schema cannot be known ahead of time or needs to be handled at runtime. By using Protobuf’s Reflection API, Dynamic Messages, and Any fields, you can create, manipulate, and serialize Protobuf messages dynamically. This allows for greater flexibility in scenarios such as plugin-based architectures, evolving APIs, or systems that need to work with arbitrary message types at runtime. However, dynamic compilation is more complex than static compilation and may introduce performance overhead due to reflection and dynamic handling of schema data.\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-04-07\",\"children\":\"2024年04月07日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"非侵入式SQL监控\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L5\",\"技术实战\",{\"href\":\"/blog/tag/%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"技术实战\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$11\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"tech/practice/Git常用命令\",\"title\":\"Git常用命令\",\"description\":\"git 不再追踪文件改动 git update-index --assume-unchanged filePath git 恢复追踪文件改动 git update-index --no-assume-unchanged filePath git 删除被管理的文件 git rm --cached fi...\",\"pubDate\":\"2024-04-05\",\"tags\":[\"技术实战\"],\"heroImage\":\"$undefined\",\"content\":\"\u003ch1\u003eGit常用命令\u003c/h1\u003e\\n\u003ch2\u003e1、取消跟踪已版本控制的文件\u003c/h2\u003e\\n\u003cp\u003egit 不再追踪文件改动 git update-index --assume-unchanged filePath\u003c/p\u003e\\n\u003cp\u003egit 恢复追踪文件改动 git update-index --no-assume-unchanged filePath\u003c/p\u003e\\n\u003cp\u003egit 删除被管理的文件 git rm --cached filePath\u003c/p\u003e\\n\u003cp\u003egit 删除被管理的文件夹 git rm -r -f --cached filePath\u003c/p\u003e\\n\"},\"next\":{\"slug\":\"tech/SUMMARY\",\"title\":\"技术专题\",\"description\":\"* [微服务系列].[系统架构].[业务架构].[技术实战]\",\"pubDate\":\"2024-04-10\",\"tags\":[\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"}},\"tagNav\":{\"技术实战\":{\"prev\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:prev\",\"next\":{\"slug\":\"tech/practice/How to implement dynamic protobuf in Golang\",\"title\":\"How to implement dynamic protobuf in Golang?\",\"description\":\"Protocol Buffers (Protobuf) is a language-neutral, platform-neutral, extensible mechanism for serializing structured data. It was developed by Google to efficiently serialize data for use in a variety of applications, including network communication, data storage, and inter-process communication (IPC).  Protobuf messages are smaller and more efficient than text-based formats like JSON and XML, and provides fast serialization and deserialization, which is crucial for high-performance systems.\",\"pubDate\":\"2025-07-29\",\"tags\":[\"技术实战\",\"Protobuf\",\"Dynamic\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}}}}]}],[\"$\",\"$L19\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"非侵入式SQL监控 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"非侵入式SQL监控\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-04-07\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"非侵入式SQL监控\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"你有没有因为应用程序没有打印SQL而导致问题排查困难？有没有因为SQL没有显示参数而导致日志毫无意义？有没有因为SQL超长而导致查看痛苦？有没有因为缺少SQL性能监控而导致无法报警？...\"}],[\"$\",\"link\",\"10\",{\"rel\":\"shortcut icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"12\",{\"rel\":\"icon\",\"href\":\"/favicon.png\"}],[\"$\",\"link\",\"13\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon.png\"}]],\"error\":null,\"digest\":\"$undefined\"}\n13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
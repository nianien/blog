<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/0a7d53676a1eb136.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-f7d11fc743a8cf38.js"/><script src="/_next/static/chunks/4bd1b696-be40ecc358c69ec3.js" async=""></script><script src="/_next/static/chunks/684-ed6d2eeb89009696.js" async=""></script><script src="/_next/static/chunks/main-app-1050779d59efeaf4.js" async=""></script><script src="/_next/static/chunks/874-f2e46e41114bd221.js" async=""></script><script src="/_next/static/chunks/app/layout-c432974c723daafe.js" async=""></script><script src="/_next/static/chunks/968-bf93abe4de13a5fc.js" async=""></script><script src="/_next/static/chunks/app/blog/%5B...slug%5D/page-26cc6d1a0064a78b.js" async=""></script><meta name="next-size-adjust" content=""/><title>从0开始做一个后台项目架构 - Skyfalling Blog</title><meta name="description" content="作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。"/><meta property="og:title" content="从0开始做一个后台项目架构"/><meta property="og:description" content="作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2024-03-18"/><meta property="article:author" content="Skyfalling"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="从0开始做一个后台项目架构"/><meta name="twitter:description" content="作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><link rel="icon" href="/favicon.svg"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_f367f3"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-[var(--background)]"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="min-h-screen"><div class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8"><div class="rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12"><header class="mb-8"><div class="flex items-center mb-6"><div class="inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal"><svg class="w-4 h-4 mr-2 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg><time dateTime="2024-03-18">2024年03月18日</time></div></div><h1 class="text-4xl font-bold text-gray-900 mb-6 text-center">从0开始做一个后台项目架构</h1><div class="flex flex-wrap gap-2 mb-6 justify-center"><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/">架构设计</a><a class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors" href="/blog/tag/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/page/1/">技术专题</a></div></header><div class="max-w-5xl mx-auto"><div class="prose prose-lg prose-gray mx-auto max-w-none prose-headings:text-gray-900 prose-headings:font-bold prose-p:text-gray-700 prose-p:leading-relaxed prose-a:text-blue-600 prose-a:no-underline hover:prose-a:text-blue-700 prose-strong:text-gray-900 prose-strong:font-semibold prose-blockquote:border-l-4 prose-blockquote:border-blue-500 prose-blockquote:bg-blue-50 prose-blockquote:py-2 prose-blockquote:px-4 prose-blockquote:rounded-r-lg prose-ul:list-disc prose-ol:list-decimal prose-li:text-gray-700 prose-hr:border-gray-300"><p><a href="https://baijiahao.baidu.com/s?id=1767938488419450782">转载</a></p>
<p>作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。</p>
<ul>
<li>团队协助基础工具链的选型和培训</li>
<li>搭建微服务开发基础设施</li>
<li>选择合适的RPC框架</li>
<li>选择和搭建高可用的注册中心</li>
<li>选择和搭建高可用的配置中心</li>
<li>选择和搭建高性能的缓存中间件</li>
<li>选择和搭建高性能的消息中间件</li>
<li>选择和搭建高性能的关系数据库</li>
<li>CICD发布系统/部署系统的架构</li>
<li>360度全方位监控和维护的架构</li>
<li>生产环境高并发高吞吐负载均衡部署架构</li>
</ul>
<p>整个后台技术架构，主要包括 4 个层面的内容：</p>
<ul>
<li><strong>语言</strong>：用了哪些开发语言，如：C++/Java/Go/PHP/Python/Ruby 等等；</li>
<li><strong>组件</strong>：用了哪些组件，如：MQ 组件，数据库组件等等；</li>
<li><strong>流程</strong>：怎样的流程和规范，如：开发流程，项目流程，发布流程，监控告警流程，代码规范等等；</li>
<li><strong>系统</strong>：系统化建设，上面的流程需要有系统来保证，如：规范发布流程的发布系统，代码管理系统等等；</li>
</ul>
<p>结合以上的的 4 个层面的内容，整个后台技术栈的结构如图1 所示：</p>
<p>图1 后台技术栈结构</p>
<p><img src="https://pics7.baidu.com/feed/f2deb48f8c5494ee55c2ea79fa27a8f29b257ec9.jpeg@f_auto?token=39d8af3c95030b48ad867ef53c70f4c5" alt=""></p>
<p>咱们一个个系统和组件的做选型，最终形成我们的后台技术栈。</p>
<p><strong>团队协助基础工具链的选型和培训</strong></p>
<p>团队协助基础工具链， 主要是三大管理</p>
<ul>
<li>项目管理</li>
<li>任务管理</li>
<li>问题管理</li>
</ul>
<p>项目管理软件是整个业务的需求，问题，流程等等的集中地，大家的跨部门沟通协同大多依赖于项目管理工具。</p>
<p>有一些 SaaS 的项目管理服务可以使用，但是很多时间不满足需求，此时我们可以选择一些开源的项目，这些项目本身有一定的定制能力，有丰富的插件可以使用，一般的创业公司需求基本上都能得到满足，常用的项目如下：</p>
<ol>
<li><strong>Jira</strong>：用 Java 开发的，有用户故事，task 拆分，燃尽图等等，可以做项目管理，也可以应用于跨部门沟通场景，较强大；</li>
<li><strong>Redmine</strong>：用 Ruby 开发的，有较多的插件可以使用，能自定义字段，集成了项目管理，Bug 问题跟踪，WIKI 等功能，不过好多插件 N 年没有更新了；</li>
<li><strong>Phabricator</strong>：用 PHP 开发的，Facebook 之前的内部工具，开发这工具的哥们离职后自己搞了一个公司专门做这个软件，集成了代码托管， Code Review，任务管理，文档管理，问题跟踪等功能，强烈推荐较敏捷的团队使用；</li>
</ol>
<p>这些平台我都用过，有些甚至还搭建过，惭愧地说一句，盗版的，目前建议是 Jira。像银行，基本上conflue+jira是标配了。</p>
<p><strong>搭建微服务开发基础设施</strong></p>
<p>搭建微服务开发基础设施需要考虑多个方面，包括但不限于以下几点：</p>
<ol>
<li><strong>选择合适的微服务框架和技术栈</strong>：目前比较流行的微服务框架有 Spring Cloud、Go-Micro、gRPC 等，选择适合自己团队技术栈的框架非常重要。</li>
<li><strong>选择合适的RPC框架</strong></li>
<li><strong>构建基础设施</strong>：包括但不限于服务注册与发现、负载均衡、API 网关、分布式配置中心、分布式锁、消息队列等。</li>
<li><strong>安全</strong>：包括但不限于服务间通信的加密、访问控制、身份认证等。</li>
</ol>
<p>在搭建微服务开发基础设施之前，需要对自己的业务场景进行分析和规划，确定需要哪些基础设施和技术栈，然后再逐步实现。同时，需要注重可扩展性和可维护性，以便在业务发展过程中能够快速适应变化。</p>
<p><strong>选择合适的微服务框架和技术栈</strong></p>
<p>选择合适的微服务框架和技术栈需要考虑多个因素，包括以下几个方面：</p>
<ol>
<li><strong>业务需求</strong>：不同的业务需求需要不同的技术栈和框架来支持。比如，如果需要高并发和高可用性，可以选择使用 Go 语言和 Kubernetes 等技术来构建微服务。</li>
<li><strong>开发团队技能</strong>：选择的技术栈和框架应该符合开发团队的技能水平，以便开发人员能够快速上手并高效开发。</li>
<li><strong>社区支持</strong>：选择流行的技术栈和框架可以获得更好的社区支持，能够更快地解决问题和获得更新的功能。</li>
<li><strong>性能和稳定性</strong>：选择的技术栈和框架应该具有良好的性能和稳定性，以便能够支持高负载和长时间运行。</li>
</ol>
<p>常见的微服务框架和技术栈包括：</p>
<ol>
<li><strong>Spring Cloud</strong>：适用于 Java 开发团队，具有丰富的功能和社区支持。</li>
<li><strong>Go Micro</strong>：适用于 Go 开发团队，具有高性能和简单易用的特点。</li>
<li><strong>Node.js + Express</strong>：适用于 JavaScript 开发团队，具有轻量级和快速开发的特点。</li>
<li><strong>Kubernetes</strong>：适用于需要高可用性和弹性的微服务架构，可以支持多种编程语言和框架。</li>
<li><strong>Istio</strong>：适用于需要服务网格功能的微服务架构，可以提供流量管理、安全性和可观察性等功能。</li>
</ol>
<p>在选择时，需要根据具体的业务需求和开发团队技能来选择合适的微服务框架和技术栈。</p>
<p>建议选用 SpringCloud Alibaba+ Dubbo RPC + Dubbo-Go，两个原因：</p>
<p>（1） <strong>高性能</strong>：做过的性能测试中， Dubbo比Feign性能 强10倍。</p>
<p>（2） <strong>兼顾团队技术栈</strong>：可以跨Go 和Java 多语言微服务架构，Java技术栈的同学们，可以基于 Java开发业务微服务，这块侧重业务开发。Go 技术栈的同学们，可以基于 Go 开发高性能的 技术微服务，这块侧重技术开发和性能优化。</p>
<p>（3）<strong>功能和性能兼顾</strong>：Java侧重功能的快速开发， Go侧重性能的快速提升。</p>
<p><strong>选择合适的RPC框架</strong></p>
<p>维基百科对 RPC 的定义是：远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。</p>
<p>通俗来讲，一个完整的 RPC 调用过程，就是 Server 端实现了一个函数，客户端使用 RPC 框架提供的接口，调用这个函数的实现，并获取返回值的过程。</p>
<p>业界 RPC 框架大致分为两大流派，一种侧重跨语言调用，另一种是偏重服务治理。</p>
<p><strong>跨语言调用型 RPC</strong>：</p>
<p>跨语言调用型的 RPC 框架有 Thrift、gRPC、Hessian、Hprose 等。这类 RPC 框架侧重于服务的跨语言调用，能够支持大部分的语言进行语言无关的调用，非常适合多语言调用场景。但这类框架没有服务发现相关机制，实际使用时需要代理层进行请求转发和负载均衡策略控制。</p>
<p>其中，gRPC 是 Google 开发的高性能、通用的开源 RPC 框架，其由 Google 主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf（Protocol Buffers）序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现框架的功能需要进一步的开发。</p>
<p>Hprose（High Performance Remote Object Service Engine）是一个 MIT 开源许可的新型轻量级跨语言跨平台的面向对象的高性能远程动态通讯中间件。</p>
<p><strong>冶理型 RPC</strong>：</p>
<p><strong>服务治理型的 RPC 框架</strong>的特点是功能丰富，提供高性能的远程调用、服务发现及服务治理能力，适用于大型服务的服务解耦及服务治理，对于特定语言(Java)的项目可以实现透明化接入。缺点是语言耦合度较高，跨语言支持难度较大。</p>
<p>国内常见的冶理型 RPC 框架如下：</p>
<ol>
<li><strong>Dubbo</strong>：Dubbo 是阿里巴巴公司开源的一个 Java 高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。当年在淘宝内部，Dubbo 由于跟淘宝另一个类似的框架 HSF 有竞争关系，导致 Dubbo 团队解散，最近又活过来了，有专职同学投入。</li>
<li><strong>DubboX</strong>：DubboX 是由当当在基于 Dubbo 框架扩展的一个 RPC 框架，支持 REST 风格的远程调用、Kryo/FST 序列化，增加了一些新的feature。Motan：Motan 是新浪微博开源的一个 Java 框架。它诞生的比较晚，起于 2013 年，2016 年 5 月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。</li>
<li><strong>rpcx</strong>：rpcx 是一个类似阿里巴巴 Dubbo 和微博 Motan 的分布式的 RPC 服务框架，基于 Golang net/rpc 实现。</li>
</ol>
<p>但是 rpcx 基本只有一个人在维护，没有完善的社区，使用前要慎重。</p>
<p>建议选用Dubbo，两个原因：</p>
<p>（1） <strong>高性能</strong>：性能测试案例中， Dubbo比Feign性能 强10倍</p>
<p>（2） <strong>跨语言</strong>：可以跨Go 和Java 进行 双语言的 RPC调用，从而实现 多语言微服务架构。</p>
<p><strong>选择和搭建高可用的注册中心</strong></p>
<p>名字发现和服务发现分为两种模式，一个是客户端发现模式，一种是服务端发现模式。框架中常用的服务发现是客户端发现模式。</p>
<p>所谓服务端发现模式是指客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。现在常用的负载均衡器都是此类模式，常用于微服务中。</p>
<p>所有的名字发现和服务发现都要依赖于一个可用性非常高的服务注册表，业界常用的服务注册表有如下三个：</p>
<p>etcd，一个高可用、分布式、一致性、key-value 方式的存储，被用在分享配置和服务发现中。两个著名的项目使用了它：Kubernetes 和 Cloud Foundry。Consul，一个发现和配置服务的工具，为客户端注册和发现服务提供了API，Consul还可以通过执行健康检查决定服务的可用性。Apache ZooKeeper，是一个广泛使用、高性能的针对分布式应用的协调服务。Apache ZooKeeper 本来是 Hadoop 的子工程，现在已经是顶级工程了。除此之外还有eureka, nacos等，大家可以根据相关的组件特性，选择适合自己的组件。</p>
<p>选择和搭建高可用的注册中心，需要考虑以下几个方面：</p>
<ol>
<li><strong>功能需求</strong>：选择注册中心时，需要根据自己的业务需求来选择，比如服务发现、负载均衡、配置管理等。</li>
<li><strong>性能要求</strong>：注册中心需要具备高性能，能够支持高并发、高吞吐量的请求。</li>
<li><strong>可用性要求</strong>：注册中心需要具备高可用性，能够保证24小时不间断运行，避免因为单点故障导致整个系统不可用。</li>
<li><strong>安全要求</strong>：注册中心需要具备一定的安全性，能够保证数据的机密性和完整性，避免数据泄露和篡改。</li>
</ol>
<p>常见的注册中心有 ZooKeeper、Etcd、Consul 等，它们都具备高可用性和安全性，并且都支持服务发现和配置管理等功能。其中，ZooKeeper 是最早的分布式协调服务，具备成熟的生态系统和广泛的应用场景；Etcd 是 CoreOS 推出的开源分布式键值存储系统，具备高可用性和一致性保证；Consul 是 HashiCorp 推出的服务发现和配置管理工具，具备易用性和可扩展性。</p>
<p>在搭建高可用的注册中心时，需要采用集群部署的方式，避免单点故障。同时，为了保证数据的安全性，可以启用 SSL/TLS 加密功能，并采用访问控制机制来限制访问权限。</p>
<p>建议是高可用的nacos，也就是 nacos+mysql的版本</p>
<p><strong>选择和搭建统一配置中心</strong></p>
<p>随着程序功能的日益复杂，程序的配置日益增多：各种功能的开关、降级开关，灰度开关，参数的配置、服务器的地址、数据库配置等等，除此之外，对后台程序配置的要求也越来越高：配置修改后实时生效，灰度发布，分环境、分用户，分集群管理配置，完善的权限、审核机制等等，在这样的大环境下，传统的通过配置文件、数据库等方式已经越来越无法满足开发人员对配置管理的需求，需要统一的、基础的配置系统</p>
<p>统一配置系统是指在一个大型系统中，将所有的配置信息集中管理，以便于对系统进行管理和维护。常见的统一配置系统架构包括以下几个组件：</p>
<ol>
<li><strong>配置中心</strong>：用于存储和管理所有的配置信息，提供配置查询、修改、删除等功能。</li>
<li><strong>配置客户端</strong>：用于从配置中心获取配置信息，并将其应用到系统中。</li>
<li><strong>配置发布工具</strong>：用于将配置信息发布到配置中心，以便于配置客户端获取。</li>
<li><strong>配置管理工具</strong>：用于对配置信息进行管理和维护，包括配置的新增、修改、删除等操作。</li>
<li><strong>配置监控工具</strong>：用于监控配置信息的变化，及时发现并处理配置信息的异常情况。</li>
</ol>
<p>在实际应用中，可以选择使用开源的配置中心工具，如 ZooKeeper、Etcd、Consul 、Nacos、Apollo等，也可以自己开发一套配置中心系统。</p>
<p>同时，还需要根据实际情况选择合适的配置客户端和配置发布工具。在配置管理和监控方面，可以使用一些开源的工具或者自己开发一套系统。总之，统一配置系统的架构需要根据实际需求进行设计和选择。</p>
<p>建议是高可用的nacos，也就是 nacos+mysql的版本</p>
<p><strong>选择和搭建高性能的缓存中间件</strong></p>
<p>选择和搭建高性能的缓存中间件需要考虑多个因素，包括性能、可靠性、可扩展性、易用性等。以下是一些常见的高性能缓存中间件：</p>
<ol>
<li><strong>Redis</strong>：Redis 是一个开源的高性能缓存和键值存储系统，支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等。Redis 通过将数据存储在内存中来提高性能，同时支持数据持久化和集群模式。</li>
<li><strong>Memcached</strong>：Memcached 是一个开源的高性能分布式内存对象缓存系统，可以缓存任何可序列化的数据，如数据库查询结果、API 响应等。Memcached 可以通过多个节点组成的集群来提高可扩展性和可靠性。</li>
<li><strong>Hazelcast</strong>：Hazelcast 是一个开源的分布式内存数据网格系统，支持缓存、分布式数据结构和分布式计算等功能。Hazelcast 可以通过多个节点组成的集群来提高可扩展性和可靠性。</li>
<li><strong>Couchbase</strong>：Couchbase 是一个开源的分布式 NoSQL 数据库和缓存系统，可以缓存任何类型的数据，包括 JSON 文档、键值对和二进制数据等。Couchbase 支持多个节点组成的集群和数据持久化等功能。</li>
</ol>
<p>在搭建高性能缓存中间件时，需要考虑以下几个方面：</p>
<ol>
<li><strong>硬件配置</strong>：缓存中间件需要占用大量内存，因此需要配置足够的内存和处理器资源。</li>
<li><strong>部署架构</strong>：需要考虑缓存中间件的部署架构，如单节点、主从复制、集群等。</li>
<li><strong>数据持久化</strong>：需要考虑数据持久化的方式，如内存快照、AOF 日志、RDB 文件等。</li>
<li><strong>安全性</strong>：需要考虑缓存中间件的安全性，如访问控制、数据加密等。</li>
<li><strong>监控和管理</strong>：需要考虑缓存中间件的监控和管理，如性能监控、故障诊断等。</li>
</ol>
<p>总之，选择和搭建高性能缓存中间件需要综合考虑多个因素，根据具体需求和场景进行选择和配置。</p>
<p>建议是高可用的redis cluster</p>
<p>要特别注意的是，redis关系到系统的高可用，很容易出生产事故。</p>
<p>如果redis出现big key，在高并发场景下，很容易出现系统瘫痪，严重影响系统的可用性，导致系统瘫痪。</p>
<p><strong>选择和搭建高性能的消息中间件</strong></p>
<p>消息中间件在后台系统中是必不可少的一个组件，一般我们会在以下场景中使用消息中间件：</p>
<ol>
<li><strong>异步处理</strong>：</li>
</ol>
<p>异步处理是使用消息中间件的一个主要原因，在工作中最常见的异步场景有用户注册成功后需要发送注册成功邮件、缓存过期时先返回老的数据，然后异步更新缓存、异步写日志等等；通过异步处理，可以减少主流程的等待响应时间，让非主流程或者非重要业务通过消息中间件做集中的异步处理。</p>
<ol>
<li><strong>系统解耦</strong>：</li>
</ol>
<p>比如在电商系统中，当用户成功支付完成订单后，需要将支付结果给通知ERP系统、发票系统、WMS、推荐系统、搜索系统、风控系统等进行业务处理；这些业务处理不需要实时处理、不需要强一致，只需要最终一致性即可，因此可以通过消息中间件进行系统解耦。通过这种系统解耦还可以应对未来不明确的系统需求。</p>
<ol>
<li><strong>削峰填谷</strong>：</li>
</ol>
<p>当系统遇到大流量时，监控图上会看到一个一个的山峰样的流量图，通过使用消息中间件将大流量的请求放入队列，通过消费者程序将队列中的处理请求慢慢消化，达到消峰填谷的效果。最典型的场景是秒杀系统，在电商的秒杀系统中下单服务往往会是系统的瓶颈，因为下单需要对库存等做数据库操作，需要保证强一致性，此时使用消息中间件进行下单排队和流控，让下单服务慢慢把队列中的单处理完，保护下单服务，以达到削峰填谷的作用。</p>
<p>业界消息中间件是一个非常通用的东西，大家在做选型时有使用开源的，也有自己造轮子的，甚至有直接用 MySQL 或 Redis 做队列的，关键看是否满足你的需求.</p>
<p>选择合适的消息中间件需要考虑多个因素，包括但不限于：</p>
<ol>
<li>需要处理的消息数量和频率</li>
<li>消息的大小和格式</li>
<li>可用性和容错性要求</li>
<li>数据安全性和加密需求</li>
<li>扩展性和灵活性要求</li>
<li>开发语言和技术栈的兼容性 常见的消息中间件包括RocketMQ、Kafka、 RabbitMQ、Kafka、ActiveMQ、Redis、NATS 等，每种中间件都有其特点和适用场景。</li>
</ol>
<p>如果需要处理大量的消息并且需要高吞吐量和低延迟，可以考虑使用 Kafka。如果需要实时处理消息并且需要高可用性和容错性，可以考虑使用 RabbitMQ。如果需要处理轻量级的消息，并且需要高性能和低延迟，可以考虑使用 Redis。</p>
<p>在选择消息中间件时，需要根据具体的业务需求和技术栈进行综合考虑，选择最合适的中间件。</p>
<p>目前建议 kafka + RocketMQ</p>
<p><strong>选择和搭建高性能的关系数据库</strong></p>
<p>关系数据库分为两种，一种是传统关系数据，如 Oracle，MySQL，Maria，DB2，PostgreSQL 等等，另一种是 NewSQL，即至少要满足以下五点的新型关系数据库：</p>
<ol>
<li>完整地支持 SQL，支持 JOIN / GROUP BY /子查询等复杂 SQL 查询。</li>
<li>支持传统数据标配的 ACID 事务，支持强隔离级别。</li>
<li>具有弹性伸缩的能力，扩容缩容对于业务层完全透明。</li>
<li>真正的高可用，异地多活、故障恢复的过程不需要人为的接入，系统能够自动地容灾和进行强一致的数据恢复。</li>
<li>具备一定的大数据分析能力。</li>
</ol>
<p>传统关系数据库用得最多的是 MySQL，成熟，稳定，一些基本的需求都能满足，在一定数据量级之前基本单机传统数据库都可以搞定，而且现在较多的开源系统都是基于 MySQL，开箱即用，再加上主从同步和前端缓存，百万 pv 的应用都可以搞定了。</p>
<p>不过 CentOS 7 已经放弃了 MySQL，而改使用 MariaDB。MariaDB 数据库管理系统是 MySQ L的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。</p>
<p>在 Google 发布了 F1: A Distributed SQL Database That Scales 和 Spanner: Google’s Globally-Distributed Databasa 之后，业界开始流行起 NewSQL。于是有了 CockroachDB，以及PingCAP的 TiDB。</p>
<p>国内已经有比较多的公司使用 TiDB，之前在创业公司时在大数据分析时已经开始应用 TiDB，当时应用的主要原因是 MySQL 要使用分库分表，逻辑开发比较复杂，扩展性不够。</p>
<p><strong>选择和搭建高性能的NoSQL</strong></p>
<p>NoSQL 顾名思义就是 Not-Only SQL，也有人说是 No – SQL，个人偏向于 Not-Only SQL，它并不是用来替代关系库，而是作为关系型数据库的补充而存在。</p>
<p>常见 NoSQL 有4个类型：</p>
<ol>
<li><strong>键值</strong>，适用于内容缓存，适合混合工作负载并发高扩展要求大的数据集，其优点是简单，查询速度快，缺点是缺少结构化数据，常见的有 Redis，Memcache，BerkeleyDB 和 Voldemort 等等；</li>
<li><strong>列式</strong>，以列簇式存储，将同一列数据存在一起，常见于分布式的文件系统，其中以 Hbase，Cassandra 为代表。Cassandra 多用于写多读少的场景，国内用得比较多的有 360，大概 1500 台机器的集群，国外大规模使用的公司比较多，如 eBay，Instagram，Apple 和沃尔玛等等；</li>
<li><strong>文档</strong>，数据存储方案非常适用承载大量不相关且结构差别很大的复杂信息。性能介于 kv 和关系数据库之间，它的灵感来于 lotus notes，常见的有 MongoDB，CouchDB 等等；</li>
<li><strong>图形</strong>，图形数据库擅长处理任何涉及关系的状况。社交网络，推荐系统等。专注于构建关系图谱，需要对整个图做计算才能得出结果，不容易做分布式的集群方案，常见的有 Neo4J，InfoGrid 等。</li>
</ol>
<p>除了以上4种类型，还有一些特种的数据库，如对象数据库，XML 数据库，这些都有针对性对某些存储类型做了优化的数据库。</p>
<p>在实际应用场景中，何时使用关系数据库，何时使用 NoSQL，使用哪种类型的数据库，这是我们在做架构选型时一个非常重要的考量，甚至会影响整个架构的方案。</p>
<p><strong>CICD发布系统/部署系统的架构</strong></p>
<p>软件生产的层面看，代码到最终服务的典型流程如图2 所示：</p>
<p>图2 流程图</p>
<p><img src="https://pics5.baidu.com/feed/79f0f736afc379317be5da173c16ff4942a91159.jpeg@f_auto?token=4bb2c4d1bb9adef5c1a6d5ad85f59fb4" alt=""></p>
<p>从上图中可以看出，从开发人员写下代码到服务最终用户是一个漫长过程，整体可以分成三个阶段：</p>
<ol>
<li><strong>从代码（Code）到制品库（Artifact）</strong>：这个阶段主要对开发人员的代码做持续构建，并把构建产生的制品集中管理，是为部署系统准备输入内容的阶段。</li>
<li><strong>从制品到可运行服务</strong>：这个阶段主要完成制品部署到指定环境，是部署系统的最基本工作内容。</li>
<li><strong>从开发环境到最终生产环境</strong>：这个阶段主要完成一次变更在不同环境的迁移，是部署系统上线最终服务的核心能力。</li>
</ol>
<p>发布系统集成了制品管理，发布流程，权限控制，线上环境版本变更，灰度发布，线上服务回滚等几方面的内容，是开发人员工作结晶最终呈现的重要通道。</p>
<p>CI/CD 发布系统/部署系统的架构通常包括以下组件：</p>
<ol>
<li><strong>源代码管理系统</strong>：例如 Git、SVN 等，用于管理代码库。</li>
<li><strong>持续集成工具</strong>：例如 Jenkins、GitLab CI、Travis CI 等，用于自动化构建、测试和打包应用程序。</li>
<li><strong>制品仓库</strong>：例如 Docker Hub、Harbor、Aliyun Container Registry 等，用于存储应用程序的镜像。</li>
<li><strong>部署工具</strong>：例如 Kubernetes、Docker Swarm、Mesos 等，用于自动化部署应用程序。</li>
</ol>
<p>这些组件可以根据实际需求进行选择和组合，形成一个完整的 CI/CD 发布系统/部署系统。</p>
<p>其中，持续集成工具和部署工具是核心组件，它们负责自动化构建、测试、打包和部署应用程序，从而实现快速、可靠、可重复的软件发布流程。</p>
<p>项目初期可以集成 Jenkins + Gitlab + Harbor，以上方案基本包括制品管理，发布流程，权限控制，线上环境版本变更，灰度发布（需要自己实现），线上服务回滚等功能。</p>
<p><strong>代码管理工具选型</strong></p>
<p>代码是项目的命脉之一，代码管理很重要，常见的考量点包括两块：</p>
<p>安全和权限管理，将代码放到内网并且对于关系公司命脉的核心代码做严格的代码控制和机器的物理隔离；代码管理工具，Git 作为代码管理的不二之选，你值得拥有。</p>
<p>GitLab 是当今最火的开源 Git 托管服务端，没有之一，虽然有企业版，但是其社区版基本能满足我们大部分需求，结合 Gerrit 做 Code review，基本就完美了。</p>
<p>当然 GitLab 也有代码对比，但没 Gerrit 直观。</p>
<p>Gerrit 比 GitLab 提供了更好的代码检查界面与主线管理体验，更适合在对代码质量有高要求的文化下使用。</p>
<p><strong>持续集成工具选型</strong></p>
<p>持续集成简称 CI（continuous integration），是一种软件开发实践，即团队开发成员经常集成他们的工作，每天可能会发生多次集成。</p>
<p>每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p>
<p>持续集成为研发流程提供了代码分支管理/比对、编译、检查、发布物输出等基础工作，为测试的覆盖率版本编译、生成等提供统一支持。</p>
<p>业界免费的持续集成工具中系统我们有如下一些选择：</p>
<ol>
<li><strong>Jenkins</strong>：Java 写的有强大的插件机制，MIT 协议开源 （免费，定制化程度高，它可以在多台机器上进行分布式地构建和负载测试）。Jenkins 可以算是无所不能，基本没有 Jenkins 做不了的，无论从小型团队到大型团队 Jenkins 都可以搞定。不过如果要大规模使用，还是需要有人力来学习和维护。</li>
<li><strong>TeamCity</strong>：TeamCity 与 Jenkins 相比使用更加友好，也是一个高度可定制化的平台。但是用的人多了，TeamCity就要收费了。</li>
<li><strong>Strider</strong>：Strider 是一个开源的持续集成和部署平台，使用 Node.js 实现，存储使用的是 MongoDB，BSD 许可证，概念上类似 Travis 和Jenkins。</li>
<li><strong>GitLab CI</strong>：从GitLab 8.0开始，GitLab CI 就已经集成在 GitLab，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。并且 GitLab 与 Docker 有着非常好的相互协作的能力。</li>
<li><strong>Travis</strong>：Travis 和 GitHub 强关联；闭源代码使用 SaaS 还需考虑安全问题；不可定制；开源项目免费，其它收费。</li>
<li><strong>Go</strong>：Go 是 ThoughtWorks 公司最新的 Cruise Control 的化身。除了 ThoughtWorks 提供的商业支持，Go 是免费的。它适用于 Windows，Mac 和各种 Linux 发行版。</li>
</ol>
<p><strong>自动化测试平台的架构</strong></p>
<p>接下来，就是自动化测试平台的搭建。</p>
<p>搭建自动化测试平台需要考虑以下几个方面：</p>
<ol>
<li><strong>选择合适的测试框架和工具</strong>：可以选择一些流行的测试框架和工具，如Selenium、Appium、JMeter等，根据需要选择适合自己的工具。</li>
<li><strong>搭建测试环境</strong>：需要搭建测试环境，包括测试服务器、测试数据库、测试数据等。可以使用虚拟机或者容器来搭建测试环境，以便进行测试。</li>
<li><strong>编写测试用例</strong>：需要编写测试用例，测试用例应该覆盖系统的各个功能点，以便发现潜在的问题。</li>
<li><strong>集成测试工具和测试用例</strong>：将测试工具和测试用例集成到自动化测试平台中，以便进行自动化测试。</li>
<li><strong>运行测试用例</strong>：编写好测试用例后，需要运行测试用例，收集测试结果，并生成测试报告。</li>
<li><strong>定期维护和更新</strong>：自动化测试平台需要定期维护和更新，以保证测试环境的稳定性和测试用例的有效性。</li>
</ol>
<p>以上是搭建自动化测试平台的一般步骤，具体实现方式还需要根据实际情况进行调整。</p>
<p>可以结合 SpringBoot + TestNG 测试框架，搭建自己的 自动化测试平台</p>
<p>提示，不用自己从0到1 去搭建自动化测试平台，可以基于开源的自动化测试平台进行改造。</p>
<p>下面的两个测试平台，就是非常好的改造项目：</p>
<ol>
<li>接口自动化测试框架（java httpClient + testNg）</li>
<li>ChenSen5/api_autotest (<a href="https://github.com/ChenSen5/api%5C_autotest">https://github.com/ChenSen5/api\_autotest</a>)</li>
<li>基于SpringBoot的高效模板化自动化测试框架</li>
<li>jinganglong123/jg-api-autotest (<a href="https://github.com/jinganglong123/jg-api-autotest">https://github.com/jinganglong123/jg-api-autotest</a>)</li>
</ol>
<p><strong>360度全方位监控和维护的架构</strong></p>
<p>360度全方位监控和维护的架构包括</p>
<ol>
<li>日志系统</li>
<li>监控系统</li>
</ol>
<p><strong>日志系统</strong></p>
<p>日志系统一般包括打日志，采集，中转，收集，存储，分析，呈现，搜索还有分发等。</p>
<p>一些特殊的如<strong>染色</strong>，全链条跟踪或者监控都可能需要依赖于日志系统实现。</p>
<p>日志系统的建设不仅仅是工具的建设，还有规范和组件的建设，最好一些基本的日志在框架和组件层面加就行了，比如全链接跟踪之类的。</p>
<p>对于常规日志系统ELK能满足大部分的需求，ELK 包括如下组件：</p>
<p>ElasticSearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，RESTful 风格接口，多数据源，自动搜索负载等。</p>
<p>Logstash 是一个完全开源的工具，它可以对你的日志进行收集、分析，并将其存储供以后使用。Kibana 是一个开源和免费的工具，它可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。</p>
<p>Filebeat 已经完全替代了 Logstash-Forwarder 成为新一代的日志采集器，同时鉴于它轻量、安全等特点，越来越多人开始使用它。</p>
<p>因为免费的 ELK 没有任何安全机制，所以这里使用了 Nginx 作反向代理，避免用户直接访问 Kibana 服务器。</p>
<p>加上配置 Nginx 实现简单的用户认证，一定程度上提高安全性。</p>
<p>另外，Nginx 本身具有负载均衡的作用，能够提高系统访问性能。</p>
<p>ELK 架构如图3 所示：</p>
<p>图3 ELK 流程图</p>
<p><img src="https://pics7.baidu.com/feed/32fa828ba61ea8d38fa0602340d87842241f5871.jpeg@f_auto?token=854c8ec61da88338fc959753af0805ad" alt=""></p>
<p>对于有实时计算的需求，可以使用 Flume + Kafka + Storm + MySQL 方案，一 般架构如图4 所示：</p>
<p>图4 实时分析系统架构图</p>
<p><img src="https://pics3.baidu.com/feed/242dd42a2834349b37545a591e385dc234d3befe.jpeg@f_auto?token=1c04504154566417238607715590eae6" alt=""></p>
<p>其中：</p>
<p>Flume 是一个分布式、可靠、和高可用的海量日志采集、聚合和传输的日志收集系统，支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume 提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。其本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，它以可水平扩展和高吞吐率而被广泛使用。</p>
<p>Kafka 追求的是高吞吐量、高负载，Flume 追求的是数据的多样性，二者结合起来简直完美。</p>
<p><strong>监控系统</strong></p>
<p>监控系统只包含与后台相关的，这里主要是两块，一个是操作系统层的监控，比如机器负载，IO，网络流量，CPU，内存等操作系统指标的监控。</p>
<p>另一个是服务质量和业务质量的监控，比如服务的可用性，成功率，失败率，容量，QPS 等等。</p>
<p>常见业务的监控系统先有操作系统层面的监控（这部分较成熟），然后扩展出其它监控，如 Zabbix，小米的 Open-Falcon，也有一出来就是两者都支持的，如 Prometheus。</p>
<p>如果对业务监控要求比较高一些，在创业选型中建议可以优先考虑 Prometheus。</p>
<p>这里有一个有趣的分布，如图5 所示。</p>
<p>图5 监控系统分布</p>
<p><img src="https://pics5.baidu.com/feed/91529822720e0cf37dff0cacdd94ba13bf09aab8.jpeg@f_auto?token=78b21d8d26b6390c49bdc8d79949e5c1" alt=""></p>
<p>亚洲区域使用 Zabbix 较多，而美洲和欧洲，以及澳大利亚使用 Prometheus 居多，换句话说，英文国家地区（发达国家？）使用 Prometheus 较多。</p>
<p>Prometheus 是由 SoundCloud 开发的开源监控报警系统和时序列数据库（TSDB）。</p>
<p>Prometheus 使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。</p>
<p>相对于其它监控系统使用的 push 数据的方式，Prometheus 使用的是 pull 的方式，其架构如图6 所示：</p>
<p>图6 Prometheus 架构图</p>
<p><img src="https://pics5.baidu.com/feed/7a899e510fb30f24b5dc0bc31e47994faf4b038f.png@f_auto?token=17e4b1472f5b8bf00dff3b872cac7b60" alt=""></p>
<p>如上图所示，Prometheus 包含的主要组件如下：</p>
<ol>
<li><strong>Prometheus Server</strong>：主要负责数据采集和存储，提供 PromQL 查询语言的支持。</li>
<li><strong>Server</strong>：通过配置文件、文本文件、ZooKeeper、Consul、DNS SRV Lookup 等方式指定抓取目标。</li>
</ol>
<p>根据这些目标会，Server 定时去抓取 metrics 数据，每个抓取目标需要暴露一个 http 服务的接口给它定时抓取。</p>
<ol>
<li><strong>客户端 SDK</strong>：官方提供的客户端类库有 Go、Java、Scala、Python、Ruby，其他还有很多第三方开发的类库，支持 Nodejs、PHP、Erlang 等。</li>
<li><strong>Push Gateway</strong>：支持临时性 Job 主动推送指标的中间网关。</li>
<li><strong>Exporter Exporter</strong>：是 Prometheus 的一类数据采集组件的总称。它负责从目标处搜集数据，并将其转化为 Prometheus 支持的格式。</li>
</ol>
<p>与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。</p>
<ol>
<li><strong>Prometheus</strong>：提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。</li>
<li><strong>Alertmanager</strong>：是一个单独的服务，可以支持 Prometheus 的查询语句，提供十分灵活的报警方式。</li>
<li><strong>Prometheus HTTP API</strong> 的查询方式，自定义所需要的输出。</li>
<li><strong>Grafana</strong>：是一套开源的分析监视平台，支持 Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch 等数据源，其 UI 非常漂亮且高度定制化。</li>
</ol>
<p>创业公司选择 Prometheus + Grafana 的方案，再加上统一的服务框架（如 gRPC），可以满足大部分中小团队的监控需求。</p>
<p><strong>生产环境高并发高吞吐负载均衡部署架构</strong></p>
<p>高并发高吞吐负载均衡链路架构，包括：</p>
<ol>
<li>DNS的选型和使用设计</li>
<li>LB（负载均衡）的选型和使用设计</li>
<li>CDN的选型和使用设计</li>
</ol>
<p><strong>DNS的选型和使用设计</strong></p>
<p>DNS 是一个很通用的服务，创业公司基本上选择一个合适的云厂商就行了，国内主要是两家：</p>
<p>阿里万网：阿里 2014 年收购了万网，整合了其域名服务，最终形成了现在的阿里万网，其中就包含 DNS 这块的服务；</p>
<p>腾讯 DNSPod：腾讯 2012 年以 4000 万收购 DNSPod 100% 股份，主要提供域名解析和一些防护功能；</p>
<p>如果你的业务是在国内，主要就是这两家，选 一个就好，像今日头条这样的企业用的也是 DNSPod 的服务，除非一些特殊的原因才需要自建，比如一些 CDN 厂商，或者对区域有特殊限制的。</p>
<p>要实惠一点用阿里最便宜的基础版就好了，要成功率高一些，还是用 DNSPod 的贵的那种。</p>
<p>在国外还是选择亚马逊吧，阿里的 DNS 服务只有在日本和美国有节点，东南亚最近才开始部点， DNSPod 也只有美国和日本，像一些出海的企业，其选择的云服务基本都是亚马逊。</p>
<p>如果是线上产品，DNS 强烈建议用付费版，阿里的那几十块钱的付费版基本可以满足需求。如果还需要一些按省份或按区域调试的逻辑，则需要加钱，一年也就几百块，省钱省力。</p>
<p>如果是国外，优先选择亚马逊，如果需要国内外互通并且有自己的 APP 的话，建议还是自己实现一些容灾逻辑或者智能调度，因为没有一个现成的 DNS 服务能同时较好的满足国内外场景，或者用多个域名，不同的域名走不同的 DNS 。</p>
<p><strong>LB（负载均衡）的选型和使用设计</strong></p>
<p>LB（负载均衡）是一个通用服务，一般云厂商的 LB 服务基本都会如下功能：</p>
<ol>
<li>支持四层协议请求（包括 TCP、UDP 协议）；</li>
<li>支持七层协议请求（包括 HTTP、HTTPS 协议）；</li>
<li>集中化的证书管理系统支持 HTTPS 协议；</li>
<li>健康检查；</li>
</ol>
<p>如果你线上的服务机器都是用的云服务，并且是在同一个云服务商的话，可以直接使用云服务商提供的 LB 服务，如阿里云的 SLB，腾讯云的 CLB，亚马逊的 ELB 等等。如果是自建机房基本都是 LVS + Nginx。</p>
<p><strong>CDN的选型和使用设计</strong></p>
<p>CDN 现在已经是一个很红很红的市场，基本上只能挣一些辛苦钱，都是贴着成本在卖。国内以网宿为龙头，他们家占据整个国内市场份额的 40% 以上，后面就是腾讯，阿里。网宿有很大一部分是因为直播的兴起而崛起。</p>
<p>国外，Amazon 和 Akamai合起来占比大概在 50%，曾经的国际市场老大 Akamai 拥有全球超一半的份额，在 Amazon CDN入局后，份额跌去了将近 20%，众多中小企业都转向后者，Akamai 也是无能为力。</p>
<p>国内出海的 CDN 厂商，更多的是为国内的出海企业服务，三家大一点的 CDN 服务商里面也就网宿的节点多一些，但是也多不了多少。阿里和腾讯还处于前期阶段，仅少部分国家有节点。</p>
<h4>最后</h4>
<p>好的架构不是一蹴而就的，而是演变出来的。对于一个问题，架构师需要做出正确的判断，而这个“正确”与否，在不同的场景下，也是不同的，也就是说答案是开放的。那么提高自己的技术能力、认知能力，就相当重要了。这就要求我们不断地学习，保持对技术的敏锐，才能做出正确的选择。</p>
<p>路漫漫其修远兮，架构求索无止尽也。</p>
</div></div><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><div class="mt-12 pt-8 border-t border-gray-200">加载导航中...</div><!--/$--><div class="mt-16 border-t border-gray-200 pt-8"><div class="mx-auto max-w-3xl"><h3 class="text-2xl font-bold text-gray-900 mb-8">评论</h3></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-[var(--background)]"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-600 hover:text-gray-800" href="/about/">关于</a><a class="text-gray-600 hover:text-gray-800" href="/blog/">博客</a><a class="text-gray-600 hover:text-gray-800" href="/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-600">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/_next/static/chunks/webpack-f7d11fc743a8cf38.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[10616,[\"874\",\"static/chunks/874-f2e46e41114bd221.js\",\"177\",\"static/chunks/app/layout-c432974c723daafe.js\"],\"default\"]\n3:I[87555,[],\"\"]\n4:I[31295,[],\"\"]\n5:I[6874,[\"874\",\"static/chunks/874-f2e46e41114bd221.js\",\"968\",\"static/chunks/968-bf93abe4de13a5fc.js\",\"909\",\"static/chunks/app/blog/%5B...slug%5D/page-26cc6d1a0064a78b.js\"],\"\"]\n7:I[59665,[],\"OutletBoundary\"]\na:I[74911,[],\"AsyncMetadataOutlet\"]\nc:I[59665,[],\"ViewportBoundary\"]\ne:I[59665,[],\"MetadataBoundary\"]\n10:I[26614,[],\"\"]\n:HL[\"/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/0a7d53676a1eb136.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"Y77GRT6uWTaI_EEOm0prR\",\"p\":\"\",\"c\":[\"\",\"blog\",\"tech\",\"system\",\"%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"tech/system/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0a7d53676a1eb136.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_f367f3\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-[var(--background)]\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-600 hover:text-gray-800\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-600\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"tech/system/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%81%9A%E4%B8%80%E4%B8%AA%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"F2EBdrr_V9Hh3xXv6dv1_v\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[74911,[],\"AsyncMetadata\"]\n14:I[32923,[\"874\",\"static/chunks/874-f2e46e41114bd221.js\",\"968\",\"static/chunks/968-bf93abe4de13a5fc.js\",\"909\",\"static/chunks/app/blog/%5B...slug%5D/page-26cc6d1a0064a78b.js\"],\"default\"]\n16:I[40780,[\"874\",\"static/chunks/874-f2e46e41114bd221.js\",\"968\",\"static/chunks/968-bf93abe4de13a5fc.js\",\"909\",\"static/chunks/app/blog/%5B...slug%5D/page-26cc6d1a0064a78b.js\"],\"default\"]\n1a:I[85300,[\"874\",\"static/chunks/874-f2e46e41114bd221.js\",\"968\",\"static/chunks/968-bf93abe4de13a5fc.js\",\"909\",\"static/chunks/app/blog/%5B...slug%5D/page-26cc6d1a0064a78b.js\"],\"default\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n15:Ta3c4,"])</script><script>self.__next_f.push([1,"\u003cp\u003e\u003ca href=\"https://baijiahao.baidu.com/s?id=1767938488419450782\"\u003e转载\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e团队协助基础工具链的选型和培训\u003c/li\u003e\n\u003cli\u003e搭建微服务开发基础设施\u003c/li\u003e\n\u003cli\u003e选择合适的RPC框架\u003c/li\u003e\n\u003cli\u003e选择和搭建高可用的注册中心\u003c/li\u003e\n\u003cli\u003e选择和搭建高可用的配置中心\u003c/li\u003e\n\u003cli\u003e选择和搭建高性能的缓存中间件\u003c/li\u003e\n\u003cli\u003e选择和搭建高性能的消息中间件\u003c/li\u003e\n\u003cli\u003e选择和搭建高性能的关系数据库\u003c/li\u003e\n\u003cli\u003eCICD发布系统/部署系统的架构\u003c/li\u003e\n\u003cli\u003e360度全方位监控和维护的架构\u003c/li\u003e\n\u003cli\u003e生产环境高并发高吞吐负载均衡部署架构\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e整个后台技术架构，主要包括 4 个层面的内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e语言\u003c/strong\u003e：用了哪些开发语言，如：C++/Java/Go/PHP/Python/Ruby 等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e组件\u003c/strong\u003e：用了哪些组件，如：MQ 组件，数据库组件等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e流程\u003c/strong\u003e：怎样的流程和规范，如：开发流程，项目流程，发布流程，监控告警流程，代码规范等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e系统\u003c/strong\u003e：系统化建设，上面的流程需要有系统来保证，如：规范发布流程的发布系统，代码管理系统等等；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e结合以上的的 4 个层面的内容，整个后台技术栈的结构如图1 所示：\u003c/p\u003e\n\u003cp\u003e图1 后台技术栈结构\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics7.baidu.com/feed/f2deb48f8c5494ee55c2ea79fa27a8f29b257ec9.jpeg@f_auto?token=39d8af3c95030b48ad867ef53c70f4c5\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e咱们一个个系统和组件的做选型，最终形成我们的后台技术栈。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e团队协助基础工具链的选型和培训\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e团队协助基础工具链， 主要是三大管理\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e项目管理\u003c/li\u003e\n\u003cli\u003e任务管理\u003c/li\u003e\n\u003cli\u003e问题管理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e项目管理软件是整个业务的需求，问题，流程等等的集中地，大家的跨部门沟通协同大多依赖于项目管理工具。\u003c/p\u003e\n\u003cp\u003e有一些 SaaS 的项目管理服务可以使用，但是很多时间不满足需求，此时我们可以选择一些开源的项目，这些项目本身有一定的定制能力，有丰富的插件可以使用，一般的创业公司需求基本上都能得到满足，常用的项目如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eJira\u003c/strong\u003e：用 Java 开发的，有用户故事，task 拆分，燃尽图等等，可以做项目管理，也可以应用于跨部门沟通场景，较强大；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRedmine\u003c/strong\u003e：用 Ruby 开发的，有较多的插件可以使用，能自定义字段，集成了项目管理，Bug 问题跟踪，WIKI 等功能，不过好多插件 N 年没有更新了；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePhabricator\u003c/strong\u003e：用 PHP 开发的，Facebook 之前的内部工具，开发这工具的哥们离职后自己搞了一个公司专门做这个软件，集成了代码托管， Code Review，任务管理，文档管理，问题跟踪等功能，强烈推荐较敏捷的团队使用；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些平台我都用过，有些甚至还搭建过，惭愧地说一句，盗版的，目前建议是 Jira。像银行，基本上conflue+jira是标配了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e搭建微服务开发基础设施\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e搭建微服务开发基础设施需要考虑多个方面，包括但不限于以下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e选择合适的微服务框架和技术栈\u003c/strong\u003e：目前比较流行的微服务框架有 Spring Cloud、Go-Micro、gRPC 等，选择适合自己团队技术栈的框架非常重要。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e选择合适的RPC框架\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e构建基础设施\u003c/strong\u003e：包括但不限于服务注册与发现、负载均衡、API 网关、分布式配置中心、分布式锁、消息队列等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全\u003c/strong\u003e：包括但不限于服务间通信的加密、访问控制、身份认证等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在搭建微服务开发基础设施之前，需要对自己的业务场景进行分析和规划，确定需要哪些基础设施和技术栈，然后再逐步实现。同时，需要注重可扩展性和可维护性，以便在业务发展过程中能够快速适应变化。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择合适的微服务框架和技术栈\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e选择合适的微服务框架和技术栈需要考虑多个因素，包括以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e业务需求\u003c/strong\u003e：不同的业务需求需要不同的技术栈和框架来支持。比如，如果需要高并发和高可用性，可以选择使用 Go 语言和 Kubernetes 等技术来构建微服务。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开发团队技能\u003c/strong\u003e：选择的技术栈和框架应该符合开发团队的技能水平，以便开发人员能够快速上手并高效开发。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e社区支持\u003c/strong\u003e：选择流行的技术栈和框架可以获得更好的社区支持，能够更快地解决问题和获得更新的功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e性能和稳定性\u003c/strong\u003e：选择的技术栈和框架应该具有良好的性能和稳定性，以便能够支持高负载和长时间运行。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e常见的微服务框架和技术栈包括：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eSpring Cloud\u003c/strong\u003e：适用于 Java 开发团队，具有丰富的功能和社区支持。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo Micro\u003c/strong\u003e：适用于 Go 开发团队，具有高性能和简单易用的特点。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eNode.js + Express\u003c/strong\u003e：适用于 JavaScript 开发团队，具有轻量级和快速开发的特点。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKubernetes\u003c/strong\u003e：适用于需要高可用性和弹性的微服务架构，可以支持多种编程语言和框架。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIstio\u003c/strong\u003e：适用于需要服务网格功能的微服务架构，可以提供流量管理、安全性和可观察性等功能。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在选择时，需要根据具体的业务需求和开发团队技能来选择合适的微服务框架和技术栈。\u003c/p\u003e\n\u003cp\u003e建议选用 SpringCloud Alibaba+ Dubbo RPC + Dubbo-Go，两个原因：\u003c/p\u003e\n\u003cp\u003e（1） \u003cstrong\u003e高性能\u003c/strong\u003e：做过的性能测试中， Dubbo比Feign性能 强10倍。\u003c/p\u003e\n\u003cp\u003e（2） \u003cstrong\u003e兼顾团队技术栈\u003c/strong\u003e：可以跨Go 和Java 多语言微服务架构，Java技术栈的同学们，可以基于 Java开发业务微服务，这块侧重业务开发。Go 技术栈的同学们，可以基于 Go 开发高性能的 技术微服务，这块侧重技术开发和性能优化。\u003c/p\u003e\n\u003cp\u003e（3）\u003cstrong\u003e功能和性能兼顾\u003c/strong\u003e：Java侧重功能的快速开发， Go侧重性能的快速提升。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择合适的RPC框架\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e维基百科对 RPC 的定义是：远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。\u003c/p\u003e\n\u003cp\u003e通俗来讲，一个完整的 RPC 调用过程，就是 Server 端实现了一个函数，客户端使用 RPC 框架提供的接口，调用这个函数的实现，并获取返回值的过程。\u003c/p\u003e\n\u003cp\u003e业界 RPC 框架大致分为两大流派，一种侧重跨语言调用，另一种是偏重服务治理。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e跨语言调用型 RPC\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e跨语言调用型的 RPC 框架有 Thrift、gRPC、Hessian、Hprose 等。这类 RPC 框架侧重于服务的跨语言调用，能够支持大部分的语言进行语言无关的调用，非常适合多语言调用场景。但这类框架没有服务发现相关机制，实际使用时需要代理层进行请求转发和负载均衡策略控制。\u003c/p\u003e\n\u003cp\u003e其中，gRPC 是 Google 开发的高性能、通用的开源 RPC 框架，其由 Google 主要面向移动应用开发并基于 HTTP/2 协议标准而设计，基于 ProtoBuf（Protocol Buffers）序列化协议开发，且支持众多开发语言。本身它不是分布式的，所以要实现框架的功能需要进一步的开发。\u003c/p\u003e\n\u003cp\u003eHprose（High Performance Remote Object Service Engine）是一个 MIT 开源许可的新型轻量级跨语言跨平台的面向对象的高性能远程动态通讯中间件。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e冶理型 RPC\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e服务治理型的 RPC 框架\u003c/strong\u003e的特点是功能丰富，提供高性能的远程调用、服务发现及服务治理能力，适用于大型服务的服务解耦及服务治理，对于特定语言(Java)的项目可以实现透明化接入。缺点是语言耦合度较高，跨语言支持难度较大。\u003c/p\u003e\n\u003cp\u003e国内常见的冶理型 RPC 框架如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eDubbo\u003c/strong\u003e：Dubbo 是阿里巴巴公司开源的一个 Java 高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring 框架无缝集成。当年在淘宝内部，Dubbo 由于跟淘宝另一个类似的框架 HSF 有竞争关系，导致 Dubbo 团队解散，最近又活过来了，有专职同学投入。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDubboX\u003c/strong\u003e：DubboX 是由当当在基于 Dubbo 框架扩展的一个 RPC 框架，支持 REST 风格的远程调用、Kryo/FST 序列化，增加了一些新的feature。Motan：Motan 是新浪微博开源的一个 Java 框架。它诞生的比较晚，起于 2013 年，2016 年 5 月开源。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erpcx\u003c/strong\u003e：rpcx 是一个类似阿里巴巴 Dubbo 和微博 Motan 的分布式的 RPC 服务框架，基于 Golang net/rpc 实现。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是 rpcx 基本只有一个人在维护，没有完善的社区，使用前要慎重。\u003c/p\u003e\n\u003cp\u003e建议选用Dubbo，两个原因：\u003c/p\u003e\n\u003cp\u003e（1） \u003cstrong\u003e高性能\u003c/strong\u003e：性能测试案例中， Dubbo比Feign性能 强10倍\u003c/p\u003e\n\u003cp\u003e（2） \u003cstrong\u003e跨语言\u003c/strong\u003e：可以跨Go 和Java 进行 双语言的 RPC调用，从而实现 多语言微服务架构。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高可用的注册中心\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e名字发现和服务发现分为两种模式，一个是客户端发现模式，一种是服务端发现模式。框架中常用的服务发现是客户端发现模式。\u003c/p\u003e\n\u003cp\u003e所谓服务端发现模式是指客户端通过一个负载均衡器向服务发送请求，负载均衡器查询服务注册表并把请求路由到一台可用的服务实例上。现在常用的负载均衡器都是此类模式，常用于微服务中。\u003c/p\u003e\n\u003cp\u003e所有的名字发现和服务发现都要依赖于一个可用性非常高的服务注册表，业界常用的服务注册表有如下三个：\u003c/p\u003e\n\u003cp\u003eetcd，一个高可用、分布式、一致性、key-value 方式的存储，被用在分享配置和服务发现中。两个著名的项目使用了它：Kubernetes 和 Cloud Foundry。Consul，一个发现和配置服务的工具，为客户端注册和发现服务提供了API，Consul还可以通过执行健康检查决定服务的可用性。Apache ZooKeeper，是一个广泛使用、高性能的针对分布式应用的协调服务。Apache ZooKeeper 本来是 Hadoop 的子工程，现在已经是顶级工程了。除此之外还有eureka, nacos等，大家可以根据相关的组件特性，选择适合自己的组件。\u003c/p\u003e\n\u003cp\u003e选择和搭建高可用的注册中心，需要考虑以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e功能需求\u003c/strong\u003e：选择注册中心时，需要根据自己的业务需求来选择，比如服务发现、负载均衡、配置管理等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e性能要求\u003c/strong\u003e：注册中心需要具备高性能，能够支持高并发、高吞吐量的请求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e可用性要求\u003c/strong\u003e：注册中心需要具备高可用性，能够保证24小时不间断运行，避免因为单点故障导致整个系统不可用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全要求\u003c/strong\u003e：注册中心需要具备一定的安全性，能够保证数据的机密性和完整性，避免数据泄露和篡改。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e常见的注册中心有 ZooKeeper、Etcd、Consul 等，它们都具备高可用性和安全性，并且都支持服务发现和配置管理等功能。其中，ZooKeeper 是最早的分布式协调服务，具备成熟的生态系统和广泛的应用场景；Etcd 是 CoreOS 推出的开源分布式键值存储系统，具备高可用性和一致性保证；Consul 是 HashiCorp 推出的服务发现和配置管理工具，具备易用性和可扩展性。\u003c/p\u003e\n\u003cp\u003e在搭建高可用的注册中心时，需要采用集群部署的方式，避免单点故障。同时，为了保证数据的安全性，可以启用 SSL/TLS 加密功能，并采用访问控制机制来限制访问权限。\u003c/p\u003e\n\u003cp\u003e建议是高可用的nacos，也就是 nacos+mysql的版本\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建统一配置中心\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e随着程序功能的日益复杂，程序的配置日益增多：各种功能的开关、降级开关，灰度开关，参数的配置、服务器的地址、数据库配置等等，除此之外，对后台程序配置的要求也越来越高：配置修改后实时生效，灰度发布，分环境、分用户，分集群管理配置，完善的权限、审核机制等等，在这样的大环境下，传统的通过配置文件、数据库等方式已经越来越无法满足开发人员对配置管理的需求，需要统一的、基础的配置系统\u003c/p\u003e\n\u003cp\u003e统一配置系统是指在一个大型系统中，将所有的配置信息集中管理，以便于对系统进行管理和维护。常见的统一配置系统架构包括以下几个组件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e配置中心\u003c/strong\u003e：用于存储和管理所有的配置信息，提供配置查询、修改、删除等功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置客户端\u003c/strong\u003e：用于从配置中心获取配置信息，并将其应用到系统中。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置发布工具\u003c/strong\u003e：用于将配置信息发布到配置中心，以便于配置客户端获取。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置管理工具\u003c/strong\u003e：用于对配置信息进行管理和维护，包括配置的新增、修改、删除等操作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置监控工具\u003c/strong\u003e：用于监控配置信息的变化，及时发现并处理配置信息的异常情况。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在实际应用中，可以选择使用开源的配置中心工具，如 ZooKeeper、Etcd、Consul 、Nacos、Apollo等，也可以自己开发一套配置中心系统。\u003c/p\u003e\n\u003cp\u003e同时，还需要根据实际情况选择合适的配置客户端和配置发布工具。在配置管理和监控方面，可以使用一些开源的工具或者自己开发一套系统。总之，统一配置系统的架构需要根据实际需求进行设计和选择。\u003c/p\u003e\n\u003cp\u003e建议是高可用的nacos，也就是 nacos+mysql的版本\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的缓存中间件\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e选择和搭建高性能的缓存中间件需要考虑多个因素，包括性能、可靠性、可扩展性、易用性等。以下是一些常见的高性能缓存中间件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eRedis\u003c/strong\u003e：Redis 是一个开源的高性能缓存和键值存储系统，支持多种数据结构，包括字符串、哈希、列表、集合和有序集合等。Redis 通过将数据存储在内存中来提高性能，同时支持数据持久化和集群模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMemcached\u003c/strong\u003e：Memcached 是一个开源的高性能分布式内存对象缓存系统，可以缓存任何可序列化的数据，如数据库查询结果、API 响应等。Memcached 可以通过多个节点组成的集群来提高可扩展性和可靠性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHazelcast\u003c/strong\u003e：Hazelcast 是一个开源的分布式内存数据网格系统，支持缓存、分布式数据结构和分布式计算等功能。Hazelcast 可以通过多个节点组成的集群来提高可扩展性和可靠性。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCouchbase\u003c/strong\u003e：Couchbase 是一个开源的分布式 NoSQL 数据库和缓存系统，可以缓存任何类型的数据，包括 JSON 文档、键值对和二进制数据等。Couchbase 支持多个节点组成的集群和数据持久化等功能。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在搭建高性能缓存中间件时，需要考虑以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e硬件配置\u003c/strong\u003e：缓存中间件需要占用大量内存，因此需要配置足够的内存和处理器资源。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e部署架构\u003c/strong\u003e：需要考虑缓存中间件的部署架构，如单节点、主从复制、集群等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据持久化\u003c/strong\u003e：需要考虑数据持久化的方式，如内存快照、AOF 日志、RDB 文件等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全性\u003c/strong\u003e：需要考虑缓存中间件的安全性，如访问控制、数据加密等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控和管理\u003c/strong\u003e：需要考虑缓存中间件的监控和管理，如性能监控、故障诊断等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e总之，选择和搭建高性能缓存中间件需要综合考虑多个因素，根据具体需求和场景进行选择和配置。\u003c/p\u003e\n\u003cp\u003e建议是高可用的redis cluster\u003c/p\u003e\n\u003cp\u003e要特别注意的是，redis关系到系统的高可用，很容易出生产事故。\u003c/p\u003e\n\u003cp\u003e如果redis出现big key，在高并发场景下，很容易出现系统瘫痪，严重影响系统的可用性，导致系统瘫痪。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的消息中间件\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e消息中间件在后台系统中是必不可少的一个组件，一般我们会在以下场景中使用消息中间件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e异步处理\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e异步处理是使用消息中间件的一个主要原因，在工作中最常见的异步场景有用户注册成功后需要发送注册成功邮件、缓存过期时先返回老的数据，然后异步更新缓存、异步写日志等等；通过异步处理，可以减少主流程的等待响应时间，让非主流程或者非重要业务通过消息中间件做集中的异步处理。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e系统解耦\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e比如在电商系统中，当用户成功支付完成订单后，需要将支付结果给通知ERP系统、发票系统、WMS、推荐系统、搜索系统、风控系统等进行业务处理；这些业务处理不需要实时处理、不需要强一致，只需要最终一致性即可，因此可以通过消息中间件进行系统解耦。通过这种系统解耦还可以应对未来不明确的系统需求。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e削峰填谷\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当系统遇到大流量时，监控图上会看到一个一个的山峰样的流量图，通过使用消息中间件将大流量的请求放入队列，通过消费者程序将队列中的处理请求慢慢消化，达到消峰填谷的效果。最典型的场景是秒杀系统，在电商的秒杀系统中下单服务往往会是系统的瓶颈，因为下单需要对库存等做数据库操作，需要保证强一致性，此时使用消息中间件进行下单排队和流控，让下单服务慢慢把队列中的单处理完，保护下单服务，以达到削峰填谷的作用。\u003c/p\u003e\n\u003cp\u003e业界消息中间件是一个非常通用的东西，大家在做选型时有使用开源的，也有自己造轮子的，甚至有直接用 MySQL 或 Redis 做队列的，关键看是否满足你的需求.\u003c/p\u003e\n\u003cp\u003e选择合适的消息中间件需要考虑多个因素，包括但不限于：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e需要处理的消息数量和频率\u003c/li\u003e\n\u003cli\u003e消息的大小和格式\u003c/li\u003e\n\u003cli\u003e可用性和容错性要求\u003c/li\u003e\n\u003cli\u003e数据安全性和加密需求\u003c/li\u003e\n\u003cli\u003e扩展性和灵活性要求\u003c/li\u003e\n\u003cli\u003e开发语言和技术栈的兼容性 常见的消息中间件包括RocketMQ、Kafka、 RabbitMQ、Kafka、ActiveMQ、Redis、NATS 等，每种中间件都有其特点和适用场景。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果需要处理大量的消息并且需要高吞吐量和低延迟，可以考虑使用 Kafka。如果需要实时处理消息并且需要高可用性和容错性，可以考虑使用 RabbitMQ。如果需要处理轻量级的消息，并且需要高性能和低延迟，可以考虑使用 Redis。\u003c/p\u003e\n\u003cp\u003e在选择消息中间件时，需要根据具体的业务需求和技术栈进行综合考虑，选择最合适的中间件。\u003c/p\u003e\n\u003cp\u003e目前建议 kafka + RocketMQ\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的关系数据库\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关系数据库分为两种，一种是传统关系数据，如 Oracle，MySQL，Maria，DB2，PostgreSQL 等等，另一种是 NewSQL，即至少要满足以下五点的新型关系数据库：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e完整地支持 SQL，支持 JOIN / GROUP BY /子查询等复杂 SQL 查询。\u003c/li\u003e\n\u003cli\u003e支持传统数据标配的 ACID 事务，支持强隔离级别。\u003c/li\u003e\n\u003cli\u003e具有弹性伸缩的能力，扩容缩容对于业务层完全透明。\u003c/li\u003e\n\u003cli\u003e真正的高可用，异地多活、故障恢复的过程不需要人为的接入，系统能够自动地容灾和进行强一致的数据恢复。\u003c/li\u003e\n\u003cli\u003e具备一定的大数据分析能力。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e传统关系数据库用得最多的是 MySQL，成熟，稳定，一些基本的需求都能满足，在一定数据量级之前基本单机传统数据库都可以搞定，而且现在较多的开源系统都是基于 MySQL，开箱即用，再加上主从同步和前端缓存，百万 pv 的应用都可以搞定了。\u003c/p\u003e\n\u003cp\u003e不过 CentOS 7 已经放弃了 MySQL，而改使用 MariaDB。MariaDB 数据库管理系统是 MySQ L的一个分支，主要由开源社区在维护，采用 GPL 授权许可。开发这个分支的原因之一是：甲骨文公司收购了 MySQL 后，有将 MySQL 闭源的潜在风险，因此社区采用分支的方式来避开这个风险。\u003c/p\u003e\n\u003cp\u003e在 Google 发布了 F1: A Distributed SQL Database That Scales 和 Spanner: Google’s Globally-Distributed Databasa 之后，业界开始流行起 NewSQL。于是有了 CockroachDB，以及PingCAP的 TiDB。\u003c/p\u003e\n\u003cp\u003e国内已经有比较多的公司使用 TiDB，之前在创业公司时在大数据分析时已经开始应用 TiDB，当时应用的主要原因是 MySQL 要使用分库分表，逻辑开发比较复杂，扩展性不够。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e选择和搭建高性能的NoSQL\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNoSQL 顾名思义就是 Not-Only SQL，也有人说是 No – SQL，个人偏向于 Not-Only SQL，它并不是用来替代关系库，而是作为关系型数据库的补充而存在。\u003c/p\u003e\n\u003cp\u003e常见 NoSQL 有4个类型：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e键值\u003c/strong\u003e，适用于内容缓存，适合混合工作负载并发高扩展要求大的数据集，其优点是简单，查询速度快，缺点是缺少结构化数据，常见的有 Redis，Memcache，BerkeleyDB 和 Voldemort 等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e列式\u003c/strong\u003e，以列簇式存储，将同一列数据存在一起，常见于分布式的文件系统，其中以 Hbase，Cassandra 为代表。Cassandra 多用于写多读少的场景，国内用得比较多的有 360，大概 1500 台机器的集群，国外大规模使用的公司比较多，如 eBay，Instagram，Apple 和沃尔玛等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e文档\u003c/strong\u003e，数据存储方案非常适用承载大量不相关且结构差别很大的复杂信息。性能介于 kv 和关系数据库之间，它的灵感来于 lotus notes，常见的有 MongoDB，CouchDB 等等；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e图形\u003c/strong\u003e，图形数据库擅长处理任何涉及关系的状况。社交网络，推荐系统等。专注于构建关系图谱，需要对整个图做计算才能得出结果，不容易做分布式的集群方案，常见的有 Neo4J，InfoGrid 等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e除了以上4种类型，还有一些特种的数据库，如对象数据库，XML 数据库，这些都有针对性对某些存储类型做了优化的数据库。\u003c/p\u003e\n\u003cp\u003e在实际应用场景中，何时使用关系数据库，何时使用 NoSQL，使用哪种类型的数据库，这是我们在做架构选型时一个非常重要的考量，甚至会影响整个架构的方案。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCICD发布系统/部署系统的架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e软件生产的层面看，代码到最终服务的典型流程如图2 所示：\u003c/p\u003e\n\u003cp\u003e图2 流程图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics5.baidu.com/feed/79f0f736afc379317be5da173c16ff4942a91159.jpeg@f_auto?token=4bb2c4d1bb9adef5c1a6d5ad85f59fb4\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e从上图中可以看出，从开发人员写下代码到服务最终用户是一个漫长过程，整体可以分成三个阶段：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e从代码（Code）到制品库（Artifact）\u003c/strong\u003e：这个阶段主要对开发人员的代码做持续构建，并把构建产生的制品集中管理，是为部署系统准备输入内容的阶段。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从制品到可运行服务\u003c/strong\u003e：这个阶段主要完成制品部署到指定环境，是部署系统的最基本工作内容。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e从开发环境到最终生产环境\u003c/strong\u003e：这个阶段主要完成一次变更在不同环境的迁移，是部署系统上线最终服务的核心能力。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e发布系统集成了制品管理，发布流程，权限控制，线上环境版本变更，灰度发布，线上服务回滚等几方面的内容，是开发人员工作结晶最终呈现的重要通道。\u003c/p\u003e\n\u003cp\u003eCI/CD 发布系统/部署系统的架构通常包括以下组件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e源代码管理系统\u003c/strong\u003e：例如 Git、SVN 等，用于管理代码库。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e持续集成工具\u003c/strong\u003e：例如 Jenkins、GitLab CI、Travis CI 等，用于自动化构建、测试和打包应用程序。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e制品仓库\u003c/strong\u003e：例如 Docker Hub、Harbor、Aliyun Container Registry 等，用于存储应用程序的镜像。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e部署工具\u003c/strong\u003e：例如 Kubernetes、Docker Swarm、Mesos 等，用于自动化部署应用程序。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些组件可以根据实际需求进行选择和组合，形成一个完整的 CI/CD 发布系统/部署系统。\u003c/p\u003e\n\u003cp\u003e其中，持续集成工具和部署工具是核心组件，它们负责自动化构建、测试、打包和部署应用程序，从而实现快速、可靠、可重复的软件发布流程。\u003c/p\u003e\n\u003cp\u003e项目初期可以集成 Jenkins + Gitlab + Harbor，以上方案基本包括制品管理，发布流程，权限控制，线上环境版本变更，灰度发布（需要自己实现），线上服务回滚等功能。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e代码管理工具选型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e代码是项目的命脉之一，代码管理很重要，常见的考量点包括两块：\u003c/p\u003e\n\u003cp\u003e安全和权限管理，将代码放到内网并且对于关系公司命脉的核心代码做严格的代码控制和机器的物理隔离；代码管理工具，Git 作为代码管理的不二之选，你值得拥有。\u003c/p\u003e\n\u003cp\u003eGitLab 是当今最火的开源 Git 托管服务端，没有之一，虽然有企业版，但是其社区版基本能满足我们大部分需求，结合 Gerrit 做 Code review，基本就完美了。\u003c/p\u003e\n\u003cp\u003e当然 GitLab 也有代码对比，但没 Gerrit 直观。\u003c/p\u003e\n\u003cp\u003eGerrit 比 GitLab 提供了更好的代码检查界面与主线管理体验，更适合在对代码质量有高要求的文化下使用。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e持续集成工具选型\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e持续集成简称 CI（continuous integration），是一种软件开发实践，即团队开发成员经常集成他们的工作，每天可能会发生多次集成。\u003c/p\u003e\n\u003cp\u003e每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。\u003c/p\u003e\n\u003cp\u003e持续集成为研发流程提供了代码分支管理/比对、编译、检查、发布物输出等基础工作，为测试的覆盖率版本编译、生成等提供统一支持。\u003c/p\u003e\n\u003cp\u003e业界免费的持续集成工具中系统我们有如下一些选择：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eJenkins\u003c/strong\u003e：Java 写的有强大的插件机制，MIT 协议开源 （免费，定制化程度高，它可以在多台机器上进行分布式地构建和负载测试）。Jenkins 可以算是无所不能，基本没有 Jenkins 做不了的，无论从小型团队到大型团队 Jenkins 都可以搞定。不过如果要大规模使用，还是需要有人力来学习和维护。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTeamCity\u003c/strong\u003e：TeamCity 与 Jenkins 相比使用更加友好，也是一个高度可定制化的平台。但是用的人多了，TeamCity就要收费了。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStrider\u003c/strong\u003e：Strider 是一个开源的持续集成和部署平台，使用 Node.js 实现，存储使用的是 MongoDB，BSD 许可证，概念上类似 Travis 和Jenkins。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGitLab CI\u003c/strong\u003e：从GitLab 8.0开始，GitLab CI 就已经集成在 GitLab，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。并且 GitLab 与 Docker 有着非常好的相互协作的能力。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTravis\u003c/strong\u003e：Travis 和 GitHub 强关联；闭源代码使用 SaaS 还需考虑安全问题；不可定制；开源项目免费，其它收费。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGo\u003c/strong\u003e：Go 是 ThoughtWorks 公司最新的 Cruise Control 的化身。除了 ThoughtWorks 提供的商业支持，Go 是免费的。它适用于 Windows，Mac 和各种 Linux 发行版。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e自动化测试平台的架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e接下来，就是自动化测试平台的搭建。\u003c/p\u003e\n\u003cp\u003e搭建自动化测试平台需要考虑以下几个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e选择合适的测试框架和工具\u003c/strong\u003e：可以选择一些流行的测试框架和工具，如Selenium、Appium、JMeter等，根据需要选择适合自己的工具。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e搭建测试环境\u003c/strong\u003e：需要搭建测试环境，包括测试服务器、测试数据库、测试数据等。可以使用虚拟机或者容器来搭建测试环境，以便进行测试。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e编写测试用例\u003c/strong\u003e：需要编写测试用例，测试用例应该覆盖系统的各个功能点，以便发现潜在的问题。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e集成测试工具和测试用例\u003c/strong\u003e：将测试工具和测试用例集成到自动化测试平台中，以便进行自动化测试。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e运行测试用例\u003c/strong\u003e：编写好测试用例后，需要运行测试用例，收集测试结果，并生成测试报告。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e定期维护和更新\u003c/strong\u003e：自动化测试平台需要定期维护和更新，以保证测试环境的稳定性和测试用例的有效性。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以上是搭建自动化测试平台的一般步骤，具体实现方式还需要根据实际情况进行调整。\u003c/p\u003e\n\u003cp\u003e可以结合 SpringBoot + TestNG 测试框架，搭建自己的 自动化测试平台\u003c/p\u003e\n\u003cp\u003e提示，不用自己从0到1 去搭建自动化测试平台，可以基于开源的自动化测试平台进行改造。\u003c/p\u003e\n\u003cp\u003e下面的两个测试平台，就是非常好的改造项目：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e接口自动化测试框架（java httpClient + testNg）\u003c/li\u003e\n\u003cli\u003eChenSen5/api_autotest (\u003ca href=\"https://github.com/ChenSen5/api%5C_autotest\"\u003ehttps://github.com/ChenSen5/api\\_autotest\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003e基于SpringBoot的高效模板化自动化测试框架\u003c/li\u003e\n\u003cli\u003ejinganglong123/jg-api-autotest (\u003ca href=\"https://github.com/jinganglong123/jg-api-autotest\"\u003ehttps://github.com/jinganglong123/jg-api-autotest\u003c/a\u003e)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e360度全方位监控和维护的架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e360度全方位监控和维护的架构包括\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e日志系统\u003c/li\u003e\n\u003cli\u003e监控系统\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e日志系统\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e日志系统一般包括打日志，采集，中转，收集，存储，分析，呈现，搜索还有分发等。\u003c/p\u003e\n\u003cp\u003e一些特殊的如\u003cstrong\u003e染色\u003c/strong\u003e，全链条跟踪或者监控都可能需要依赖于日志系统实现。\u003c/p\u003e\n\u003cp\u003e日志系统的建设不仅仅是工具的建设，还有规范和组件的建设，最好一些基本的日志在框架和组件层面加就行了，比如全链接跟踪之类的。\u003c/p\u003e\n\u003cp\u003e对于常规日志系统ELK能满足大部分的需求，ELK 包括如下组件：\u003c/p\u003e\n\u003cp\u003eElasticSearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，RESTful 风格接口，多数据源，自动搜索负载等。\u003c/p\u003e\n\u003cp\u003eLogstash 是一个完全开源的工具，它可以对你的日志进行收集、分析，并将其存储供以后使用。Kibana 是一个开源和免费的工具，它可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助汇总、分析和搜索重要数据日志。\u003c/p\u003e\n\u003cp\u003eFilebeat 已经完全替代了 Logstash-Forwarder 成为新一代的日志采集器，同时鉴于它轻量、安全等特点，越来越多人开始使用它。\u003c/p\u003e\n\u003cp\u003e因为免费的 ELK 没有任何安全机制，所以这里使用了 Nginx 作反向代理，避免用户直接访问 Kibana 服务器。\u003c/p\u003e\n\u003cp\u003e加上配置 Nginx 实现简单的用户认证，一定程度上提高安全性。\u003c/p\u003e\n\u003cp\u003e另外，Nginx 本身具有负载均衡的作用，能够提高系统访问性能。\u003c/p\u003e\n\u003cp\u003eELK 架构如图3 所示：\u003c/p\u003e\n\u003cp\u003e图3 ELK 流程图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics7.baidu.com/feed/32fa828ba61ea8d38fa0602340d87842241f5871.jpeg@f_auto?token=854c8ec61da88338fc959753af0805ad\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e对于有实时计算的需求，可以使用 Flume + Kafka + Storm + MySQL 方案，一 般架构如图4 所示：\u003c/p\u003e\n\u003cp\u003e图4 实时分析系统架构图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics3.baidu.com/feed/242dd42a2834349b37545a591e385dc234d3befe.jpeg@f_auto?token=1c04504154566417238607715590eae6\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e其中：\u003c/p\u003e\n\u003cp\u003eFlume 是一个分布式、可靠、和高可用的海量日志采集、聚合和传输的日志收集系统，支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume 提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。Kafka 是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写。其本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，它以可水平扩展和高吞吐率而被广泛使用。\u003c/p\u003e\n\u003cp\u003eKafka 追求的是高吞吐量、高负载，Flume 追求的是数据的多样性，二者结合起来简直完美。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e监控系统\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e监控系统只包含与后台相关的，这里主要是两块，一个是操作系统层的监控，比如机器负载，IO，网络流量，CPU，内存等操作系统指标的监控。\u003c/p\u003e\n\u003cp\u003e另一个是服务质量和业务质量的监控，比如服务的可用性，成功率，失败率，容量，QPS 等等。\u003c/p\u003e\n\u003cp\u003e常见业务的监控系统先有操作系统层面的监控（这部分较成熟），然后扩展出其它监控，如 Zabbix，小米的 Open-Falcon，也有一出来就是两者都支持的，如 Prometheus。\u003c/p\u003e\n\u003cp\u003e如果对业务监控要求比较高一些，在创业选型中建议可以优先考虑 Prometheus。\u003c/p\u003e\n\u003cp\u003e这里有一个有趣的分布，如图5 所示。\u003c/p\u003e\n\u003cp\u003e图5 监控系统分布\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics5.baidu.com/feed/91529822720e0cf37dff0cacdd94ba13bf09aab8.jpeg@f_auto?token=78b21d8d26b6390c49bdc8d79949e5c1\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e亚洲区域使用 Zabbix 较多，而美洲和欧洲，以及澳大利亚使用 Prometheus 居多，换句话说，英文国家地区（发达国家？）使用 Prometheus 较多。\u003c/p\u003e\n\u003cp\u003ePrometheus 是由 SoundCloud 开发的开源监控报警系统和时序列数据库（TSDB）。\u003c/p\u003e\n\u003cp\u003ePrometheus 使用 Go 语言开发，是 Google BorgMon 监控系统的开源版本。\u003c/p\u003e\n\u003cp\u003e相对于其它监控系统使用的 push 数据的方式，Prometheus 使用的是 pull 的方式，其架构如图6 所示：\u003c/p\u003e\n\u003cp\u003e图6 Prometheus 架构图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://pics5.baidu.com/feed/7a899e510fb30f24b5dc0bc31e47994faf4b038f.png@f_auto?token=17e4b1472f5b8bf00dff3b872cac7b60\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示，Prometheus 包含的主要组件如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePrometheus Server\u003c/strong\u003e：主要负责数据采集和存储，提供 PromQL 查询语言的支持。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eServer\u003c/strong\u003e：通过配置文件、文本文件、ZooKeeper、Consul、DNS SRV Lookup 等方式指定抓取目标。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e根据这些目标会，Server 定时去抓取 metrics 数据，每个抓取目标需要暴露一个 http 服务的接口给它定时抓取。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e客户端 SDK\u003c/strong\u003e：官方提供的客户端类库有 Go、Java、Scala、Python、Ruby，其他还有很多第三方开发的类库，支持 Nodejs、PHP、Erlang 等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePush Gateway\u003c/strong\u003e：支持临时性 Job 主动推送指标的中间网关。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExporter Exporter\u003c/strong\u003e：是 Prometheus 的一类数据采集组件的总称。它负责从目标处搜集数据，并将其转化为 Prometheus 支持的格式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e与传统的数据采集组件不同的是，它并不向中央服务器发送数据，而是等待中央服务器主动前来抓取。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ePrometheus\u003c/strong\u003e：提供多种类型的 Exporter 用于采集各种不同服务的运行状态。目前支持的有数据库、硬件、消息中间件、存储系统、HTTP 服务器、JMX 等。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAlertmanager\u003c/strong\u003e：是一个单独的服务，可以支持 Prometheus 的查询语句，提供十分灵活的报警方式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrometheus HTTP API\u003c/strong\u003e 的查询方式，自定义所需要的输出。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGrafana\u003c/strong\u003e：是一套开源的分析监视平台，支持 Graphite，InfluxDB，OpenTSDB，Prometheus，Elasticsearch，CloudWatch 等数据源，其 UI 非常漂亮且高度定制化。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e创业公司选择 Prometheus + Grafana 的方案，再加上统一的服务框架（如 gRPC），可以满足大部分中小团队的监控需求。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e生产环境高并发高吞吐负载均衡部署架构\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e高并发高吞吐负载均衡链路架构，包括：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDNS的选型和使用设计\u003c/li\u003e\n\u003cli\u003eLB（负载均衡）的选型和使用设计\u003c/li\u003e\n\u003cli\u003eCDN的选型和使用设计\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003eDNS的选型和使用设计\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eDNS 是一个很通用的服务，创业公司基本上选择一个合适的云厂商就行了，国内主要是两家：\u003c/p\u003e\n\u003cp\u003e阿里万网：阿里 2014 年收购了万网，整合了其域名服务，最终形成了现在的阿里万网，其中就包含 DNS 这块的服务；\u003c/p\u003e\n\u003cp\u003e腾讯 DNSPod：腾讯 2012 年以 4000 万收购 DNSPod 100% 股份，主要提供域名解析和一些防护功能；\u003c/p\u003e\n\u003cp\u003e如果你的业务是在国内，主要就是这两家，选 一个就好，像今日头条这样的企业用的也是 DNSPod 的服务，除非一些特殊的原因才需要自建，比如一些 CDN 厂商，或者对区域有特殊限制的。\u003c/p\u003e\n\u003cp\u003e要实惠一点用阿里最便宜的基础版就好了，要成功率高一些，还是用 DNSPod 的贵的那种。\u003c/p\u003e\n\u003cp\u003e在国外还是选择亚马逊吧，阿里的 DNS 服务只有在日本和美国有节点，东南亚最近才开始部点， DNSPod 也只有美国和日本，像一些出海的企业，其选择的云服务基本都是亚马逊。\u003c/p\u003e\n\u003cp\u003e如果是线上产品，DNS 强烈建议用付费版，阿里的那几十块钱的付费版基本可以满足需求。如果还需要一些按省份或按区域调试的逻辑，则需要加钱，一年也就几百块，省钱省力。\u003c/p\u003e\n\u003cp\u003e如果是国外，优先选择亚马逊，如果需要国内外互通并且有自己的 APP 的话，建议还是自己实现一些容灾逻辑或者智能调度，因为没有一个现成的 DNS 服务能同时较好的满足国内外场景，或者用多个域名，不同的域名走不同的 DNS 。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLB（负载均衡）的选型和使用设计\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eLB（负载均衡）是一个通用服务，一般云厂商的 LB 服务基本都会如下功能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e支持四层协议请求（包括 TCP、UDP 协议）；\u003c/li\u003e\n\u003cli\u003e支持七层协议请求（包括 HTTP、HTTPS 协议）；\u003c/li\u003e\n\u003cli\u003e集中化的证书管理系统支持 HTTPS 协议；\u003c/li\u003e\n\u003cli\u003e健康检查；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e如果你线上的服务机器都是用的云服务，并且是在同一个云服务商的话，可以直接使用云服务商提供的 LB 服务，如阿里云的 SLB，腾讯云的 CLB，亚马逊的 ELB 等等。如果是自建机房基本都是 LVS + Nginx。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCDN的选型和使用设计\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eCDN 现在已经是一个很红很红的市场，基本上只能挣一些辛苦钱，都是贴着成本在卖。国内以网宿为龙头，他们家占据整个国内市场份额的 40% 以上，后面就是腾讯，阿里。网宿有很大一部分是因为直播的兴起而崛起。\u003c/p\u003e\n\u003cp\u003e国外，Amazon 和 Akamai合起来占比大概在 50%，曾经的国际市场老大 Akamai 拥有全球超一半的份额，在 Amazon CDN入局后，份额跌去了将近 20%，众多中小企业都转向后者，Akamai 也是无能为力。\u003c/p\u003e\n\u003cp\u003e国内出海的 CDN 厂商，更多的是为国内的出海企业服务，三家大一点的 CDN 服务商里面也就网宿的节点多一些，但是也多不了多少。阿里和腾讯还处于前期阶段，仅少部分国家有节点。\u003c/p\u003e\n\u003ch4\u003e最后\u003c/h4\u003e\n\u003cp\u003e好的架构不是一蹴而就的，而是演变出来的。对于一个问题，架构师需要做出正确的判断，而这个“正确”与否，在不同的场景下，也是不同的，也就是说答案是开放的。那么提高自己的技术能力、认知能力，就相当重要了。这就要求我们不断地学习，保持对技术的敏锐，才能做出正确的选择。\u003c/p\u003e\n\u003cp\u003e路漫漫其修远兮，架构求索无止尽也。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"17:T3726,"])</script><script>self.__next_f.push([1,"\u003cp\u003e记得很久之前，去面试过\u003cstrong\u003e字节跳动\u003c/strong\u003e。被三面的面试官问了一道场景设计题目：\u003cstrong\u003e如何设计一个高并发系统\u003c/strong\u003e。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/system/image_3_1.png\" alt=\"image_3_1.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e如何理解高并发系统 \u003ca href=\"#item-0-1\" id=\"item-0-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e所谓设计\u003cstrong\u003e高并发\u003c/strong\u003e系统，就是设计一个系统，保证它\u003cstrong\u003e整体可用\u003c/strong\u003e的同时，能够\u003cstrong\u003e处理很高的并发用户请求\u003c/strong\u003e，能够承受\u003cstrong\u003e很大的流量冲击\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e我们要设计高并发的系统，那就需要处理好一些常见的系统瓶颈问题，如\u003cstrong\u003e内存不足、磁盘空间不足，连接数不够，网络宽带不够\u003c/strong\u003e等等，以应对突发的流量洪峰。\u003c/p\u003e\n\u003ch3\u003e1. 分而治之，横向扩展 \u003ca href=\"#item-0-2\" id=\"item-0-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e如果你\u003cstrong\u003e只部署一个应用，只部署一台服务器\u003c/strong\u003e，那抗住的流量请求是非常有限的。并且，单体的应用，有单点的风险，如果它挂了，那服务就不可用了。\u003c/p\u003e\n\u003cp\u003e因此，设计一个高并发系统，我们可以\u003cstrong\u003e分而治之，横向扩展\u003c/strong\u003e。也就是说，采用分布式部署的方式，部署多台服务器，把流量分流开，让每个服务器都承担一部分的并发和流量，提升\u003cstrong\u003e整体系统的并发能力\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e2. 微服务拆分（系统拆分） \u003ca href=\"#item-0-3\" id=\"item-0-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e要提高系统的吞吐，提高系统的处理并发请求的能力。除了采用\u003cstrong\u003e分布式部署的方式\u003c/strong\u003e外，还可以做\u003cstrong\u003e微服务拆分\u003c/strong\u003e，这样就可以达到分摊请求流量的目的，提高了并发能力。\u003c/p\u003e\n\u003cp\u003e所谓的\u003cstrong\u003e微服务拆分\u003c/strong\u003e，其实就是把一个单体的应用，按功能单一性，拆分为多个服务模块。\u003cstrong\u003e比如一个电商系统，拆分为用户系统、订单系统、商品系统等等\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/system/image_3_2.png\" alt=\"image_3_2.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e3. 分库分表 \u003ca href=\"#item-0-4\" id=\"item-0-4\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e当业务量暴增的话，MySQL单机\u003cstrong\u003e磁盘容量会撑爆\u003c/strong\u003e。并且，我们知道数据库连接数是有限的。\u003cstrong\u003e在高并发的场景下\u003c/strong\u003e，大量请求访问数据库，\u003ccode\u003eMySQL\u003c/code\u003e单机是扛不住的！高并发场景下，会出现\u003ccode\u003etoo many connections\u003c/code\u003e报错。\u003c/p\u003e\n\u003cp\u003e所以高并发的系统，\u003cstrong\u003e需要考虑拆分为多个数据库，来抗住高并发的毒打\u003c/strong\u003e。而假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做\u003cstrong\u003e分表\u003c/strong\u003e了。一般千万级别数据量，就需要\u003cstrong\u003e分表\u003c/strong\u003e，每个表的数据量少一点，提升SQL查询性能。\u003c/p\u003e\n\u003cp\u003e当面试官问要求你设计一个高并发系统的时候，一般都要说到\u003cstrong\u003e分库分表\u003c/strong\u003e这个点。\u003c/p\u003e\n\u003ch3\u003e4. 池化技术 \u003ca href=\"#item-0-5\" id=\"item-0-5\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e在高并发的场景下，\u003cstrong\u003e数据库连接数\u003c/strong\u003e可能成为瓶颈，因为连接数是有限的。\u003c/p\u003e\n\u003cp\u003e我们的请求调用数据库时，都会先获取数据库的连接，然后依靠这个连接来查询数据，搞完收工，最后关闭连接，释放资源。如果我们不用数据库连接池的话，每次执行\u003ccode\u003eSQL\u003c/code\u003e，都要创建连接和销毁连接，这就会导致每个查询请求都变得更慢了，相应的，系统处理用户请求的能力就降低了。\u003c/p\u003e\n\u003cp\u003e因此，需要使用池化技术，即\u003cstrong\u003e数据库连接池、HTTP 连接池、Redis 连接池\u003c/strong\u003e等等。使用数据库连接池，可以避免每次查询都新建连接，减少不必要的资源开销，通过复用连接池，\u003cstrong\u003e提高系统处理高并发请求的能力\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e同理，我们使用线程池，也能\u003cstrong\u003e让任务并行处理，更高效地完成任务\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3\u003e5. 主从分离 \u003ca href=\"#item-0-6\" id=\"item-0-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e通常来说，一台单机的MySQL服务器，可以支持\u003ccode\u003e500\u003c/code\u003e左右的\u003ccode\u003eTPS\u003c/code\u003e和\u003ccode\u003e10000\u003c/code\u003e左右的\u003ccode\u003eQPS\u003c/code\u003e，即单机支撑的\u003cstrong\u003e请求访问是有限\u003c/strong\u003e的。因此你做了分布式部署，部署了多台机器，部署了主数据库、从数据库。\u003c/p\u003e\n\u003cp\u003e但是，如果双十一搞活动，流量肯定会猛增的。如果所有的查询请求，都走主库的话，主库肯定扛不住，因为查询请求量是非常非常大的。因此一般都要求做\u003cstrong\u003e主从分离\u003c/strong\u003e，然后实时性要求不高的读请求，都去读从库，\u003cstrong\u003e写的请求或者实时性要求高的请求，才走主库\u003c/strong\u003e。这样就很好保护了主库，也提高了系统的吞吐。\u003c/p\u003e\n\u003cp\u003e当然，如果回答了主从分离，面试官可能扩展开问你\u003cstrong\u003e主从复制原理，问你主从延迟问题\u003c/strong\u003e等等，这块大家需要\u003cstrong\u003e全方位复习好\u003c/strong\u003e哈。\u003c/p\u003e\n\u003ch3\u003e6. 使用缓存 \u003ca href=\"#item-0-7\" id=\"item-0-7\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e无论是操作系统，浏览器，还是一些复杂的中间件，你都可以看到缓存的影子。我们使用缓存，主要是提升系统接口的性能，这样高并发场景，你的系统就可以支持更多的用户同时访问。\u003c/p\u003e\n\u003cp\u003e常用的缓存包括：\u003ccode\u003eRedis\u003c/code\u003e缓存，\u003ccode\u003eJVM\u003c/code\u003e本地缓存，\u003ccode\u003ememcached\u003c/code\u003e等等。就拿\u003ccode\u003eRedis\u003c/code\u003e来说，它单机就能轻轻松松应对几万的并发，你读场景的业务，可以用缓存来抗高并发。\u003c/p\u003e\n\u003cp\u003e缓存虽然用得爽，但是要\u003cstrong\u003e注意缓存使用的一些问题\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e缓存与数据库的一致性问题\u003c/li\u003e\n\u003cli\u003e缓存雪崩\u003c/li\u003e\n\u003cli\u003e缓存穿透\u003c/li\u003e\n\u003cli\u003e缓存击穿\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e7. CDN，加速静态资源访问 \u003ca href=\"#item-0-8\" id=\"item-0-8\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e商品图片，\u003ccode\u003eicon\u003c/code\u003e等等静态资源，可以对页面做\u003cstrong\u003e静态化处理，减少访问服务端的请求\u003c/strong\u003e。如果用户分布在全国各地，有的在上海，有的在深圳，地域相差很远，网速也各不相同。为了让用户最快访问到页面，可以使用\u003ccode\u003eCDN\u003c/code\u003e。\u003ccode\u003eCDN\u003c/code\u003e可以让用户就近获取所需内容。\u003c/p\u003e\n\u003cp\u003e什么是CDN？\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eContent Delivery Network/Content Distribution Network,翻译过来就是内容分发网络，它表示将静态资源分发到位于多个地理位置机房的服务器，可以做到数据就近访问，加速了静态资源的访问速度，因此让系统更好处理正常别的动态请求。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e8. 消息队列，削锋 \u003ca href=\"#item-0-9\" id=\"item-0-9\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e我们搞一些双十一、双十二等运营活动时，需要\u003cstrong\u003e避免流量暴涨，打垮应用系统的风险\u003c/strong\u003e。因此一般会引入消息队列，来应对\u003cstrong\u003e高并发的场景\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/system/image_3_3.png\" alt=\"image_3_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e假设你的应用系统每秒最多可以处理\u003ccode\u003e2k\u003c/code\u003e个请求，每秒却有\u003ccode\u003e5k\u003c/code\u003e的请求过来，可以引入消息队列，应用系统每秒从消息队列拉\u003ccode\u003e2k\u003c/code\u003e请求处理得了。\u003c/p\u003e\n\u003cp\u003e有些伙伴担心这样可能会出现\u003cstrong\u003e消息积压\u003c/strong\u003e的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先，搞一些运营活动，不会每时每刻都那么多请求过来你的系统（\u003cstrong\u003e除非有人恶意攻击\u003c/strong\u003e），高峰期过去后，积压的请求可以慢慢处理；\u003c/li\u003e\n\u003cli\u003e其次，如果消息队列长度超过最大数量，可以直接抛弃用户请求或跳转到错误页面；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e9. ElasticSearch \u003ca href=\"#item-0-10\" id=\"item-0-10\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eElasticsearch\u003c/code\u003e，大家都使用得比较多了吧，\u003cstrong\u003e一般搜索功能都会用到它\u003c/strong\u003e。它是一个分布式、高扩展、高实时的搜索与数据分析引擎，简称为\u003ccode\u003eES\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e我们在聊高并发，为啥聊到\u003ccode\u003eES\u003c/code\u003e呢？因为\u003ccode\u003eES\u003c/code\u003e可以扩容方便，天然支撑高并发。\u003cstrong\u003e当数据量大的时候，不用动不动就加机器扩容，分库等等\u003c/strong\u003e，可以考虑用\u003ccode\u003eES\u003c/code\u003e来支持简单的查询搜索、统计类的操作。\u003c/p\u003e\n\u003ch3\u003e10. 降级熔断 \u003ca href=\"#item-0-11\" id=\"item-0-11\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e熔断降级\u003c/strong\u003e是保护系统的一种手段。当前互联网系统一般都是分布式部署的。而分布式系统中偶尔会出现某个基础服务不可用，最终导致整个系统不可用的情况, 这种现象被称为\u003cstrong\u003e服务雪崩效应\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e比如分布式调用链路\u003ccode\u003eA-\u0026gt;B-\u0026gt;C....\u003c/code\u003e，下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/system/image_3_4.png\" alt=\"image_3_4.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果服务\u003ccode\u003eC\u003c/code\u003e出现问题，比如是因为慢\u003ccode\u003eSQL\u003c/code\u003e导致调用缓慢，那将导致\u003ccode\u003eB\u003c/code\u003e也会延迟，从而\u003ccode\u003eA\u003c/code\u003e也会延迟。堵住的\u003ccode\u003eA\u003c/code\u003e请求会消耗占用系统的线程、IO、CPU等资源。当请求\u003ccode\u003eA\u003c/code\u003e的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e为了应对服务雪崩, 常见的做法是\u003cstrong\u003e熔断和降级\u003c/strong\u003e。最简单是加开关控制，当下游系统出问题时，开关打开降级，不再调用下游系统。还可以选用开源组件\u003ccode\u003eHystrix\u003c/code\u003e来支持。\u003c/p\u003e\n\u003cp\u003e你要保证设计的系统能应对\u003cstrong\u003e高并发场景\u003c/strong\u003e，那肯定要考虑\u003cstrong\u003e熔断降级\u003c/strong\u003e逻辑进来。\u003c/p\u003e\n\u003ch3\u003e11. 限流 \u003ca href=\"#item-0-12\" id=\"item-0-12\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e限流也是我们应对高并发的一种方案。我们当然希望，在高并发大流量过来时，系统能全部请求都正常处理。但是有时候没办法，系统的CPU、网络带宽、内存、线程等资源都是有限的。因此，我们要考虑限流。\u003c/p\u003e\n\u003cp\u003e如果你的系统每秒扛住的请求是一千，\u003cstrong\u003e如果一秒钟来了十万请求呢\u003c/strong\u003e？换个角度就是说，高并发的时候，流量洪峰来了，超过系统的承载能力，怎么办呢？\u003c/p\u003e\n\u003cp\u003e这时候，我们可以采取限流方案。就是为了保护系统，多余的请求，直接丢弃。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e什么是限流\u003c/strong\u003e：在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。限流，也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e可以使用\u003ccode\u003eGuava\u003c/code\u003e的\u003ccode\u003eRateLimiter\u003c/code\u003e单机版限流，也可以使用\u003ccode\u003eRedis\u003c/code\u003e分布式限流，还可以使用阿里开源组件\u003ccode\u003esentinel\u003c/code\u003e限流。\u003c/p\u003e\n\u003cp\u003e面试的时候，你说到限流这块的话？面试官很大概率会问你限流的算法，因此，大家在准备面试的时候，需要复习一下这几种经典的限流算法哈\u003c/p\u003e\n\u003ch3\u003e12. 异步 \u003ca href=\"#item-0-13\" id=\"item-0-13\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e回忆一下什么是同步，什么是异步呢？以\u003cstrong\u003e方法调用\u003c/strong\u003e为例，它代表\u003cstrong\u003e调用方要阻塞等待被调用方法中的逻辑执行完成\u003c/strong\u003e。这种方式下，当被调用方法响应时间较长时，会造成调用方长久的阻塞，在高并发下会造成整体系统性能下降甚至发生雪崩。异步调用恰恰相反，调用方不需要等待方法逻辑执行完成就可以返回执行其他的逻辑，在被调用方法执行完毕后再通过回调、事件通知等方式将结果反馈给调用方。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e因此，设计一个高并发的系统，\u003cstrong\u003e需要在恰当的场景使用异步\u003c/strong\u003e。如何使用异步呢？后端可以借用消息队列实现。比如在海量秒杀请求过来时，先放到消息队列中，快速响应用户，告诉用户请求正在处理中，这样就可以释放资源来处理更多的请求。秒杀请求处理完后，通知用户秒杀抢购成功或者失败。\u003c/p\u003e\n\u003ch3\u003e13. 接口的常规优化 \u003ca href=\"#item-0-14\" id=\"item-0-14\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e设计一个高并发的系统，需要设计接口的性能足够好，这样系统在相同时间，就可以处理更多的请求。当说到这里的话，可以跟面试官说说接口优化的一些方案了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/system/image_3_5.png\" alt=\"image_3_5.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e14. 压力测试确定系统瓶颈 \u003ca href=\"#item-0-15\" id=\"item-0-15\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e设计高并发系统，离不开最重要的一环，\u003cstrong\u003e就是压力测试\u003c/strong\u003e。就是在系统上线前，需要对系统进行压力测试，测清楚你的系统支撑的最大并发是多少，确定系统的瓶颈点，让自己心里有底，最好预防措施。\u003c/p\u003e\n\u003cp\u003e压测完要分析整个调用链路，性能可能出现问题是网络层（如带宽）、Nginx层、服务层、还是数据路缓存等中间件等等。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eloadrunner\u003c/code\u003e是一款不错的压力测试工具，\u003ccode\u003ejmeter\u003c/code\u003e则是接口性能测试工具，都可以来做下压测。\u003c/p\u003e\n\u003ch3\u003e15. 应对突发流量峰值：扩容+切流量 \u003ca href=\"#item-0-16\" id=\"item-0-16\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e如果是突发的流量高峰，除了降级、限流保证系统不跨，我们可以采用这两种方案，保证系统尽可能服务用户请求：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e扩容：\u003cstrong\u003e比如增加从库、提升配置的方式\u003c/strong\u003e，提升系统/组件的流量承载能力。比如增加\u003ccode\u003eMySQL、Redis\u003c/code\u003e从库来处理查询请求。\u003c/li\u003e\n\u003cli\u003e切流量：\u003cstrong\u003e服务多机房部署\u003c/strong\u003e，如果高并发流量来了，把流量从一个机房切换到另一个机房。\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"18:T3b49,"])</script><script>self.__next_f.push([1,"\u003ch3\u003e1 传统单体系统介绍 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增，\u003c/p\u003e\n\u003cp\u003e发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。\u003c/p\u003e\n\u003cp\u003e但是物理服务器的CPU、内存、存储器、连接数等资源有限，单体系统能够承受的的QPS也是有限的，某个时段大量连接同时执行操作，会导致web服务和数据库服务在处理上遇到性能瓶颈。\u003c/p\u003e\n\u003cp\u003e为了解决这个问题，伟大的前辈们发扬了分而治之的思想，对大数据库、大表进行分割，可以参考我的《\u003ca href=\"https://www.cnblogs.com/wzh2010/p/15049878.html\"\u003e分库分表\u003c/a\u003e》，以便实施更好的控制和管理。\u003c/p\u003e\n\u003cp\u003e同时创建多个服务实例，使用多台服务机进行CPU、内存、存储的分摊，提供更好的性能。\u003c/p\u003e\n\u003ch4\u003e1.1 单体系统的问题 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、复杂性高：由于是一个单体的系统，所以整个系统的模块是耦合在一起的，模块的边界比较模糊、依赖关系错综复杂。功能的调整，容易带来不可知的影响和潜在的bug风险。\u003c/p\u003e\n\u003cp\u003e2、服务性能问题：单体系统遇到性能瓶颈问题，只能横向扩展，增加服务实例，进行负载均衡分担压力。无法纵向扩展，做模块拆分。\u003c/p\u003e\n\u003cp\u003e3、扩缩容能力受限：单体应用只能作为一个整体进行扩展，影响范围大，无法根据业务模块的需要进行单个模块的伸缩。\u003c/p\u003e\n\u003cp\u003e4、无法做故障隔离：当所有的业务功能模块都聚集在一个程序集当中，如果其中的某一个小的功能模块出现问题（如某个请求堵塞），那么都有可能会造成整个系统的崩溃。\u003c/p\u003e\n\u003cp\u003e5、发布的影响范围较大：每次发布都是整个系统进行发布，发布会导致整个系统的重启，对于大型的综合系统挑战比较大，如果将各个模块拆分，哪个部分做了修改，只发布哪个部分所在的模块即可。\u003c/p\u003e\n\u003ch4\u003e\u0026#x20;\u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003ch4\u003e1.2 单体系统的优点 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e1、系统的简易性：系统语言风格、业务结构，接口格式均具有一致性，服务都是耦合在一起的，不存在各个业务通信问题。\u003c/p\u003e\n\u003cp\u003e2、易于测试：单体应用一旦部署，所有的服务或特性就都可以使用了，简化了测试过程，无需额外测试服务间的依赖，测试均可在部署完成后开始。\u003c/p\u003e\n\u003cp\u003e3、易于部署与升级：相对于微服务架构中的每个服务独立部署，单体系统只需将单个目录下的服务程序统一部署和升级。\u003c/p\u003e\n\u003cp\u003e4、较低的维护成本：只需维护单个系统即可。运维主要包括配置、部署、监控与告警和日志收集四大方面。相对于单体系统，微服务架构中的每个服务都需要独立地配置、部署、监控和日志收集，成本呈指数级增长。\u003c/p\u003e\n\u003ch4\u003e\u0026#x20;\u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003ch4\u003e1.3 单体服务到微服务的发展过程 \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eEUREKA的注册中心逐渐被ZooKeeper和Nacos等替代了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_1.png\" alt=\"image_2_1.png\"\u003e\u003c/p\u003e\n\u003ch3\u003e2 关于微服务 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e微服务是一种架构模式，是面向服务的体系结构（SOA）软件架构模式的一种演变，它提倡将单一应用程序划分成一组松散耦合的细粒度小型服务，辅助轻量级的协议，互相协调、互相配合，为用户提供最终价值。所以，微服务（或微服务架构）是一种云原生架构方法，其中单个应用程序由许多松散耦合且可独立部署的较小组件或服务组成。这些服务通常包含如下特点：\u003c/p\u003e\n\u003ch4\u003e2.1 单一职责 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e微服务架构中的每个节点高度服务化，都是具有业务逻辑的，符合高内聚、低耦合原则以及单一职责原则的单元，包括数据库和数据模型；不同的服务通过“管道”的方式灵活组合，从而构建出庞大的系统。\u003c/p\u003e\n\u003ch4\u003e2.2 轻量级通信 \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e通过REST API模式或者RPC框架，实现服务间互相协作的轻量级通信机制。\u003c/p\u003e\n\u003ch4\u003e2.3 独立性 \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e在微服务架构中，每个服务都是独立的业务单元，与其他服务高度解耦，只需要改变当前服务本身，就可以完成独立的开发、测试、部署、运维。\u003c/p\u003e\n\u003ch4\u003e2.4 进程隔离 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e在微服务架构中，应用程序由多个服务组成，每个服务都是高度自治的独立业务实体，可以运行在独立的进程中，不同的服务能非常容易地部署到不同的主机上，实现高度自治和高度隔离。进程的隔离，还能保证服务达到动态扩缩容的能力，业务高峰期自动增加服务资源以提升并发能力，业务低谷期则可自动释放服务资源以节省开销。\u003c/p\u003e\n\u003ch4\u003e2.5 混合技术栈和混合部署方式 \u003ca href=\"#scroller-12\" id=\"scroller-12\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e团队可以为不同的服务组件使用不同的技术栈和不同的部署方式（公有云、私有云、混合云）。\u003c/p\u003e\n\u003ch4\u003e2.6 简化治理 \u003ca href=\"#scroller-13\" id=\"scroller-13\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e组件可以彼此独立地进行扩缩容和治理，从而减少了因必须缩放整个应用程序而产生的浪费和成本，因为单个功能可能面临过多的负载。\u003c/p\u003e\n\u003ch4\u003e2.7 安全可靠，可维护。 \u003ca href=\"#scroller-14\" id=\"scroller-14\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e从架构上对运维提供友好的支撑，在安全、可维护的基础上规范化发布流程，支持数据存储容灾、业务模块隔离、访问权限控制、编码安全检测等。\u003c/p\u003e\n\u003ch3\u003e3 微服务演进史 \u003ca href=\"#scroller-15\" id=\"scroller-15\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e我们前面已经了解了微服务的概念，通过百度指数可以看出，从2012年之后，微服务的发展有显著的发展趋势。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_2.png\" alt=\"image_2_2.png\"\u003e\u003c/p\u003e\n\u003cp\u003e目前业内的微服务相关开发平台和框架还是比较多的，比如较早的Spring Cloud（使用Eureke做服务注册与发现，Ribbon做服务间负载均衡，Hystrix做服务容错保护），\u003c/p\u003e\n\u003cp\u003e阿里的Dubbo，微软的.Net体系微服务框架 Service Fabric，再到后来进阶的服务网格(Service Mesh,如 Istio、Linkerd）。\u003c/p\u003e\n\u003cp\u003e那从12年开始到现在，微服务到底发展到哪个阶段了，在各个阶段的进阶过程中，又有哪些的变化。所以我们需要了解微服务技术的历史发展脉络。\u003c/p\u003e\n\u003cp\u003e下面的内容参考了 \u003ca href=\"https://philcalcado.com/\"\u003ePhil Calçado\u003c/a\u003e的文章\u003ca href=\"https://philcalcado.com/2017/08/03/pattern_service_mesh.html\"\u003e《Pattern: Service Mesh》\u003c/a\u003e，从开发者的视角，详细分析了从微服务到Service Mesh技术的演进过程，这边做了进一步的整理和总结。\u003c/p\u003e\n\u003ch4\u003e3.1 第一阶：简单服务通信模块 \u003ca href=\"#scroller-16\" id=\"scroller-16\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e这是最初的模样，开发人员最开始的时候想象的两个服务间简单的通信模式，抽象表示如下，两个服务之间直接进行通信：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_3.png\" alt=\"image_2_3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e3.2 第二阶：原始通信时代\u003c/p\u003e\n\u003cp\u003e上面的方式非常简单，但实际情况远比想象的复杂很多，通信需要底层字节码传输和电子信号的物理层来完成，在TCP协议出现之前，\u003c/p\u003e\n\u003cp\u003e服务需要自己处理网络通信所面临的丢包、错误、乱序、重试等一系列流控问题，因此服务实现中，除了业务逻辑外，还包含对网络传输问题的处理逻辑。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_4.png\" alt=\"image_2_4.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e3.3 第三阶：TCP时代 \u003ca href=\"#scroller-18\" id=\"scroller-18\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eTCP协议的出现，避免了每个服务自己实现一套相似的网络传输处理逻辑，解决网络传输中通用的流量控制问题。\u003c/p\u003e\n\u003cp\u003e这时候我们把处理网络传输的能力下沉，从服务的实现中抽离出来，成为操作系统网络层的一部分。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_5.png\" alt=\"image_2_5.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e3.4 第四阶：第一代微服务（Spring Cloud/RPC） \u003ca href=\"#scroller-19\" id=\"scroller-19\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eTCP出现之后，服务间的网络通信已经不是一个难题了，所以 GFS/BigTable/MapReduce 为代表的分布式系统得到了蓬勃的发展。\u003c/p\u003e\n\u003cp\u003e这时，分布式系统特有的通信语义又出现了，如服务注册与发现、负载均衡、熔断降级策略、认证和授权、端到端trace、日志与监控等，因此根据业务需求,完成一些通信语义的实现。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_6.png\" alt=\"image_2_6.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e3.5 第五阶：第二代微服务 \u003ca href=\"#scroller-20\" id=\"scroller-20\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e为了避免每个服务都需要自己实现一套分布式系统通信的语义功能，随着技术的发展，一些面向微服务架构的通用开发框架出现了，如Twitter的\u003ca href=\"https://finagle.github.io/\"\u003eFinagle\u003c/a\u003e、Facebook的\u003ca href=\"https://code.facebook.com/posts/1503205539947302\"\u003eProxygen\u003c/a\u003e以及Spring Cloud等，\u003c/p\u003e\n\u003cp\u003e这些框架实现了分布式系统通信需要的各种通用语义功能：如负载均衡和服务发现等，因此一定程度上屏蔽了这些通信细节，使得开发人员使用较少的框架代码就能开发出健壮的分布式系统。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_7.png\" alt=\"image_2_7.png\"\u003e\u003c/p\u003e\n\u003ch4\u003e3.6 第六阶：第一代Service Mesh \u003ca href=\"#scroller-21\" id=\"scroller-21\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e上面的第二代微服务框架目前看着挺完美了，但整套微服务框架其实是很复杂的，比如Spring Cloud，聚合了很多组件。所以在实践过程中，会发现有如下诸多问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e**侵入性强。**想要集成SDK的能力，除了需要添加相关依赖，业务层中入侵的代码、注解、配置，与治理层界限不清晰。\u003c/li\u003e\n\u003cli\u003e**升级成本高。**每次升级都需要业务应用修改SDK版本，重新进行功能回归测试，并对每一台服务进行部署上线，与快速迭代开发相悖。\u003c/li\u003e\n\u003cli\u003e**版本碎片化严重。**由于升级成本高，而中间件版本更新快，导致线上不同服务引用的SDK版本不统一、能力参差不齐，造成很难统一治理。\u003c/li\u003e\n\u003cli\u003e**中间件演变困难。**由于版本碎片化严重，导致中间件向前演进的过程中就需要在代码中兼容各种各样的老版本逻辑，带着\u0026quot;枷锁”前行，无法实现快速迭代。\u003c/li\u003e\n\u003cli\u003e**内容多、门槛高。**依赖组件多，学习成本高，即使通用分布式系统屏蔽了很多的实现细节，我们引入微服务框架并熟练使用也是要花费巨大的精力的。\u003c/li\u003e\n\u003cli\u003e**治理功能不全。**不同于RPC框架，SpringCloud作为治理全家桶的典型，也不是万能的，诸如协议转换支持、多重授权机制、动态请求路由、故障注入、灰度发布等高级功能并没有覆盖到。\u003c/li\u003e\n\u003cli\u003e**无法实现真正意义上的语言无关性。**提供的框架一般只支持一种或几种语言，要将框架不支持的语言研发的服务也纳入微服务架构中，是比较有难度的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以，第一代微服务架构 Service Mesh就产生了，它作为一个基础设施层，能够与业务解耦，主要解决复杂网络拓扑下微服务与微服务之间的通信，其实现形态一般为轻量级网络代理，并与应用以边车代理（SideCar）模式部署，同时对业务应用透明。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_8.png\" alt=\"image_2_8.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSideCar将分布式服务的通信抽象为单独一层，需要和服务部署在一起，接管服务的流量，通过代理之间的通信间接完成服务之间的通信请求。\u003c/p\u003e\n\u003cp\u003e所以在这一层中它能够实现负载均衡、服务发现、认证授权、监控追踪、流量控制等分布式系统所需要的功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_9.png\" alt=\"image_2_9.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如果我们从一个全局视角来看，绿色的为应用服务，蓝色的为SideCar，就会得到如下部署图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_10.png\" alt=\"image_2_10.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如果我们省略去服务，只看Service Mesh的代理边车的网格应该是这样的：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_11.png\" alt=\"image_2_11.png\"\u003e\u003c/p\u003e\n\u003cp\u003e流量经过的时候，会先被代理边车所劫持，然后再进入服务，所以它就是一个由若干服务代理所组成的错综复杂的网格。\u003c/p\u003e\n\u003ch4\u003e3.7 第七阶：第二代Service Mesh \u003ca href=\"#scroller-22\" id=\"scroller-22\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e第一代Service Mesh由一系列独立运行的单机代理服务构成，为了提供统一的上层运维入口，演化出了集中式的控制面板，我们称之为控制面（control plane）。\u003c/p\u003e\n\u003cp\u003e控制面和所有的数据面（data plane，即代理边车）进行交互，比如策略下发、数据采集等。这就是以Istio为代表的第二代Service Mesh。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_12.png\" alt=\"image_2_12.png\"\u003e\u003c/p\u003e\n\u003cp\u003e只包含控制面和数据面的 Service Mesh 服务网格全局结构图 如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/blog/tech/microservice/image_2_13.png\" alt=\"image_2_13.png\"\u003e\u003c/p\u003e\n\u003cp\u003e从上面的结构图可以看出，Service Mesh 的基础设施层主要分为两部分：控制平面与数据平面。当前流行的开源服务网格 Istio 和 Linkerd 都是这种构造。\u003c/p\u003e\n\u003cp\u003e控制平面的特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不直接解析数据包。\u003c/li\u003e\n\u003cli\u003e与控制平面中的代理通信，下发策略和配置。\u003c/li\u003e\n\u003cli\u003e负责网络行为的可视化。\u003c/li\u003e\n\u003cli\u003e通常提供 API 或者命令行工具可用于配置版本化管理，便于持续集成和部署。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e数据平面的特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通常是按照无状态目标设计的，但实际上为了提高流量转发性能，需要缓存一些数据，因此无状态也是有争议的。\u003c/li\u003e\n\u003cli\u003e直接处理入站和出站数据包，转发、路由、健康检查、负载均衡、认证、鉴权、产生监控数据等。\u003c/li\u003e\n\u003cli\u003e对应用来说透明，即可以做到无感知部署。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e到这一步我们大概了解了微服务架构的演进过程，也初步了解Service Mesh技术比较于传统的微服务架构有哪些优势。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"19:T173e,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e架构设计模板\u003c/h1\u003e\n\u003cp\u003e最近一年的时间内，我参与了很多后端基础组件的设计、重构、重写、微服务化等工作，写了很多设计文档、与同事开了很多次技术研讨会，一直以来没有总结一套工作模板，以至于在开会时总有遗漏。今天我的朋友分享给了我一套架构设计模板，我针对文档做了一些总结，分享给大家：\u003c/p\u003e\n\u003cp\u003e总体来说，一个完善的设计需要考虑一下 11 个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e需求介绍\u003c/li\u003e\n\u003cli\u003e架构总览\u003c/li\u003e\n\u003cli\u003e核心流程\u003c/li\u003e\n\u003cli\u003e详细设计\u003c/li\u003e\n\u003cli\u003e高可用设计\u003c/li\u003e\n\u003cli\u003e高性能设计\u003c/li\u003e\n\u003cli\u003e可扩展设计\u003c/li\u003e\n\u003cli\u003e安全设计\u003c/li\u003e\n\u003cli\u003e其他设计\u003c/li\u003e\n\u003cli\u003e部署方案\u003c/li\u003e\n\u003cli\u003e架构演进规划\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这 11 条既可以作为我们写设计文档时的 CheckList，也可以直接用来做题纲，下面我们详细说说具体要做什么。\u003c/p\u003e\n\u003ch3\u003e1. 需求介绍 \u003ca href=\"#xu-qiu-jie-shao\" id=\"xu-qiu-jie-shao\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e需求介绍主要描述需求的背景、以及新系统想要达成的目标。\u003cbr\u003e比如我在设计公司\u003ccode\u003e用户动态与Websocet\u003c/code\u003e业务时提到：旧动态系统延迟过高、进程池进程数量有限，有时会出现任务卡死的情况，需要手动重启系统才能暂时恢复（不能根治），导致用户动态推送业务极不稳定。新系统的目标是为了改善这一情况，保障动态业务稳定性。\u003cbr\u003e再比如我在设计公司自动化部署在线文档时提到：旧文档由各个开发人员在本地生成，上传到 Git 时可能有冲突、且不方便人员查看，所以准备部署一个在线文档，开发人员编写好文档后自动生成在线文档，方便查阅。\u003cbr\u003e总结就是三个关键点：哪里有问题、想怎么解决问题、能达到什么效果。\u003c/p\u003e\n\u003ch3\u003e2. 架构总览 \u003ca href=\"#jia-gou-zong-lan\" id=\"jia-gou-zong-lan\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e架构总览的\u003cstrong\u003e核心内容是架构图\u003c/strong\u003e，以及针对架构图的描述，包括模块或者子系统的职责描述、核心流程。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e架构图的画法没有严格要求，唯一的要求就是易懂。个人建议 Figma 和 ProcessOn 二者结合使用。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e可以给大家瞧瞧我当初做 Wordpress 站点 CDN 优化的架构图：\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.kaolengmian7.com/app/imgs/architecture/architecture_design_template/1.png\" alt=\"\"\u003e\u003cfigcaption\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\u003cp\u003e再给大伙看看我利用 Github Action、DroneCI/CD、Docker、K8s 做的自动化在线文档：\u003c/p\u003e\n\u003cfigure\u003e\u003cimg src=\"https://www.kaolengmian7.com/app/imgs/architecture/architecture_design_template/2.png\" alt=\"\"\u003e\u003cfigcaption\u003e\u003c/figcaption\u003e\u003c/figure\u003e\n\n\u003cp\u003e有了架构图的支撑，会大大降低技术研讨会讲解的难度，非常实用。\u003c/p\u003e\n\u003ch3\u003e3. 核心流程 \u003ca href=\"#he-xin-liu-cheng\" id=\"he-xin-liu-cheng\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e核心流程的主要任务是针对上面的架构图讲解各个关键组件是如何工作的、数据的流向与处理方式等等，复杂的业务最好给出\u003cstrong\u003e时序图。\u003c/strong\u003e\u003cbr\u003e\u003cstrong\u003e个人认为架构图和时序图是最重要的两个图，让整个系统结构和处理逻辑一目了然，配合口头讲解非常易懂。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3\u003e4. 详细设计 \u003ca href=\"#xiang-xi-she-ji\" id=\"xiang-xi-she-ji\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e对于一些比较复杂的小组件 or 小设计，需要额外写一些详细设计文档，降低同事理解代码的成本。\u003cbr\u003e比如我在设计分布式唯一 Id 生成器时详细介绍了\u003ccode\u003e双Buffer优化\u003c/code\u003e这个小设计：\u003cbr\u003e\u003cimg src=\"https://www.kaolengmian7.com/app/imgs/architecture/architecture_design_template/3.png\" alt=\"image.png\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eid 容器采用双 buffer 实现，目的是防止某一个请求进来恰巧桶内没数据需要请求 mysql 从而造成高延迟的情况。（buffer 容量可配置）\u003c/li\u003e\n\u003cli\u003e双 buffer 的切换逻辑为：当前承担发号任务的 buffer 余额 \u0026lt; 20%，休息状态的 buffer 已经填充完毕（isReady）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e5. 高可用设计 \u003ca href=\"#gao-ke-yong-she-ji\" id=\"gao-ke-yong-she-ji\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e讲解系统设计是怎样考虑高可用这个指标的。比如数据库宕机怎么办？数据一致性如何处理？数据丢失怎么办？缓存的方案？出Bug如何补救？如何 Debug、如何排查线上问题？性能指标、业务指标监控该怎么做？\u003cbr\u003e这块内容的要诀有两个：一是要结合具体情况，二是要多积累经验。\u003c/p\u003e\n\u003ch3\u003e6. 高性能设计 \u003ca href=\"#gao-xing-neng-she-ji\" id=\"gao-xing-neng-she-ji\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e讲解系统设计是怎样考虑高性能这个指标的。此外还可以提一提压力测试计划、目标 QPS 等等。\u003c/p\u003e\n\u003ch3\u003e7. 可扩展性设计 \u003ca href=\"#ke-kuo-zhan-xing-she-ji\" id=\"ke-kuo-zhan-xing-she-ji\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e讲解系统设计是怎样考虑扩展性这个指标的。\u003c/p\u003e\n\u003ch3\u003e8. 安全设计 \u003ca href=\"#an-quan-she-ji\" id=\"an-quan-she-ji\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e比如权限控制。如果没有可以填“无”，但是不能不写，这表明我们是有考虑安全性的，在研讨会时说不定有同事会补充。\u003c/p\u003e\n\u003ch3\u003e9. 其他设计 \u003ca href=\"#qi-ta-she-ji\" id=\"qi-ta-she-ji\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e可以写一写使用的语言、框架、库等等。也可以是公司团队内部的一些规范。\u003c/p\u003e\n\u003ch3\u003e10. 部署方案 \u003ca href=\"#bu-shu-fang-an\" id=\"bu-shu-fang-an\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e现在基本上都是 K8s 部署，可以讲讲是用 Stateful 部署还是用 Deployment 部署。副本数量设计，生产环境多少个副本、灰度环境多少个、测试环境多少个。\u003c/p\u003e\n\u003ch3\u003e11. 架构演进计划 \u003ca href=\"#jia-gou-yan-jin-ji-hua\" id=\"jia-gou-yan-jin-ji-hua\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e如果是小项目不用写，如果是大型项目那大概率不能一下子全部完成。这时候就要分步骤、分期实现。可以写写第一期要实现 xxx、第二期要 xxx 类似这样的目标。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"rounded-2xl shadow-2xl border border-gray-200 hover:shadow-3xl transition-all duration-300 p-8 sm:p-12\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center mb-6\",\"children\":[\"$\",\"div\",null,{\"className\":\"inline-flex items-center px-3 py-1.5 bg-gray-50 text-gray-600 rounded-md text-sm font-normal\",\"children\":[[\"$\",\"svg\",null,{\"className\":\"w-4 h-4 mr-2 text-gray-400\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"viewBox\":\"0 0 24 24\",\"children\":[\"$\",\"path\",null,{\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"strokeWidth\":2,\"d\":\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\"}]}],[\"$\",\"time\",null,{\"dateTime\":\"2024-03-18\",\"children\":\"2024年03月18日\"}]]}]}],[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold text-gray-900 mb-6 text-center\",\"children\":\"从0开始做一个后台项目架构\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-6 justify-center\",\"children\":[[\"$\",\"$L5\",\"架构设计\",{\"href\":\"/blog/tag/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"架构设计\"}],[\"$\",\"$L5\",\"技术专题\",{\"href\":\"/blog/tag/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/page/1/\",\"className\":\"inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300 hover:text-gray-900 transition-colors\",\"children\":\"技术专题\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"max-w-5xl mx-auto\",\"children\":[\"$\",\"$L14\",null,{\"content\":\"$15\"}]}],[\"$\",\"$11\",null,{\"fallback\":[\"$\",\"div\",null,{\"className\":\"mt-12 pt-8 border-t border-gray-200\",\"children\":\"加载导航中...\"}],\"children\":[\"$\",\"$L16\",null,{\"globalNav\":{\"prev\":{\"slug\":\"tech/system/高并发系统设计的15个锦囊\",\"title\":\"高并发系统设计的15个锦囊\",\"description\":\"记得很久之前，去面试过**字节跳动**。被三面的面试官问了一道场景设计题目：**如何设计一个高并发系统**。当时我回答得比较粗糙，最近回想起来，所以整理了设计高并发系统的15个锦囊，相信大家看完会有帮助的。 所谓设计**高并发**系统，就是设计一个系统，保证它**整体可用**的同时，能够**处理很高...\",\"pubDate\":\"2024-03-17\",\"tags\":[\"系统架构\"],\"heroImage\":\"$undefined\",\"content\":\"$17\"},\"next\":{\"slug\":\"tech/microservice/微服务及其演进史\",\"title\":\"微服务及其演进史\",\"description\":\"在很多项目的业务初期阶段，高速迭代上线是首要考虑的事情，对后期的容量预估、可扩展性和系统健壮性、高可用一般没有那么重视。但随着业务的发展，用户量、请求量的暴增， 发现原来的单体系统已经远远不满足需求了，特别是随着互联网整体的高速发展，对系统的要求越来越高。 但是物理服务器的CPU、内存、存储器、连接...\",\"pubDate\":\"2024-03-19\",\"tags\":[\"微服务架构\",\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$18\"}},\"tagNav\":{\"架构设计\":{\"prev\":{\"slug\":\"tech/system/架构设计模板\",\"title\":\"架构设计模板\",\"description\":\"最近一年的时间内，我参与了很多后端基础组件的设计、重构、重写、微服务化等工作，写了很多设计文档、与同事开了很多次技术研讨会，一直以来没有总结一套工作模板，以至于在开会时总有遗漏。今天我的朋友分享给了我一套架构设计模板，我针对文档做了一些总结，分享给大家...\",\"pubDate\":\"2024-03-16\",\"tags\":[\"架构设计\",\"技术专题\"],\"heroImage\":\"$undefined\",\"content\":\"$19\"},\"next\":null},\"技术专题\":{\"prev\":\"$6:props:children:props:children:props:children:2:props:children:props:tagNav:架构设计:prev\",\"next\":\"$6:props:children:props:children:props:children:2:props:children:props:globalNav:next\"}}}]}],[\"$\",\"$L1a\",null,{}]]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"从0开始做一个后台项目架构 - Skyfalling Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。\"}],[\"$\",\"meta\",\"2\",{\"property\":\"og:title\",\"content\":\"从0开始做一个后台项目架构\"}],[\"$\",\"meta\",\"3\",{\"property\":\"og:description\",\"content\":\"作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"5\",{\"property\":\"article:published_time\",\"content\":\"2024-03-18\"}],[\"$\",\"meta\",\"6\",{\"property\":\"article:author\",\"content\":\"Skyfalling\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"从0开始做一个后台项目架构\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"作为一名架构师，老板要求你把公司的后端技术栈搞一下，那你该如何去做呢？对我而言我，我的答案是综合考虑下面的这些内容然后进行决定。\"}],[\"$\",\"link\",\"10\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}],[\"$\",\"link\",\"11\",{\"rel\":\"icon\",\"href\":\"/favicon.svg\"}]],\"error\":null,\"digest\":\"$undefined\"}\n13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/gitbook/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/gitbook/_next/static/css/443e11d9362f4e82.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/gitbook/_next/static/chunks/webpack-53d905a932a6f993.js"/><script src="/gitbook/_next/static/chunks/4bd1b696-a6a68ffbe959fe28.js" async=""></script><script src="/gitbook/_next/static/chunks/684-776aabfcbdbee233.js" async=""></script><script src="/gitbook/_next/static/chunks/main-app-75103b4b1f3159f6.js" async=""></script><script src="/gitbook/_next/static/chunks/874-80549eca86098588.js" async=""></script><script src="/gitbook/_next/static/chunks/app/layout-f035406da26395a3.js" async=""></script><script src="/gitbook/_next/static/chunks/app/blog/%5B...slug%5D/page-b420037c820534af.js" async=""></script><meta name="next-size-adjust" content=""/><title>Skyfalling</title><meta name="description" content="分享技术、生活和思考的个人博客"/><link rel="icon" href="/favicon.svg"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/gitbook/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_feb414"><div hidden=""><!--$--><!--/$--></div><div class="min-h-screen flex flex-col"><header class="bg-white shadow-sm"><nav class="mx-auto flex max-w-7xl items-center justify-between p-6 lg:px-8" aria-label="Global"><div class="flex lg:flex-1"><a class="-m-1.5 p-1.5" href="/gitbook/"><span class="sr-only">Skyfalling Blog</span><span class="text-2xl font-bold text-gray-900">Skyfalling</span></a></div><div class="flex lg:hidden"><button type="button" class="-m-2.5 inline-flex items-center justify-center rounded-md p-2.5 text-gray-700"><span class="sr-only">打开主菜单</span><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-slot="icon" class="h-6 w-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"></path></svg></button></div><div class="hidden lg:flex lg:gap-x-12"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/gitbook/">首页</a><a class="text-base font-semibold leading-6 transition-colors text-blue-600 border-b-2 border-blue-600 pb-1" href="/gitbook/blog/">博客</a><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/gitbook/about/">关于</a></div><div class="hidden lg:flex lg:flex-1 lg:justify-end"><a class="text-base font-semibold leading-6 transition-colors text-gray-900 hover:text-blue-600" href="/gitbook/contact/">联系 <span aria-hidden="true">→</span></a></div></nav></header><main class="flex-1"><article class="py-24 sm:py-32"><div class="mx-auto max-w-3xl px-6 lg:px-8"><div class="xl:relative"><div class="mx-auto max-w-2xl"><div class="text-center"><time dateTime="2024-04-01" class="text-gray-500">2024年04月01日</time><h1 class="mt-6 text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl">服务注册与发现</h1><p class="mt-6 text-lg leading-8 text-gray-600">我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。</p><div class="mt-6 flex justify-center gap-2"><a class="rounded-full bg-gray-100 px-3 py-1 text-sm font-medium text-gray-700 hover:bg-gray-200" href="/gitbook/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1/">微服务</a></div></div><div class="mt-16 prose prose-lg prose-gray mx-auto"><div class="prose prose-lg prose-gray mx-auto">
<h1>服务注册与发现</h1></p><p><h2>1 微服务的注册与发现 <a href="#scroller-1" id="scroller-1"></a></h2></p><p>我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。</p><p>微服务注册与发现类似于生活中的"电话通讯录"的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。</p><p>步骤如下：</p><p>1、你先要把"好友某某"记录在通讯录中。</p><p>2、拨打电话的时候通过通讯录中找到"好友某某"，并拨通回电话。</p><p>3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。</p><p>从这个过程中我们看到了一些特点：</p><p>1、把 "好友某某" 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。</p><p>2、后续我们通过"好友某某"就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。</p><p>而我们微服务架构中的服务注册与发现结构如下图所示：</p><img src="/images/books/image_22_1.png" alt="" /><p>图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：</p><p>provider - 服务提供者</p><p>consumer - 服务消费者</p><p>register center - 注册中心</p><p>它们之间的关系大致如下：</p><p>1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。</p><p>2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。</p><p>3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。</p><p>优点如下：</p><p>1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响</p><p>2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响</p><p>3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。</p><p>从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。</p><p><h3>1.1 服务注册 <a href="#scroller-2" id="scroller-2"></a></h3></p><p>如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。</p><img src="/images/books/image_9_1_1.png" alt="" /><p>服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：</p><p>1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。</p><p>2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。</p><p>3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。</p><p>可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。</p><img src="/images/books/image_42.png" alt="" /><p><h3>1.2 服务发现 <a href="#scroller-3" id="scroller-3"></a></h3></p><p>服务发现实际就是我们查询已经注册好的服务提供者，比如 p->p.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，</p><p>返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。</p><p>这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。</p><p>服务发现的方式一般有两种：</p><p>1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。</p><p>2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。</p><p><h3>1.3 注册中心 <a href="#scroller-4" id="scroller-4"></a></h3></p><p>注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。</p><p>服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。</p><p>主要的检查方式包括：</p><p>1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。</p><p>2、注册中心主动检查服务Provider接口。</p><p>综合我们前面的内容，可以总结下注册中心有如下几种能力：</p><p>1、高可用</p><p>这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的</p><p>2、可视化操作</p><p>常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。</p><p>3、高效运维</p><p>注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。</p><p>4、权限控制</p><p>数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求</p><p>5、服务注册推、拉能力</p><p>这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。</p><img src="/images/books/image_34.png" alt="" /><p><h2>2 现下的主流注册中心 <a href="#scroller-5" id="scroller-5"></a></h2></p><p><h3>2.1 Eureka <a href="#scroller-6" id="scroller-6"></a></h3></p><p><h4>2.1.1 介绍 <a href="#scroller-7" id="scroller-7"></a></h4></p><p>Eureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。</p><p>目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 [Eureka 2.0已经停止维护](https://github.com/Netflix/eureka/wiki)，所以新的微服务架构设计中，不再建议使用。</p><p>Spring Cloud Netflix主要分为两个部分：</p><p>1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。</p><p>2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。</p><img src="/images/books/image_55.png" alt="" /><p>Eureka有比较友好的管理界面，如上图所示：</p><p>1、System Status：显示当前Eureka Server信息。</p><p>2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。</p><p>3、General Info：基本信息，如cpu、内存、环境等。</p><p><h4>2.1.2 整体架构 <a href="#scroller-8" id="scroller-8"></a></h4></p><img src="/images/books/image_32.png" alt="" /><p>Eureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。</p><p>所以他有如下特点：</p><p>1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。</p><p>2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。</p><p>3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。</p><p>同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。</p><p>4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。</p><p><h4>2.1.3 接入Spring Cloud <a href="#scroller-9" id="scroller-9"></a></h4></p><img src="/images/books/image_4_1.png" alt="" /><p>如上图所示：</p><p>1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -> 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。</p><p>所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。</p><p>2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。</p><p>3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。</p><p><h3>2.2 ZooKeeper <a href="#scroller-10" id="scroller-10"></a></h3></p><p><h4>2.2.1 介绍 <a href="#scroller-11" id="scroller-11"></a></h4></p><p>作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。</p><p>这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。</p><img src="/images/books/image_57.png" alt="" /><p>在数据模型上，类似于传统的文件系统，节点类型分为：</p><p>1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。</p><p>2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。</p><p>在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。</p><img src="/images/books/image_56.png" alt="" /><p>Zookeeper有如下特点：</p><p>1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。</p><p><h4>2.2.2 整体架构 <a href="#scroller-12" id="scroller-12"></a></h4></p><img src="/images/books/image_3_1_1.png" alt="" /><p>上图是Zookeeper 的服务架构，他有如下流程：</p><p>1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；</p><p>2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。</p><p>3、Leader负责处理数据更新等操作（Zab协议）；</p><p><h4>2.2.3 接入Dubbo生态 <a href="#scroller-13" id="scroller-13"></a></h4></p><img src="/images/books/image_43_1.png" alt="" /><p>上图中的角色如下：</p><p>Provider：提供者,服务发布方</p><p>Consumer：消费者, 调用服务方</p><p>Container：Dubbo容器.依赖于Spring容器</p><p>Registry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置</p><p>Monitor:监听器</p><p>说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。</p><p>服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。</p><p>这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。</p><p><h3>2.3 Consul <a href="#scroller-14" id="scroller-14"></a></h3></p><p><h4>2.3.1 介绍 <a href="#scroller-15" id="scroller-15"></a></h4></p><p>Consul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：</p><p>1、Service Discovery（服务发现）</p><p>2、Configuration（配置化）</p><p>3、Segmentation Functionality</p><p>这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。</p><p>Consul提供的关键功能如下：</p><p>1、Service Discovery：服务注册/发现功能。</p><p>2、Health Checking：健康检查，丰富的健康检查方式；</p><p>3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。</p><p>4、Multi DataCenter：多数据中心。</p><p><h4>2.3.2 整体架构 <a href="#scroller-16" id="scroller-16"></a></h4></p><img src="/images/books/image_28_1.png" alt="" /><p>如上图为Consul的架构，这边对技术点做一下说明：</p><p>1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式</p><p>2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。</p><p>3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。</p><p>4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。</p><p>5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。</p><p>6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。</p><p>7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。</p><p>8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。</p><p>9、RPC: 远程过程调用，用于服务之间的通信。</p><p>10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2\*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。</p><p>所以是典型的CP模式。</p><img src="/images/books/image_45.png" alt="" /><p>根据Consul 的选举机制和服务原理，我们有两个注意点 ：</p><p>1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。</p><p>2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。</p><p>有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。</p><p><h4>2.3.3 生态对接 <a href="#scroller-17" id="scroller-17"></a></h4><strong>对接Spring Cloud生态</strong><img src="/images/books/image_15_1.png" alt="" /><p>Consul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。</p><p>但是这边的健康检查更丰富，可以有多种不同的的Check方式：</p><p>* Script check（Script+ Interval）</p>
<p>* 基于HTTP请求</p>
<p>* 基于tcp请求</p>
<p>* 基于grpc请求</p><h3>2.4 总结对比 <a href="#scroller-19" id="scroller-19"></a></h3><p>| <strong>指标</strong>             | <strong>Eureka</strong>        | <strong>Zookeeper</strong>   | <strong>Consul</strong>          | <strong>Etcd</strong>            |</p>
<p>| ------------------ | ----------------- | --------------- | ------------------- | ------------------- |</p>
<p>| 一致性协议              | AP                | CP（Paxos算法）     | CP（Raft算法）          | CP（Raft算法）          |</p>
<p>| 健康检查               | TTL(Time To Live) | TCP Keep Alive  | TTL\HTTP\TCP\Script | Lease TTL KeepAlive |</p>
<p>| watch/long polling | 不支持               | watch           | long polling        | watch               |</p>
<p>| 雪崩保护               | 支持                | 不支持             | 不支持                 | 不支持                 |</p>
<p>| 安全与权限              | 不支持               | ACL             | ACL                 | RBAC                |</p>
<p>| 是否支持多数据中心          | 是                 | 否               | 是                   | 否                   |</p>
<p>| 是否有管理界面            | 是                 | 否（可用第三方ZkTools） | 是                   | 否                   |</p>
<p>| Spring Cloud 集成    | 支持                | 支持              | 支持                  | 支持                  |</p>
<p>| Dubbo 集成           | 不支持               | 支持              | 支持                  | 不支持                 |</p>
<p>| K8S 集成             | 不支持               | 不支持             | 支持                  | 支持                  |</p><p>这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。</p><p>当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。</p><p>如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。</p>
</div></div><div class="mt-16 flex items-center justify-between border-t border-gray-200 pt-8"><a class="relative z-10 rounded-md px-4 py-2 text-sm font-semibold leading-6 text-gray-900 hover:text-blue-600 hover:bg-gray-50" href="/gitbook/blog/">← 返回博客列表</a></div><div class="mt-8 grid grid-cols-1 gap-8 border-t border-gray-200 pt-8 lg:grid-cols-2"><div class="group"><div class="flex items-center gap-x-3"><div class="text-sm text-gray-500">上一篇</div></div><h3 class="mt-2 text-lg font-semibold leading-6 text-gray-900 group-hover:text-gray-600"><a href="/gitbook/blog/wei-fu-wu-chai-fen-ce-lve-fu-jia-pian/"><span class="absolute inset-0"></span>微服务拆分策略（附加篇）</a></h3><p class="mt-3 text-sm leading-6 text-gray-600 line-clamp-2">关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。 1. AKF扩展立方体 AKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一...</p></div><div class="group"><div class="flex items-center gap-x-3"><div class="text-sm text-gray-500">下一篇</div></div><h3 class="mt-2 text-lg font-semibold leading-6 text-gray-900 group-hover:text-gray-600"><a href="/gitbook/blog/fu-wu-zhu-ce-yu-fa-xian-shi-jian-pian/"><span class="absolute inset-0"></span>服务注册与发现（实践篇）</a></h3><p class="mt-3 text-sm leading-6 text-gray-600 line-clamp-2">前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景...</p></div></div></div></div></div></article><!--$--><!--/$--></main><footer class="bg-gray-900"><div class="mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8"><div class="flex justify-center space-x-6 md:order-2"><a class="text-gray-400 hover:text-gray-300" href="/gitbook/about/">关于</a><a class="text-gray-400 hover:text-gray-300" href="/gitbook/blog/">博客</a><a class="text-gray-400 hover:text-gray-300" href="/gitbook/contact/">联系</a></div><div class="mt-8 md:order-1 md:mt-0"><p class="text-center text-xs leading-5 text-gray-400">© 2024 Skyfalling Blog. All rights reserved.</p></div></div></footer></div><script src="/gitbook/_next/static/chunks/webpack-53d905a932a6f993.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5651,[\"874\",\"static/chunks/874-80549eca86098588.js\",\"177\",\"static/chunks/app/layout-f035406da26395a3.js\"],\"default\"]\n3:I[7555,[],\"\"]\n4:I[1295,[],\"\"]\n5:I[6874,[\"874\",\"static/chunks/874-80549eca86098588.js\",\"909\",\"static/chunks/app/blog/%5B...slug%5D/page-b420037c820534af.js\"],\"\"]\n7:I[9665,[],\"OutletBoundary\"]\na:I[4911,[],\"AsyncMetadataOutlet\"]\nc:I[9665,[],\"ViewportBoundary\"]\ne:I[9665,[],\"MetadataBoundary\"]\n10:I[6614,[],\"\"]\n:HL[\"/gitbook/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/gitbook/_next/static/css/443e11d9362f4e82.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"vtR8vRym_dmCF4uoCEze4\",\"p\":\"/gitbook\",\"c\":[\"\",\"blog\",\"fu-wu-zhu-ce-yu-fa-xian\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"fu-wu-zhu-ce-yu-fa-xian\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/gitbook/_next/static/css/443e11d9362f4e82.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[\"$\",\"body\",null,{\"className\":\"__className_feb414\",\"children\":[\"$\",\"div\",null,{\"className\":\"min-h-screen flex flex-col\",\"children\":[[\"$\",\"$L2\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-1\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"footer\",null,{\"className\":\"bg-gray-900\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex justify-center space-x-6 md:order-2\",\"children\":[[\"$\",\"$L5\",null,{\"href\":\"/about\",\"className\":\"text-gray-400 hover:text-gray-300\",\"children\":\"关于\"}],[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"text-gray-400 hover:text-gray-300\",\"children\":\"博客\"}],[\"$\",\"$L5\",null,{\"href\":\"/contact\",\"className\":\"text-gray-400 hover:text-gray-300\",\"children\":\"联系\"}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 md:order-1 md:mt-0\",\"children\":[\"$\",\"p\",null,{\"className\":\"text-center text-xs leading-5 text-gray-400\",\"children\":\"© 2024 Skyfalling Blog. All rights reserved.\"}]}]]}]}]]}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"fu-wu-zhu-ce-yu-fa-xian\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L6\",null,[\"$\",\"$L7\",null,{\"children\":[\"$L8\",\"$L9\",[\"$\",\"$La\",null,{\"promise\":\"$@b\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"PeTF8jMiTixwtn0DYMwUjv\",{\"children\":[[\"$\",\"$Lc\",null,{\"children\":\"$Ld\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],[\"$\",\"$Le\",null,{\"children\":\"$Lf\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$10\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:\"$Sreact.suspense\"\n12:I[4911,[],\"AsyncMetadata\"]\nf:[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$11\",null,{\"fallback\":null,\"children\":[\"$\",\"$L12\",null,{\"promise\":\"$@13\"}]}]}]\n14:T4ee6,"])</script><script>self.__next_f.push([1,"\n\u003ch1\u003e服务注册与发现\u003c/h1\u003e\u003c/p\u003e\u003cp\u003e\u003ch2\u003e1 微服务的注册与发现 \u003ca href=\"#scroller-1\" id=\"scroller-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003c/p\u003e\u003cp\u003e我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。\u003c/p\u003e\u003cp\u003e微服务注册与发现类似于生活中的\"电话通讯录\"的概念，它记录了通讯录服务和电话的映射关系。在分布式架构中，服务会注册进去，当服务需要调用其它服务时，就这里找到服务的地址，进行调用。\u003c/p\u003e\u003cp\u003e步骤如下：\u003c/p\u003e\u003cp\u003e1、你先要把\"好友某某\"记录在通讯录中。\u003c/p\u003e\u003cp\u003e2、拨打电话的时候通过通讯录中找到\"好友某某\"，并拨通回电话。\u003c/p\u003e\u003cp\u003e3、当好友某某电话号码更新的时候，需要通知到你，并修改通讯录服务中的号码。\u003c/p\u003e\u003cp\u003e从这个过程中我们看到了一些特点：\u003c/p\u003e\u003cp\u003e1、把 \"好友某某\" 的电话号码写入通讯录中，统一在通讯录中维护，后续号码变更也是更新到通讯录中，这个过程就是服务注册的过程。\u003c/p\u003e\u003cp\u003e2、后续我们通过\"好友某某\"就可以定位到通讯录中的电话号码，并拨通电话，这个过程理解为服务发现的过程。\u003c/p\u003e\u003cp\u003e而我们微服务架构中的服务注册与发现结构如下图所示：\u003c/p\u003e\u003cimg src=\"/images/books/image_22_1.png\" alt=\"\" /\u003e\u003cp\u003e图片中是一个典型的微服务架构，这个结构中主要涉及到三大角色：\u003c/p\u003e\u003cp\u003eprovider - 服务提供者\u003c/p\u003e\u003cp\u003econsumer - 服务消费者\u003c/p\u003e\u003cp\u003eregister center - 注册中心\u003c/p\u003e\u003cp\u003e它们之间的关系大致如下：\u003c/p\u003e\u003cp\u003e1、每个微服务在启动时，将自己的网络地址等信息（微服务的ServiceName、IP、Port、MetaData等）注册到注册中心，注册中心存储这些数据。\u003c/p\u003e\u003cp\u003e2、服务消费者从注册中心查询服务提供者的地址，并通过该地址调用服务提供者的接口。\u003c/p\u003e\u003cp\u003e3、各个微服务与注册中心使用一定机制（例如心跳）通信。如果注册中心与某微服务长时间无法通信，就会注销该实例。\u003c/p\u003e\u003cp\u003e优点如下：\u003c/p\u003e\u003cp\u003e1、解耦：服务消费者跟服务提供者解耦，各自变化，不互相影响\u003c/p\u003e\u003cp\u003e2、扩展：服务消费者和服务提供者增加和删除新的服务，对于双方没有任何影响\u003c/p\u003e\u003cp\u003e3、中介者设计模式：用一个中介对象来封装一系列的对象交互，这是一种多对多关系的中介者模式。\u003c/p\u003e\u003cp\u003e从功能上拆开主要有三块：服务注册、服务发现，和注册中心。我们一个一个来看。\u003c/p\u003e\u003cp\u003e\u003ch3\u003e1.1 服务注册 \u003ca href=\"#scroller-2\" id=\"scroller-2\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003c/p\u003e\u003cp\u003e如图中，为Register注册中心注册一个服务信息，会将服务的信息：ServiceName、IP、Port以及服务实例MetaData元数据信息写入到注册中心。当服务发生变化的时候，也可以更新到注册中心。\u003c/p\u003e\u003cimg src=\"/images/books/image_9_1_1.png\" alt=\"\" /\u003e\u003cp\u003e服务提供者（服务实例） 的服务注册模型是一种简单、容易理解、流行的服务注册模型，其在多种技术生态中都有所体现：\u003c/p\u003e\u003cp\u003e1、在K8S生态中，通过 K8S Service服务信息，和Pod的 endpoint（用来记录service对应的pod的访问地址）来进行注册。\u003c/p\u003e\u003cp\u003e2、在Spring Cloud生态中，应用名 对应 服务Service，实例 IP + Port 对应 Instance实例。比较典型的就是A服务，后面对应有多个实例做负载均衡。\u003c/p\u003e\u003cp\u003e3、在其他的注册组件中，比如 Eureka、Consul，服务模型也都是 服务→ 服务实例。\u003c/p\u003e\u003cp\u003e可以认为服务实例是一个真正的实体的载体，服务是对这些相同能力或者相同功能服务实例的一个抽象。\u003c/p\u003e\u003cimg src=\"/images/books/image_42.png\" alt=\"\" /\u003e\u003cp\u003e\u003ch3\u003e1.2 服务发现 \u003ca href=\"#scroller-3\" id=\"scroller-3\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003c/p\u003e\u003cp\u003e服务发现实际就是我们查询已经注册好的服务提供者，比如 p-\u003ep.queryService(serviceName)，通过服务名称查询某个服务是否存在，如果存在，\u003c/p\u003e\u003cp\u003e返回它的所有实例信息，即一组包含ip 、 port 、metadata元数据信息的endpoints信息。\u003c/p\u003e\u003cp\u003e这一组endpoints信息一般会被缓存在本地，如果注册中心挂掉，可保证段时间内依旧可用，这是去中心化的做法。对于单个 Service 后面有多个 Instance的情况（如上图），做 load balance。\u003c/p\u003e\u003cp\u003e服务发现的方式一般有两种：\u003c/p\u003e\u003cp\u003e1、拉取的方式：服务消费方（Consumer）主动向注册中心发起服务查询的请求。\u003c/p\u003e\u003cp\u003e2、推送的方式：服务订阅/通知变更（下发）：服务消费方（Consumer）主动向注册中心订阅某个服务，当注册中心中该服务信息发生变更时，注册中心主动通知消费者。\u003c/p\u003e\u003cp\u003e\u003ch3\u003e1.3 注册中心 \u003ca href=\"#scroller-4\" id=\"scroller-4\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003c/p\u003e\u003cp\u003e注册中心提供的基本能力包括：提供服务注册、服务发现 以及 健康检查。\u003c/p\u003e\u003cp\u003e服务注册跟服务发现上面已经详细介绍了， 健康检查指的是指注册中心能够感知到微服务实例的健康状况，便于上游微服务实例及时发现下游微服务实例的健康状况。采取必备的访问措施，如避免访问不健康的实例。\u003c/p\u003e\u003cp\u003e主要的检查方式包括：\u003c/p\u003e\u003cp\u003e1、服务Provider 进行 TTL 健康汇报（Time To Live，微服务Provider定期向注册中心汇报健康状态）。\u003c/p\u003e\u003cp\u003e2、注册中心主动检查服务Provider接口。\u003c/p\u003e\u003cp\u003e综合我们前面的内容，可以总结下注册中心有如下几种能力：\u003c/p\u003e\u003cp\u003e1、高可用\u003c/p\u003e\u003cp\u003e这个主要体现在两个方面。一个方面是，注册中心本身作为基础设施层，具备高可用；第二种是就是前面我们说到的去中心化，极端情况下的故障，短时间内是不影响微服务应用的调用的\u003c/p\u003e\u003cp\u003e2、可视化操作\u003c/p\u003e\u003cp\u003e常用的注册中心，类似 Eureka、Consul 都有比较丰富的管理界面，对配置、服务注册、服务发现进行可视化管理。\u003c/p\u003e\u003cp\u003e3、高效运维\u003c/p\u003e\u003cp\u003e注册中心的文档丰富，对运维的支持比较好，并且对于服务的注册是动态感知获取的，方便动态扩容。\u003c/p\u003e\u003cp\u003e4、权限控制\u003c/p\u003e\u003cp\u003e数据是具有敏感性，无论是服务信息注册或服务是调用，需要具备权限控制能力，避免侵入或越权请求\u003c/p\u003e\u003cp\u003e5、服务注册推、拉能力\u003c/p\u003e\u003cp\u003e这个前面说过了，微服务应用程序（服务的Consumer），能够快速感知到服务实例的变化情况，使用拉取或者注册中心下发的方式进行处理。\u003c/p\u003e\u003cimg src=\"/images/books/image_34.png\" alt=\"\" /\u003e\u003cp\u003e\u003ch2\u003e2 现下的主流注册中心 \u003ca href=\"#scroller-5\" id=\"scroller-5\"\u003e\u003c/a\u003e\u003c/h2\u003e\u003c/p\u003e\u003cp\u003e\u003ch3\u003e2.1 Eureka \u003ca href=\"#scroller-6\" id=\"scroller-6\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.1.1 介绍 \u003ca href=\"#scroller-7\" id=\"scroller-7\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cp\u003eEureka是Netflix OSS套件中关于服务注册和发现的解决方案。因为Spring Cloud 在它的微服务解决方案中对Eureka进行了集成，并作为优先推荐方案进行宣传，所以早期有用 Spring Cloud 来建设微服务系统的同学会比较熟悉。\u003c/p\u003e\u003cp\u003e目前大量公司的微服务系统中依旧使用Eureka作为注册中心，它的核心设计思想也被后续大量注册中心产品借鉴。但目前 [Eureka 2.0已经停止维护](https://github.com/Netflix/eureka/wiki)，所以新的微服务架构设计中，不再建议使用。\u003c/p\u003e\u003cp\u003eSpring Cloud Netflix主要分为两个部分：\u003c/p\u003e\u003cp\u003e1、Eureka Server： 作为注册中心Server端，向微服务应用程序提供服务注册、发现、健康检查等能力。\u003c/p\u003e\u003cp\u003e2、Eureka Client： 微服务应用程序Client端，用以和Eureka Server进行通信。\u003c/p\u003e\u003cimg src=\"/images/books/image_55.png\" alt=\"\" /\u003e\u003cp\u003eEureka有比较友好的管理界面，如上图所示：\u003c/p\u003e\u003cp\u003e1、System Status：显示当前Eureka Server信息。\u003c/p\u003e\u003cp\u003e2、Instances Current registered with Eureka：在Eureka Server当前注册的数据，在Spring Cloud生态中，被注册的服务可以呗发现并罗列在这个地方。\u003c/p\u003e\u003cp\u003e3、General Info：基本信息，如cpu、内存、环境等。\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.1.2 整体架构 \u003ca href=\"#scroller-8\" id=\"scroller-8\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cimg src=\"/images/books/image_32.png\" alt=\"\" /\u003e\u003cp\u003eEureka Server可以运行多个实例来构建集群，解决单点问题，但不同于ZooKeeper的选举leader的过程，Eureka Server采用的是Peer to Peer对等通信。\u003c/p\u003e\u003cp\u003e所以他有如下特点：\u003c/p\u003e\u003cp\u003e1、去中心化的架构：无master/slave区分，每一个Peer都是对等的。在这种架构中，节点通过彼此互相注册来提高可用性，每个节点需要添加一个或多个有效的serviceUrl指向其他节点。每个节点都可被视为其他节点的副本。\u003c/p\u003e\u003cp\u003e2、故障转移/故障恢复：如果某台Eureka Server宕机，Eureka Client的请求会自动切换到新的Eureka Server节点，当宕机的服务器重新恢复后，Eureka会再次将其纳入到服务器集群管理之中。\u003c/p\u003e\u003cp\u003e3、节点复制：当节点开始接受客户端请求时，所有的操作都会进行replicateToPeer（节点间复制）操作，将请求复制到其他Eureka Server当前所知的所有节点中。\u003c/p\u003e\u003cp\u003e同理，一个新的Eureka Server节点启动后，会首先尝试从邻近节点获取所有实例注册表信息，完成初始化。\u003c/p\u003e\u003cp\u003e4、CAP模式：复制算法非强一致性算法，而是当有数据写入时，Eureka Server将数据同步给其他的节点，因此Eureka在CAP提系统（一致性、可用性、分区容错性）是典型的AP系统。\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.1.3 接入Spring Cloud \u003ca href=\"#scroller-9\" id=\"scroller-9\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cimg src=\"/images/books/image_4_1.png\" alt=\"\" /\u003e\u003cp\u003e如上图所示：\u003c/p\u003e\u003cp\u003e1、Provider 服务提供者：服务向注册中心注册服务信息，即 服务 -\u003e 服务实例 数据模型， 同时定时向注册中心汇报健康检查，如果一定时间内（一般90s）没有进行心跳汇报，则会被注册中心剔除。\u003c/p\u003e\u003cp\u003e所以这边注意，注册中心感知到应用下线并进行剔除这个过程可能比较长。\u003c/p\u003e\u003cp\u003e2、Consumer 服务消费者：服务向注册中心获取所需服务对应的服务实例信息。这边需要注意，Eureka不支持订阅，因此在Spring Cloud生态中，通过定时拉取方式从注册中心中获取所需的服务实例信息。\u003c/p\u003e\u003cp\u003e3、Remote Call 远程调用：Consumer从注册中心获取的Provider的实例信息，通过 Load Balance的策略，确定一个实际的实例，发起远程调用。\u003c/p\u003e\u003cp\u003e\u003ch3\u003e2.2 ZooKeeper \u003ca href=\"#scroller-10\" id=\"scroller-10\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.2.1 介绍 \u003ca href=\"#scroller-11\" id=\"scroller-11\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cp\u003e作为一个分布式的、开源的协调服务，ZooKeeper实现了一系列基础功能，包括简单易用的接口。\u003c/p\u003e\u003cp\u003e这些接口被用来实现服务的注册与发现功能。并实现一些高级功能，如数据同步、分布式锁、配置中心、集群选举、命名服务等。\u003c/p\u003e\u003cimg src=\"/images/books/image_57.png\" alt=\"\" /\u003e\u003cp\u003e在数据模型上，类似于传统的文件系统，节点类型分为：\u003c/p\u003e\u003cp\u003e1、持久节点：节点创建后，就一直存在，除非执行删除操作，主动删掉这个节点。\u003c/p\u003e\u003cp\u003e2、临时节点（注册中心场景下的主要实现机制）：临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。\u003c/p\u003e\u003cp\u003e在实际场景下，微服务启动的时候，会创建一个服务临时节点，等把服务停止，短时间后节点就没有了。\u003c/p\u003e\u003cimg src=\"/images/books/image_56.png\" alt=\"\" /\u003e\u003cp\u003eZookeeper有如下特点：\u003c/p\u003e\u003cp\u003e1、最终一致性：为客户端展示同一视图，这是zookeeper最重要的功能。2、可靠性：如果消息被到一台服务器接受，那么它将被所有的服务器接受。3、实时性：Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。4、等待无关（wait-free）：慢的或者失效的client不干预快速的client的请求。5、原子性：更新只能成功或者失败，没有中间状态。6、顺序性：所有Server，同一消息发布顺序一致。\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.2.2 整体架构 \u003ca href=\"#scroller-12\" id=\"scroller-12\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cimg src=\"/images/books/image_3_1_1.png\" alt=\"\" /\u003e\u003cp\u003e上图是Zookeeper 的服务架构，他有如下流程：\u003c/p\u003e\u003cp\u003e1、 多个节点组成分布式架构，每个Server在内存中存储一份数据；\u003c/p\u003e\u003cp\u003e2、通过选举产生leader，通过 Paxos(帕克索斯)强一致性算法 进行保证，是典型的CP结构。\u003c/p\u003e\u003cp\u003e3、Leader负责处理数据更新等操作（Zab协议）；\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.2.3 接入Dubbo生态 \u003ca href=\"#scroller-13\" id=\"scroller-13\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cimg src=\"/images/books/image_43_1.png\" alt=\"\" /\u003e\u003cp\u003e上图中的角色如下：\u003c/p\u003e\u003cp\u003eProvider：提供者,服务发布方\u003c/p\u003e\u003cp\u003eConsumer：消费者, 调用服务方\u003c/p\u003e\u003cp\u003eContainer：Dubbo容器.依赖于Spring容器\u003c/p\u003e\u003cp\u003eRegistry：注册中心，当Container启动时把所有可以提供的服务列表上Registry中进行注册，告诉Consumer提供了什么服务，以及服务方的位置\u003c/p\u003e\u003cp\u003eMonitor:监听器\u003c/p\u003e\u003cp\u003e说明：ZooKeeper在注册中心方面对Dubbo生态支持的比较好。服务提供者Providerzai Container启动时主动向注册中心Registry ZooKeeper中注册信息。\u003c/p\u003e\u003cp\u003e服务消费者Consumer启动时向注册中心Registry ZooKeeper中订阅注册中心，当Provider的信息发生变化时，注册中心ZooKeeper会主动向Consumer进行推送通知变更。\u003c/p\u003e\u003cp\u003e这边注意与Eureka的区别，这是主动推送通知，是注册中心下发的操作。\u003c/p\u003e\u003cp\u003e\u003ch3\u003e2.3 Consul \u003ca href=\"#scroller-14\" id=\"scroller-14\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.3.1 介绍 \u003ca href=\"#scroller-15\" id=\"scroller-15\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cp\u003eConsul是HashiCorp推出的一款软件，是一个Service Mesh解决方案，提供了功能丰富的控制面功能：\u003c/p\u003e\u003cp\u003e1、Service Discovery（服务发现）\u003c/p\u003e\u003cp\u003e2、Configuration（配置化）\u003c/p\u003e\u003cp\u003e3、Segmentation Functionality\u003c/p\u003e\u003cp\u003e这些功能可以根据需要独立使用，或者将它们一起使用用来构建完整的Service Mesh。\u003c/p\u003e\u003cp\u003eConsul提供的关键功能如下：\u003c/p\u003e\u003cp\u003e1、Service Discovery：服务注册/发现功能。\u003c/p\u003e\u003cp\u003e2、Health Checking：健康检查，丰富的健康检查方式；\u003c/p\u003e\u003cp\u003e3、KV Store：KV存储功能，可应用多种场景，如动态配置存储，分布式协调、leader选举等。\u003c/p\u003e\u003cp\u003e4、Multi DataCenter：多数据中心。\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.3.2 整体架构 \u003ca href=\"#scroller-16\" id=\"scroller-16\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003c/p\u003e\u003cimg src=\"/images/books/image_28_1.png\" alt=\"\" /\u003e\u003cp\u003e如上图为Consul的架构，这边对技术点做一下说明：\u003c/p\u003e\u003cp\u003e1、Raft: 一种分布式一致性算法，Consul使用该算法保持强一致性，所以也是典型的CP模式\u003c/p\u003e\u003cp\u003e2、Client：Client是一种agent，其将会重定向所有的RPC 请求到Server。Client是无状态的，其主要参与LAN Gossip协议池。其占用很少的资源，并且消耗很少的网络带宽。\u003c/p\u003e\u003cp\u003e3、Server：Server是一种agent，其包含了一系列的责任包括：参与Raft协议写半数（Raft Quorum）、维护集群状态、响应RPC响应、和其他Datacenter通过WAN gossip交换信息和重定向查询请求至leader或者远端Datacenter。\u003c/p\u003e\u003cp\u003e4、Datacenter: Datacenter其是私有的、低延迟、高带宽的网络环境，去除了在公共网络上的网络交互。\u003c/p\u003e\u003cp\u003e5、Consensus: Consensus一致性在leader 选举、顺序执行transaction 上。当这些事务已经提交至有限状态机（finite-state machine）中，Consul定义consensus作为复制状态机的一致性。本质上使用实现了Raft协议，对于具体实现细节可参考 Consensus Protocol。\u003c/p\u003e\u003cp\u003e6、Gossip：Consul使用了Serf，其提供了Gossip协议多种用途，Serf提供成员关系、失败检查和事件广播。\u003c/p\u003e\u003cp\u003e7、LAN Gossip: Local Area Network Gossip其包含在同一个网络环境或Datacenter的节点。\u003c/p\u003e\u003cp\u003e8、WAN Gossip: Wide Area Network Gossip 其只包含Server节点，这些server分布在不同的datacenter中，其主要通过因特网或广域网相互交流。\u003c/p\u003e\u003cp\u003e9、RPC: 远程过程调用，用于服务之间的通信。\u003c/p\u003e\u003cp\u003e10、CAP抉择：在高可用方面，Consul使用Raft协议作为其分布式一致性协议，本身对故障节点有一定的容忍性，在单个DataCenter中Consul集群中节点的数量控制在2\\*n + 1个节点，其中n为可容忍的宕机个数，通常为3个节点。\u003c/p\u003e\u003cp\u003e所以是典型的CP模式。\u003c/p\u003e\u003cimg src=\"/images/books/image_45.png\" alt=\"\" /\u003e\u003cp\u003e根据Consul 的选举机制和服务原理，我们有两个注意点 ：\u003c/p\u003e\u003cp\u003e1、部署Consul Service 节点应该奇数为宜，因为+1的偶数节点和奇数节点可容忍的故障数是一样的，比如上图3和4，另一方面，偶数个节点在选主节点的时候可能会出现二分选票的情况，还得重新选举。\u003c/p\u003e\u003cp\u003e2、Consul Service 节点数不是越多越好，虽然Server数量越多可容忍的故障数越多，但是Raft进行日志复制也是很耗时间的，而且Server数量越多，性能越低，所以结合实际场景，一般建议Server部署3个即可。\u003c/p\u003e\u003cp\u003e有兴趣的同学可以去Consul官网看看它的选举机制，还可以对比下Redis中Sentinel模式。\u003c/p\u003e\u003cp\u003e\u003ch4\u003e2.3.3 生态对接 \u003ca href=\"#scroller-17\" id=\"scroller-17\"\u003e\u003c/a\u003e\u003c/h4\u003e\u003cstrong\u003e对接Spring Cloud生态\u003c/strong\u003e\u003cimg src=\"/images/books/image_15_1.png\" alt=\"\" /\u003e\u003cp\u003eConsul作为注册中心，集成在Spring Cloud生态。可以看出，跟Eureka对接到Spring Cloud 生态的过程很像。\u003c/p\u003e\u003cp\u003e但是这边的健康检查更丰富，可以有多种不同的的Check方式：\u003c/p\u003e\u003cp\u003e* Script check（Script+ Interval）\u003c/p\u003e\n\u003cp\u003e* 基于HTTP请求\u003c/p\u003e\n\u003cp\u003e* 基于tcp请求\u003c/p\u003e\n\u003cp\u003e* 基于grpc请求\u003c/p\u003e\u003ch3\u003e2.4 总结对比 \u003ca href=\"#scroller-19\" id=\"scroller-19\"\u003e\u003c/a\u003e\u003c/h3\u003e\u003cp\u003e| \u003cstrong\u003e指标\u003c/strong\u003e             | \u003cstrong\u003eEureka\u003c/strong\u003e        | \u003cstrong\u003eZookeeper\u003c/strong\u003e   | \u003cstrong\u003eConsul\u003c/strong\u003e          | \u003cstrong\u003eEtcd\u003c/strong\u003e            |\u003c/p\u003e\n\u003cp\u003e| ------------------ | ----------------- | --------------- | ------------------- | ------------------- |\u003c/p\u003e\n\u003cp\u003e| 一致性协议              | AP                | CP（Paxos算法）     | CP（Raft算法）          | CP（Raft算法）          |\u003c/p\u003e\n\u003cp\u003e| 健康检查               | TTL(Time To Live) | TCP Keep Alive  | TTL\\HTTP\\TCP\\Script | Lease TTL KeepAlive |\u003c/p\u003e\n\u003cp\u003e| watch/long polling | 不支持               | watch           | long polling        | watch               |\u003c/p\u003e\n\u003cp\u003e| 雪崩保护               | 支持                | 不支持             | 不支持                 | 不支持                 |\u003c/p\u003e\n\u003cp\u003e| 安全与权限              | 不支持               | ACL             | ACL                 | RBAC                |\u003c/p\u003e\n\u003cp\u003e| 是否支持多数据中心          | 是                 | 否               | 是                   | 否                   |\u003c/p\u003e\n\u003cp\u003e| 是否有管理界面            | 是                 | 否（可用第三方ZkTools） | 是                   | 否                   |\u003c/p\u003e\n\u003cp\u003e| Spring Cloud 集成    | 支持                | 支持              | 支持                  | 支持                  |\u003c/p\u003e\n\u003cp\u003e| Dubbo 集成           | 不支持               | 支持              | 支持                  | 不支持                 |\u003c/p\u003e\n\u003cp\u003e| K8S 集成             | 不支持               | 不支持             | 支持                  | 支持                  |\u003c/p\u003e\u003cp\u003e这边是对业内4种注册中心各纬度上的对比，Eureka是典型的AP类型，Zookeeper和Consul是典型的CP类型。如何选择取决你的业务是倾向A：高可用性 还是 C：强一致性。\u003c/p\u003e\u003cp\u003e当然，业务是复杂的，在真正的技术选型时，还是要根据自己的实际业务现状来判断。有一些倾向，比如你的系统是Spring Cloud体系下，那优先选择Eureka、Consul。\u003c/p\u003e\u003cp\u003e如果业务会更多向云原生对齐，则Consul、Etcd会是比较优先的选择。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"6:[\"$\",\"article\",null,{\"className\":\"py-24 sm:py-32\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-3xl px-6 lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"xl:relative\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl\",\"children\":[[\"$\",\"div\",null,{\"className\":\"text-center\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2024-04-01\",\"className\":\"text-gray-500\",\"children\":\"2024年04月01日\"}],[\"$\",\"h1\",null,{\"className\":\"mt-6 text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl\",\"children\":\"服务注册与发现\"}],[\"$\",\"p\",null,{\"className\":\"mt-6 text-lg leading-8 text-gray-600\",\"children\":\"我们前面在全景架构中对服务注册与发现做了大致的说明，本章我们着重详细说明微服务下注册与发现的这个能力。微服务注册与发现类似于生活中的电话通讯录的概念，它记录了通讯录服务和电话的映射关系。\"}],[\"$\",\"div\",null,{\"className\":\"mt-6 flex justify-center gap-2\",\"children\":[[\"$\",\"$L5\",\"微服务\",{\"href\":\"/blog/tag/%E5%BE%AE%E6%9C%8D%E5%8A%A1/page/1\",\"className\":\"rounded-full bg-gray-100 px-3 py-1 text-sm font-medium text-gray-700 hover:bg-gray-200\",\"children\":\"微服务\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-16 prose prose-lg prose-gray mx-auto\",\"children\":[\"$\",\"div\",null,{\"className\":\"prose prose-lg prose-gray mx-auto\",\"dangerouslySetInnerHTML\":{\"__html\":\"$14\"}}]}],[\"$\",\"div\",null,{\"className\":\"mt-16 flex items-center justify-between border-t border-gray-200 pt-8\",\"children\":[\"$\",\"$L5\",null,{\"href\":\"/blog\",\"className\":\"relative z-10 rounded-md px-4 py-2 text-sm font-semibold leading-6 text-gray-900 hover:text-blue-600 hover:bg-gray-50\",\"children\":\"← 返回博客列表\"}]}],[\"$\",\"div\",null,{\"className\":\"mt-8 grid grid-cols-1 gap-8 border-t border-gray-200 pt-8 lg:grid-cols-2\",\"children\":[[\"$\",\"div\",null,{\"className\":\"group\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-x-3\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-sm text-gray-500\",\"children\":\"上一篇\"}]}],[\"$\",\"h3\",null,{\"className\":\"mt-2 text-lg font-semibold leading-6 text-gray-900 group-hover:text-gray-600\",\"children\":[\"$\",\"$L5\",null,{\"href\":\"/blog/wei-fu-wu-chai-fen-ce-lve-fu-jia-pian\",\"children\":[[\"$\",\"span\",null,{\"className\":\"absolute inset-0\"}],\"微服务拆分策略（附加篇）\"]}]}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-sm leading-6 text-gray-600 line-clamp-2\",\"children\":\"关于服务拆分的切入点，我们先从MartinL.Abbott所著《架构即未来》中所介绍的AKF扩展立方体出发寻找一些灵感，然后给出本文中关于服务拆分的两大维度。 1. AKF扩展立方体 AKF扩展立方体（Scalability Cube）是一种可扩展模型，这个立方体有三个轴线，每个轴线描述扩展性的一...\"}]]}],[\"$\",\"div\",null,{\"className\":\"group\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-x-3\",\"children\":[\"$\",\"div\",null,{\"className\":\"text-sm text-gray-500\",\"children\":\"下一篇\"}]}],[\"$\",\"h3\",null,{\"className\":\"mt-2 text-lg font-semibold leading-6 text-gray-900 group-hover:text-gray-600\",\"children\":[\"$\",\"$L5\",null,{\"href\":\"/blog/fu-wu-zhu-ce-yu-fa-xian-shi-jian-pian\",\"children\":[[\"$\",\"span\",null,{\"className\":\"absolute inset-0\"}],\"服务注册与发现（实践篇）\"]}]}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-sm leading-6 text-gray-600 line-clamp-2\",\"children\":\"前面我们对业内几种比较常见的注册中心做了介绍：Eureka、Zookeeper、Consul、Etcd。 并且在各个指标上做了对比：注册方式（watch/polling）、健康检查、雪崩保护、安全与权限，以及在Spring Cloud、Dubbo、Kubernets上的支持程度。方便我们在不同的场景...\"}]]}]]}]]}]}]}]}]\n"])</script><script>self.__next_f.push([1,"9:null\n"])</script><script>self.__next_f.push([1,"d:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:null\n"])</script><script>self.__next_f.push([1,"b:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Skyfalling\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"分享技术、生活和思考的个人博客\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.svg\"}]],\"error\":null,\"digest\":\"$undefined\"}\n13:{\"metadata\":\"$b:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>
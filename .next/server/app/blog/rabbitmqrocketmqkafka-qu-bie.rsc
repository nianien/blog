1:"$Sreact.fragment"
2:I[5651,["874","static/chunks/874-80549eca86098588.js","177","static/chunks/app/layout-f035406da26395a3.js"],"default"]
3:I[7555,[],""]
4:I[1295,[],""]
5:I[6874,["874","static/chunks/874-80549eca86098588.js","909","static/chunks/app/blog/%5B...slug%5D/page-b420037c820534af.js"],""]
7:I[9665,[],"OutletBoundary"]
a:I[4911,[],"AsyncMetadataOutlet"]
c:I[9665,[],"ViewportBoundary"]
e:I[9665,[],"MetadataBoundary"]
10:I[6614,[],""]
:HL["/gitbook/_next/static/media/e4af272ccee01ff0-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/gitbook/_next/static/css/443e11d9362f4e82.css","style"]
0:{"P":null,"b":"vtR8vRym_dmCF4uoCEze4","p":"/gitbook","c":["","blog","rabbitmqrocketmqkafka-qu-bie",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","rabbitmqrocketmqkafka-qu-bie","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/gitbook/_next/static/css/443e11d9362f4e82.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"zh-CN","children":["$","body",null,{"className":"__className_feb414","children":["$","div",null,{"className":"min-h-screen flex flex-col","children":[["$","$L2",null,{}],["$","main",null,{"className":"flex-1","children":["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","footer",null,{"className":"bg-gray-900","children":["$","div",null,{"className":"mx-auto max-w-7xl px-6 py-12 md:flex md:items-center md:justify-between lg:px-8","children":[["$","div",null,{"className":"flex justify-center space-x-6 md:order-2","children":[["$","$L5",null,{"href":"/about","className":"text-gray-400 hover:text-gray-300","children":"关于"}],["$","$L5",null,{"href":"/blog","className":"text-gray-400 hover:text-gray-300","children":"博客"}],["$","$L5",null,{"href":"/contact","className":"text-gray-400 hover:text-gray-300","children":"联系"}]]}],["$","div",null,{"className":"mt-8 md:order-1 md:mt-0","children":["$","p",null,{"className":"text-center text-xs leading-5 text-gray-400","children":"© 2024 Skyfalling Blog. All rights reserved."}]}]]}]}]]}]}]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","rabbitmqrocketmqkafka-qu-bie","c"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L6",null,["$","$L7",null,{"children":["$L8","$L9",["$","$La",null,{"promise":"$@b"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","4zKSudgyN2u2UGYBiqJRxv",{"children":[["$","$Lc",null,{"children":"$Ld"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}],["$","$Le",null,{"children":"$Lf"}]]}],false]],"m":"$undefined","G":["$10","$undefined"],"s":false,"S":true}
11:"$Sreact.suspense"
12:I[4911,[],"AsyncMetadata"]
f:["$","div",null,{"hidden":true,"children":["$","$11",null,{"fallback":null,"children":["$","$L12",null,{"promise":"$@13"}]}]}]
14:T2bd7,
<p>---</p>
<p>description: RabbitMQ、RocketMQ、Kafka区别</p>
<p>layout:</p>
<p>  title:</p>
<p>    visible: true</p>
<p>  description:</p>
<p>    visible: false</p>
<p>  tableOfContents:</p>
<p>    visible: true</p>
<p>  outline:</p>
<p>    visible: true</p>
<p>  pagination:</p>
<p>    visible: true</p>
<p>---</p><h1>RabbitMQ、RocketMQ、Kafka区别</h1></p><p>[转载](https://baijiahao.baidu.com/s?id=1769207484615537227)</p><p><h4>引言</h4></p><p><h4>1、队列应用场景：</h4><p>MQ（Message Queue，消息队列）</p>
<p><strong>消息队列在实际应用中常用的使用场景（优点）</strong>：<code>异步处理</code>，<code>应用解耦</code>，<code>流量削锋</code>和<code>消息通讯</code>四个场景。</p><h4>2、目前使用较多的消息队列：</h4></p><p>有老牌的ActiveMQ、RabbitMQ，ZeroMQ，炙手可热的Kafka，MetaMQ，阿里巴巴的RocketMQ。</p><p><h4>3、如何选型（目前现状）：</h4></p><p>ActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。最早大家都用 ActiveMQ，但是现在确实大家用的不多了，社区也不是很活跃，不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高，可视化的管理界面比较友好；</p><p>不过现在确实越来越多的公司，会去用 RocketMQ，确实很不错（阿里出品），它是纯Java开发，它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。但社区可能有突然黄掉的风险，对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则老老实实用 RabbitMQ 吧，毕竟RabbitMQ有活跃的开源社区，绝对不会黄。</p><p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，适合产生大量数据的互联网服务的数据收集业务等。社区活跃度很高，何况几乎是全世界这个领域的事实性规范。kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。</p><p><h4>4、使用消息队列缺点：</h4><p>* 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，万一MQ挂了，整套系统崩溃了。</p>
<p>* 系统复杂性提高：加MQ进来，怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？</p>
<p>* 一致性问题：A系统处理完了直接返回成功了，后面的如果失败了，这数据就不一致了。</p><h4>一、RabbitMQ</h4></p><p><h4>1、RabbitMQ概述</h4><p><code>AMQP</code>，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层<strong>标准高级消息队列协议</strong>，是应用层协议的一个开放标准，为面向消息的中间件设计。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
<p>AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</p><p><code>RabbitMQ</code>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的。</p><p>RabbitMQ 是比较有代表性的，因为是<code>基于主从（非分布式）做高可用性</code>的。</p><h4>2、RabbitMQ原理图</h4><p>RabbitMQ通过<code>信道</code>的方式传输数据，将消息发布到交换机上，消息拥有一个路邮键，由消息创建时设定，通过队列路由键，可以把队列绑定到交换机上，消息到达交换机后，RabbitMQ将消息的路由键与队列的路由键进行匹配（不同的交换机有不同的路由规则），匹配到相应的队列，消息投递到队列的队列中供消费者消费。</p><p>> 多个消费者可以订阅同一个Queue，消息将以<code>循环（round-robin）</code>的方式发送给消费者，每条消息只会发给一个订阅的消费者，而不是每个消费者都收到所有的消息并处理。</p><p>> 每个Channel运行在独立的线程上，多个线程共享同一个socket。</p><img src="https://pic.rmb.bdstatic.com/bjh/beautify/dfde605794cc90a31ce1223c54218372.jpeg@c\_1,w\_901,h\_315,x\_0,y\_0" alt="" />
<strong>相关概念：</strong><p>* ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；</p>
<p>* Broker：简单来说就是消息队列服务器实体。</p>
<p>* Channel（信道）：消息推送使用的通道；</p>
<p>* Exchange（交换器）：用于接受、分配消息；</p>
<p>* Queue（队列）：用于存储生产者的消息；</p>
<p>* RoutingKey（路由键）：用于把生成者的数据分配到交换器上；【最大255个字节】</p>
<p>* BindingKey（绑定键）：用于把交换器的消息绑定到队列上；【最大255个字节】</p>
<p>* vhost（虚拟主机）每个Rabbit都能创建很多vhost，每个虚拟主机其实都是mini版的RabbitMQ，拥有自己的队列，交换器和绑定，拥有自己的权限机制。</p><h4>3、RabbitMQ常用的三种交换机</h4></p><p><strong>RabbitMQ常用的三种Exchange</strong>：fanout,direct,topic</p><p><h4>（1）Direct Exchange ：</h4><p>直连型交换机，根据消息携带的路由键将消息投递给对应队列。</p>
<p>　　大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key。　然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。</p><h4>（2）Fanout Exchange：</h4></p><p>扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。</p><p><h4>（3）Topic Exchange：</h4><p>主题交换机，这个交换机其实跟直连交换机流程差不多，但是它的特点就是在它的路由键和绑定键之间是有规则的。</p>
<p>　　</p>
<p><strong>性能排序</strong>：fanout > direct >> topic。</p><h4>4、 RabbitMQ集群元数据</h4><p>RabbitMQ集群会始终同步四种类型的内部元数据：</p><p>* a. 队列元数据：队列名称和它的属性</p>
<p>* b. 交换器元数据：交换器名称、类型和属性</p>
<p>* c. 绑定元数据：一张简单的表格展示了如何将消息路由到队列</p>
<p>* d. vhost元数据：为vhost内的队列、交换器和绑定提供命名空间和安全属性</p><h4>5、RabbitMQ镜像集群</h4><p><strong>RabbitMQ 有三种模式</strong>：单机模式、普通集群模式（无高可用性）、<code>镜像集群模式</code>（高可用性）。</p><p><code>镜像队列</code>将需要消费的队列变成镜像队列，存在于多个节点，实现RabbitMQ的高可用，保证 100% 数据不丢失。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在消费者消费数据时临时拉取，缺点就是集群内部的<code>同步通讯</code>会占去大量的网络带宽。</p>
<img src="https://pic.rmb.bdstatic.com/bjh/beautify/53a92fdedade9355420e866bbdb51be1.jpeg@c\_1,w\_613,h\_390,x\_0,y\_0" alt="" /><h4>二、RocketMQ</h4><p><code>RocketMQ</code>是阿里开源的消息中间件，目前也已经孵化为Apache顶级项目。用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。RocketMQ在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p><strong>RocketMQ缺点：</strong><p>* 单机支持1万以上持久化队列；</p>
<p>* RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从内存读取。</p>
<p>* 模型简单，接口易用（JMS的接口很多场合并不太实用）；</p>
<p>* 性能非常好，可以允许大量堆积消息在Broker中；</p>
<p>* 支持多种消费模式，包括集群消费、广播消费等；</p>
<p>* 各个环节分布式扩展设计，支持主从和高可用；</p>
<p>* 开发度较活跃，版本更新很快。</p><strong>RocketMQ缺点：</strong><p>* 支持的 客户端语言不多，目前是Java及C++，其中C++还不成熟</p>
<p>* 维护RocketMQ需要专业的团队</p>
<p>* 商业版收费，有许多功能是不对外提供的。</p>
<p>* 没有在MQ核心里实现JMS等接口</p><h4>三、kafka</h4></p><p><h4>1、kafka概述</h4><p><code>kafka</code>是Linkedin于2010年12月份开源的<code>消息发布订阅</code>系统,它主要用于处理活跃的流式数据,大数据量的数据处理上。作为hadoop生态系统的一部分，被各种商业公司广泛应用。</p><strong>kafka优点：</strong><p>* 高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒</p>
<p>* 可扩展性：kafka集群支持热扩展</p>
<p>* 持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</p>
<p>* 容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</p>
<p>* 高并发：支持数千个客户端同时读写</p><strong>kafka缺点：</strong><p>* 快速持久化：可以在O(1)的系统开销下进行消息持久化；</p>
<p>* 高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</p>
<p>* 完全的分布式系统：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；</p>
<p>* 支持同步和异步复制两种高可用机制；</p>
<p>* 支持数据批量发送和拉取；</p>
<p>* 零拷贝技术(zero-copy)：减少IO操作步骤，提高系统吞吐量；</p>
<p>* 数据迁移、扩容对用户透明；</p>
<p>* 无需停机即可扩展机器；</p>
<p>* 其他特性：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制</p><h4>2、kafka原理图</h4><img src="https://pic.rmb.bdstatic.com/bjh/beautify/3d90e1705de49c669f22628af2f6004a.jpeg@c\_1,w\_1010,h\_651,x\_0,y\_0" alt="" />
<img src="https://pic.rmb.bdstatic.com/bjh/beautify/a5531d658050ce7abecb5ad4242d92ab.jpeg@c\_1,w\_1002,h\_300,x\_0,y\_0" alt="" /><h4>四、总结</h4><p><div align="left"></p><img src="/images/books/image_31.png" alt="" /><p></div></p>
6:["$","article",null,{"className":"py-24 sm:py-32","children":["$","div",null,{"className":"mx-auto max-w-3xl px-6 lg:px-8","children":["$","div",null,{"className":"xl:relative","children":["$","div",null,{"className":"mx-auto max-w-2xl","children":[["$","div",null,{"className":"text-center","children":[["$","time",null,{"dateTime":"2024-03-11","className":"text-gray-500","children":"2024年03月11日"}],["$","h1",null,{"className":"mt-6 text-3xl font-bold tracking-tight text-gray-900 sm:text-4xl","children":"RabbitMQ、RocketMQ、Kafka区别"}],["$","p",null,{"className":"mt-6 text-lg leading-8 text-gray-600","children":"--- description: RabbitMQ、RocketMQ、Kafka区别 layout:..."}],["$","div",null,{"className":"mt-6 flex justify-center gap-2","children":[["$","$L5","消息队列",{"href":"/blog/tag/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/page/1","className":"rounded-full bg-gray-100 px-3 py-1 text-sm font-medium text-gray-700 hover:bg-gray-200","children":"消息队列"}]]}]]}],["$","div",null,{"className":"mt-16 prose prose-lg prose-gray mx-auto","children":["$","div",null,{"className":"prose prose-lg prose-gray mx-auto","dangerouslySetInnerHTML":{"__html":"$14"}}]}],["$","div",null,{"className":"mt-16 flex items-center justify-between border-t border-gray-200 pt-8","children":["$","$L5",null,{"href":"/blog","className":"relative z-10 rounded-md px-4 py-2 text-sm font-semibold leading-6 text-gray-900 hover:text-blue-600 hover:bg-gray-50","children":"← 返回博客列表"}]}],["$","div",null,{"className":"mt-8 grid grid-cols-1 gap-8 border-t border-gray-200 pt-8 lg:grid-cols-2","children":[["$","div",null,{"className":"group","children":[["$","div",null,{"className":"flex items-center gap-x-3","children":["$","div",null,{"className":"text-sm text-gray-500","children":"上一篇"}]}],["$","h3",null,{"className":"mt-2 text-lg font-semibold leading-6 text-gray-900 group-hover:text-gray-600","children":["$","$L5",null,{"href":"/blog/dian-shang-fen-xi-bi-dong-de-zhi-biao-ti-xi-yin-liu-zhuan-hua-liu-cun-yi-wen-dai-ni-gao-dong","children":[["$","span",null,{"className":"absolute inset-0"}],"电商分析必懂的指标体系，引流、转化、留存，一文带你搞懂"]}]}],["$","p",null,{"className":"mt-3 text-sm leading-6 text-gray-600 line-clamp-2","children":"今天，我就来讲讲电商到底该重点关注哪些指标，又该拿这些指标来进行怎么样的分析。 一般来说，在运营模块，需要重点关注的是新用户的引流和转化，以及老用户的活跃、留存、回购、流失。 简单来说，引流就是要吸引没买过我们的商品的人来买我们的商品。..."}]]}],["$","div",null,{"className":"group","children":[["$","div",null,{"className":"flex items-center gap-x-3","children":["$","div",null,{"className":"text-sm text-gray-500","children":"下一篇"}]}],["$","h3",null,{"className":"mt-2 text-lg font-semibold leading-6 text-gray-900 group-hover:text-gray-600","children":["$","$L5",null,{"href":"/blog/yi-ge-miao-sha-xi-tong-de-she-ji-si-kao","children":[["$","span",null,{"className":"absolute inset-0"}],"一个秒杀系统的设计思考"]}]}],["$","p",null,{"className":"mt-3 text-sm leading-6 text-gray-600 line-clamp-2","children":"前言 秒杀大家都不陌生。自2011年首次出现以来，无论是双十一购物还是 12306抢票，秒杀场景已随处可见。简单来说，秒杀就是在同一时刻大量请求争抢购买同一商品并完成交易的过程。从架构视角来看，秒杀系统本质是一个高性能、高一致、高可用的三高系统。"}]]}]]}]]}]}]}]}]
9:null
d:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:null
b:{"metadata":[["$","title","0",{"children":"Skyfalling"}],["$","meta","1",{"name":"description","content":"分享技术、生活和思考的个人博客"}],["$","link","2",{"rel":"icon","href":"/favicon.svg"}]],"error":null,"digest":"$undefined"}
13:{"metadata":"$b:metadata","error":null,"digest":"$undefined"}
